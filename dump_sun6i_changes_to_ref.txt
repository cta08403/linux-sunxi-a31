diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 20f876e..7d5549f 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -282,9 +282,29 @@ config ARCH_REALVIEW
 	select ARM_TIMER_SP804
 	select GPIO_PL061 if GPIOLIB
 	select NEED_MACH_MEMORY_H
+	select SPARSE_IRQ
 	help
 	  This enables support for ARM Ltd RealView boards.
 
+config ARCH_SUN6I
+	bool "Allwinner Ltd. AW163x family"
+	select ARM_AMBA
+	select CLKDEV_LOOKUP
+	select ARM_GIC
+	select CPU_V7
+	select HAVE_SMP
+	select HAVE_MACH_CLKDEV
+	select GENERIC_CLOCKEVENTS
+	select NEED_MACH_MEMORY_H
+	select MIGHT_HAVE_CACHE_L2X0
+	select ARCH_HAS_BARRIERS if SMP
+	select ZONE_DMA
+	select HAVE_SCHED_CLOCK
+	select ARCH_REQUIRE_GPIOLIB
+	select ARCH_HAS_CPUFREQ
+	help
+	  This enables support for AllWinner Ltd develop boards.
+
 config ARCH_VERSATILE
 	bool "ARM Ltd. Versatile family"
 	select ARM_AMBA
@@ -985,6 +1005,8 @@ config ARCH_ZYNQ
 	  Support for Xilinx Zynq ARM Cortex A9 Platform
 endchoice
 
+
+
 #
 # This is sorted alphabetically by mach-* pathname.  However, plat-*
 # Kconfigs may be included either alphabetically (according to the
@@ -1040,6 +1062,8 @@ source "arch/arm/mach-mxs/Kconfig"
 
 source "arch/arm/mach-netx/Kconfig"
 
+source "arch/arm/mach-sun6i/Kconfig"
+
 source "arch/arm/mach-nomadik/Kconfig"
 source "arch/arm/plat-nomadik/Kconfig"
 
@@ -1163,6 +1187,15 @@ if !MMU
 source "arch/arm/Kconfig-nommu"
 endif
 
+config ARM_ERRATA_326103
+	bool "ARM errata: FSR write bit incorrect on a SWP to read-only memory"
+	depends on CPU_V6
+	help
+	  Executing a SWP instruction to read-only memory does not set bit 11
+	  of the FSR on the ARM 1136 prior to r1p0. This causes the kernel to
+	  treat the access as a read, preventing a COW from occurring and
+	  causing the faulting task to livelock.
+
 config ARM_ERRATA_411920
 	bool "ARM errata: Invalidation of the Instruction Cache operation can fail"
 	depends on CPU_V6 || CPU_V6K
@@ -1520,6 +1553,13 @@ config HAVE_ARM_SCU
 	help
 	  This option enables support for the ARM system coherency unit
 
+config ARM_ARCH_TIMER
+	bool "Architected timer support"
+	depends on CPU_V7
+	select TICK_ONESHOT
+	help
+	  This option enables support for the ARM architected timer
+
 config HAVE_ARM_TWD
 	bool
 	depends on SMP
@@ -1527,6 +1567,12 @@ config HAVE_ARM_TWD
 	help
 	  This options enables support for the ARM timer and watchdog unit
 
+config AW_TIME_DELAY
+	bool "Timer counter delay"
+	depends on ARCH_SUN6I
+	---help---
+	  The udelay will use timer0 counter, not use bogomips.
+
 choice
 	prompt "Memory split"
 	default VMSPLIT_3G
diff --git a/arch/arm/Kconfig.debug b/arch/arm/Kconfig.debug
index c81df6c..758dfdc 100644
--- a/arch/arm/Kconfig.debug
+++ b/arch/arm/Kconfig.debug
@@ -313,6 +313,36 @@ choice
 		  Say Y here if you want the debug print routines to direct
 		  their output to the serial port on MSM 8960 devices.
 
+	config DEBUG_AW_UART0
+		bool "Kernel low-level debugging messages via AW163x UART0"
+		depends on ARCH_SUN6I
+		help
+		  Say Y here if you want the debug print routines to direct
+		  their output to the serial port on MSM 8960 devices.
+
+	config DEBUG_AW_R_UART
+		bool "Kernel low-level debugging messages via AW163x R_UART"
+		depends on ARCH_SUN6I
+		help
+		  Say Y here if you want the debug print routines to direct
+		  their output to the serial port on MSM 8960 devices.
+
+	config DEBUG_VEXPRESS_CA9X4_UART
+		bool "Kernel low-level debugging messages via CA9X4 UART"
+		depends on ARCH_VEXPRESS_CA9X4
+		help
+		  Say Y here if you want the debug print routines to direct
+		  their output to UART0 of the Versatile Express motherboards
+		  that pre-date the RS1 memory map.
+
+	config DEBUG_VEXPRESS_RS1_UART
+		bool "Kernel low-level debugging messages via RS1 UART"
+		depends on ARCH_VEXPRESS_DT
+		help
+		  Say Y here if you want the debug print routines to direct
+		  their output to UART0 of the Versatile Express motherboards
+		  with the RS1 memory map.
+
 endchoice
 
 config EARLY_PRINTK
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 1683bfb..6860eaa 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -173,6 +173,7 @@ machine-$(CONFIG_ARCH_PNX4008)		:= pnx4008
 machine-$(CONFIG_ARCH_PRIMA2)		:= prima2
 machine-$(CONFIG_ARCH_PXA)		:= pxa
 machine-$(CONFIG_ARCH_REALVIEW)		:= realview
+machine-$(CONFIG_ARCH_SUN6I)		:= sun6i
 machine-$(CONFIG_ARCH_RPC)		:= rpc
 machine-$(CONFIG_ARCH_S3C2410)		:= s3c2410 s3c2412 s3c2416 s3c2440 s3c2443
 machine-$(CONFIG_ARCH_S3C64XX)		:= s3c64xx
diff --git a/arch/arm/boot/compressed/Makefile b/arch/arm/boot/compressed/Makefile
index cf0a64c..5448c3f 100644
--- a/arch/arm/boot/compressed/Makefile
+++ b/arch/arm/boot/compressed/Makefile
@@ -123,7 +123,6 @@ KBUILD_CFLAGS = $(subst -pg, , $(ORIG_CFLAGS))
 endif
 
 ccflags-y := -fpic -fno-builtin -I$(obj)
-asflags-y := -Wa,-march=all
 
 # Supply kernel BSS size to the decompressor via a linker symbol.
 KBSS_SZ = $(shell $(CROSS_COMPILE)size $(obj)/../../../../vmlinux | \
diff --git a/arch/arm/boot/compressed/atags_to_fdt.c b/arch/arm/boot/compressed/atags_to_fdt.c
index 6ce11c4..797f04b 100644
--- a/arch/arm/boot/compressed/atags_to_fdt.c
+++ b/arch/arm/boot/compressed/atags_to_fdt.c
@@ -77,6 +77,8 @@ int atags_to_fdt(void *atag_list, void *fdt, int total_space)
 		} else if (atag->hdr.tag == ATAG_MEM) {
 			if (memcount >= sizeof(mem_reg_property)/4)
 				continue;
+			if (!atag->u.mem.size)
+				continue;
 			mem_reg_property[memcount++] = cpu_to_fdt32(atag->u.mem.start);
 			mem_reg_property[memcount++] = cpu_to_fdt32(atag->u.mem.size);
 		} else if (atag->hdr.tag == ATAG_INITRD2) {
diff --git a/arch/arm/boot/compressed/head.S b/arch/arm/boot/compressed/head.S
index 38342c7..5e8aa52 100644
--- a/arch/arm/boot/compressed/head.S
+++ b/arch/arm/boot/compressed/head.S
@@ -273,7 +273,7 @@ restart:	adr	r0, LC0
 		add	r0, r0, #0x100
 		mov	r1, r6
 		sub	r2, sp, r6
-		blne	atags_to_fdt
+		bleq	atags_to_fdt
 
 		ldmfd	sp!, {r0-r3, ip, lr}
 		sub	sp, sp, #0x10000
diff --git a/arch/arm/boot/dts/highbank.dts b/arch/arm/boot/dts/highbank.dts
index 305635b..37c0ff9 100644
--- a/arch/arm/boot/dts/highbank.dts
+++ b/arch/arm/boot/dts/highbank.dts
@@ -72,15 +72,15 @@
 		ranges;
 
 		timer@fff10600 {
-			compatible = "arm,smp-twd";
+			compatible = "arm,cortex-a9-twd-timer";
 			reg = <0xfff10600 0x20>;
-			interrupts = <1 13 0xf04>;
+			interrupts = <1 13 0xf01>;
 		};
 
 		watchdog@fff10620 {
-			compatible = "arm,cortex-a9-wdt";
+			compatible = "arm,cortex-a9-twd-wdt";
 			reg = <0xfff10620 0x20>;
-			interrupts = <1 14 0xf04>;
+			interrupts = <1 14 0xf01>;
 		};
 
 		intc: interrupt-controller@fff11000 {
diff --git a/arch/arm/boot/dts/imx6q.dtsi b/arch/arm/boot/dts/imx6q.dtsi
index 263e8f3..4905f51 100644
--- a/arch/arm/boot/dts/imx6q.dtsi
+++ b/arch/arm/boot/dts/imx6q.dtsi
@@ -88,9 +88,9 @@
 		ranges;
 
 		timer@00a00600 {
-			compatible = "arm,smp-twd";
-			reg = <0x00a00600 0x100>;
-			interrupts = <1 13 0xf4>;
+			compatible = "arm,cortex-a9-twd-timer";
+			reg = <0x00a00600 0x20>;
+			interrupts = <1 13 0xf01>;
 		};
 
 		L2: l2-cache@00a02000 {
diff --git a/arch/arm/boot/dts/vexpress-v2f-2xv6-ca15x2.dts b/arch/arm/boot/dts/vexpress-v2f-2xv6-ca15x2.dts
new file mode 100644
index 0000000..dd2e253
--- /dev/null
+++ b/arch/arm/boot/dts/vexpress-v2f-2xv6-ca15x2.dts
@@ -0,0 +1,130 @@
+/*
+ * ARM Ltd. Versatile Express
+ *
+ * LogicTile Express 13MG
+ * V2F-2XV6
+ *
+ * Cortex-A15 (2 cores) Soft Macrocell Model
+ *
+ * HBI-0217B
+ */
+
+/dts-v1/;
+
+/ {
+	model = "V2F-2XV6 Cortex-A15x2 SMM";
+	arm,hbi = <0x217>;
+	compatible = "arm,vexpress,v2f-2xv6,ca15x2", "arm,vexpress,v2f-2xv6", "arm,vexpress";
+	interrupt-parent = <&gic>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	chosen { };
+
+	aliases {
+		serial0 = &v2m_serial0;
+		serial1 = &v2m_serial1;
+		serial2 = &v2m_serial2;
+		serial3 = &v2m_serial3;
+		i2c0 = &v2m_i2c_dvi;
+		i2c1 = &v2m_i2c_pcie;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a15";
+			reg = <0>;
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a15";
+			reg = <1>;
+		};
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x80000000 0x40000000>;
+	};
+
+	gic: interrupt-controller@2c001000 {
+		compatible = "arm,cortex-a15-gic", "arm,cortex-a9-gic";
+		#interrupt-cells = <3>;
+		#address-cells = <0>;
+		interrupt-controller;
+		reg = <0x2c001000 0x1000>,
+		      <0x2c002000 0x100>;
+	};
+
+	timer {
+		compatible = "arm,armv7-timer";
+		interrupts = <1 13 0xf08 1 14 0xf08>;
+	};
+
+	pmu {
+		compatible = "arm,cortex-a15-pmu", "arm,cortex-a9-pmu";
+		interrupts = <0 68 4>,
+			     <0 69 4>;
+	};
+
+	motherboard {
+		ranges = <0 0 0x08000000 0x04000000>,
+			 <1 0 0x14000000 0x04000000>,
+			 <2 0 0x18000000 0x04000000>,
+			 <3 0 0x1c000000 0x04000000>,
+			 <4 0 0x0c000000 0x04000000>,
+			 <5 0 0x10000000 0x04000000>;
+
+		interrupt-map-mask = <0 0 63>;
+		interrupt-map = <0 0  0 &gic 0  0 4>,
+				<0 0  1 &gic 0  1 4>,
+				<0 0  2 &gic 0  2 4>,
+				<0 0  3 &gic 0  3 4>,
+				<0 0  4 &gic 0  4 4>,
+				<0 0  5 &gic 0  5 4>,
+				<0 0  6 &gic 0  6 4>,
+				<0 0  7 &gic 0  7 4>,
+				<0 0  8 &gic 0  8 4>,
+				<0 0  9 &gic 0  9 4>,
+				<0 0 10 &gic 0 10 4>,
+				<0 0 11 &gic 0 11 4>,
+				<0 0 12 &gic 0 12 4>,
+				<0 0 13 &gic 0 13 4>,
+				<0 0 14 &gic 0 14 4>,
+				<0 0 15 &gic 0 15 4>,
+				<0 0 16 &gic 0 16 4>,
+				<0 0 17 &gic 0 17 4>,
+				<0 0 18 &gic 0 18 4>,
+				<0 0 19 &gic 0 19 4>,
+				<0 0 20 &gic 0 20 4>,
+				<0 0 21 &gic 0 21 4>,
+				<0 0 22 &gic 0 22 4>,
+				<0 0 23 &gic 0 23 4>,
+				<0 0 24 &gic 0 24 4>,
+				<0 0 25 &gic 0 25 4>,
+				<0 0 26 &gic 0 26 4>,
+				<0 0 27 &gic 0 27 4>,
+				<0 0 28 &gic 0 28 4>,
+				<0 0 29 &gic 0 29 4>,
+				<0 0 30 &gic 0 30 4>,
+				<0 0 31 &gic 0 31 4>,
+				<0 0 32 &gic 0 32 4>,
+				<0 0 33 &gic 0 33 4>,
+				<0 0 34 &gic 0 34 4>,
+				<0 0 35 &gic 0 35 4>,
+				<0 0 36 &gic 0 36 4>,
+				<0 0 37 &gic 0 37 4>,
+				<0 0 38 &gic 0 38 4>,
+				<0 0 39 &gic 0 39 4>,
+				<0 0 40 &gic 0 40 4>,
+				<0 0 41 &gic 0 41 4>,
+				<0 0 42 &gic 0 42 4>;
+	};
+};
+
+/include/ "vexpress-v2m-rs1.dtsi"
diff --git a/arch/arm/boot/dts/vexpress-v2f-2xv6-ca7x3.dts b/arch/arm/boot/dts/vexpress-v2f-2xv6-ca7x3.dts
new file mode 100644
index 0000000..76c7abd
--- /dev/null
+++ b/arch/arm/boot/dts/vexpress-v2f-2xv6-ca7x3.dts
@@ -0,0 +1,164 @@
+/*
+ * ARM Ltd. Versatile Express
+ *
+ * LogicTile Express 13MG
+ * V2F-2XV6
+ *
+ * Cortex A7 (3 cores) Soft Macrocell Model (r0p2)
+ *
+ * HBI-0217A
+ */
+
+/dts-v1/;
+
+/ {
+	model = "V2F-2XV6 Cortex-A7x3 SMM";
+	arm,hbi = <0x217>;
+	compatible = "arm,vexpress,v2f-2xv6,ca7x3", "arm,vexpress,v2f-2xv6", "arm,vexpress";
+	interrupt-parent = <&gic>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	chosen { };
+
+	aliases {
+		serial0 = &v2m_serial0;
+		serial1 = &v2m_serial1;
+		serial2 = &v2m_serial2;
+		serial3 = &v2m_serial3;
+		i2c0 = &v2m_i2c_dvi;
+		i2c1 = &v2m_i2c_pcie;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			reg = <0>;
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			reg = <1>;
+		};
+
+		cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			reg = <2>;
+		};
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x80000000 0x40000000>;
+	};
+
+	hdlcd@2b000000 {
+		compatible = "arm,hdlcd";
+		reg = <0x2b000000 0x1000>;
+		interrupts = <0 85 4>;
+	};
+
+	memory-controller@2b0a0000 {
+		compatible = "arm,pl341", "arm,primecell";
+		reg = <0x2b0a0000 0x1000>;
+	};
+
+	gic: interrupt-controller@2c001000 {
+		compatible = "arm,cortex-a7-gic", "arm,cortex-a9-gic";
+		#interrupt-cells = <3>;
+		#address-cells = <0>;
+		interrupt-controller;
+		reg = <0x2c001000 0x1000>,
+		      <0x2c002000 0x100>;
+	};
+
+	memory-controller@7ffd0000 {
+		compatible = "arm,pl354", "arm,primecell";
+		reg = <0x7ffd0000 0x1000>;
+		interrupts = <0 86 4>,
+			     <0 87 4>;
+	};
+
+	dma@7ff00000 {
+		compatible = "arm,pl330", "arm,primecell";
+		reg = <0x7ff00000 0x1000>;
+		interrupts = <0 92 4>,
+			     <0 88 4>,
+			     <0 89 4>;
+	};
+
+	timer {
+		compatible = "arm,armv7-timer";
+		interrupts = <1 13 0xf08 1 14 0xf08>;
+		clock-frequency = <40000000>;
+	};
+
+	pmu {
+		compatible = "arm,cortex-a7-pmu", "arm,cortex-a9-pmu";
+		interrupts = <0 68 4>,
+			     <0 69 4>,
+			     <0 70 4>;
+	};
+
+	motherboard {
+		ranges = <0 0 0x08000000 0x04000000>,
+			 <1 0 0x14000000 0x04000000>,
+			 <2 0 0x18000000 0x04000000>,
+			 <3 0 0x1c000000 0x04000000>,
+			 <4 0 0x0c000000 0x04000000>,
+			 <5 0 0x10000000 0x04000000>;
+
+		interrupt-map-mask = <0 0 63>;
+		interrupt-map = <0 0  0 &gic 0  0 4>,
+				<0 0  1 &gic 0  1 4>,
+				<0 0  2 &gic 0  2 4>,
+				<0 0  3 &gic 0  3 4>,
+				<0 0  4 &gic 0  4 4>,
+				<0 0  5 &gic 0  5 4>,
+				<0 0  6 &gic 0  6 4>,
+				<0 0  7 &gic 0  7 4>,
+				<0 0  8 &gic 0  8 4>,
+				<0 0  9 &gic 0  9 4>,
+				<0 0 10 &gic 0 10 4>,
+				<0 0 11 &gic 0 11 4>,
+				<0 0 12 &gic 0 12 4>,
+				<0 0 13 &gic 0 13 4>,
+				<0 0 14 &gic 0 14 4>,
+				<0 0 15 &gic 0 15 4>,
+				<0 0 16 &gic 0 16 4>,
+				<0 0 17 &gic 0 17 4>,
+				<0 0 18 &gic 0 18 4>,
+				<0 0 19 &gic 0 19 4>,
+				<0 0 20 &gic 0 20 4>,
+				<0 0 21 &gic 0 21 4>,
+				<0 0 22 &gic 0 22 4>,
+				<0 0 23 &gic 0 23 4>,
+				<0 0 24 &gic 0 24 4>,
+				<0 0 25 &gic 0 25 4>,
+				<0 0 26 &gic 0 26 4>,
+				<0 0 27 &gic 0 27 4>,
+				<0 0 28 &gic 0 28 4>,
+				<0 0 29 &gic 0 29 4>,
+				<0 0 30 &gic 0 30 4>,
+				<0 0 31 &gic 0 31 4>,
+				<0 0 32 &gic 0 32 4>,
+				<0 0 33 &gic 0 33 4>,
+				<0 0 34 &gic 0 34 4>,
+				<0 0 35 &gic 0 35 4>,
+				<0 0 36 &gic 0 36 4>,
+				<0 0 37 &gic 0 37 4>,
+				<0 0 38 &gic 0 38 4>,
+				<0 0 39 &gic 0 39 4>,
+				<0 0 40 &gic 0 40 4>,
+				<0 0 41 &gic 0 41 4>,
+				<0 0 42 &gic 0 42 4>;
+	};
+};
+
+/include/ "vexpress-v2m-rs1.dtsi"
diff --git a/arch/arm/boot/dts/vexpress-v2m-rs1-rtsm.dtsi b/arch/arm/boot/dts/vexpress-v2m-rs1-rtsm.dtsi
new file mode 100644
index 0000000..a1f71a5
--- /dev/null
+++ b/arch/arm/boot/dts/vexpress-v2m-rs1-rtsm.dtsi
@@ -0,0 +1,184 @@
+/*
+ * ARM Ltd. Versatile Express
+ *
+ * Motherboard Express uATX
+ * V2M-P1
+ *
+ * HBI-0190D
+ *
+ * RS1 memory map ("ARM Cortex-A Series memory map" in the board's
+ * Technical Reference Manual)
+ *
+ */
+
+/ {
+	aliases {
+		arm,v2m_timer = &v2m_timer01;
+	};
+
+	motherboard {
+		compatible = "simple-bus";
+		arm,v2m-memory-map = "rs1";
+		#address-cells = <2>; /* SMB chipselect number and offset */
+		#size-cells = <1>;
+		#interrupt-cells = <1>;
+
+		flash@0,00000000 {
+			compatible = "arm,vexpress-flash", "cfi-flash";
+			reg = <0 0x00000000 0x04000000>,
+			      <4 0x00000000 0x04000000>;
+			bank-width = <4>;
+		};
+
+		psram@1,00000000 {
+			compatible = "arm,vexpress-psram", "mtd-ram";
+			reg = <1 0x00000000 0x02000000>;
+			bank-width = <4>;
+		};
+
+		vram@2,00000000 {
+			compatible = "arm,vexpress-vram";
+			reg = <2 0x00000000 0x00800000>;
+		};
+
+		ethernet@2,02000000 {
+			compatible = "smsc,lan91c111";
+			reg = <2 0x02000000 0x10000>;
+			interrupts = <15>;
+		};
+
+		usb@2,03000000 {
+			compatible = "nxp,usb-isp1761";
+			reg = <2 0x03000000 0x20000>;
+			interrupts = <16>;
+			port1-otg;
+		};
+
+		iofpga@3,00000000 {
+			compatible = "arm,amba-bus", "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 3 0 0x200000>;
+
+			sysreg@010000 {
+				compatible = "arm,vexpress-sysreg";
+				reg = <0x010000 0x1000>;
+			};
+
+			sysctl@020000 {
+				compatible = "arm,sp810", "arm,primecell";
+				reg = <0x020000 0x1000>;
+			};
+
+			/* PCI-E I2C bus */
+			v2m_i2c_pcie: i2c@030000 {
+				compatible = "arm,versatile-i2c";
+				reg = <0x030000 0x1000>;
+
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				pcie-switch@60 {
+					compatible = "idt,89hpes32h8";
+					reg = <0x60>;
+				};
+			};
+
+			aaci@040000 {
+				compatible = "arm,pl041", "arm,primecell";
+				reg = <0x040000 0x1000>;
+				interrupts = <11>;
+			};
+
+			mmci@050000 {
+				compatible = "arm,pl180", "arm,primecell";
+				reg = <0x050000 0x1000>;
+				interrupts = <9 10>;
+			};
+
+			kmi@060000 {
+				compatible = "arm,pl050", "arm,primecell";
+				reg = <0x060000 0x1000>;
+				interrupts = <12>;
+			};
+
+			kmi@070000 {
+				compatible = "arm,pl050", "arm,primecell";
+				reg = <0x070000 0x1000>;
+				interrupts = <13>;
+			};
+
+			v2m_serial0: uart@090000 {
+				compatible = "arm,pl011", "arm,primecell";
+				reg = <0x090000 0x1000>;
+				interrupts = <5>;
+			};
+
+			v2m_serial1: uart@0a0000 {
+				compatible = "arm,pl011", "arm,primecell";
+				reg = <0x0a0000 0x1000>;
+				interrupts = <6>;
+			};
+
+			v2m_serial2: uart@0b0000 {
+				compatible = "arm,pl011", "arm,primecell";
+				reg = <0x0b0000 0x1000>;
+				interrupts = <7>;
+			};
+
+			v2m_serial3: uart@0c0000 {
+				compatible = "arm,pl011", "arm,primecell";
+				reg = <0x0c0000 0x1000>;
+				interrupts = <8>;
+			};
+
+			wdt@0f0000 {
+				compatible = "arm,sp805", "arm,primecell";
+				reg = <0x0f0000 0x1000>;
+				interrupts = <0>;
+			};
+
+			v2m_timer01: timer@110000 {
+				compatible = "arm,sp804", "arm,primecell";
+				reg = <0x110000 0x1000>;
+				interrupts = <2>;
+			};
+
+			v2m_timer23: timer@120000 {
+				compatible = "arm,sp804", "arm,primecell";
+				reg = <0x120000 0x1000>;
+			};
+
+			/* DVI I2C bus */
+			v2m_i2c_dvi: i2c@160000 {
+				compatible = "arm,versatile-i2c";
+				reg = <0x160000 0x1000>;
+
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				dvi-transmitter@39 {
+					compatible = "sil,sii9022-tpi", "sil,sii9022";
+					reg = <0x39>;
+				};
+
+				dvi-transmitter@60 {
+					compatible = "sil,sii9022-cpi", "sil,sii9022";
+					reg = <0x60>;
+				};
+			};
+
+			rtc@170000 {
+				compatible = "arm,pl031", "arm,primecell";
+				reg = <0x170000 0x1000>;
+				interrupts = <4>;
+			};
+
+			clcd@1f0000 {
+				compatible = "arm,pl111", "arm,primecell";
+				reg = <0x1f0000 0x1000>;
+				interrupts = <14>;
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/vexpress-v2m-rs1.dtsi b/arch/arm/boot/dts/vexpress-v2m-rs1.dtsi
new file mode 100644
index 0000000..16076e2
--- /dev/null
+++ b/arch/arm/boot/dts/vexpress-v2m-rs1.dtsi
@@ -0,0 +1,201 @@
+/*
+ * ARM Ltd. Versatile Express
+ *
+ * Motherboard Express uATX
+ * V2M-P1
+ *
+ * HBI-0190D
+ *
+ * RS1 memory map ("ARM Cortex-A Series memory map" in the board's
+ * Technical Reference Manual)
+ *
+ * WARNING! The hardware described in this file is independent from the
+ * original variant (vexpress-v2m.dtsi), but there is a strong
+ * correspondence between the two configurations.
+ *
+ * TAKE CARE WHEN MAINTAINING THIS FILE TO PROPAGATE ANY RELEVANT
+ * CHANGES TO vexpress-v2m.dtsi!
+ */
+
+/ {
+	aliases {
+		arm,v2m_timer = &v2m_timer01;
+	};
+
+	motherboard {
+		compatible = "simple-bus";
+		arm,v2m-memory-map = "rs1";
+		#address-cells = <2>; /* SMB chipselect number and offset */
+		#size-cells = <1>;
+		#interrupt-cells = <1>;
+
+		flash@0,00000000 {
+			compatible = "arm,vexpress-flash", "cfi-flash";
+			reg = <0 0x00000000 0x04000000>,
+			      <4 0x00000000 0x04000000>;
+			bank-width = <4>;
+		};
+
+		psram@1,00000000 {
+			compatible = "arm,vexpress-psram", "mtd-ram";
+			reg = <1 0x00000000 0x02000000>;
+			bank-width = <4>;
+		};
+
+		vram@2,00000000 {
+			compatible = "arm,vexpress-vram";
+			reg = <2 0x00000000 0x00800000>;
+		};
+
+		ethernet@2,02000000 {
+			compatible = "smsc,lan9118", "smsc,lan9115";
+			reg = <2 0x02000000 0x10000>;
+			interrupts = <15>;
+			phy-mode = "mii";
+			reg-io-width = <4>;
+			smsc,irq-active-high;
+			smsc,irq-push-pull;
+		};
+
+		usb@2,03000000 {
+			compatible = "nxp,usb-isp1761";
+			reg = <2 0x03000000 0x20000>;
+			interrupts = <16>;
+			port1-otg;
+		};
+
+		iofpga@3,00000000 {
+			compatible = "arm,amba-bus", "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 3 0 0x200000>;
+
+			sysreg@010000 {
+				compatible = "arm,vexpress-sysreg";
+				reg = <0x010000 0x1000>;
+			};
+
+			sysctl@020000 {
+				compatible = "arm,sp810", "arm,primecell";
+				reg = <0x020000 0x1000>;
+			};
+
+			/* PCI-E I2C bus */
+			v2m_i2c_pcie: i2c@030000 {
+				compatible = "arm,versatile-i2c";
+				reg = <0x030000 0x1000>;
+
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				pcie-switch@60 {
+					compatible = "idt,89hpes32h8";
+					reg = <0x60>;
+				};
+			};
+
+			aaci@040000 {
+				compatible = "arm,pl041", "arm,primecell";
+				reg = <0x040000 0x1000>;
+				interrupts = <11>;
+			};
+
+			mmci@050000 {
+				compatible = "arm,pl180", "arm,primecell";
+				reg = <0x050000 0x1000>;
+				interrupts = <9 10>;
+			};
+
+			kmi@060000 {
+				compatible = "arm,pl050", "arm,primecell";
+				reg = <0x060000 0x1000>;
+				interrupts = <12>;
+			};
+
+			kmi@070000 {
+				compatible = "arm,pl050", "arm,primecell";
+				reg = <0x070000 0x1000>;
+				interrupts = <13>;
+			};
+
+			v2m_serial0: uart@090000 {
+				compatible = "arm,pl011", "arm,primecell";
+				reg = <0x090000 0x1000>;
+				interrupts = <5>;
+			};
+
+			v2m_serial1: uart@0a0000 {
+				compatible = "arm,pl011", "arm,primecell";
+				reg = <0x0a0000 0x1000>;
+				interrupts = <6>;
+			};
+
+			v2m_serial2: uart@0b0000 {
+				compatible = "arm,pl011", "arm,primecell";
+				reg = <0x0b0000 0x1000>;
+				interrupts = <7>;
+			};
+
+			v2m_serial3: uart@0c0000 {
+				compatible = "arm,pl011", "arm,primecell";
+				reg = <0x0c0000 0x1000>;
+				interrupts = <8>;
+			};
+
+			wdt@0f0000 {
+				compatible = "arm,sp805", "arm,primecell";
+				reg = <0x0f0000 0x1000>;
+				interrupts = <0>;
+			};
+
+			v2m_timer01: timer@110000 {
+				compatible = "arm,sp804", "arm,primecell";
+				reg = <0x110000 0x1000>;
+				interrupts = <2>;
+			};
+
+			v2m_timer23: timer@120000 {
+				compatible = "arm,sp804", "arm,primecell";
+				reg = <0x120000 0x1000>;
+			};
+
+			/* DVI I2C bus */
+			v2m_i2c_dvi: i2c@160000 {
+				compatible = "arm,versatile-i2c";
+				reg = <0x160000 0x1000>;
+
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				dvi-transmitter@39 {
+					compatible = "sil,sii9022-tpi", "sil,sii9022";
+					reg = <0x39>;
+				};
+
+				dvi-transmitter@60 {
+					compatible = "sil,sii9022-cpi", "sil,sii9022";
+					reg = <0x60>;
+				};
+			};
+
+			rtc@170000 {
+				compatible = "arm,pl031", "arm,primecell";
+				reg = <0x170000 0x1000>;
+				interrupts = <4>;
+			};
+
+			compact-flash@1a0000 {
+				compatible = "arm,vexpress-cf", "ata-generic";
+				reg = <0x1a0000 0x100
+				       0x1a0100 0xf00>;
+				reg-shift = <2>;
+			};
+
+			clcd@1f0000 {
+				compatible = "arm,pl111", "arm,primecell";
+				reg = <0x1f0000 0x1000>;
+				interrupts = <14>;
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/vexpress-v2m.dtsi b/arch/arm/boot/dts/vexpress-v2m.dtsi
new file mode 100644
index 0000000..a6c9c7c
--- /dev/null
+++ b/arch/arm/boot/dts/vexpress-v2m.dtsi
@@ -0,0 +1,200 @@
+/*
+ * ARM Ltd. Versatile Express
+ *
+ * Motherboard Express uATX
+ * V2M-P1
+ *
+ * HBI-0190D
+ *
+ * Original memory map ("Legacy memory map" in the board's
+ * Technical Reference Manual)
+ *
+ * WARNING! The hardware described in this file is independent from the
+ * RS1 variant (vexpress-v2m-rs1.dtsi), but there is a strong
+ * correspondence between the two configurations.
+ *
+ * TAKE CARE WHEN MAINTAINING THIS FILE TO PROPAGATE ANY RELEVANT
+ * CHANGES TO vexpress-v2m-rs1.dtsi!
+ */
+
+/ {
+	aliases {
+		arm,v2m_timer = &v2m_timer01;
+	};
+
+	motherboard {
+		compatible = "simple-bus";
+		#address-cells = <2>; /* SMB chipselect number and offset */
+		#size-cells = <1>;
+		#interrupt-cells = <1>;
+
+		flash@0,00000000 {
+			compatible = "arm,vexpress-flash", "cfi-flash";
+			reg = <0 0x00000000 0x04000000>,
+			      <1 0x00000000 0x04000000>;
+			bank-width = <4>;
+		};
+
+		psram@2,00000000 {
+			compatible = "arm,vexpress-psram", "mtd-ram";
+			reg = <2 0x00000000 0x02000000>;
+			bank-width = <4>;
+		};
+
+		vram@3,00000000 {
+			compatible = "arm,vexpress-vram";
+			reg = <3 0x00000000 0x00800000>;
+		};
+
+		ethernet@3,02000000 {
+			compatible = "smsc,lan9118", "smsc,lan9115";
+			reg = <3 0x02000000 0x10000>;
+			interrupts = <15>;
+			phy-mode = "mii";
+			reg-io-width = <4>;
+			smsc,irq-active-high;
+			smsc,irq-push-pull;
+		};
+
+		usb@3,03000000 {
+			compatible = "nxp,usb-isp1761";
+			reg = <3 0x03000000 0x20000>;
+			interrupts = <16>;
+			port1-otg;
+		};
+
+		iofpga@7,00000000 {
+			compatible = "arm,amba-bus", "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 7 0 0x20000>;
+
+			sysreg@00000 {
+				compatible = "arm,vexpress-sysreg";
+				reg = <0x00000 0x1000>;
+			};
+
+			sysctl@01000 {
+				compatible = "arm,sp810", "arm,primecell";
+				reg = <0x01000 0x1000>;
+			};
+
+			/* PCI-E I2C bus */
+			v2m_i2c_pcie: i2c@02000 {
+				compatible = "arm,versatile-i2c";
+				reg = <0x02000 0x1000>;
+
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				pcie-switch@60 {
+					compatible = "idt,89hpes32h8";
+					reg = <0x60>;
+				};
+			};
+
+			aaci@04000 {
+				compatible = "arm,pl041", "arm,primecell";
+				reg = <0x04000 0x1000>;
+				interrupts = <11>;
+			};
+
+			mmci@05000 {
+				compatible = "arm,pl180", "arm,primecell";
+				reg = <0x05000 0x1000>;
+				interrupts = <9 10>;
+			};
+
+			kmi@06000 {
+				compatible = "arm,pl050", "arm,primecell";
+				reg = <0x06000 0x1000>;
+				interrupts = <12>;
+			};
+
+			kmi@07000 {
+				compatible = "arm,pl050", "arm,primecell";
+				reg = <0x07000 0x1000>;
+				interrupts = <13>;
+			};
+
+			v2m_serial0: uart@09000 {
+				compatible = "arm,pl011", "arm,primecell";
+				reg = <0x09000 0x1000>;
+				interrupts = <5>;
+			};
+
+			v2m_serial1: uart@0a000 {
+				compatible = "arm,pl011", "arm,primecell";
+				reg = <0x0a000 0x1000>;
+				interrupts = <6>;
+			};
+
+			v2m_serial2: uart@0b000 {
+				compatible = "arm,pl011", "arm,primecell";
+				reg = <0x0b000 0x1000>;
+				interrupts = <7>;
+			};
+
+			v2m_serial3: uart@0c000 {
+				compatible = "arm,pl011", "arm,primecell";
+				reg = <0x0c000 0x1000>;
+				interrupts = <8>;
+			};
+
+			wdt@0f000 {
+				compatible = "arm,sp805", "arm,primecell";
+				reg = <0x0f000 0x1000>;
+				interrupts = <0>;
+			};
+
+			v2m_timer01: timer@11000 {
+				compatible = "arm,sp804", "arm,primecell";
+				reg = <0x11000 0x1000>;
+				interrupts = <2>;
+			};
+
+			v2m_timer23: timer@12000 {
+				compatible = "arm,sp804", "arm,primecell";
+				reg = <0x12000 0x1000>;
+			};
+
+			/* DVI I2C bus */
+			v2m_i2c_dvi: i2c@16000 {
+				compatible = "arm,versatile-i2c";
+				reg = <0x16000 0x1000>;
+
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				dvi-transmitter@39 {
+					compatible = "sil,sii9022-tpi", "sil,sii9022";
+					reg = <0x39>;
+				};
+
+				dvi-transmitter@60 {
+					compatible = "sil,sii9022-cpi", "sil,sii9022";
+					reg = <0x60>;
+				};
+			};
+
+			rtc@17000 {
+				compatible = "arm,pl031", "arm,primecell";
+				reg = <0x17000 0x1000>;
+				interrupts = <4>;
+			};
+
+			compact-flash@1a000 {
+				compatible = "arm,vexpress-cf", "ata-generic";
+				reg = <0x1a000 0x100
+				       0x1a100 0xf00>;
+				reg-shift = <2>;
+			};
+
+			clcd@1f000 {
+				compatible = "arm,pl111", "arm,primecell";
+				reg = <0x1f000 0x1000>;
+				interrupts = <14>;
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/vexpress-v2p-ca15-rtsm.dts b/arch/arm/boot/dts/vexpress-v2p-ca15-rtsm.dts
new file mode 100644
index 0000000..b080265
--- /dev/null
+++ b/arch/arm/boot/dts/vexpress-v2p-ca15-rtsm.dts
@@ -0,0 +1,134 @@
+/*
+ * ARM Ltd. Versatile Express
+ *
+ * CoreTile Express A15x2 (on ARM RTSM)
+ * Cortex-A15 MPCore (V2P-CA15)
+ *
+ * HBI-0237A
+ */
+
+/dts-v1/;
+
+/ {
+	model = "V2P-CA15";
+	compatible = "arm,vexpress,v2p-ca15", "arm,vexpress";
+	interrupt-parent = <&gic>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	chosen { };
+
+	aliases {
+		serial0 = &v2m_serial0;
+		serial1 = &v2m_serial1;
+		serial2 = &v2m_serial2;
+		serial3 = &v2m_serial3;
+		i2c0 = &v2m_i2c_dvi;
+		i2c1 = &v2m_i2c_pcie;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a15";
+			reg = <0>;
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a15";
+			reg = <1>;
+		};
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x80000000 0x80000000>;
+	};
+
+	hdlcd@2b000000 {
+		compatible = "arm,hdlcd";
+		reg = <0x2b000000 0x1000>;
+		interrupts = <0 85 4>;
+	};
+
+
+	gic: interrupt-controller@2c001000 {
+		compatible = "arm,cortex-a15-gic", "arm,cortex-a9-gic";
+		#interrupt-cells = <3>;
+		#address-cells = <0>;
+		interrupt-controller;
+		reg = <0x2c001000 0x1000>,
+		      <0x2c002000 0x100>;
+	};
+
+	timer {
+		compatible = "arm,armv7-timer";
+		interrupts = <1 13 0xf08 1 14 0xf08>;
+	};
+
+	pmu {
+		compatible = "arm,cortex-a15-pmu", "arm,cortex-a9-pmu";
+		interrupts = <0 68 4>,
+			     <0 69 4>;
+	};
+
+	motherboard {
+		ranges = <0 0 0x08000000 0x04000000>,
+			 <1 0 0x14000000 0x04000000>,
+			 <2 0 0x18000000 0x04000000>,
+			 <3 0 0x1c000000 0x04000000>,
+			 <4 0 0x0c000000 0x04000000>,
+			 <5 0 0x10000000 0x04000000>;
+
+		interrupt-map-mask = <0 0 63>;
+		interrupt-map = <0 0  0 &gic 0  0 4>,
+				<0 0  1 &gic 0  1 4>,
+				<0 0  2 &gic 0  2 4>,
+				<0 0  3 &gic 0  3 4>,
+				<0 0  4 &gic 0  4 4>,
+				<0 0  5 &gic 0  5 4>,
+				<0 0  6 &gic 0  6 4>,
+				<0 0  7 &gic 0  7 4>,
+				<0 0  8 &gic 0  8 4>,
+				<0 0  9 &gic 0  9 4>,
+				<0 0 10 &gic 0 10 4>,
+				<0 0 11 &gic 0 11 4>,
+				<0 0 12 &gic 0 12 4>,
+				<0 0 13 &gic 0 13 4>,
+				<0 0 14 &gic 0 14 4>,
+				<0 0 15 &gic 0 15 4>,
+				<0 0 16 &gic 0 16 4>,
+				<0 0 17 &gic 0 17 4>,
+				<0 0 18 &gic 0 18 4>,
+				<0 0 19 &gic 0 19 4>,
+				<0 0 20 &gic 0 20 4>,
+				<0 0 21 &gic 0 21 4>,
+				<0 0 22 &gic 0 22 4>,
+				<0 0 23 &gic 0 23 4>,
+				<0 0 24 &gic 0 24 4>,
+				<0 0 25 &gic 0 25 4>,
+				<0 0 26 &gic 0 26 4>,
+				<0 0 27 &gic 0 27 4>,
+				<0 0 28 &gic 0 28 4>,
+				<0 0 29 &gic 0 29 4>,
+				<0 0 30 &gic 0 30 4>,
+				<0 0 31 &gic 0 31 4>,
+				<0 0 32 &gic 0 32 4>,
+				<0 0 33 &gic 0 33 4>,
+				<0 0 34 &gic 0 34 4>,
+				<0 0 35 &gic 0 35 4>,
+				<0 0 36 &gic 0 36 4>,
+				<0 0 37 &gic 0 37 4>,
+				<0 0 38 &gic 0 38 4>,
+				<0 0 39 &gic 0 39 4>,
+				<0 0 40 &gic 0 40 4>,
+				<0 0 41 &gic 0 41 4>,
+				<0 0 42 &gic 0 42 4>;
+	};
+};
+
+/include/ "vexpress-v2m-rs1-rtsm.dtsi"
diff --git a/arch/arm/boot/dts/vexpress-v2p-ca5s.dts b/arch/arm/boot/dts/vexpress-v2p-ca5s.dts
new file mode 100644
index 0000000..18917a0
--- /dev/null
+++ b/arch/arm/boot/dts/vexpress-v2p-ca5s.dts
@@ -0,0 +1,167 @@
+/*
+ * ARM Ltd. Versatile Express
+ *
+ * CoreTile Express A5x2
+ * Cortex-A5 MPCore (V2P-CA5s)
+ *
+ * HBI-0225B
+ */
+
+/dts-v1/;
+
+/ {
+	model = "V2P-CA5s";
+	arm,hbi = <0x225>;
+	compatible = "arm,vexpress,v2p-ca5s", "arm,vexpress";
+	interrupt-parent = <&gic>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	chosen { };
+
+	aliases {
+		serial0 = &v2m_serial0;
+		serial1 = &v2m_serial1;
+		serial2 = &v2m_serial2;
+		serial3 = &v2m_serial3;
+		i2c0 = &v2m_i2c_dvi;
+		i2c1 = &v2m_i2c_pcie;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a5";
+			reg = <0>;
+			next-level-cache = <&L2>;
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a5";
+			reg = <1>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x80000000 0x40000000>;
+	};
+
+	hdlcd@2a110000 {
+		compatible = "arm,hdlcd";
+		reg = <0x2a110000 0x1000>;
+		interrupts = <0 85 4>;
+	};
+
+	memory-controller@2a150000 {
+		compatible = "arm,pl341", "arm,primecell";
+		reg = <0x2a150000 0x1000>;
+	};
+
+	memory-controller@2a190000 {
+		compatible = "arm,pl354", "arm,primecell";
+		reg = <0x2a190000 0x1000>;
+		interrupts = <0 86 4>,
+			     <0 87 4>;
+	};
+
+	scu@2c000000 {
+		compatible = "arm,cortex-a5-scu";
+		reg = <0x2c000000 0x58>;
+	};
+
+	timer@2c000600 {
+		compatible = "arm,cortex-a5-twd-timer";
+		reg = <0x2c000600 0x20>;
+		interrupts = <1 13 0x304>;
+	};
+
+	watchdog@2c000620 {
+		compatible = "arm,cortex-a5-twd-wdt";
+		reg = <0x2c000620 0x20>;
+		interrupts = <1 14 0x304>;
+	};
+
+	gic: interrupt-controller@2c001000 {
+		compatible = "arm,cortex-a5-gic", "arm,cortex-a9-gic";
+		#interrupt-cells = <3>;
+		#address-cells = <0>;
+		interrupt-controller;
+		reg = <0x2c001000 0x1000>,
+		      <0x2c000100 0x100>;
+	};
+
+	L2: cache-controller@2c0f0000 {
+		compatible = "arm,pl310-cache";
+		reg = <0x2c0f0000 0x1000>;
+		interrupts = <0 84 4>;
+		cache-level = <2>;
+	};
+
+	pmu {
+		compatible = "arm,cortex-a5-pmu", "arm,cortex-a9-pmu";
+		interrupts = <0 68 4>,
+			     <0 69 4>;
+	};
+
+	motherboard {
+		ranges = <0 0 0x08000000 0x04000000>,
+			 <1 0 0x14000000 0x04000000>,
+			 <2 0 0x18000000 0x04000000>,
+			 <3 0 0x1c000000 0x04000000>,
+			 <4 0 0x0c000000 0x04000000>,
+			 <5 0 0x10000000 0x04000000>;
+
+		interrupt-map-mask = <0 0 63>;
+		interrupt-map = <0 0  0 &gic 0  0 4>,
+				<0 0  1 &gic 0  1 4>,
+				<0 0  2 &gic 0  2 4>,
+				<0 0  3 &gic 0  3 4>,
+				<0 0  4 &gic 0  4 4>,
+				<0 0  5 &gic 0  5 4>,
+				<0 0  6 &gic 0  6 4>,
+				<0 0  7 &gic 0  7 4>,
+				<0 0  8 &gic 0  8 4>,
+				<0 0  9 &gic 0  9 4>,
+				<0 0 10 &gic 0 10 4>,
+				<0 0 11 &gic 0 11 4>,
+				<0 0 12 &gic 0 12 4>,
+				<0 0 13 &gic 0 13 4>,
+				<0 0 14 &gic 0 14 4>,
+				<0 0 15 &gic 0 15 4>,
+				<0 0 16 &gic 0 16 4>,
+				<0 0 17 &gic 0 17 4>,
+				<0 0 18 &gic 0 18 4>,
+				<0 0 19 &gic 0 19 4>,
+				<0 0 20 &gic 0 20 4>,
+				<0 0 21 &gic 0 21 4>,
+				<0 0 22 &gic 0 22 4>,
+				<0 0 23 &gic 0 23 4>,
+				<0 0 24 &gic 0 24 4>,
+				<0 0 25 &gic 0 25 4>,
+				<0 0 26 &gic 0 26 4>,
+				<0 0 27 &gic 0 27 4>,
+				<0 0 28 &gic 0 28 4>,
+				<0 0 29 &gic 0 29 4>,
+				<0 0 30 &gic 0 30 4>,
+				<0 0 31 &gic 0 31 4>,
+				<0 0 32 &gic 0 32 4>,
+				<0 0 33 &gic 0 33 4>,
+				<0 0 34 &gic 0 34 4>,
+				<0 0 35 &gic 0 35 4>,
+				<0 0 36 &gic 0 36 4>,
+				<0 0 37 &gic 0 37 4>,
+				<0 0 38 &gic 0 38 4>,
+				<0 0 39 &gic 0 39 4>,
+				<0 0 40 &gic 0 40 4>,
+				<0 0 41 &gic 0 41 4>,
+				<0 0 42 &gic 0 42 4>;
+	};
+};
+
+/include/ "vexpress-v2m-rs1.dtsi"
diff --git a/arch/arm/boot/dts/vexpress-v2p-ca9.dts b/arch/arm/boot/dts/vexpress-v2p-ca9.dts
new file mode 100644
index 0000000..b1607c8
--- /dev/null
+++ b/arch/arm/boot/dts/vexpress-v2p-ca9.dts
@@ -0,0 +1,191 @@
+/*
+ * ARM Ltd. Versatile Express
+ *
+ * CoreTile Express A9x4
+ * Cortex-A9 MPCore (V2P-CA9)
+ *
+ * HBI-0191B
+ */
+
+/dts-v1/;
+
+/ {
+	model = "V2P-CA9";
+	arm,hbi = <0x191>;
+	compatible = "arm,vexpress,v2p-ca9", "arm,vexpress";
+	interrupt-parent = <&gic>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	chosen { };
+
+	aliases {
+		serial0 = &v2m_serial0;
+		serial1 = &v2m_serial1;
+		serial2 = &v2m_serial2;
+		serial3 = &v2m_serial3;
+		i2c0 = &v2m_i2c_dvi;
+		i2c1 = &v2m_i2c_pcie;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0>;
+			next-level-cache = <&L2>;
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <1>;
+			next-level-cache = <&L2>;
+		};
+
+		cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <2>;
+			next-level-cache = <&L2>;
+		};
+
+		cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <3>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	memory@60000000 {
+		device_type = "memory";
+		reg = <0x60000000 0x40000000>;
+	};
+
+	clcd@10020000 {
+		compatible = "arm,pl111", "arm,primecell";
+		reg = <0x10020000 0x1000>;
+		interrupts = <0 44 4>;
+	};
+
+	memory-controller@100e0000 {
+		compatible = "arm,pl341", "arm,primecell";
+		reg = <0x100e0000 0x1000>;
+	};
+
+	memory-controller@100e1000 {
+		compatible = "arm,pl354", "arm,primecell";
+		reg = <0x100e1000 0x1000>;
+		interrupts = <0 45 4>,
+			     <0 46 4>;
+	};
+
+	timer@100e4000 {
+		compatible = "arm,sp804", "arm,primecell";
+		reg = <0x100e4000 0x1000>;
+		interrupts = <0 48 4>,
+			     <0 49 4>;
+	};
+
+	scu@1e000000 {
+		compatible = "arm,cortex-a9-scu";
+		reg = <0x1e000000 0x58>;
+	};
+
+	timer@1e000600 {
+		compatible = "arm,cortex-a9-twd-timer";
+		reg = <0x1e000600 0x20>;
+		interrupts = <1 13 0xf04>;
+	};
+
+	watchdog@1e000620 {
+		compatible = "arm,cortex-a9-twd-wdt";
+		reg = <0x1e000620 0x20>;
+		interrupts = <1 14 0xf04>;
+	};
+
+	gic: interrupt-controller@1e001000 {
+		compatible = "arm,cortex-a9-gic";
+		#interrupt-cells = <3>;
+		#address-cells = <0>;
+		interrupt-controller;
+		reg = <0x1e001000 0x1000>,
+		      <0x1e000100 0x100>;
+	};
+
+	L2: cache-controller@1e00a000 {
+		compatible = "arm,pl310-cache";
+		reg = <0x1e00a000 0x1000>;
+		interrupts = <0 43 4>;
+		cache-level = <2>;
+		arm,data-latency = <1 1 1>;
+		arm,tag-latency = <1 1 1>;
+	};
+
+	pmu {
+		compatible = "arm,cortex-a9-pmu";
+		interrupts = <0 60 4>,
+			     <0 61 4>,
+			     <0 62 4>,
+			     <0 63 4>;
+	};
+
+	motherboard {
+		ranges = <0 0 0x40000000 0x04000000>,
+			 <1 0 0x44000000 0x04000000>,
+			 <2 0 0x48000000 0x04000000>,
+			 <3 0 0x4c000000 0x04000000>,
+			 <7 0 0x10000000 0x00020000>;
+
+		interrupt-map-mask = <0 0 63>;
+		interrupt-map = <0 0  0 &gic 0  0 4>,
+				<0 0  1 &gic 0  1 4>,
+				<0 0  2 &gic 0  2 4>,
+				<0 0  3 &gic 0  3 4>,
+				<0 0  4 &gic 0  4 4>,
+				<0 0  5 &gic 0  5 4>,
+				<0 0  6 &gic 0  6 4>,
+				<0 0  7 &gic 0  7 4>,
+				<0 0  8 &gic 0  8 4>,
+				<0 0  9 &gic 0  9 4>,
+				<0 0 10 &gic 0 10 4>,
+				<0 0 11 &gic 0 11 4>,
+				<0 0 12 &gic 0 12 4>,
+				<0 0 13 &gic 0 13 4>,
+				<0 0 14 &gic 0 14 4>,
+				<0 0 15 &gic 0 15 4>,
+				<0 0 16 &gic 0 16 4>,
+				<0 0 17 &gic 0 17 4>,
+				<0 0 18 &gic 0 18 4>,
+				<0 0 19 &gic 0 19 4>,
+				<0 0 20 &gic 0 20 4>,
+				<0 0 21 &gic 0 21 4>,
+				<0 0 22 &gic 0 22 4>,
+				<0 0 23 &gic 0 23 4>,
+				<0 0 24 &gic 0 24 4>,
+				<0 0 25 &gic 0 25 4>,
+				<0 0 26 &gic 0 26 4>,
+				<0 0 27 &gic 0 27 4>,
+				<0 0 28 &gic 0 28 4>,
+				<0 0 29 &gic 0 29 4>,
+				<0 0 30 &gic 0 30 4>,
+				<0 0 31 &gic 0 31 4>,
+				<0 0 32 &gic 0 32 4>,
+				<0 0 33 &gic 0 33 4>,
+				<0 0 34 &gic 0 34 4>,
+				<0 0 35 &gic 0 35 4>,
+				<0 0 36 &gic 0 36 4>,
+				<0 0 37 &gic 0 37 4>,
+				<0 0 38 &gic 0 38 4>,
+				<0 0 39 &gic 0 39 4>,
+				<0 0 40 &gic 0 40 4>,
+				<0 0 41 &gic 0 41 4>,
+				<0 0 42 &gic 0 42 4>;
+	};
+};
+
+/include/ "vexpress-v2m.dtsi"
diff --git a/arch/arm/common/gic.c b/arch/arm/common/gic.c
index c47d619..ca6b5dd 100644
--- a/arch/arm/common/gic.c
+++ b/arch/arm/common/gic.c
@@ -694,13 +694,12 @@ void __init gic_init_bases(unsigned int gic_nr, int irq_start,
 	 * For primary GICs, skip over SGIs.
 	 * For secondary GICs, skip over PPIs, too.
 	 */
-	domain->hwirq_base = 32;
-	if (gic_nr == 0) {
-		if ((irq_start & 31) > 0) {
-			domain->hwirq_base = 16;
-			if (irq_start != -1)
-				irq_start = (irq_start & ~31) + 16;
-		}
+	if (gic_nr == 0 && (irq_start & 31) > 0) {
+		domain->hwirq_base = 16;
+		if (irq_start != -1)
+			irq_start = (irq_start & ~31) + 16;
+	} else {
+		domain->hwirq_base = 32;
 	}
 
 	/*
diff --git a/arch/arm/common/vic.c b/arch/arm/common/vic.c
index dcb004a..cb6b49a 100644
--- a/arch/arm/common/vic.c
+++ b/arch/arm/common/vic.c
@@ -441,11 +441,9 @@ static int handle_one_vic(struct vic_device *vic, struct pt_regs *regs)
 	u32 stat, irq;
 	int handled = 0;
 
-	stat = readl_relaxed(vic->base + VIC_IRQ_STATUS);
-	while (stat) {
+	while ((stat = readl_relaxed(vic->base + VIC_IRQ_STATUS))) {
 		irq = ffs(stat) - 1;
 		handle_IRQ(irq_domain_to_irq(&vic->domain, irq), regs);
-		stat &= ~(1 << irq);
 		handled = 1;
 	}
 
diff --git a/arch/arm/configs/realview_ael_defconfig b/arch/arm/configs/realview_ael_defconfig
new file mode 100644
index 0000000..14e833e8
--- /dev/null
+++ b/arch/arm/configs/realview_ael_defconfig
@@ -0,0 +1,210 @@
+CONFIG_EXPERIMENTAL=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_FHANDLE=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_AUDIT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_NET_NS is not set
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_EMBEDDED=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_ARCH_REALVIEW=y
+CONFIG_MACH_REALVIEW_EB=y
+CONFIG_REALVIEW_EB_A9MP=y
+CONFIG_REALVIEW_EB_ARM11MP=y
+CONFIG_MACH_REALVIEW_PB11MP=y
+CONFIG_MACH_REALVIEW_PB1176=y
+CONFIG_MACH_REALVIEW_PBA8=y
+CONFIG_MACH_REALVIEW_PBX=y
+CONFIG_ARM_THUMBEE=y
+CONFIG_ARM_ERRATA_326103=y
+CONFIG_ARM_ERRATA_411920=y
+CONFIG_ARM_ERRATA_430973=y
+CONFIG_ARM_ERRATA_458693=y
+CONFIG_ARM_ERRATA_460075=y
+CONFIG_ARM_ERRATA_742230=y
+CONFIG_ARM_ERRATA_742231=y
+CONFIG_PL310_ERRATA_588369=y
+CONFIG_ARM_ERRATA_720789=y
+CONFIG_PL310_ERRATA_727915=y
+CONFIG_ARM_ERRATA_743622=y
+CONFIG_ARM_ERRATA_751472=y
+CONFIG_ARM_ERRATA_754322=y
+CONFIG_ARM_ERRATA_754327=y
+CONFIG_ARM_ERRATA_764369=y
+CONFIG_PL310_ERRATA_769419=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_SMP=y
+CONFIG_HOTPLUG_CPU=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+CONFIG_HIGHMEM=y
+CONFIG_HIGHPTE=y
+CONFIG_COMPACTION=y
+CONFIG_KSM=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_KEXEC=y
+CONFIG_AUTO_ZRELADDR=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_MISC=y
+# CONFIG_SUSPEND is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_INET_LRO is not set
+# CONFIG_IPV6 is not set
+# CONFIG_WIRELESS is not set
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_AFS_PARTS=y
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_ATA=y
+CONFIG_PATA_PLATFORM=y
+CONFIG_NETDEVICES=y
+CONFIG_TUN=y
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+CONFIG_SMC91X=y
+CONFIG_SMC911X=y
+CONFIG_SMSC911X=y
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_WLAN is not set
+# CONFIG_MOUSE_PS2_ALPS is not set
+# CONFIG_MOUSE_PS2_LOGIPS2PP is not set
+# CONFIG_MOUSE_PS2_SYNAPTICS is not set
+# CONFIG_MOUSE_PS2_TRACKPOINT is not set
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIO_AMBAKMI=y
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+# CONFIG_HWMON is not set
+CONFIG_FB=y
+CONFIG_FB_ARMCLCD=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_DRIVERS is not set
+CONFIG_SND_ARMAACI=y
+# CONFIG_SND_USB is not set
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KYE=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LOGITECH=y
+CONFIG_HID_LOGITECH_DJ=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_ISP1760_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_MMC=y
+CONFIG_MMC_ARMMMCI=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_PL031=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+CONFIG_ISO9660_FS=y
+CONFIG_UDF_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_TMPFS=y
+CONFIG_JFFS2_FS=y
+CONFIG_CRAMFS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_FS=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_RCU_CPU_STALL_VERBOSE is not set
+# CONFIG_FTRACE is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
diff --git a/arch/arm/configs/sun6ismp_defconfig b/arch/arm/configs/sun6ismp_defconfig
new file mode 100644
index 0000000..7a9f8c2
--- /dev/null
+++ b/arch/arm/configs/sun6ismp_defconfig
@@ -0,0 +1,2397 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.3.0 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_SCHED_CLOCK=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_LOCKBREAK=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_NEED_MACH_MEMORY_H=y
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_IRQ_DOMAIN=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_RCU_FAST_NO_HZ is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=16
+# CONFIG_HAVE_UNSTABLE_SCHED_CLOCK is not set
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_EXPERT is not set
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="deadline"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+CONFIG_ARCH_SUN6I=y
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_PRIMA2 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PICOXCELL is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_AW_FPGA_V4_PLATFORM is not set
+# CONFIG_AW_FPGA_V7_PLATFORM is not set
+CONFIG_AW_ASIC_EVB_PLATFORM=y
+# CONFIG_SUNXI_SYSFS is not set
+
+#
+# System MMU
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+CONFIG_ARM_THUMBEE=y
+# CONFIG_SWP_EMULATE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_ARCH_HAS_BARRIERS=y
+CONFIG_ARM_NR_BANKS=8
+CONFIG_CPU_HAS_PMU=y
+CONFIG_MULTI_IRQ_HANDLER=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_743622 is not set
+# CONFIG_ARM_ERRATA_751472 is not set
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_764369 is not set
+CONFIG_ARM_GIC=y
+# CONFIG_FIQ_DEBUGGER is not set
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_HAVE_ARM_SCU=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_HAVE_ARM_TWD=y
+CONFIG_AW_TIME_DELAY=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=4
+CONFIG_HOTPLUG_CPU=y
+CONFIG_LOCAL_TIMERS=y
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ=100
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+CONFIG_HIGHPTE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART=y
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="earlyprintk=ttyS0,115200 loglevel=9 console=ttyS0,115200"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_FANTASYS is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_INTERACTIVE is not set
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_FANTASYS=y
+# CONFIG_CPU_FREQ_USR_EVNT_NOTIFY is not set
+
+#
+# ARM CPU frequency scaling drivers
+#
+# CONFIG_ARM_EXYNOS4210_CPUFREQ is not set
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_HAVE_AOUT=y
+CONFIG_BINFMT_AOUT=y
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_WAKELOCK is not set
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_CAN_PM_TRACE=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+CONFIG_CPU_PM=y
+CONFIG_SUSPEND_TIME=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+CONFIG_NET_ACTIVITY_STATS=y
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+CONFIG_BQL=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+CONFIG_CFG80211_ALLOW_RECONNECT=y
+# CONFIG_MAC80211 is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+# CONFIG_DMA_SHARED_BUFFER is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_SUN6I_VIBRATOR is not set
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_SENSORS_AK8975 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+CONFIG_UID_STAT=y
+# CONFIG_BMP085 is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_SUNXI_REGDEBUG is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+# CONFIG_SW_3G_MODULE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_MII=m
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_ETHERNET=y
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+CONFIG_NET_VENDOR_MICROCHIP=y
+# CONFIG_ENC28J60 is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+CONFIG_NET_VENDOR_SUNXI=y
+CONFIG_SUNXI_GMAC=m
+CONFIG_GMAC_SCRIPT_SYS=y
+CONFIG_GMAC_CLK_SYS=y
+CONFIG_GMAC_RING=y
+# CONFIG_GMAC_CHAINED is not set
+CONFIG_PHYLIB=m
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MICREL_KS8995MA is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+CONFIG_USB_RTL8150=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_QF9700=m
+CONFIG_USB_NET_CDCETHER=m
+# CONFIG_USB_NET_CDC_EEM is not set
+# CONFIG_USB_NET_CDC_NCM is not set
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_SMSC75XX is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_PLUSB is not set
+CONFIG_USB_NET_MCS7830=m
+# CONFIG_USB_NET_RNDIS_HOST is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_KALMIA is not set
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_USB_SIERRA_NET is not set
+# CONFIG_USB_VL600 is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_KEYRESET is not set
+CONFIG_INPUT_INIT_CTP=y
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_SW_KEYBOARD=m
+CONFIG_IR_SUN6I=m
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+CONFIG_TOUCHSCREEN_FT5X_TS=m
+CONFIG_TOUCHSCREEN_GSLX680=m
+CONFIG_TOUCHSCREEN_GT82X=m
+CONFIG_TOUCHSCREEN_SUN6I_TS=m
+# CONFIG_INPUT_MISC is not set
+# CONFIG_INPUT_GYR is not set
+# CONFIG_INPUT_E_COMPASS is not set
+# CONFIG_INPUT_LIGHT_SENSOR is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_AMBAKMI is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=6
+CONFIG_SERIAL_8250_RUNTIME_UARTS=6
+CONFIG_SERIAL_8250_EXTENDED=y
+# CONFIG_SERIAL_8250_MANY_PORTS is not set
+# CONFIG_SERIAL_8250_SHARE_IRQ is not set
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+# CONFIG_SERIAL_8250_RSA is not set
+CONFIG_SERIAL_8250_SUNXI=y
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_SW is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+# CONFIG_RAMOOPS is not set
+# CONFIG_DMA_TEST_DRIVER is not set
+# CONFIG_GPIO_TEST_DRIVER is not set
+CONFIG_SUN6I_AR100_TEST=m
+CONFIG_AR100_TEST_DRIVER=m
+CONFIG_SUN6I_G2D=y
+CONFIG_SUNXI_TIMER_TEST=m
+CONFIG_SUNXI_PHYS_MEM_ALLOCATOR=y
+# CONFIG_SUNXI_MEM_TEST is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+CONFIG_I2C_SUN6I=y
+# CONFIG_SUN6I_I2C_PRINT_TRANSFER_INFO is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PL022 is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_SUN6I is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC=y
+
+#
+# Memory mapped GPIO drivers:
+#
+CONFIG_GPIO_GENERIC_PLATFORM=y
+# CONFIG_GPIO_PL061 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+CONFIG_AW_AXP=y
+# CONFIG_AW_AXP18 is not set
+# CONFIG_AW_AXP19 is not set
+# CONFIG_AW_AXP20 is not set
+CONFIG_AW_AXP22=y
+CONFIG_AXP_CHARGEINIT=y
+CONFIG_AXP_CHGCHANGE=y
+# CONFIG_AXP_TWI_USED is not set
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+CONFIG_SENSORS_MMA7660=m
+CONFIG_SENSORS_MMA865x=m
+CONFIG_SENSORS_MMA8452=m
+CONFIG_SENSORS_AFA750=m
+# CONFIG_SENSORS_AD7314 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_S5M_CORE is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+# CONFIG_MEDIA_CONTROLLER is not set
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+CONFIG_RC_CORE=y
+CONFIG_LIRC=y
+CONFIG_RC_MAP=y
+CONFIG_IR_NEC_DECODER=y
+CONFIG_IR_RC5_DECODER=y
+CONFIG_IR_RC6_DECODER=y
+CONFIG_IR_JVC_DECODER=y
+CONFIG_IR_SONY_DECODER=y
+CONFIG_IR_RC5_SZ_DECODER=y
+CONFIG_IR_SANYO_DECODER=y
+CONFIG_IR_MCE_KBD_DECODER=y
+CONFIG_IR_LIRC_CODEC=y
+# CONFIG_RC_ATI_REMOTE is not set
+# CONFIG_IR_IMON is not set
+# CONFIG_IR_MCEUSB is not set
+# CONFIG_IR_REDRAT3 is not set
+# CONFIG_IR_STREAMZAP is not set
+# CONFIG_RC_LOOPBACK is not set
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA827X=y
+CONFIG_MEDIA_TUNER_TDA18271=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_XC4000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF_GEN=m
+CONFIG_VIDEOBUF_DMA_CONTIG=m
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+CONFIG_VIDEO_IR_I2C=y
+
+#
+# Audio decoders, processors and mixers
+#
+
+#
+# RDS decoders
+#
+
+#
+# Video decoders
+#
+
+#
+# Video and audio decoders
+#
+
+#
+# MPEG video encoders
+#
+
+#
+# Video encoders
+#
+
+#
+# Camera sensor devices
+#
+
+#
+# Flash devices
+#
+
+#
+# Video improvement chips
+#
+
+#
+# Miscelaneous helper chips
+#
+CONFIG_V4L_USB_DRIVERS=y
+# CONFIG_USB_VIDEO_CLASS is not set
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_JL2005BCD is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SE401 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TOPRO is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_TM6000 is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_V4L_PLATFORM_DRIVERS is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+CONFIG_VIDEO_SUN6I_CEDAR=y
+CONFIG_VIDEO_DECODER_SUN6I=y
+CONFIG_VIDEO_CSI_SUNXI=y
+CONFIG_CSI_DEV_SEL=m
+CONFIG_CSI1_SUNXI=m
+CONFIG_CSI_OV7670=m
+CONFIG_CSI_GT2005=m
+CONFIG_CSI_GC0308=m
+CONFIG_CSI_HI704=m
+CONFIG_CSI_SP0838=m
+CONFIG_CSI_MT9M112=m
+CONFIG_CSI_MT9M113=m
+CONFIG_CSI_OV2655=m
+CONFIG_CSI_HI253=m
+CONFIG_CSI_MT9D112=m
+CONFIG_CSI_GC0307=m
+CONFIG_CSI_OV5640=m
+CONFIG_CSI_OV5640_MIPI=m
+CONFIG_CSI_GC2015=m
+CONFIG_CSI_OV2643=m
+CONFIG_CSI_GC0329=m
+CONFIG_CSI_GC0309=m
+CONFIG_CSI_TVP5150=m
+CONFIG_CSI_S5K4EC=m
+CONFIG_CSI_GC2035=m
+CONFIG_CSI_OV5642=m
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_RADIO_SI470X is not set
+# CONFIG_USB_MR800 is not set
+# CONFIG_USB_DSBR is not set
+# CONFIG_I2C_SI4713 is not set
+# CONFIG_RADIO_SI4713 is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_RADIO_SAA7706H is not set
+# CONFIG_RADIO_TEF6862 is not set
+# CONFIG_RADIO_WL1273 is not set
+
+#
+# Texas Instruments WL128x FM driver (ST based)
+#
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_ION is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_LYCHEE_FB_SUN6I=y
+CONFIG_LYCHEE_LCD_SUN6I=y
+CONFIG_LYCHEE_HDMI_SUN6I=y
+# CONFIG_FB_ARMCLCD is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ARM=y
+# CONFIG_SND_ARMAACI is not set
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_SUN6I_SOC_CODEC=y
+CONFIG_SND_SUN6I_SOC_HDMIAUDIO=y
+CONFIG_SND_SUN6I_SOC_SPDIF=m
+CONFIG_SND_SUN6I_SOC_I2S_INTERFACE=m
+CONFIG_SND_SUN6I_SOC_PCM_INTERFACE=m
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+CONFIG_HID_BATTERY_STRENGTH=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+# CONFIG_HID_ACRUX is not set
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+# CONFIG_HID_PRODIKEYS is not set
+CONFIG_HID_CYPRESS=y
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+CONFIG_HID_EZKEY=y
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+CONFIG_HID_KYE=y
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+CONFIG_HID_KENSINGTON=y
+# CONFIG_HID_LCPOWER is not set
+CONFIG_HID_LOGITECH=y
+CONFIG_HID_LOGITECH_DJ=m
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIWHEELS_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+# CONFIG_USB_ARCH_HAS_XHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_EHCI_MV is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+CONFIG_USB_SW_SUN6I_HCD=y
+CONFIG_USB_SW_SUN6I_HCD0=y
+CONFIG_USB_SW_SUN6I_HCI=y
+CONFIG_USB_SW_SUN6I_EHCI0=y
+CONFIG_USB_SW_SUN6I_EHCI1=y
+CONFIG_USB_SW_SUN6I_OHCI0=y
+CONFIG_USB_SW_SUN6I_OHCI1=y
+# CONFIG_USB_SW_SUN6I_OHCI2 is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_RENESAS_USBHS is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_REALTEK=y
+CONFIG_REALTEK_AUTOPM=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_USB_STORAGE_ENE_UB6250=y
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+CONFIG_USB_SW_SUN6I_UDC0=y
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_G_ANDROID=y
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_USB_SW_SUN6I_USB=y
+CONFIG_USB_SW_SUN6I_USB_MANAGER=y
+# CONFIG_USB_SW_SUN6I_USB0_NULL is not set
+# CONFIG_USB_SW_SUN6I_USB0_DEVICE_ONLY is not set
+# CONFIG_USB_SW_SUN6I_USB0_HOST_ONLY is not set
+CONFIG_USB_SW_SUN6I_USB0_OTG=y
+CONFIG_USB_SW_SUN6I_USB_DEBUG=y
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_CLKGATE is not set
+# CONFIG_MMC_EMBEDDED_SDIO is not set
+CONFIG_MMC_PARANOID_SD_INIT=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=16
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_ARMMMCI is not set
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+# CONFIG_MMC_DW is not set
+CONFIG_MMC_SUN6I=y
+# CONFIG_MMC_DEBUG_SUNXI is not set
+CONFIG_MMC_PRE_DBGLVL_SUNXI=0
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_SWITCH=y
+CONFIG_SWITCH_GPIO=m
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_ALARM=y
+CONFIG_RTC_INTF_ALARM_DEV=y
+# CONFIG_RTC_ALARM_CLOCK_WAKEUP is not set
+# CONFIG_RTC_ALARM_SHUTDOWN_WAKEUP is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+CONFIG_RTC_DRV_SUN6I=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_MACH_CLKDEV=y
+
+#
+# Hardware Spinlock drivers
+#
+# CONFIG_IOMMU_SUPPORT is not set
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_GSENSOR is not set
+
+#
+# MediaTek Connectivity Combo Chip Config
+#
+# CONFIG_MTK_COMBO is not set
+# CONFIG_MTK_COMBO_CHIP_MT6620 is not set
+# CONFIG_MTK_GPS is not set
+
+#
+# gpu
+#
+# CONFIG_GATOR_PERF is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+CONFIG_EXT4_FS_XATTR=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+
+#
+# Caches
+#
+CONFIG_FSCACHE=y
+CONFIG_FSCACHE_STATS=y
+# CONFIG_FSCACHE_HISTOGRAM is not set
+# CONFIG_FSCACHE_DEBUG is not set
+# CONFIG_FSCACHE_OBJECT_LIST is not set
+CONFIG_CACHEFILES=y
+# CONFIG_CACHEFILES_DEBUG is not set
+# CONFIG_CACHEFILES_HISTOGRAM is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+CONFIG_NTFS_FS=y
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFS_FSCACHE is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_FSCACHE is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=4096
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+CONFIG_DEBUG_VM=y
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_DEBUG_LIST=y
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_CPU_NOTIFIER_ERROR_INJECT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_DEBUG_PAGEALLOC=y
+CONFIG_WANT_PAGE_DEBUG_FLAGS=y
+CONFIG_PAGE_POISONING=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+CONFIG_DYNAMIC_DEBUG=y
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_RODATA=y
+CONFIG_DEBUG_RODATA_TEST=y
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_LL_UART_NONE is not set
+# CONFIG_DEBUG_ICEDCC is not set
+CONFIG_DEBUG_AW_UART0=y
+# CONFIG_DEBUG_AW_R_UART is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_PCI_IOMAP=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+# CONFIG_AVERAGE is not set
+# CONFIG_CORDIC is not set
diff --git a/arch/arm/configs/sun6ismp_fiber_defconfig b/arch/arm/configs/sun6ismp_fiber_defconfig
new file mode 100644
index 0000000..ea83ab5
--- /dev/null
+++ b/arch/arm/configs/sun6ismp_fiber_defconfig
@@ -0,0 +1,2739 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.3.0 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_SCHED_CLOCK=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_LOCKBREAK=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_NEED_MACH_MEMORY_H=y
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_IRQ_DOMAIN=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_RCU_FAST_NO_HZ is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=16
+# CONFIG_HAVE_UNSTABLE_SCHED_CLOCK is not set
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+# CONFIG_CGROUP_FREEZER is not set
+# CONFIG_CGROUP_DEVICE is not set
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+# CONFIG_CGROUP_CPUACCT is not set
+# CONFIG_RESOURCE_COUNTERS is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_BLK_CGROUP is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_EXPERT is not set
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_PROFILING is not set
+CONFIG_TRACEPOINTS=y
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="deadline"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+CONFIG_ARCH_SUN6I=y
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_PRIMA2 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PICOXCELL is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_AW_FPGA_V4_PLATFORM is not set
+# CONFIG_AW_FPGA_V7_PLATFORM is not set
+CONFIG_AW_ASIC_EVB_PLATFORM=y
+# CONFIG_SUNXI_SYSFS is not set
+
+#
+# System MMU
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+CONFIG_ARM_THUMBEE=y
+# CONFIG_SWP_EMULATE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_ARCH_HAS_BARRIERS=y
+CONFIG_ARM_NR_BANKS=8
+CONFIG_CPU_HAS_PMU=y
+CONFIG_MULTI_IRQ_HANDLER=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_743622 is not set
+# CONFIG_ARM_ERRATA_751472 is not set
+# CONFIG_ARM_ERRATA_754322 is not set
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_764369 is not set
+CONFIG_ARM_GIC=y
+# CONFIG_FIQ_DEBUGGER is not set
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_HAVE_ARM_SCU=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_HAVE_ARM_TWD=y
+CONFIG_AW_TIME_DELAY=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=4
+CONFIG_HOTPLUG_CPU=y
+CONFIG_LOCAL_TIMERS=y
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ=100
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+CONFIG_HIGHPTE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART=y
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="earlyprintk=ttyS0,115200 loglevel=9 initcall_debug=1 console=ttyS0,115200"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_FANTASYS is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_INTERACTIVE is not set
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_FANTASYS=y
+CONFIG_CPU_FREQ_USR_EVNT_NOTIFY=y
+CONFIG_CPU_FREQ_EARLYSUSPEND=y
+
+#
+# ARM CPU frequency scaling drivers
+#
+# CONFIG_ARM_EXYNOS4210_CPUFREQ is not set
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_HAVE_AOUT=y
+CONFIG_BINFMT_AOUT=y
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_EARLYSUSPEND_DELAY is not set
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+# CONFIG_CONSOLE_EARLYSUSPEND is not set
+CONFIG_FB_EARLYSUSPEND=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_CAN_PM_TRACE=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+CONFIG_CPU_PM=y
+CONFIG_SUSPEND_TIME=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPGRE_DEMUX=y
+CONFIG_NET_IPGRE=y
+# CONFIG_NET_IPGRE_BROADCAST is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_INET_XFRM_TUNNEL=y
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+# CONFIG_IPV6_MIP6 is not set
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+CONFIG_NET_ACTIVITY_STATS=y
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_PROCFS=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+CONFIG_NF_CT_PROTO_GRE=y
+# CONFIG_NF_CT_PROTO_SCTP is not set
+CONFIG_NF_CT_PROTO_UDPLITE=y
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+CONFIG_NF_CONNTRACK_FTP=y
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=y
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+CONFIG_NETFILTER_XT_MATCH_ECN=y
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_HL=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP_NF_TARGET_LOG=y
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_NF_NAT_FTP=y
+# CONFIG_NF_NAT_IRC is not set
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NF_NAT_AMANDA is not set
+CONFIG_NF_NAT_PPTP=y
+# CONFIG_NF_NAT_H323 is not set
+# CONFIG_NF_NAT_SIP is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_RAW=y
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=y
+CONFIG_NF_CONNTRACK_IPV6=y
+# CONFIG_IP6_NF_QUEUE is not set
+CONFIG_IP6_NF_IPTABLES=y
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_RPFILTER is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+CONFIG_L2TP=y
+# CONFIG_L2TP_DEBUGFS is not set
+CONFIG_L2TP_V3=y
+CONFIG_L2TP_IP=y
+CONFIG_L2TP_ETH=y
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_NETPRIO_CGROUP is not set
+CONFIG_BQL=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_BCSP=y
+# CONFIG_BT_HCIUART_ATH3K is not set
+CONFIG_BT_HCIUART_RTKH5=y
+# CONFIG_BT_HCIUART_LL is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+CONFIG_CFG80211_ALLOW_RECONNECT=y
+# CONFIG_MAC80211 is not set
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_PM=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+# CONFIG_DMA_SHARED_BUFFER is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+CONFIG_SUN6I_VIBRATOR=y
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_SENSORS_AK8975 is not set
+# CONFIG_DS1682 is not set
+CONFIG_UID_STAT=y
+# CONFIG_BMP085 is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_WL127X_RFKILL is not set
+# CONFIG_SUNXI_REGDEBUG is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+# CONFIG_SW_3G_MODULE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=y
+CONFIG_DM_SNAPSHOT=y
+# CONFIG_DM_THIN_PROVISIONING is not set
+CONFIG_DM_MIRROR=y
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_MII=y
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+CONFIG_TUN=y
+# CONFIG_VETH is not set
+
+#
+# CAIF transport drivers
+#
+# CONFIG_ETHERNET is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=y
+CONFIG_PPTP=y
+CONFIG_PPPOL2TP=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+CONFIG_USB_RTL8150=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_QF9700=m
+CONFIG_USB_NET_CDCETHER=m
+# CONFIG_USB_NET_CDC_EEM is not set
+# CONFIG_USB_NET_CDC_NCM is not set
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_SMSC75XX is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_PLUSB is not set
+CONFIG_USB_NET_MCS7830=m
+# CONFIG_USB_NET_RNDIS_HOST is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_KALMIA is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_USB_SIERRA_NET is not set
+# CONFIG_USB_VL600 is not set
+CONFIG_WLAN=y
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_WIFI_CONTROL_FUNC is not set
+# CONFIG_ATH_COMMON is not set
+# CONFIG_BCM4330 is not set
+# CONFIG_BCMDHD is not set
+# CONFIG_BRCMFMAC is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_IWM is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_MWIFIEX is not set
+CONFIG_RTL8192CU_SW=m
+CONFIG_RTL8188EU=m
+CONFIG_RTL8189ES=m
+CONFIG_RTL8723AS=m
+# CONFIG_RTL8723AU is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_KEYRESET is not set
+CONFIG_INPUT_INIT_CTP=y
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_SW_KEYBOARD=m
+CONFIG_IR_SUN6I=m
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+CONFIG_TOUCHSCREEN_FT5X_TS=m
+CONFIG_TOUCHSCREEN_GSLX680=m
+CONFIG_TOUCHSCREEN_GT82X=m
+CONFIG_TOUCHSCREEN_SUN6I_TS=m
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYCHORD is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+CONFIG_INPUT_GYR=y
+CONFIG_GYR_L3GD20=m
+CONFIG_INPUT_E_COMPASS=y
+CONFIG_E_COMPASS_L3M303D=m
+CONFIG_E_COMPASS_FXOS8700=m
+CONFIG_INPUT_LIGHT_SENSOR=y
+CONFIG_INPUT_LTR501ALS=m
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_AMBAKMI is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=6
+CONFIG_SERIAL_8250_RUNTIME_UARTS=6
+CONFIG_SERIAL_8250_EXTENDED=y
+# CONFIG_SERIAL_8250_MANY_PORTS is not set
+# CONFIG_SERIAL_8250_SHARE_IRQ is not set
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+# CONFIG_SERIAL_8250_RSA is not set
+CONFIG_SERIAL_8250_SUNXI=y
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_SW is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+# CONFIG_RAMOOPS is not set
+# CONFIG_DMA_TEST_DRIVER is not set
+# CONFIG_GPIO_TEST_DRIVER is not set
+# CONFIG_SUN6I_AR100_TEST is not set
+CONFIG_SUN6I_G2D=m
+# CONFIG_SUNXI_TIMER_TEST is not set
+CONFIG_SUNXI_PHYS_MEM_ALLOCATOR=y
+# CONFIG_SUNXI_MEM_TEST is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+CONFIG_I2C_SUN6I=y
+# CONFIG_SUN6I_I2C_PRINT_TRANSFER_INFO is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC=y
+
+#
+# Memory mapped GPIO drivers:
+#
+CONFIG_GPIO_GENERIC_PLATFORM=y
+# CONFIG_GPIO_PL061 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MCP23S08 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+CONFIG_AW_AXP=y
+# CONFIG_AW_AXP18 is not set
+# CONFIG_AW_AXP19 is not set
+# CONFIG_AW_AXP20 is not set
+CONFIG_AW_AXP22=y
+CONFIG_AXP_CHARGEINIT=y
+CONFIG_AXP_CHGCHANGE=y
+# CONFIG_AXP_TWI_USED is not set
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+CONFIG_SENSORS_MMA7660=m
+CONFIG_SENSORS_MMA865x=m
+CONFIG_SENSORS_MMA8452=m
+CONFIG_SENSORS_AFA750=m
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_S5M_CORE is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_AD5398 is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+# CONFIG_MEDIA_CONTROLLER is not set
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_RC_CORE is not set
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA827X=y
+CONFIG_MEDIA_TUNER_TDA18271=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_XC4000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF_GEN=m
+CONFIG_VIDEOBUF_DMA_CONTIG=m
+CONFIG_VIDEOBUF2_CORE=m
+CONFIG_VIDEOBUF2_MEMOPS=m
+CONFIG_VIDEOBUF2_VMALLOC=m
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+
+#
+# Encoders, decoders, sensors and other helper chips
+#
+
+#
+# Audio decoders, processors and mixers
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_AK881X is not set
+
+#
+# Camera sensor devices
+#
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_TCM825X is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+
+#
+# Flash devices
+#
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+
+#
+# Miscelaneous helper chips
+#
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_M52790 is not set
+CONFIG_V4L_USB_DRIVERS=y
+CONFIG_USB_VIDEO_CLASS=m
+# CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV is not set
+# CONFIG_USB_GSPCA is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_V4L_PLATFORM_DRIVERS is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+CONFIG_VIDEO_SUN6I_CEDAR=y
+CONFIG_VIDEO_DECODER_SUN6I=y
+CONFIG_VIDEO_CSI_SUNXI=y
+CONFIG_CSI_DEV_SEL=m
+CONFIG_CSI1_SUNXI=m
+CONFIG_CSI_OV7670=m
+CONFIG_CSI_GT2005=m
+CONFIG_CSI_GC0308=m
+CONFIG_CSI_HI704=m
+CONFIG_CSI_SP0838=m
+CONFIG_CSI_MT9M112=m
+CONFIG_CSI_MT9M113=m
+CONFIG_CSI_OV2655=m
+CONFIG_CSI_HI253=m
+CONFIG_CSI_MT9D112=m
+CONFIG_CSI_GC0307=m
+CONFIG_CSI_OV5640=m
+CONFIG_CSI_OV5640_MIPI=m
+CONFIG_CSI_GC2015=m
+CONFIG_CSI_OV2643=m
+CONFIG_CSI_GC0329=m
+CONFIG_CSI_GC0309=m
+CONFIG_CSI_TVP5150=m
+CONFIG_CSI_S5K4EC=m
+CONFIG_CSI_GC2035=m
+CONFIG_CSI_OV5642=m
+# CONFIG_RADIO_ADAPTERS is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+CONFIG_ION=y
+CONFIG_ION_SUNXI_CARVEOUT_SIZE=256
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_LYCHEE_FB_SUN6I=m
+CONFIG_LYCHEE_LCD_SUN6I=m
+CONFIG_LYCHEE_HDMI_SUN6I=m
+# CONFIG_FB_ARMCLCD is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ARM=y
+# CONFIG_SND_ARMAACI is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_SUN6I_SOC_CODEC=y
+CONFIG_SND_SUN6I_SOC_HDMIAUDIO=y
+CONFIG_SND_SUN6I_SOC_SPDIF=m
+CONFIG_SND_SUN6I_SOC_I2S_INTERFACE=m
+CONFIG_SND_SUN6I_SOC_PCM_INTERFACE=m
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+CONFIG_HID_BATTERY_STRENGTH=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+# CONFIG_HID_ACRUX is not set
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+# CONFIG_HID_PRODIKEYS is not set
+CONFIG_HID_CYPRESS=y
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+CONFIG_HID_EZKEY=y
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+CONFIG_HID_KYE=y
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+CONFIG_HID_KENSINGTON=y
+# CONFIG_HID_LCPOWER is not set
+CONFIG_HID_LOGITECH=y
+CONFIG_HID_LOGITECH_DJ=m
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIWHEELS_FF is not set
+# CONFIG_HID_MAGICMOUSE is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+# CONFIG_USB_ARCH_HAS_XHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_EHCI_MV is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+CONFIG_USB_SW_SUN6I_HCD=y
+CONFIG_USB_SW_SUN6I_HCD0=y
+CONFIG_USB_SW_SUN6I_HCI=y
+CONFIG_USB_SW_SUN6I_EHCI0=y
+CONFIG_USB_SW_SUN6I_EHCI1=y
+CONFIG_USB_SW_SUN6I_OHCI0=y
+CONFIG_USB_SW_SUN6I_OHCI1=y
+CONFIG_USB_SW_SUN6I_OHCI2=y
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_RENESAS_USBHS is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_REALTEK=y
+CONFIG_REALTEK_AUTOPM=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_USB_STORAGE_ENE_UB6250=y
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+# CONFIG_USB_EZUSB is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+CONFIG_USB_SERIAL_WWAN=y
+CONFIG_USB_SERIAL_OPTION=y
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
+# CONFIG_USB_SERIAL_ZIO is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+CONFIG_USB_SW_SUN6I_UDC0=y
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_G_ANDROID=y
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+CONFIG_USB_OTG_WAKELOCK=y
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_USB_SW_SUN6I_USB=y
+CONFIG_USB_SW_SUN6I_USB_MANAGER=y
+# CONFIG_USB_SW_SUN6I_USB0_NULL is not set
+# CONFIG_USB_SW_SUN6I_USB0_DEVICE_ONLY is not set
+# CONFIG_USB_SW_SUN6I_USB0_HOST_ONLY is not set
+CONFIG_USB_SW_SUN6I_USB0_OTG=y
+CONFIG_USB_SW_SUN6I_USB_DEBUG=y
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_CLKGATE is not set
+# CONFIG_MMC_EMBEDDED_SDIO is not set
+CONFIG_MMC_PARANOID_SD_INIT=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=16
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_ARMMMCI is not set
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+# CONFIG_MMC_DW is not set
+CONFIG_MMC_SUN6I=y
+# CONFIG_MMC_DEBUG_SUNXI is not set
+CONFIG_MMC_PRE_DBGLVL_SUNXI=0
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_SWITCH is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_ALARM=y
+CONFIG_RTC_INTF_ALARM_DEV=y
+CONFIG_RTC_ALARM_CLOCK_WAKEUP=y
+# CONFIG_RTC_ALARM_SHUTDOWN_WAKEUP is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+CONFIG_RTC_DRV_SUN6I=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+CONFIG_STAGING=y
+# CONFIG_USBIP_CORE is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_R8712U is not set
+# CONFIG_RTS5139 is not set
+# CONFIG_TRANZPORT is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_USB_SERIAL_QUATECH2 is not set
+# CONFIG_USB_SERIAL_QUATECH_USB2 is not set
+# CONFIG_VT6656 is not set
+# CONFIG_IIO is not set
+# CONFIG_XVMALLOC is not set
+# CONFIG_ZRAM is not set
+# CONFIG_FB_SM7XX is not set
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+# CONFIG_STAGING_MEDIA is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_PERSISTENT_RAM=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+# CONFIG_PERSISTENT_TRACER is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_ANDROID_SWITCH=y
+CONFIG_SWITCH_HEADSET=y
+# CONFIG_ANDROID_SWITCH_GPIO is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_MACH_CLKDEV=y
+
+#
+# Hardware Spinlock drivers
+#
+# CONFIG_IOMMU_SUPPORT is not set
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_PM_DEVFREQ is not set
+CONFIG_GSENSOR=y
+CONFIG_SENSORS_BMA250=m
+CONFIG_SENSORS_LIS3DH_ACC=m
+CONFIG_SENSORS_LIS3DE_ACC=m
+
+#
+# MediaTek Connectivity Combo Chip Config
+#
+# CONFIG_MTK_COMBO is not set
+# CONFIG_MTK_COMBO_CHIP_MT6620 is not set
+# CONFIG_MTK_GPS is not set
+
+#
+# gpu
+#
+# CONFIG_GATOR_PERF is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+CONFIG_EXT4_FS_XATTR=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+
+#
+# Caches
+#
+CONFIG_FSCACHE=y
+CONFIG_FSCACHE_STATS=y
+# CONFIG_FSCACHE_HISTOGRAM is not set
+# CONFIG_FSCACHE_DEBUG is not set
+# CONFIG_FSCACHE_OBJECT_LIST is not set
+CONFIG_CACHEFILES=y
+# CONFIG_CACHEFILES_DEBUG is not set
+# CONFIG_CACHEFILES_HISTOGRAM is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+CONFIG_NTFS_FS=y
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_FSCACHE is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_FSCACHE is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_CPU_NOTIFIER_ERROR_INJECT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACER_MAX_TRACE=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+# CONFIG_EVENT_POWER_TRACING_DEPRECATED is not set
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+CONFIG_SCHED_TRACER=y
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_DYNAMIC_FTRACE=y
+# CONFIG_FUNCTION_PROFILER is not set
+CONFIG_FTRACE_MCOUNT_RECORD=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+CONFIG_DYNAMIC_DEBUG=y
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_OLD_MCOUNT=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_RODATA=y
+CONFIG_DEBUG_RODATA_TEST=y
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_LL_UART_NONE is not set
+# CONFIG_DEBUG_ICEDCC is not set
+CONFIG_DEBUG_AW_UART0=y
+# CONFIG_DEBUG_AW_R_UART is not set
+# CONFIG_EARLY_PRINTK is not set
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+# CONFIG_AVERAGE is not set
+# CONFIG_CORDIC is not set
diff --git a/arch/arm/configs/vexpress_ael_defconfig b/arch/arm/configs/vexpress_ael_defconfig
new file mode 100644
index 0000000..62f3b9f
--- /dev/null
+++ b/arch/arm/configs/vexpress_ael_defconfig
@@ -0,0 +1,208 @@
+CONFIG_EXPERIMENTAL=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_FHANDLE=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_AUDIT=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_NET_NS is not set
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_EMBEDDED=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_ARCH_VEXPRESS=y
+CONFIG_ARCH_VEXPRESS_DT=y
+CONFIG_ARM_THUMBEE=y
+CONFIG_ARM_ERRATA_430973=y
+CONFIG_ARM_ERRATA_458693=y
+CONFIG_ARM_ERRATA_460075=y
+CONFIG_ARM_ERRATA_742230=y
+CONFIG_ARM_ERRATA_742231=y
+CONFIG_PL310_ERRATA_588369=y
+CONFIG_PL310_ERRATA_727915=y
+CONFIG_ARM_ERRATA_743622=y
+CONFIG_ARM_ERRATA_754322=y
+CONFIG_ARM_ERRATA_754327=y
+CONFIG_ARM_ERRATA_764369=y
+CONFIG_PL310_ERRATA_769419=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_SMP=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_HOTPLUG_CPU=y
+CONFIG_PREEMPT=y
+CONFIG_THUMB2_KERNEL=y
+CONFIG_HIGHMEM=y
+CONFIG_HIGHPTE=y
+CONFIG_COMPACTION=y
+CONFIG_KSM=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_ARM_APPENDED_DTB=y
+CONFIG_ARM_ATAG_DTB_COMPAT=y
+CONFIG_KEXEC=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_MISC=y
+# CONFIG_SUSPEND is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_INET_LRO is not set
+# CONFIG_IPV6 is not set
+# CONFIG_WIRELESS is not set
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_AFS_PARTS=y
+CONFIG_MTD_OF_PARTS=y
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_PROC_DEVICETREE=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_ATA=y
+CONFIG_PATA_PLATFORM=y
+CONFIG_PATA_OF_PLATFORM=y
+CONFIG_NETDEVICES=y
+CONFIG_TUN=y
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+CONFIG_SMC91X=y
+CONFIG_SMC911X=y
+CONFIG_SMSC911X=y
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_WLAN is not set
+# CONFIG_MOUSE_PS2_ALPS is not set
+# CONFIG_MOUSE_PS2_LOGIPS2PP is not set
+# CONFIG_MOUSE_PS2_SYNAPTICS is not set
+# CONFIG_MOUSE_PS2_TRACKPOINT is not set
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIO_AMBAKMI=y
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_ARM_SP805_WATCHDOG=y
+CONFIG_FB=y
+CONFIG_FB_ARMCLCD=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+# CONFIG_SND_DRIVERS is not set
+CONFIG_SND_ARMAACI=y
+# CONFIG_SND_USB is not set
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KYE=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LOGITECH=y
+CONFIG_HID_LOGITECH_DJ=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_ISP1760_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_MMC=y
+CONFIG_MMC_ARMMMCI=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_PL031=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+CONFIG_ISO9660_FS=y
+CONFIG_UDF_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_TMPFS=y
+CONFIG_JFFS2_FS=y
+CONFIG_CRAMFS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_FS=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_RCU_CPU_STALL_VERBOSE is not set
+# CONFIG_FTRACE is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
diff --git a/arch/arm/include/asm/arch_timer.h b/arch/arm/include/asm/arch_timer.h
new file mode 100644
index 0000000..935897f
--- /dev/null
+++ b/arch/arm/include/asm/arch_timer.h
@@ -0,0 +1,31 @@
+#ifndef __ASMARM_ARCH_TIMER_H
+#define __ASMARM_ARCH_TIMER_H
+
+#include <linux/ioport.h>
+
+struct arch_timer {
+	struct resource	res[2];
+};
+
+#ifdef CONFIG_ARM_ARCH_TIMER
+int arch_timer_register(struct arch_timer *);
+int arch_timer_sched_clock_init(void);
+int arch_timer_of_register(void);
+#else
+static inline int arch_timer_register(struct arch_timer *at)
+{
+	return -ENXIO;
+}
+
+static inline int arch_timer_of_register(void)
+{
+	return -ENXIO;
+}
+
+static inline int arch_timer_sched_clock_init(void)
+{
+	return -ENXIO;
+}
+#endif
+
+#endif
diff --git a/arch/arm/include/asm/delay.h b/arch/arm/include/asm/delay.h
index b2deda1..fa34eb5 100644
--- a/arch/arm/include/asm/delay.h
+++ b/arch/arm/include/asm/delay.h
@@ -34,11 +34,25 @@ extern void __const_udelay(unsigned long);
 
 #define MAX_UDELAY_MS 2
 
+#ifdef CONFIG_AW_TIME_DELAY
+
+extern void use_time_delay(void);
+extern void(*delay_fn)(unsigned long usecs);
+#define udelay(n)							\
+	(__builtin_constant_p(n) ?					\
+	 ((n) > (MAX_UDELAY_MS * 1000) ? __bad_udelay() :		\
+	  delay_fn(n)) :	\
+	 delay_fn(n))
+
+#else
+
 #define udelay(n)							\
 	(__builtin_constant_p(n) ?					\
-	  ((n) > (MAX_UDELAY_MS * 1000) ? __bad_udelay() :		\
+	 ((n) > (MAX_UDELAY_MS * 1000) ? __bad_udelay() :		\
 			__const_udelay((n) * ((2199023U*HZ)>>11))) :	\
-	  __udelay(n))
+	 __udelay(n))
+
+#endif
 
 #endif /* defined(_ARM_DELAY_H) */
 
diff --git a/arch/arm/include/asm/elf.h b/arch/arm/include/asm/elf.h
index 0e9ce8d..38050b1 100644
--- a/arch/arm/include/asm/elf.h
+++ b/arch/arm/include/asm/elf.h
@@ -130,8 +130,4 @@ struct mm_struct;
 extern unsigned long arch_randomize_brk(struct mm_struct *mm);
 #define arch_randomize_brk arch_randomize_brk
 
-extern int vectors_user_mapping(void);
-#define arch_setup_additional_pages(bprm, uses_interp) vectors_user_mapping()
-#define ARCH_HAS_SETUP_ADDITIONAL_PAGES
-
 #endif
diff --git a/arch/arm/include/asm/hardware/arm_timer.h b/arch/arm/include/asm/hardware/arm_timer.h
index c0f4e7b..d6030ff 100644
--- a/arch/arm/include/asm/hardware/arm_timer.h
+++ b/arch/arm/include/asm/hardware/arm_timer.h
@@ -9,7 +9,12 @@
  *
  * Integrator AP has 16-bit timers, Integrator CP, Versatile and Realview
  * can have 16-bit or 32-bit selectable via a bit in the control register.
+ *
+ * Every SP804 contains two identical timers.
  */
+#define TIMER_1_BASE	0x00
+#define TIMER_2_BASE	0x20
+
 #define TIMER_LOAD	0x00			/* ACVR rw */
 #define TIMER_VALUE	0x04			/* ACVR ro */
 #define TIMER_CTRL	0x08			/* ACVR rw */
diff --git a/arch/arm/include/asm/localtimer.h b/arch/arm/include/asm/localtimer.h
index c6a1842..f77ffc1 100644
--- a/arch/arm/include/asm/localtimer.h
+++ b/arch/arm/include/asm/localtimer.h
@@ -11,47 +11,24 @@
 #define __ASM_ARM_LOCALTIMER_H
 
 #include <linux/errno.h>
-#include <linux/interrupt.h>
 
 struct clock_event_device;
 
-/*
- * Setup a per-cpu timer, whether it be a local timer or dummy broadcast
- */
-void percpu_timer_setup(void);
+struct local_timer_ops {
+	int  (*setup)(struct clock_event_device *);
+	void (*stop)(struct clock_event_device *);
+};
 
 #ifdef CONFIG_LOCAL_TIMERS
-
-#ifdef CONFIG_HAVE_ARM_TWD
-
-#include "smp_twd.h"
-
-#define local_timer_stop(c)	twd_timer_stop((c))
-
-#else
-
-/*
- * Stop the local timer
- */
-void local_timer_stop(struct clock_event_device *);
-
-#endif
-
 /*
- * Setup a local timer interrupt for a CPU.
+ * Register a local timer driver
  */
-int local_timer_setup(struct clock_event_device *);
-
+int local_timer_register(struct local_timer_ops *);
 #else
-
-static inline int local_timer_setup(struct clock_event_device *evt)
+static inline int local_timer_register(struct local_timer_ops *ops)
 {
 	return -ENXIO;
 }
-
-static inline void local_timer_stop(struct clock_event_device *evt)
-{
-}
 #endif
 
 #endif
diff --git a/arch/arm/include/asm/mmu_context.h b/arch/arm/include/asm/mmu_context.h
index 71605d9..0306bc6 100644
--- a/arch/arm/include/asm/mmu_context.h
+++ b/arch/arm/include/asm/mmu_context.h
@@ -18,6 +18,7 @@
 #include <asm/cacheflush.h>
 #include <asm/cachetype.h>
 #include <asm/proc-fns.h>
+#include <asm-generic/mm_hooks.h>
 
 void __check_kvm_seq(struct mm_struct *mm);
 
@@ -42,45 +43,104 @@ void __check_kvm_seq(struct mm_struct *mm);
 #define ASID_FIRST_VERSION	(1 << ASID_BITS)
 
 extern unsigned int cpu_last_asid;
-#ifdef CONFIG_SMP
-DECLARE_PER_CPU(struct mm_struct *, current_mm);
-#endif
 
 void __init_new_context(struct task_struct *tsk, struct mm_struct *mm);
 void __new_context(struct mm_struct *mm);
+void cpu_set_reserved_ttbr0(void);
 
-static inline void check_context(struct mm_struct *mm)
+static inline void switch_new_context(struct mm_struct *mm)
 {
-	/*
-	 * This code is executed with interrupts enabled. Therefore,
-	 * mm->context.id cannot be updated to the latest ASID version
-	 * on a different CPU (and condition below not triggered)
-	 * without first getting an IPI to reset the context. The
-	 * alternative is to take a read_lock on mm->context.id_lock
-	 * (after changing its type to rwlock_t).
-	 */
-	if (unlikely((mm->context.id ^ cpu_last_asid) >> ASID_BITS))
-		__new_context(mm);
+	unsigned long flags;
 
+	__new_context(mm);
+
+	local_irq_save(flags);
+	cpu_switch_mm(mm->pgd, mm);
+	local_irq_restore(flags);
+}
+
+static inline void check_and_switch_context(struct mm_struct *mm,
+					    struct task_struct *tsk)
+{
 	if (unlikely(mm->context.kvm_seq != init_mm.context.kvm_seq))
 		__check_kvm_seq(mm);
+
+	/*
+	 * Required during context switch to avoid speculative page table
+	 * walking with the wrong TTBR.
+	 */
+	cpu_set_reserved_ttbr0();
+
+	if (!((mm->context.id ^ cpu_last_asid) >> ASID_BITS))
+		/*
+		 * The ASID is from the current generation, just switch to the
+		 * new pgd. This condition is only true for calls from
+		 * context_switch() and interrupts are already disabled.
+		 */
+		cpu_switch_mm(mm->pgd, mm);
+	else if (irqs_disabled())
+		/*
+		 * Defer the new ASID allocation until after the context
+		 * switch critical region since __new_context() cannot be
+		 * called with interrupts disabled (it sends IPIs).
+		 */
+		set_ti_thread_flag(task_thread_info(tsk), TIF_SWITCH_MM);
+	else
+		/*
+		 * That is a direct call to switch_mm() or activate_mm() with
+		 * interrupts enabled and a new context.
+		 */
+		switch_new_context(mm);
 }
 
 #define init_new_context(tsk,mm)	(__init_new_context(tsk,mm),0)
 
-#else
-
-static inline void check_context(struct mm_struct *mm)
+#define finish_arch_post_lock_switch \
+	finish_arch_post_lock_switch
+static inline void finish_arch_post_lock_switch(void)
 {
+	if (test_and_clear_thread_flag(TIF_SWITCH_MM))
+		switch_new_context(current->mm);
+}
+
+#else	/* !CONFIG_CPU_HAS_ASID */
+
 #ifdef CONFIG_MMU
+
+static inline void check_and_switch_context(struct mm_struct *mm,
+					    struct task_struct *tsk)
+{
 	if (unlikely(mm->context.kvm_seq != init_mm.context.kvm_seq))
 		__check_kvm_seq(mm);
-#endif
+
+	if (irqs_disabled())
+		/*
+		 * cpu_switch_mm() needs to flush the VIVT caches. To avoid
+		 * high interrupt latencies, defer the call and continue
+		 * running with the old mm. Since we only support UP systems
+		 * on non-ASID CPUs, the old mm will remain valid until the
+		 * finish_arch_post_lock_switch() call.
+		 */
+		set_ti_thread_flag(task_thread_info(tsk), TIF_SWITCH_MM);
+	else
+		cpu_switch_mm(mm->pgd, mm);
+}
+
+#define finish_arch_post_lock_switch \
+	finish_arch_post_lock_switch
+static inline void finish_arch_post_lock_switch(void)
+{
+	if (test_and_clear_thread_flag(TIF_SWITCH_MM)) {
+		struct mm_struct *mm = current->mm;
+		cpu_switch_mm(mm->pgd, mm);
+	}
 }
 
+#endif	/* CONFIG_MMU */
+
 #define init_new_context(tsk,mm)	0
 
-#endif
+#endif	/* CONFIG_CPU_HAS_ASID */
 
 #define destroy_context(mm)		do { } while(0)
 
@@ -118,12 +178,7 @@ switch_mm(struct mm_struct *prev, struct mm_struct *next,
 		__flush_icache_all();
 #endif
 	if (!cpumask_test_and_set_cpu(cpu, mm_cpumask(next)) || prev != next) {
-#ifdef CONFIG_SMP
-		struct mm_struct **crt_mm = &per_cpu(current_mm, cpu);
-		*crt_mm = next;
-#endif
-		check_context(next);
-		cpu_switch_mm(next->pgd, next);
+		check_and_switch_context(next, tsk);
 		if (cache_is_vivt())
 			cpumask_clear_cpu(cpu, mm_cpumask(prev));
 	}
@@ -133,32 +188,4 @@ switch_mm(struct mm_struct *prev, struct mm_struct *next,
 #define deactivate_mm(tsk,mm)	do { } while (0)
 #define activate_mm(prev,next)	switch_mm(prev, next, NULL)
 
-/*
- * We are inserting a "fake" vma for the user-accessible vector page so
- * gdb and friends can get to it through ptrace and /proc/<pid>/mem.
- * But we also want to remove it before the generic code gets to see it
- * during process exit or the unmapping of it would  cause total havoc.
- * (the macro is used as remove_vma() is static to mm/mmap.c)
- */
-#define arch_exit_mmap(mm) \
-do { \
-	struct vm_area_struct *high_vma = find_vma(mm, 0xffff0000); \
-	if (high_vma) { \
-		BUG_ON(high_vma->vm_next);  /* it should be last */ \
-		if (high_vma->vm_prev) \
-			high_vma->vm_prev->vm_next = NULL; \
-		else \
-			mm->mmap = NULL; \
-		rb_erase(&high_vma->vm_rb, &mm->mm_rb); \
-		mm->mmap_cache = NULL; \
-		mm->map_count--; \
-		remove_vma(high_vma); \
-	} \
-} while (0)
-
-static inline void arch_dup_mmap(struct mm_struct *oldmm,
-				 struct mm_struct *mm)
-{
-}
-
 #endif
diff --git a/arch/arm/include/asm/page.h b/arch/arm/include/asm/page.h
index 97b440c..5838361 100644
--- a/arch/arm/include/asm/page.h
+++ b/arch/arm/include/asm/page.h
@@ -151,6 +151,8 @@ extern void __cpu_copy_user_highpage(struct page *to, struct page *from,
 #define clear_page(page)	memset((void *)(page), 0, PAGE_SIZE)
 extern void copy_page(void *to, const void *from);
 
+#define __HAVE_ARCH_GATE_AREA 1
+
 #ifdef CONFIG_ARM_LPAE
 #include <asm/pgtable-3level-types.h>
 #else
diff --git a/arch/arm/include/asm/perf_event.h b/arch/arm/include/asm/perf_event.h
index 99cfe36..ee7c056 100644
--- a/arch/arm/include/asm/perf_event.h
+++ b/arch/arm/include/asm/perf_event.h
@@ -26,6 +26,7 @@ enum arm_perf_pmu_ids {
 	ARM_PERF_PMU_ID_CA9,
 	ARM_PERF_PMU_ID_CA5,
 	ARM_PERF_PMU_ID_CA15,
+	ARM_PERF_PMU_ID_CA7,
 	ARM_NUM_PMU_IDS,
 };
 
diff --git a/arch/arm/include/asm/smp_twd.h b/arch/arm/include/asm/smp_twd.h
index ef9ffba9..0f01f46 100644
--- a/arch/arm/include/asm/smp_twd.h
+++ b/arch/arm/include/asm/smp_twd.h
@@ -18,11 +18,28 @@
 #define TWD_TIMER_CONTROL_PERIODIC	(1 << 1)
 #define TWD_TIMER_CONTROL_IT_ENABLE	(1 << 2)
 
-struct clock_event_device;
+#include <linux/ioport.h>
 
-extern void __iomem *twd_base;
+struct twd_local_timer {
+	struct resource	res[2];
+};
 
-void twd_timer_setup(struct clock_event_device *);
-void twd_timer_stop(struct clock_event_device *);
+#define DEFINE_TWD_LOCAL_TIMER(name,base,irq)	\
+struct twd_local_timer name __initdata = {	\
+	.res	= {				\
+		DEFINE_RES_MEM(base, 0x10),	\
+		DEFINE_RES_IRQ(irq),		\
+	},					\
+};
+
+int twd_local_timer_register(struct twd_local_timer *);
+
+#ifdef CONFIG_HAVE_ARM_TWD
+void twd_local_timer_of_register(void);
+#else
+static inline void twd_local_timer_of_register(void)
+{
+}
+#endif
 
 #endif
diff --git a/arch/arm/include/asm/system.h b/arch/arm/include/asm/system.h
index e4c96cc..0e14a0a 100644
--- a/arch/arm/include/asm/system.h
+++ b/arch/arm/include/asm/system.h
@@ -226,13 +226,6 @@ static inline void set_copro_access(unsigned int val)
 }
 
 /*
- * switch_mm() may do a full cache flush over the context switch,
- * so enable interrupts over the context switch to avoid high
- * latency.
- */
-#define __ARCH_WANT_INTERRUPTS_ON_CTXSW
-
-/*
  * switch_to(prev, next) should switch from task `prev' to `next'
  * `prev' will never be the same as `next'.  schedule() itself
  * contains the memory barrier to tell GCC not to cache `current'.
@@ -471,66 +464,19 @@ static inline unsigned long __cmpxchg_local(volatile void *ptr,
 				       (unsigned long)(n),		\
 				       sizeof(*(ptr))))
 
-#ifndef CONFIG_CPU_V6	/* min ARCH >= ARMv6K */
-
-/*
- * Note : ARMv7-M (currently unsupported by Linux) does not support
- * ldrexd/strexd. If ARMv7-M is ever supported by the Linux kernel, it should
- * not be allowed to use __cmpxchg64.
- */
-static inline unsigned long long __cmpxchg64(volatile void *ptr,
-					     unsigned long long old,
-					     unsigned long long new)
-{
-	register unsigned long long oldval asm("r0");
-	register unsigned long long __old asm("r2") = old;
-	register unsigned long long __new asm("r4") = new;
-	unsigned long res;
-
-	do {
-		asm volatile(
-		"	@ __cmpxchg8\n"
-		"	ldrexd	%1, %H1, [%2]\n"
-		"	mov	%0, #0\n"
-		"	teq	%1, %3\n"
-		"	teqeq	%H1, %H3\n"
-		"	strexdeq %0, %4, %H4, [%2]\n"
-			: "=&r" (res), "=&r" (oldval)
-			: "r" (ptr), "Ir" (__old), "r" (__new)
-			: "memory", "cc");
-	} while (res);
-
-	return oldval;
-}
-
-static inline unsigned long long __cmpxchg64_mb(volatile void *ptr,
-						unsigned long long old,
-						unsigned long long new)
-{
-	unsigned long long ret;
-
-	smp_mb();
-	ret = __cmpxchg64(ptr, old, new);
-	smp_mb();
-
-	return ret;
-}
-
-#define cmpxchg64(ptr,o,n)						\
-	((__typeof__(*(ptr)))__cmpxchg64_mb((ptr),			\
-					    (unsigned long long)(o),	\
-					    (unsigned long long)(n)))
-
-#define cmpxchg64_local(ptr,o,n)					\
-	((__typeof__(*(ptr)))__cmpxchg64((ptr),				\
-					 (unsigned long long)(o),	\
-					 (unsigned long long)(n)))
-
-#else /* min ARCH = ARMv6 */
-
-#define cmpxchg64_local(ptr, o, n) __cmpxchg64_local_generic((ptr), (o), (n))
-
-#endif
+#define cmpxchg64(ptr, o, n)						\
+	((__typeof__(*(ptr)))atomic64_cmpxchg(container_of((ptr),	\
+						atomic64_t,		\
+						counter),		\
+					      (unsigned long)(o),	\
+					      (unsigned long)(n)))
+
+#define cmpxchg64_local(ptr, o, n)					\
+	((__typeof__(*(ptr)))local64_cmpxchg(container_of((ptr),	\
+						local64_t,		\
+						a),			\
+					     (unsigned long)(o),	\
+					     (unsigned long)(n)))
 
 #endif	/* __LINUX_ARM_ARCH__ >= 6 */
 
diff --git a/arch/arm/include/asm/thread_info.h b/arch/arm/include/asm/thread_info.h
index d4c24d4..a5460c4 100644
--- a/arch/arm/include/asm/thread_info.h
+++ b/arch/arm/include/asm/thread_info.h
@@ -14,9 +14,10 @@
 
 #include <linux/compiler.h>
 #include <asm/fpstate.h>
+#include <asm/page.h>
 
 #define THREAD_SIZE_ORDER	1
-#define THREAD_SIZE		8192
+#define THREAD_SIZE		(PAGE_SIZE << THREAD_SIZE_ORDER)
 #define THREAD_START_SP		(THREAD_SIZE - 8)
 
 #ifndef __ASSEMBLY__
@@ -118,6 +119,13 @@ extern void iwmmxt_task_switch(struct thread_info *);
 extern void vfp_sync_hwstate(struct thread_info *);
 extern void vfp_flush_hwstate(struct thread_info *);
 
+struct user_vfp;
+struct user_vfp_exc;
+
+extern int vfp_preserve_user_clear_hwstate(struct user_vfp __user *,
+					   struct user_vfp_exc __user *);
+extern int vfp_restore_user_hwstate(struct user_vfp __user *,
+				    struct user_vfp_exc __user *);
 #endif
 
 /*
@@ -146,6 +154,7 @@ extern void vfp_flush_hwstate(struct thread_info *);
 #define TIF_MEMDIE		18	/* is terminating due to OOM killer */
 #define TIF_RESTORE_SIGMASK	20
 #define TIF_SECCOMP		21
+#define TIF_SWITCH_MM		22	/* deferred switch_mm */
 
 #define _TIF_SIGPENDING		(1 << TIF_SIGPENDING)
 #define _TIF_NEED_RESCHED	(1 << TIF_NEED_RESCHED)
diff --git a/arch/arm/include/asm/tls.h b/arch/arm/include/asm/tls.h
index 60843eb..73409e6 100644
--- a/arch/arm/include/asm/tls.h
+++ b/arch/arm/include/asm/tls.h
@@ -7,6 +7,8 @@
 
 	.macro set_tls_v6k, tp, tmp1, tmp2
 	mcr	p15, 0, \tp, c13, c0, 3		@ set TLS register
+	mov	\tmp1, #0
+	mcr	p15, 0, \tmp1, c13, c0, 2	@ clear user r/w TLS register
 	.endm
 
 	.macro set_tls_v6, tp, tmp1, tmp2
@@ -15,6 +17,8 @@
 	mov	\tmp2, #0xffff0fff
 	tst	\tmp1, #HWCAP_TLS		@ hardware TLS available?
 	mcrne	p15, 0, \tp, c13, c0, 3		@ yes, set TLS register
+	movne	\tmp1, #0
+	mcrne	p15, 0, \tmp1, c13, c0, 2	@ clear user r/w TLS register
 	streq	\tp, [\tmp2, #-15]		@ set TLS value at 0xffff0ff0
 	.endm
 
diff --git a/arch/arm/kernel/Makefile b/arch/arm/kernel/Makefile
index 43b740d..518cea4 100644
--- a/arch/arm/kernel/Makefile
+++ b/arch/arm/kernel/Makefile
@@ -34,6 +34,7 @@ obj-$(CONFIG_HAVE_SCHED_CLOCK)	+= sched_clock.o
 obj-$(CONFIG_SMP)		+= smp.o smp_tlb.o
 obj-$(CONFIG_HAVE_ARM_SCU)	+= smp_scu.o
 obj-$(CONFIG_HAVE_ARM_TWD)	+= smp_twd.o
+obj-$(CONFIG_ARM_ARCH_TIMER)	+= arch_timer.o
 obj-$(CONFIG_DYNAMIC_FTRACE)	+= ftrace.o
 obj-$(CONFIG_FUNCTION_GRAPH_TRACER)	+= ftrace.o
 obj-$(CONFIG_KEXEC)		+= machine_kexec.o relocate_kernel.o
diff --git a/arch/arm/kernel/arch_timer.c b/arch/arm/kernel/arch_timer.c
new file mode 100644
index 0000000..31232c3
--- /dev/null
+++ b/arch/arm/kernel/arch_timer.c
@@ -0,0 +1,367 @@
+/*
+ *  linux/arch/arm/kernel/arch_timer.c
+ *
+ *  Copyright (C) 2011 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/smp.h>
+#include <linux/cpu.h>
+#include <linux/jiffies.h>
+#include <linux/clockchips.h>
+#include <linux/interrupt.h>
+#include <linux/of_irq.h>
+#include <linux/io.h>
+
+#include <asm/cputype.h>
+#include <asm/localtimer.h>
+#include <asm/arch_timer.h>
+#include <asm/sched_clock.h>
+
+static unsigned long arch_timer_rate = 24000000;
+static int arch_timer_ppi = 29;
+static int arch_timer_ppi2 = 30;
+
+static struct clock_event_device __percpu **arch_timer_evt;
+
+/*
+ * Architected system timer support.
+ */
+
+#define ARCH_TIMER_CTRL_ENABLE		(1 << 0)
+#define ARCH_TIMER_CTRL_IT_MASK		(1 << 1)
+#define ARCH_TIMER_CTRL_IT_STAT		(1 << 2)
+
+#define ARCH_TIMER_REG_CTRL		0
+#define ARCH_TIMER_REG_FREQ		1
+#define ARCH_TIMER_REG_TVAL		2
+
+static void arch_timer_reg_write(int reg, u32 val)
+{
+	switch (reg) {
+	case ARCH_TIMER_REG_CTRL:
+		asm volatile("mcr p15, 0, %0, c14, c2, 1" : : "r" (val));
+		break;
+	case ARCH_TIMER_REG_TVAL:
+		asm volatile("mcr p15, 0, %0, c14, c2, 0" : : "r" (val));
+		break;
+	}
+
+	isb();
+}
+
+static u32 arch_timer_reg_read(int reg)
+{
+	u32 val;
+
+	switch (reg) {
+	case ARCH_TIMER_REG_CTRL:
+		asm volatile("mrc p15, 0, %0, c14, c2, 1" : "=r" (val));
+		break;
+	case ARCH_TIMER_REG_FREQ:
+		asm volatile("mrc p15, 0, %0, c14, c0, 0" : "=r" (val));
+		break;
+	case ARCH_TIMER_REG_TVAL:
+		asm volatile("mrc p15, 0, %0, c14, c2, 0" : "=r" (val));
+		break;
+	default:
+		BUG();
+	}
+
+	return val;
+}
+
+static irqreturn_t arch_timer_handler(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = *(struct clock_event_device **)dev_id;
+	unsigned long ctrl;
+
+	ctrl = arch_timer_reg_read(ARCH_TIMER_REG_CTRL);
+	if (ctrl & ARCH_TIMER_CTRL_IT_STAT) {
+		ctrl |= ARCH_TIMER_CTRL_IT_MASK;
+		arch_timer_reg_write(ARCH_TIMER_REG_CTRL, ctrl);
+		evt->event_handler(evt);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+static void arch_timer_disable(void)
+{
+	unsigned long ctrl;
+
+	ctrl = arch_timer_reg_read(ARCH_TIMER_REG_CTRL);
+	ctrl &= ~ARCH_TIMER_CTRL_ENABLE;
+	arch_timer_reg_write(ARCH_TIMER_REG_CTRL, ctrl);
+}
+
+static void arch_timer_set_mode(enum clock_event_mode mode,
+				struct clock_event_device *clk)
+{
+	switch (mode) {
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+		arch_timer_disable();
+		break;
+	default:
+		break;
+	}
+}
+
+static int arch_timer_set_next_event(unsigned long evt,
+				     struct clock_event_device *unused)
+{
+	unsigned long ctrl;
+
+	ctrl = arch_timer_reg_read(ARCH_TIMER_REG_CTRL);
+	ctrl |= ARCH_TIMER_CTRL_ENABLE;
+	ctrl &= ~ARCH_TIMER_CTRL_IT_MASK;
+
+	arch_timer_reg_write(ARCH_TIMER_REG_TVAL, evt);
+	arch_timer_reg_write(ARCH_TIMER_REG_CTRL, ctrl);
+
+	return 0;
+}
+
+static int __cpuinit arch_timer_setup(struct clock_event_device *clk)
+{
+	/* Be safe... */
+	arch_timer_disable();
+
+	clk->features = CLOCK_EVT_FEAT_ONESHOT;
+	clk->name = "local_timer";
+	clk->rating = 450;
+	clk->set_mode = arch_timer_set_mode;
+	clk->set_next_event = arch_timer_set_next_event;
+	clk->irq = arch_timer_ppi;
+
+	clockevents_config_and_register(clk, arch_timer_rate,
+					0xf, 0x7fffffff);
+
+	*__this_cpu_ptr(arch_timer_evt) = clk;
+
+	enable_percpu_irq(clk->irq, 0);
+	if (arch_timer_ppi2)
+		enable_percpu_irq(arch_timer_ppi2, 0);
+
+	return 0;
+}
+
+/* Is the optional system timer available? */
+static int local_timer_is_architected(void)
+{
+	return (cpu_architecture() >= CPU_ARCH_ARMv7) &&
+	       ((read_cpuid_ext(CPUID_EXT_PFR1) >> 16) & 0xf) == 1;
+}
+
+static int arch_timer_available(void)
+{
+	unsigned long freq;
+
+	if (!local_timer_is_architected())
+		return -ENXIO;
+
+	if (arch_timer_rate == 0) {
+		arch_timer_reg_write(ARCH_TIMER_REG_CTRL, 0);
+		freq = arch_timer_reg_read(ARCH_TIMER_REG_FREQ);
+
+		/* Check the timer frequency. */
+		if (freq == 0) {
+			pr_warn("Architected timer frequency not available\n");
+			return -EINVAL;
+		}
+
+		arch_timer_rate = freq;
+	}
+
+	pr_info_once("Architected local timer running at %lu.%02luMHz.\n",
+		     arch_timer_rate / 1000000, (arch_timer_rate / 10000) % 100);
+	return 0;
+}
+
+static inline cycle_t arch_counter_get_cntpct(void)
+{
+	u32 cvall, cvalh;
+
+	asm volatile("mrrc p15, 0, %0, %1, c14" : "=r" (cvall), "=r" (cvalh));
+
+	return ((cycle_t) cvalh << 32) | cvall;
+}
+
+static inline cycle_t arch_counter_get_cntvct(void)
+{
+	u32 cvall, cvalh;
+
+	asm volatile("mrrc p15, 1, %0, %1, c14" : "=r" (cvall), "=r" (cvalh));
+
+	return ((cycle_t) cvalh << 32) | cvall;
+}
+
+static u32 notrace arch_counter_get_cntvct32(void)
+{
+	cycle_t cntvct = arch_counter_get_cntvct();
+
+	/*
+	 * The sched_clock infrastructure only knows about counters
+	 * with at most 32bits. Forget about the upper 24 bits for the
+	 * time being...
+	 */
+	return (u32)(cntvct & (u32)~0);
+}
+
+static cycle_t arch_counter_read(struct clocksource *cs)
+{
+	return arch_counter_get_cntpct();
+}
+
+static struct clocksource clocksource_counter = {
+	.name	= "arch_sys_counter",
+	.rating	= 400,
+	.read	= arch_counter_read,
+	.mask	= CLOCKSOURCE_MASK(56),
+	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static void __cpuinit arch_timer_stop(struct clock_event_device *clk)
+{
+	pr_debug("arch_timer_teardown disable IRQ%d cpu #%d\n",
+		 clk->irq, smp_processor_id());
+	disable_percpu_irq(clk->irq);
+	if (arch_timer_ppi2)
+		disable_percpu_irq(arch_timer_ppi2);
+	arch_timer_set_mode(CLOCK_EVT_MODE_UNUSED, clk);
+}
+
+static struct local_timer_ops arch_timer_ops __cpuinitdata = {
+	.setup	= arch_timer_setup,
+	.stop	= arch_timer_stop,
+};
+
+static struct clock_event_device arch_timer_global_evt;
+
+int arch_timer_common_register(void)
+{
+	int err;
+
+	err = arch_timer_available();
+	if (err)
+		return err;
+
+	arch_timer_evt = alloc_percpu(struct clock_event_device *);
+	if (!arch_timer_evt)
+		return -ENOMEM;
+
+	clocksource_register_hz(&clocksource_counter, arch_timer_rate);
+
+	err = request_percpu_irq(arch_timer_ppi, arch_timer_handler,
+				 "arch_timer", arch_timer_evt);
+	if (err) {
+		pr_err("arch_timer: can't register interrupt %d (%d)\n",
+		       arch_timer_ppi, err);
+		goto out_free;
+	}
+
+	if (arch_timer_ppi2) {
+		err = request_percpu_irq(arch_timer_ppi2, arch_timer_handler,
+					 "arch_timer", arch_timer_evt);
+		if (err) {
+			pr_err("arch_timer: can't register interrupt %d (%d)\n",
+			       arch_timer_ppi2, err);
+			arch_timer_ppi2 = 0;
+			goto out_free_irq;
+		}
+	}
+
+	err = local_timer_register(&arch_timer_ops);
+	if (err) {
+		/*
+		 * We couldn't register as a local timer (could be
+		 * because we're on a UP platform, or because some
+		 * other local timer is already present...). Try as a
+		 * global timer instead.
+		 */
+		arch_timer_global_evt.cpumask = cpumask_of(0);
+		err = arch_timer_setup(&arch_timer_global_evt);
+	}
+
+	if (err)
+		goto out_free_irq;
+
+	return 0;
+
+out_free_irq:
+	free_percpu_irq(arch_timer_ppi, arch_timer_evt);
+	if (arch_timer_ppi2)
+		free_percpu_irq(arch_timer_ppi2, arch_timer_evt);
+
+out_free:
+	free_percpu(arch_timer_evt);
+
+	return err;
+}
+
+int __init arch_timer_register(struct arch_timer *at)
+{
+	if (at->res[0].start <= 0 || !(at->res[0].flags & IORESOURCE_IRQ))
+		return -EINVAL;
+
+	arch_timer_ppi = at->res[0].start;
+
+	if (at->res[1].start > 0 || (at->res[1].flags & IORESOURCE_IRQ))
+		arch_timer_ppi2 = at->res[1].start;
+
+	return arch_timer_common_register();
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id arch_timer_of_match[] __initconst = {
+	{ .compatible	= "arm,armv7-timer",	},
+	{},
+};
+
+int __init arch_timer_of_register(void)
+{
+	struct device_node *np;
+	u32 freq;
+
+	np = of_find_matching_node(NULL, arch_timer_of_match);
+	if (!np) {
+		pr_err("arch_timer: can't find DT node\n");
+		return -ENODEV;
+	}
+
+	/* Try to determine the frequency from the device tree or CNTFRQ */
+	if (!of_property_read_u32(np, "clock-frequency", &freq))
+		arch_timer_rate = freq;
+
+	arch_timer_ppi = irq_of_parse_and_map(np, 0);
+	arch_timer_ppi2 = irq_of_parse_and_map(np, 1);
+	pr_info("arch_timer: found %s irqs %d %d\n",
+		np->name, arch_timer_ppi, arch_timer_ppi2);
+
+	return arch_timer_common_register();
+}
+#endif
+
+int __init arch_timer_sched_clock_init(void)
+{
+	int err;
+
+	err = arch_timer_available();
+	if (err)
+		return err;
+
+	local_irq_disable();
+	setup_sched_clock(arch_counter_get_cntvct32, 32, arch_timer_rate);
+	local_irq_enable();
+
+	return 0;
+}
diff --git a/arch/arm/kernel/early_printk.c b/arch/arm/kernel/early_printk.c
index 85aa2b2..56232d1 100644
--- a/arch/arm/kernel/early_printk.c
+++ b/arch/arm/kernel/early_printk.c
@@ -11,15 +11,34 @@
 #include <linux/kernel.h>
 #include <linux/console.h>
 #include <linux/init.h>
+#include <mach/platform.h>
+#include <asm/io.h>
 
 extern void printch(int);
 
+#define aw_readb(addr)		(*((volatile unsigned char  *)(addr)))
+#define aw_readw(addr)		(*((volatile unsigned short *)(addr)))
+#define aw_readl(addr)		(*((volatile unsigned long  *)(addr)))
+#define aw_writeb(v, addr)	(*((volatile unsigned char  *)(addr)) = (unsigned char)(v))
+#define aw_writew(v, addr)	(*((volatile unsigned short *)(addr)) = (unsigned short)(v))
+#define aw_writel(v, addr)	(*((volatile unsigned long  *)(addr)) = (unsigned long)(v))
+
+
+void aw_putc(char c)
+{
+	while (!(aw_readb(0xf0000000 + AW_UART0_BASE + AW_UART_USR) & 2));
+		aw_writeb(c, 0xf0000000 + AW_UART0_BASE + AW_UART_THR);
+}
+
+
+
 static void early_write(const char *s, unsigned n)
 {
 	while (n-- > 0) {
 		if (*s == '\n')
 			printch('\r');
-		printch(*s);
+		//printch(*s);
+		aw_putc(*s);
 		s++;
 	}
 }
diff --git a/arch/arm/kernel/entry-header.S b/arch/arm/kernel/entry-header.S
index 9a8531e..25188e2 100644
--- a/arch/arm/kernel/entry-header.S
+++ b/arch/arm/kernel/entry-header.S
@@ -109,8 +109,8 @@
 	.endm
 
 	.macro	get_thread_info, rd
-	mov	\rd, sp, lsr #13
-	mov	\rd, \rd, lsl #13
+	mov	\rd, sp, lsr #(PAGE_SHIFT + THREAD_SIZE_ORDER)
+	mov	\rd, \rd, lsl #(PAGE_SHIFT + THREAD_SIZE_ORDER)
 	.endm
 
 	@
@@ -150,8 +150,8 @@
 
 	.macro	get_thread_info, rd
 	mov	\rd, sp
-	lsr	\rd, \rd, #13
-	mov	\rd, \rd, lsl #13
+	lsr	\rd, \rd, #(PAGE_SHIFT + THREAD_SIZE_ORDER)
+	mov	\rd, \rd, lsl #(PAGE_SHIFT + THREAD_SIZE_ORDER)
 	.endm
 
 	@
diff --git a/arch/arm/kernel/head.S b/arch/arm/kernel/head.S
index 6d57911..1765ec0 100644
--- a/arch/arm/kernel/head.S
+++ b/arch/arm/kernel/head.S
@@ -107,6 +107,13 @@ ENTRY(stext)
 	blo	__error_p			@ only classic page table format
 #endif
 
+#if defined(CONFIG_MMU) && defined(CONFIG_ARM_V7)
+	mrc	p15, 0, r3, c0, c1, 4		@ read ID_MMFR0
+	and	r3, r3, #0xf			@ extract VMSA support
+ THUMB( it	eq )				@ force fixup-able long branch encoding
+	beq	__error_p			@ We have CONFIG_MMU and no MMU, so fail
+#endif
+
 #ifndef CONFIG_XIP_KERNEL
 	adr	r3, 2f
 	ldmia	r3, {r4, r8}
diff --git a/arch/arm/kernel/irq.c b/arch/arm/kernel/irq.c
index 3efd82c..0d8c17c 100644
--- a/arch/arm/kernel/irq.c
+++ b/arch/arm/kernel/irq.c
@@ -156,10 +156,10 @@ static bool migrate_one_irq(struct irq_desc *desc)
 	}
 
 	c = irq_data_get_irq_chip(d);
-	if (c->irq_set_affinity)
-		c->irq_set_affinity(d, affinity, true);
-	else
+	if (!c->irq_set_affinity)
 		pr_debug("IRQ%u: unable to set affinity\n", d->irq);
+	else if (c->irq_set_affinity(d, affinity, true) == IRQ_SET_MASK_OK && ret)
+		cpumask_copy(d->affinity, affinity);
 
 	return ret;
 }
@@ -181,10 +181,7 @@ void migrate_irqs(void)
 	local_irq_save(flags);
 
 	for_each_irq_desc(i, desc) {
-		bool affinity_broken = false;
-
-		if (!desc)
-			continue;
+		bool affinity_broken;
 
 		raw_spin_lock(&desc->lock);
 		affinity_broken = migrate_one_irq(desc);
diff --git a/arch/arm/kernel/machine_kexec.c b/arch/arm/kernel/machine_kexec.c
index 764bd45..a300044 100644
--- a/arch/arm/kernel/machine_kexec.c
+++ b/arch/arm/kernel/machine_kexec.c
@@ -7,6 +7,7 @@
 #include <linux/delay.h>
 #include <linux/reboot.h>
 #include <linux/io.h>
+#include <linux/irq.h>
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
 #include <asm/mmu_context.h>
@@ -53,6 +54,29 @@ void machine_crash_nonpanic_core(void *unused)
 		cpu_relax();
 }
 
+static void machine_kexec_mask_interrupts(void)
+{
+	unsigned int i;
+	struct irq_desc *desc;
+
+	for_each_irq_desc(i, desc) {
+		struct irq_chip *chip;
+
+		chip = irq_desc_get_chip(desc);
+		if (!chip)
+			continue;
+
+		if (chip->irq_eoi && irqd_irq_inprogress(&desc->irq_data))
+			chip->irq_eoi(&desc->irq_data);
+
+		if (chip->irq_mask)
+			chip->irq_mask(&desc->irq_data);
+
+		if (chip->irq_disable && !irqd_irq_disabled(&desc->irq_data))
+			chip->irq_disable(&desc->irq_data);
+	}
+}
+
 void machine_crash_shutdown(struct pt_regs *regs)
 {
 	unsigned long msecs;
@@ -70,6 +94,7 @@ void machine_crash_shutdown(struct pt_regs *regs)
 		printk(KERN_WARNING "Non-crashing CPUs did not react to IPI\n");
 
 	crash_save_cpu(regs, smp_processor_id());
+	machine_kexec_mask_interrupts();
 
 	printk(KERN_INFO "Loading crashdump kernel...\n");
 }
diff --git a/arch/arm/kernel/perf_event.c b/arch/arm/kernel/perf_event.c
index b2abfa1..662100a 100644
--- a/arch/arm/kernel/perf_event.c
+++ b/arch/arm/kernel/perf_event.c
@@ -734,6 +734,9 @@ init_hw_perf_events(void)
 		case 0xC0F0:	/* Cortex-A15 */
 			cpu_pmu = armv7_a15_pmu_init();
 			break;
+		case 0xC070:	/* Cortex-A7 */
+			cpu_pmu = armv7_a7_pmu_init();
+			break;
 		}
 	/* Intel CPUs [xscale]. */
 	} else if (0x69 == implementor) {
diff --git a/arch/arm/kernel/perf_event_v7.c b/arch/arm/kernel/perf_event_v7.c
index 4d7095a..00755d8 100644
--- a/arch/arm/kernel/perf_event_v7.c
+++ b/arch/arm/kernel/perf_event_v7.c
@@ -610,6 +610,130 @@ static const unsigned armv7_a15_perf_cache_map[PERF_COUNT_HW_CACHE_MAX]
 };
 
 /*
+ * Cortex-A7 HW events mapping
+ */
+static const unsigned armv7_a7_perf_map[PERF_COUNT_HW_MAX] = {
+	[PERF_COUNT_HW_CPU_CYCLES]		= ARMV7_PERFCTR_CPU_CYCLES,
+	[PERF_COUNT_HW_INSTRUCTIONS]		= ARMV7_PERFCTR_INSTR_EXECUTED,
+	[PERF_COUNT_HW_CACHE_REFERENCES]	= ARMV7_PERFCTR_L1_DCACHE_ACCESS,
+	[PERF_COUNT_HW_CACHE_MISSES]		= ARMV7_PERFCTR_L1_DCACHE_REFILL,
+	[PERF_COUNT_HW_BRANCH_INSTRUCTIONS]	= ARMV7_PERFCTR_PC_WRITE,
+	[PERF_COUNT_HW_BRANCH_MISSES]		= ARMV7_PERFCTR_PC_BRANCH_MIS_PRED,
+	[PERF_COUNT_HW_BUS_CYCLES]		= ARMV7_PERFCTR_BUS_CYCLES,
+	[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND]	= HW_OP_UNSUPPORTED,
+	[PERF_COUNT_HW_STALLED_CYCLES_BACKEND]	= HW_OP_UNSUPPORTED,
+};
+
+static const unsigned armv7_a7_perf_cache_map[PERF_COUNT_HW_CACHE_MAX]
+					[PERF_COUNT_HW_CACHE_OP_MAX]
+					[PERF_COUNT_HW_CACHE_RESULT_MAX] = {
+	[C(L1D)] = {
+		/*
+		 * The performance counters don't differentiate between read
+		 * and write accesses/misses so this isn't strictly correct,
+		 * but it's the best we can do. Writes and reads get
+		 * combined.
+		 */
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)]	= ARMV7_PERFCTR_L1_DCACHE_ACCESS,
+			[C(RESULT_MISS)]	= ARMV7_PERFCTR_L1_DCACHE_REFILL,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)]	= ARMV7_PERFCTR_L1_DCACHE_ACCESS,
+			[C(RESULT_MISS)]	= ARMV7_PERFCTR_L1_DCACHE_REFILL,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= CACHE_OP_UNSUPPORTED,
+		},
+	},
+	[C(L1I)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)]	= ARMV7_PERFCTR_L1_ICACHE_ACCESS,
+			[C(RESULT_MISS)]	= ARMV7_PERFCTR_L1_ICACHE_REFILL,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)]	= ARMV7_PERFCTR_L1_ICACHE_ACCESS,
+			[C(RESULT_MISS)]	= ARMV7_PERFCTR_L1_ICACHE_REFILL,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= CACHE_OP_UNSUPPORTED,
+		},
+	},
+	[C(LL)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)]	= ARMV7_PERFCTR_L2_CACHE_ACCESS,
+			[C(RESULT_MISS)]	= ARMV7_PERFCTR_L2_CACHE_REFILL,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)]	= ARMV7_PERFCTR_L2_CACHE_ACCESS,
+			[C(RESULT_MISS)]	= ARMV7_PERFCTR_L2_CACHE_REFILL,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= CACHE_OP_UNSUPPORTED,
+		},
+	},
+	[C(DTLB)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= ARMV7_PERFCTR_DTLB_REFILL,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= ARMV7_PERFCTR_DTLB_REFILL,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= CACHE_OP_UNSUPPORTED,
+		},
+	},
+	[C(ITLB)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= ARMV7_PERFCTR_ITLB_REFILL,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= ARMV7_PERFCTR_ITLB_REFILL,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= CACHE_OP_UNSUPPORTED,
+		},
+	},
+	[C(BPU)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)]	= ARMV7_PERFCTR_PC_BRANCH_PRED,
+			[C(RESULT_MISS)]	= ARMV7_PERFCTR_PC_BRANCH_MIS_PRED,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)]	= ARMV7_PERFCTR_PC_BRANCH_PRED,
+			[C(RESULT_MISS)]	= ARMV7_PERFCTR_PC_BRANCH_MIS_PRED,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= CACHE_OP_UNSUPPORTED,
+		},
+	},
+	[C(NODE)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= CACHE_OP_UNSUPPORTED,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= CACHE_OP_UNSUPPORTED,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)]	= CACHE_OP_UNSUPPORTED,
+			[C(RESULT_MISS)]	= CACHE_OP_UNSUPPORTED,
+		},
+	},
+};
+
+/*
  * Perf Events' indices
  */
 #define	ARMV7_IDX_CYCLE_COUNTER	0
@@ -1104,6 +1228,12 @@ static int armv7_a15_map_event(struct perf_event *event)
 				&armv7_a15_perf_cache_map, 0xFF);
 }
 
+static int armv7_a7_map_event(struct perf_event *event)
+{
+	return map_cpu_event(event, &armv7_a7_perf_map,
+				&armv7_a7_perf_cache_map, 0xFF);
+}
+
 static struct arm_pmu armv7pmu = {
 	.handle_irq		= armv7pmu_handle_irq,
 	.enable			= armv7pmu_enable_event,
@@ -1164,6 +1294,16 @@ static struct arm_pmu *__init armv7_a15_pmu_init(void)
 	armv7pmu.set_event_filter = armv7pmu_set_event_filter;
 	return &armv7pmu;
 }
+
+static struct arm_pmu *__init armv7_a7_pmu_init(void)
+{
+	armv7pmu.id		= ARM_PERF_PMU_ID_CA7;
+	armv7pmu.name		= "ARMv7 Cortex-A7";
+	armv7pmu.map_event	= armv7_a7_map_event;
+	armv7pmu.num_events	= armv7_read_num_pmnc_events();
+	armv7pmu.set_event_filter = armv7pmu_set_event_filter;
+	return &armv7pmu;
+}
 #else
 static struct arm_pmu *__init armv7_a8_pmu_init(void)
 {
@@ -1184,4 +1324,9 @@ static struct arm_pmu *__init armv7_a15_pmu_init(void)
 {
 	return NULL;
 }
+
+static struct arm_pmu *__init armv7_a7_pmu_init(void)
+{
+	return NULL;
+}
 #endif	/* CONFIG_CPU_V7 */
diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index c26f414..ca64a05 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -640,22 +640,40 @@ unsigned long arch_randomize_brk(struct mm_struct *mm)
 #ifdef CONFIG_MMU
 /*
  * The vectors page is always readable from user space for the
- * atomic helpers and the signal restart code.  Let's declare a mapping
- * for it so it is visible through ptrace and /proc/<pid>/mem.
+ * atomic helpers and the signal restart code. Insert it into the
+ * gate_vma so that it is visible through ptrace and /proc/<pid>/mem.
  */
+static struct vm_area_struct gate_vma;
 
-int vectors_user_mapping(void)
+static int __init gate_vma_init(void)
 {
-	struct mm_struct *mm = current->mm;
-	return install_special_mapping(mm, 0xffff0000, PAGE_SIZE,
-				       VM_READ | VM_EXEC |
-				       VM_MAYREAD | VM_MAYEXEC |
-				       VM_ALWAYSDUMP | VM_RESERVED,
-				       NULL);
+	gate_vma.vm_start	= 0xffff0000;
+	gate_vma.vm_end		= 0xffff0000 + PAGE_SIZE;
+	gate_vma.vm_page_prot	= PAGE_READONLY_EXEC;
+	gate_vma.vm_flags	= VM_READ | VM_EXEC |
+				  VM_MAYREAD | VM_MAYEXEC |
+				  VM_ALWAYSDUMP;
+	return 0;
+}
+arch_initcall(gate_vma_init);
+
+struct vm_area_struct *get_gate_vma(struct mm_struct *mm)
+{
+	return &gate_vma;
+}
+
+int in_gate_area(struct mm_struct *mm, unsigned long addr)
+{
+	return (addr >= gate_vma.vm_start) && (addr < gate_vma.vm_end);
+}
+
+int in_gate_area_no_mm(unsigned long addr)
+{
+	return in_gate_area(NULL, addr);
 }
 
 const char *arch_vma_name(struct vm_area_struct *vma)
 {
-	return (vma->vm_start == 0xffff0000) ? "[vectors]" : NULL;
+	return (vma == &gate_vma) ? "[vectors]" : NULL;
 }
 #endif
diff --git a/arch/arm/kernel/ptrace.c b/arch/arm/kernel/ptrace.c
index ede6443..4fe2d598 100644
--- a/arch/arm/kernel/ptrace.c
+++ b/arch/arm/kernel/ptrace.c
@@ -257,7 +257,7 @@ static int ptrace_read_user(struct task_struct *tsk, unsigned long off,
 {
 	unsigned long tmp;
 
-	if (off & 3 || off >= sizeof(struct user))
+	if (off & 3)
 		return -EIO;
 
 	tmp = 0;
@@ -269,6 +269,8 @@ static int ptrace_read_user(struct task_struct *tsk, unsigned long off,
 		tmp = tsk->mm->end_code;
 	else if (off < sizeof(struct pt_regs))
 		tmp = get_user_reg(tsk, off >> 2);
+	else if (off >= sizeof(struct user))
+		return -EIO;
 
 	return put_user(tmp, ret);
 }
diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index a255c39..b50a2a5 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -53,6 +53,9 @@
 #include <asm/traps.h>
 #include <asm/unwind.h>
 #include <asm/memblock.h>
+#ifdef CONFIG_ARCH_SUN6I
+#include <mach/system.h>
+#endif
 
 #if defined(CONFIG_DEPRECATED_PARAM_STRUCT)
 #include "compat.h"
@@ -521,7 +524,21 @@ int __init arm_add_memory(phys_addr_t start, unsigned long size)
 	 */
 	size -= start & ~PAGE_MASK;
 	bank->start = PAGE_ALIGN(start);
-	bank->size  = size & PAGE_MASK;
+
+#ifndef CONFIG_LPAE
+	if (bank->start + size < bank->start) {
+		printk(KERN_CRIT "Truncating memory at 0x%08llx to fit in "
+			"32-bit physical address space\n", (long long)start);
+		/*
+		 * To ensure bank->start + bank->size is representable in
+		 * 32 bits, we use ULONG_MAX as the upper limit rather than 4GB.
+		 * This means we lose a page after masking.
+		 */
+		size = ULONG_MAX - bank->start;
+	}
+#endif
+
+	bank->size = size & PAGE_MASK;
 
 	/*
 	 * Check whether this memory region has non-zero size or
@@ -1031,10 +1048,25 @@ static const char *hwcap_str[] = {
 	NULL
 };
 
+
+#ifdef CONFIG_ARCH_SUN6I
+extern int axp_chip_id_get(uint8_t chip_id[16]);
+#endif
+
 static int c_show(struct seq_file *m, void *v)
 {
 	int i;
 
+#ifdef CONFIG_ARCH_SUN6I
+	uint32_t chipid[4];
+    enum sw_ic_ver  ic_ver;
+	int ret;
+
+	memset(chipid, 0, sizeof(chipid));
+	ret = axp_chip_id_get((uint8_t *)chipid);
+    ic_ver = sw_get_ic_ver();
+#endif
+
 	seq_printf(m, "Processor\t: %s rev %d (%s)\n",
 		   cpu_name, read_cpuid_id() & 15, elf_platform);
 
@@ -1088,8 +1120,16 @@ static int c_show(struct seq_file *m, void *v)
 
 	seq_printf(m, "Hardware\t: %s\n", machine_name);
 	seq_printf(m, "Revision\t: %04x\n", system_rev);
+
+#ifdef CONFIG_ARCH_SUN6I
+	seq_printf(m, "Revision\t: %04x\n", ic_ver);
+	seq_printf(m, "Serial\t\t: %08x%08x%08x%08x\n",
+		   chipid[0], chipid[1], chipid[2], chipid[3]);
+#else
+	seq_printf(m, "Revision\t: %04x\n", system_rev);
 	seq_printf(m, "Serial\t\t: %08x%08x\n",
 		   system_serial_high, system_serial_low);
+#endif
 
 	return 0;
 }
diff --git a/arch/arm/kernel/signal.c b/arch/arm/kernel/signal.c
index 9e617bd..b02ce1d 100644
--- a/arch/arm/kernel/signal.c
+++ b/arch/arm/kernel/signal.c
@@ -179,44 +179,23 @@ static int restore_iwmmxt_context(struct iwmmxt_sigframe *frame)
 
 static int preserve_vfp_context(struct vfp_sigframe __user *frame)
 {
-	struct thread_info *thread = current_thread_info();
-	struct vfp_hard_struct *h = &thread->vfpstate.hard;
 	const unsigned long magic = VFP_MAGIC;
 	const unsigned long size = VFP_STORAGE_SIZE;
 	int err = 0;
 
-	vfp_sync_hwstate(thread);
 	__put_user_error(magic, &frame->magic, err);
 	__put_user_error(size, &frame->size, err);
 
-	/*
-	 * Copy the floating point registers. There can be unused
-	 * registers see asm/hwcap.h for details.
-	 */
-	err |= __copy_to_user(&frame->ufp.fpregs, &h->fpregs,
-			      sizeof(h->fpregs));
-	/*
-	 * Copy the status and control register.
-	 */
-	__put_user_error(h->fpscr, &frame->ufp.fpscr, err);
-
-	/*
-	 * Copy the exception registers.
-	 */
-	__put_user_error(h->fpexc, &frame->ufp_exc.fpexc, err);
-	__put_user_error(h->fpinst, &frame->ufp_exc.fpinst, err);
-	__put_user_error(h->fpinst2, &frame->ufp_exc.fpinst2, err);
+	if (err)
+		return -EFAULT;
 
-	return err ? -EFAULT : 0;
+	return vfp_preserve_user_clear_hwstate(&frame->ufp, &frame->ufp_exc);
 }
 
 static int restore_vfp_context(struct vfp_sigframe __user *frame)
 {
-	struct thread_info *thread = current_thread_info();
-	struct vfp_hard_struct *h = &thread->vfpstate.hard;
 	unsigned long magic;
 	unsigned long size;
-	unsigned long fpexc;
 	int err = 0;
 
 	__get_user_error(magic, &frame->magic, err);
@@ -227,33 +206,7 @@ static int restore_vfp_context(struct vfp_sigframe __user *frame)
 	if (magic != VFP_MAGIC || size != VFP_STORAGE_SIZE)
 		return -EINVAL;
 
-	vfp_flush_hwstate(thread);
-
-	/*
-	 * Copy the floating point registers. There can be unused
-	 * registers see asm/hwcap.h for details.
-	 */
-	err |= __copy_from_user(&h->fpregs, &frame->ufp.fpregs,
-				sizeof(h->fpregs));
-	/*
-	 * Copy the status and control register.
-	 */
-	__get_user_error(h->fpscr, &frame->ufp.fpscr, err);
-
-	/*
-	 * Sanitise and restore the exception registers.
-	 */
-	__get_user_error(fpexc, &frame->ufp_exc.fpexc, err);
-	/* Ensure the VFP is enabled. */
-	fpexc |= FPEXC_EN;
-	/* Ensure FPINST2 is invalid and the exception flag is cleared. */
-	fpexc &= ~(FPEXC_EX | FPEXC_FP2V);
-	h->fpexc = fpexc;
-
-	__get_user_error(h->fpinst, &frame->ufp_exc.fpinst, err);
-	__get_user_error(h->fpinst2, &frame->ufp_exc.fpinst2, err);
-
-	return err ? -EFAULT : 0;
+	return vfp_restore_user_hwstate(&frame->ufp, &frame->ufp_exc);
 }
 
 #endif
diff --git a/arch/arm/kernel/smp.c b/arch/arm/kernel/smp.c
index bfb93dc..4c8d8c2 100644
--- a/arch/arm/kernel/smp.c
+++ b/arch/arm/kernel/smp.c
@@ -59,6 +59,9 @@ enum ipi_msg_type {
 	IPI_CPU_BACKTRACE,
 };
 
+static DECLARE_COMPLETION(cpu_running);
+
+
 int __cpuinit __cpu_up(unsigned int cpu)
 {
 	struct cpuinfo_arm *ci = &per_cpu(cpu_data, cpu);
@@ -99,20 +102,11 @@ int __cpuinit __cpu_up(unsigned int cpu)
 	 */
 	ret = boot_secondary(cpu, idle);
 	if (ret == 0) {
-		unsigned long timeout;
-
 		/*
 		 * CPU was successfully started, wait for it
 		 * to come online or time out.
 		 */
-		timeout = jiffies + HZ;
-		while (time_before(jiffies, timeout)) {
-			if (cpu_online(cpu))
-				break;
-
-			udelay(10);
-			barrier();
-		}
+		wait_for_completion_timeout(&cpu_running, msecs_to_jiffies(1000*3));
 
 		if (!cpu_online(cpu)) {
 			pr_crit("CPU%u: failed to come online\n", cpu);
@@ -247,6 +241,8 @@ static void __cpuinit smp_store_cpu_info(unsigned int cpuid)
 	store_cpu_topology(cpuid);
 }
 
+static void percpu_timer_setup(void);
+
 /*
  * This is the secondary CPU boot entry.  We're using this CPUs
  * idle thread stack, but a set of temporary page tables.
@@ -290,6 +286,7 @@ asmlinkage void __cpuinit secondary_start_kernel(void)
 	 * before we continue.
 	 */
 	set_cpu_online(cpu, true);
+	complete(&cpu_running);
 
 	/*
 	 * Setup the percpu timer for this CPU.
@@ -461,7 +458,23 @@ static void __cpuinit broadcast_timer_setup(struct clock_event_device *evt)
 	clockevents_register_device(evt);
 }
 
-void __cpuinit percpu_timer_setup(void)
+static struct local_timer_ops *lt_ops;
+
+#ifdef CONFIG_LOCAL_TIMERS
+int local_timer_register(struct local_timer_ops *ops)
+{
+	if (!is_smp() || !setup_max_cpus)
+		return -ENXIO;
+
+	if (lt_ops)
+		return -EBUSY;
+
+	lt_ops = ops;
+	return 0;
+}
+#endif
+
+static void __cpuinit percpu_timer_setup(void)
 {
 	unsigned int cpu = smp_processor_id();
 	struct clock_event_device *evt = &per_cpu(percpu_clockevent, cpu);
@@ -469,7 +482,7 @@ void __cpuinit percpu_timer_setup(void)
 	evt->cpumask = cpumask_of(cpu);
 	evt->broadcast = smp_timer_broadcast;
 
-	if (local_timer_setup(evt))
+	if (!lt_ops || lt_ops->setup(evt))
 		broadcast_timer_setup(evt);
 }
 
@@ -484,7 +497,8 @@ static void percpu_timer_stop(void)
 	unsigned int cpu = smp_processor_id();
 	struct clock_event_device *evt = &per_cpu(percpu_clockevent, cpu);
 
-	local_timer_stop(evt);
+	if (lt_ops)
+		lt_ops->stop(evt);
 }
 #endif
 
@@ -508,10 +522,6 @@ static void ipi_cpu_stop(unsigned int cpu)
 	local_fiq_disable();
 	local_irq_disable();
 
-#ifdef CONFIG_HOTPLUG_CPU
-	platform_cpu_kill(cpu);
-#endif
-
 	while (1)
 		cpu_relax();
 }
@@ -630,16 +640,25 @@ void smp_send_reschedule(int cpu)
 	smp_cross_call(cpumask_of(cpu), IPI_RESCHEDULE);
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+static void smp_kill_cpus(cpumask_t *mask)
+{
+	unsigned int cpu;
+	for_each_cpu(cpu, mask)
+		platform_cpu_kill(cpu);
+}
+#else
+static void smp_kill_cpus(cpumask_t *mask) { }
+#endif
+
 void smp_send_stop(void)
 {
 	unsigned long timeout;
+	cpumask_t mask = cpu_online_map;
+	cpu_clear(smp_processor_id(), mask);
 
-	if (num_online_cpus() > 1) {
-		cpumask_t mask = cpu_online_map;
-		cpu_clear(smp_processor_id(), mask);
-
+	if (num_online_cpus() > 1)
 		smp_cross_call(&mask, IPI_CPU_STOP);
-	}
 
 	/* Wait up to one second for other CPUs to stop */
 	timeout = USEC_PER_SEC;
@@ -648,6 +667,8 @@ void smp_send_stop(void)
 
 	if (num_online_cpus() > 1)
 		pr_warning("SMP: failed to stop secondary CPUs\n");
+
+	smp_kill_cpus(&mask);
 }
 
 /*
diff --git a/arch/arm/kernel/smp_scu.c b/arch/arm/kernel/smp_scu.c
index 8f5dd79..079981e 100644
--- a/arch/arm/kernel/smp_scu.c
+++ b/arch/arm/kernel/smp_scu.c
@@ -11,6 +11,7 @@
 #include <linux/init.h>
 #include <linux/io.h>
 
+#include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 #include <asm/cacheflush.h>
 #include <asm/cputype.h>
@@ -21,14 +22,18 @@
 #define SCU_INVALIDATE		0x0c
 #define SCU_FPGA_REVISION	0x10
 
-#ifdef CONFIG_SMP
 /*
  * Get the number of CPU cores from the SCU configuration
  */
 unsigned int __init scu_get_core_count(void __iomem *scu_base)
 {
-	unsigned int ncores = __raw_readl(scu_base + SCU_CONFIG);
-	return (ncores & 0x03) + 1;
+        unsigned int cores;
+
+        /* Read current CP15 Cache Size ID Register */
+        asm volatile ("mrc p15, 1, %0, c9, c0, 2" : "=r" (cores));
+
+        cores = ((cores >> 24) & 0x3) + 1;
+        return cores;
 }
 
 /*
@@ -36,32 +41,7 @@ unsigned int __init scu_get_core_count(void __iomem *scu_base)
  */
 void scu_enable(void __iomem *scu_base)
 {
-	u32 scu_ctrl;
-
-#ifdef CONFIG_ARM_ERRATA_764369
-	/* Cortex-A9 only */
-	if ((read_cpuid(CPUID_ID) & 0xff0ffff0) == 0x410fc090) {
-		scu_ctrl = __raw_readl(scu_base + 0x30);
-		if (!(scu_ctrl & 1))
-			__raw_writel(scu_ctrl | 0x1, scu_base + 0x30);
-	}
-#endif
-
-	scu_ctrl = __raw_readl(scu_base + SCU_CTRL);
-	/* already enabled? */
-	if (scu_ctrl & 1)
-		return;
-
-	scu_ctrl |= 1;
-	__raw_writel(scu_ctrl, scu_base + SCU_CTRL);
-
-	/*
-	 * Ensure that the data accessed by CPU0 before the SCU was
-	 * initialised is visible to the other CPUs.
-	 */
-	flush_cache_all();
 }
-#endif
 
 /*
  * Set the executing CPUs power mode as defined.  This will be in
@@ -73,15 +53,5 @@ void scu_enable(void __iomem *scu_base)
  */
 int scu_power_mode(void __iomem *scu_base, unsigned int mode)
 {
-	unsigned int val;
-	int cpu = smp_processor_id();
-
-	if (mode > 3 || mode == 1 || cpu > 3)
-		return -EINVAL;
-
-	val = __raw_readb(scu_base + SCU_CPU_STATUS + cpu) & ~0x03;
-	val |= mode;
-	__raw_writeb(val, scu_base + SCU_CPU_STATUS + cpu);
-
 	return 0;
 }
diff --git a/arch/arm/kernel/smp_twd.c b/arch/arm/kernel/smp_twd.c
index 7a79b24..fef42b2 100644
--- a/arch/arm/kernel/smp_twd.c
+++ b/arch/arm/kernel/smp_twd.c
@@ -18,20 +18,23 @@
 #include <linux/smp.h>
 #include <linux/jiffies.h>
 #include <linux/clockchips.h>
-#include <linux/irq.h>
+#include <linux/interrupt.h>
 #include <linux/io.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
 
 #include <asm/smp_twd.h>
 #include <asm/localtimer.h>
 #include <asm/hardware/gic.h>
 
 /* set up by the platform code */
-void __iomem *twd_base;
+static void __iomem *twd_base;
 
 static struct clk *twd_clk;
 static unsigned long twd_timer_rate;
 
 static struct clock_event_device __percpu **twd_evt;
+static int twd_ppi;
 
 static void twd_set_mode(enum clock_event_mode mode,
 			struct clock_event_device *clk)
@@ -77,7 +80,7 @@ static int twd_set_next_event(unsigned long evt,
  * If a local timer interrupt has occurred, acknowledge and return 1.
  * Otherwise, return 0.
  */
-int twd_timer_ack(void)
+static int twd_timer_ack(void)
 {
 	if (__raw_readl(twd_base + TWD_TIMER_INTSTAT)) {
 		__raw_writel(1, twd_base + TWD_TIMER_INTSTAT);
@@ -87,7 +90,7 @@ int twd_timer_ack(void)
 	return 0;
 }
 
-void twd_timer_stop(struct clock_event_device *clk)
+static void twd_timer_stop(struct clock_event_device *clk)
 {
 	twd_set_mode(CLOCK_EVT_MODE_UNUSED, clk);
 	disable_percpu_irq(clk->irq);
@@ -222,28 +225,10 @@ static struct clk *twd_get_clock(void)
 /*
  * Setup the local clock events for a CPU.
  */
-void __cpuinit twd_timer_setup(struct clock_event_device *clk)
+static int __cpuinit twd_timer_setup(struct clock_event_device *clk)
 {
 	struct clock_event_device **this_cpu_clk;
 
-	if (!twd_evt) {
-		int err;
-
-		twd_evt = alloc_percpu(struct clock_event_device *);
-		if (!twd_evt) {
-			pr_err("twd: can't allocate memory\n");
-			return;
-		}
-
-		err = request_percpu_irq(clk->irq, twd_handler,
-					 "twd", twd_evt);
-		if (err) {
-			pr_err("twd: can't register interrupt %d (%d)\n",
-			       clk->irq, err);
-			return;
-		}
-	}
-
 	if (!twd_clk)
 		twd_clk = twd_get_clock();
 
@@ -260,6 +245,7 @@ void __cpuinit twd_timer_setup(struct clock_event_device *clk)
 	clk->rating = 350;
 	clk->set_mode = twd_set_mode;
 	clk->set_next_event = twd_set_next_event;
+	clk->irq = twd_ppi;
 
 	this_cpu_clk = __this_cpu_ptr(twd_evt);
 	*this_cpu_clk = clk;
@@ -267,4 +253,95 @@ void __cpuinit twd_timer_setup(struct clock_event_device *clk)
 	clockevents_config_and_register(clk, twd_timer_rate,
 					0xf, 0xffffffff);
 	enable_percpu_irq(clk->irq, 0);
+
+	return 0;
+}
+
+static struct local_timer_ops twd_lt_ops __cpuinitdata = {
+	.setup	= twd_timer_setup,
+	.stop	= twd_timer_stop,
+};
+
+static int __init twd_local_timer_common_register(void)
+{
+	int err;
+
+	twd_evt = alloc_percpu(struct clock_event_device *);
+	if (!twd_evt) {
+		err = -ENOMEM;
+		goto out_free;
+	}
+
+	err = request_percpu_irq(twd_ppi, twd_handler, "twd", twd_evt);
+	if (err) {
+		pr_err("twd: can't register interrupt %d (%d)\n", twd_ppi, err);
+		goto out_free;
+	}
+
+	err = local_timer_register(&twd_lt_ops);
+	if (err)
+		goto out_irq;
+
+	return 0;
+
+out_irq:
+	free_percpu_irq(twd_ppi, twd_evt);
+out_free:
+	iounmap(twd_base);
+	twd_base = NULL;
+	free_percpu(twd_evt);
+
+	return err;
 }
+
+int __init twd_local_timer_register(struct twd_local_timer *tlt)
+{
+	if (twd_base || twd_evt)
+		return -EBUSY;
+
+	twd_ppi	= tlt->res[1].start;
+
+	twd_base = ioremap(tlt->res[0].start, resource_size(&tlt->res[0]));
+	if (!twd_base)
+		return -ENOMEM;
+
+	return twd_local_timer_common_register();
+}
+
+#ifdef CONFIG_OF
+const static struct of_device_id twd_of_match[] __initconst = {
+	{ .compatible = "arm,cortex-a9-twd-timer",	},
+	{ .compatible = "arm,cortex-a5-twd-timer",	},
+	{ .compatible = "arm,arm11mp-twd-timer",	},
+	{ },
+};
+
+void __init twd_local_timer_of_register(void)
+{
+	struct device_node *np;
+	int err;
+
+	np = of_find_matching_node(NULL, twd_of_match);
+	if (!np) {
+		err = -ENODEV;
+		goto out;
+	}
+
+	twd_ppi = irq_of_parse_and_map(np, 0);
+	if (!twd_ppi) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	twd_base = of_iomap(np, 0);
+	if (!twd_base) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	err = twd_local_timer_common_register();
+
+out:
+	WARN(err, "twd_local_timer_of_register failed (%d)\n", err);
+}
+#endif
diff --git a/arch/arm/kernel/suspend.c b/arch/arm/kernel/suspend.c
index 1794cc3..073601e 100644
--- a/arch/arm/kernel/suspend.c
+++ b/arch/arm/kernel/suspend.c
@@ -10,28 +10,7 @@
 extern int __cpu_suspend(unsigned long, int (*)(unsigned long));
 extern void cpu_resume_mmu(void);
 
-/*
- * This is called by __cpu_suspend() to save the state, and do whatever
- * flushing is required to ensure that when the CPU goes to sleep we have
- * the necessary data available when the caches are not searched.
- */
-void __cpu_suspend_save(u32 *ptr, u32 ptrsz, u32 sp, u32 *save_ptr)
-{
-	*save_ptr = virt_to_phys(ptr);
-
-	/* This must correspond to the LDM in cpu_resume() assembly */
-	*ptr++ = virt_to_phys(idmap_pgd);
-	*ptr++ = sp;
-	*ptr++ = virt_to_phys(cpu_do_resume);
-
-	cpu_do_suspend(ptr);
-
-	flush_cache_all();
-	outer_clean_range(*save_ptr, *save_ptr + ptrsz);
-	outer_clean_range(virt_to_phys(save_ptr),
-			  virt_to_phys(save_ptr) + sizeof(*save_ptr));
-}
-
+#ifdef CONFIG_MMU
 /*
  * Hide the first two arguments to __cpu_suspend - these are an implementation
  * detail which platform code shouldn't have to know about.
@@ -58,3 +37,32 @@ int cpu_suspend(unsigned long arg, int (*fn)(unsigned long))
 
 	return ret;
 }
+#else
+int cpu_suspend(unsigned long arg, int (*fn)(unsigned long))
+{
+	return __cpu_suspend(arg, fn);
+}
+#define	idmap_pgd	NULL
+#endif
+
+/*
+ * This is called by __cpu_suspend() to save the state, and do whatever
+ * flushing is required to ensure that when the CPU goes to sleep we have
+ * the necessary data available when the caches are not searched.
+ */
+void __cpu_suspend_save(u32 *ptr, u32 ptrsz, u32 sp, u32 *save_ptr)
+{
+	*save_ptr = virt_to_phys(ptr);
+
+	/* This must correspond to the LDM in cpu_resume() assembly */
+	*ptr++ = virt_to_phys(idmap_pgd);
+	*ptr++ = sp;
+	*ptr++ = virt_to_phys(cpu_do_resume);
+
+	cpu_do_suspend(ptr);
+
+	flush_cache_all();
+	outer_clean_range(*save_ptr, *save_ptr + ptrsz);
+	outer_clean_range(virt_to_phys(save_ptr),
+			  virt_to_phys(save_ptr) + sizeof(*save_ptr));
+}
diff --git a/arch/arm/kernel/thumbee.c b/arch/arm/kernel/thumbee.c
index 9cb7aac..3471f63 100644
--- a/arch/arm/kernel/thumbee.c
+++ b/arch/arm/kernel/thumbee.c
@@ -20,6 +20,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 
+#include <asm/cputype.h>
 #include <asm/thread_notify.h>
 
 /*
@@ -66,8 +67,7 @@ static int __init thumbee_init(void)
 	if (cpu_arch < CPU_ARCH_ARMv7)
 		return 0;
 
-	/* processor feature register 0 */
-	asm("mrc	p15, 0, %0, c0, c1, 0\n" : "=r" (pfr0));
+	pfr0 = read_cpuid_ext(CPUID_EXT_PFR0);
 	if ((pfr0 & 0x0000f000) != 0x00001000)
 		return 0;
 
diff --git a/arch/arm/kernel/traps.c b/arch/arm/kernel/traps.c
index 504b28a..a31187b 100644
--- a/arch/arm/kernel/traps.c
+++ b/arch/arm/kernel/traps.c
@@ -788,7 +788,7 @@ static void __init kuser_get_tls_init(unsigned long vectors)
 
 void __init early_trap_init(void)
 {
-#if defined(CONFIG_CPU_USE_DOMAINS)
+#if defined(CONFIG_CPU_USE_DOMAINS) || !defined(CONFIG_MMU)
 	unsigned long vectors = CONFIG_VECTORS_BASE;
 #else
 	unsigned long vectors = (unsigned long)vectors_page;
@@ -821,6 +821,6 @@ void __init early_trap_init(void)
 	memcpy((void *)(vectors + KERN_RESTART_CODE - CONFIG_VECTORS_BASE),
 	       syscall_restart_code, sizeof(syscall_restart_code));
 
-	flush_icache_range(vectors, vectors + PAGE_SIZE);
+	flush_icache_range(CONFIG_VECTORS_BASE, CONFIG_VECTORS_BASE+PAGE_SIZE);
 	modify_domain(DOMAIN_USER, DOMAIN_CLIENT);
 }
diff --git a/arch/arm/kernel/vmlinux.lds.S b/arch/arm/kernel/vmlinux.lds.S
index 43a31fb..98c467e 100644
--- a/arch/arm/kernel/vmlinux.lds.S
+++ b/arch/arm/kernel/vmlinux.lds.S
@@ -200,7 +200,7 @@ SECTIONS
 
 		/*
 		 * first, the init task union, aligned
-		 * to an 8192 byte boundary.
+		 * to an THREAD_SIZE byte boundary.
 		 */
 		INIT_TASK_DATA(THREAD_SIZE)
 
diff --git a/arch/arm/mach-exynos/mct.c b/arch/arm/mach-exynos/mct.c
index 85b5527..edc4b94 100644
--- a/arch/arm/mach-exynos/mct.c
+++ b/arch/arm/mach-exynos/mct.c
@@ -21,6 +21,7 @@
 #include <linux/percpu.h>
 
 #include <asm/hardware/gic.h>
+#include <asm/localtimer.h>
 
 #include <plat/cpu.h>
 
@@ -375,7 +376,7 @@ static struct irqaction mct_tick1_event_irq = {
 	.handler	= exynos4_mct_tick_isr,
 };
 
-static void exynos4_mct_tick_init(struct clock_event_device *evt)
+static int __cpuinit exynos4_local_timer_setup(struct clock_event_device *evt)
 {
 	struct mct_clock_event_device *mevt;
 	unsigned int cpu = smp_processor_id();
@@ -417,17 +418,11 @@ static void exynos4_mct_tick_init(struct clock_event_device *evt)
 	} else {
 		enable_percpu_irq(IRQ_MCT_LOCALTIMER, 0);
 	}
-}
-
-/* Setup the local clock events for a CPU */
-int __cpuinit local_timer_setup(struct clock_event_device *evt)
-{
-	exynos4_mct_tick_init(evt);
 
 	return 0;
 }
 
-void local_timer_stop(struct clock_event_device *evt)
+static void exynos4_local_timer_stop(struct clock_event_device *evt)
 {
 	unsigned int cpu = smp_processor_id();
 	evt->set_mode(CLOCK_EVT_MODE_UNUSED, evt);
@@ -439,6 +434,11 @@ void local_timer_stop(struct clock_event_device *evt)
 	else
 		disable_percpu_irq(IRQ_MCT_LOCALTIMER);
 }
+
+static struct local_timer_ops exynos4_mct_tick_ops __cpuinitdata = {
+	.setup	= exynos4_local_timer_setup,
+	.stop	= exynos4_local_timer_stop,
+};
 #endif /* CONFIG_LOCAL_TIMERS */
 
 static void __init exynos4_timer_resources(void)
@@ -458,6 +458,8 @@ static void __init exynos4_timer_resources(void)
 		WARN(err, "MCT: can't request IRQ %d (%d)\n",
 		     IRQ_MCT_LOCALTIMER, err);
 	}
+
+	local_timer_register(&exynos4_mct_tick_ops);
 #endif /* CONFIG_LOCAL_TIMERS */
 }
 
diff --git a/arch/arm/mach-highbank/Makefile b/arch/arm/mach-highbank/Makefile
index 986958a..f8437dd 100644
--- a/arch/arm/mach-highbank/Makefile
+++ b/arch/arm/mach-highbank/Makefile
@@ -1,6 +1,5 @@
 obj-y					:= clock.o highbank.o system.o
 obj-$(CONFIG_DEBUG_HIGHBANK_UART)	+= lluart.o
 obj-$(CONFIG_SMP)			+= platsmp.o
-obj-$(CONFIG_LOCAL_TIMERS)		+= localtimer.o
 obj-$(CONFIG_HOTPLUG_CPU)		+= hotplug.o
 obj-$(CONFIG_PM_SLEEP)			+= pm.o
diff --git a/arch/arm/mach-highbank/highbank.c b/arch/arm/mach-highbank/highbank.c
index 8394d51..bb1684f 100644
--- a/arch/arm/mach-highbank/highbank.c
+++ b/arch/arm/mach-highbank/highbank.c
@@ -27,6 +27,7 @@
 #include <asm/cacheflush.h>
 #include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
+#include <asm/smp_twd.h>
 #include <asm/hardware/arm_timer.h>
 #include <asm/hardware/timer-sp.h>
 #include <asm/hardware/gic.h>
@@ -111,6 +112,8 @@ static void __init highbank_timer_init(void)
 
 	sp804_clocksource_init(timer_base + 0x20, "timer1");
 	sp804_clockevents_init(timer_base, irq, "timer0");
+
+	twd_local_timer_of_register();
 }
 
 static struct sys_timer highbank_timer = {
diff --git a/arch/arm/mach-highbank/localtimer.c b/arch/arm/mach-highbank/localtimer.c
deleted file mode 100644
index 5a00e79..0000000
--- a/arch/arm/mach-highbank/localtimer.c
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright 2010-2011 Calxeda, Inc.
- * Based on localtimer.c, Copyright (C) 2002 ARM Ltd.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-#include <linux/init.h>
-#include <linux/clockchips.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/of_irq.h>
-
-#include <asm/smp_twd.h>
-
-/*
- * Setup the local clock events for a CPU.
- */
-int __cpuinit local_timer_setup(struct clock_event_device *evt)
-{
-	struct device_node *np;
-
-	np = of_find_compatible_node(NULL, NULL, "arm,smp-twd");
-	if (!twd_base) {
-		twd_base = of_iomap(np, 0);
-		WARN_ON(!twd_base);
-	}
-	evt->irq = irq_of_parse_and_map(np, 0);
-	twd_timer_setup(evt);
-	return 0;
-}
diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile
index 55db9c4..190d570 100644
--- a/arch/arm/mach-imx/Makefile
+++ b/arch/arm/mach-imx/Makefile
@@ -71,7 +71,6 @@ obj-$(CONFIG_CPU_V7) += head-v7.o
 AFLAGS_head-v7.o :=-Wa,-march=armv7-a
 obj-$(CONFIG_SMP) += platsmp.o
 obj-$(CONFIG_HOTPLUG_CPU) += hotplug.o
-obj-$(CONFIG_LOCAL_TIMERS) += localtimer.o
 obj-$(CONFIG_SOC_IMX6Q) += clock-imx6q.o mach-imx6q.o
 
 ifeq ($(CONFIG_PM),y)
diff --git a/arch/arm/mach-imx/localtimer.c b/arch/arm/mach-imx/localtimer.c
deleted file mode 100644
index 3a16351..0000000
--- a/arch/arm/mach-imx/localtimer.c
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright 2011 Freescale Semiconductor, Inc.
- * Copyright 2011 Linaro Ltd.
- *
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-#include <linux/init.h>
-#include <linux/clockchips.h>
-#include <linux/of_address.h>
-#include <linux/of_irq.h>
-#include <asm/smp_twd.h>
-
-/*
- * Setup the local clock events for a CPU.
- */
-int __cpuinit local_timer_setup(struct clock_event_device *evt)
-{
-	struct device_node *np;
-
-	np = of_find_compatible_node(NULL, NULL, "arm,smp-twd");
-	if (!twd_base) {
-		twd_base = of_iomap(np, 0);
-		WARN_ON(!twd_base);
-	}
-	evt->irq = irq_of_parse_and_map(np, 0);
-	twd_timer_setup(evt);
-
-	return 0;
-}
diff --git a/arch/arm/mach-imx/mach-imx6q.c b/arch/arm/mach-imx/mach-imx6q.c
index c257281..a2eea86 100644
--- a/arch/arm/mach-imx/mach-imx6q.c
+++ b/arch/arm/mach-imx/mach-imx6q.c
@@ -21,6 +21,7 @@
 #include <linux/of_platform.h>
 #include <linux/phy.h>
 #include <linux/micrel_phy.h>
+#include <asm/smp_twd.h>
 #include <asm/hardware/cache-l2x0.h>
 #include <asm/hardware/gic.h>
 #include <asm/mach/arch.h>
@@ -119,6 +120,7 @@ static void __init imx6q_init_irq(void)
 static void __init imx6q_timer_init(void)
 {
 	mx6q_clocks_init();
+	twd_local_timer_of_register();
 }
 
 static struct sys_timer imx6q_timer = {
diff --git a/arch/arm/mach-msm/timer.c b/arch/arm/mach-msm/timer.c
index 11d0d8f..75f4be4 100644
--- a/arch/arm/mach-msm/timer.c
+++ b/arch/arm/mach-msm/timer.c
@@ -127,6 +127,45 @@ static struct clocksource msm_clocksource = {
 	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
+#ifdef CONFIG_LOCAL_TIMERS
+static int __cpuinit msm_local_timer_setup(struct clock_event_device *evt)
+{
+	/* Use existing clock_event for cpu 0 */
+	if (!smp_processor_id())
+		return 0;
+
+	writel_relaxed(0, event_base + TIMER_ENABLE);
+	writel_relaxed(0, event_base + TIMER_CLEAR);
+	writel_relaxed(~0, event_base + TIMER_MATCH_VAL);
+	evt->irq = msm_clockevent.irq;
+	evt->name = "local_timer";
+	evt->features = msm_clockevent.features;
+	evt->rating = msm_clockevent.rating;
+	evt->set_mode = msm_timer_set_mode;
+	evt->set_next_event = msm_timer_set_next_event;
+	evt->shift = msm_clockevent.shift;
+	evt->mult = div_sc(GPT_HZ, NSEC_PER_SEC, evt->shift);
+	evt->max_delta_ns = clockevent_delta2ns(0xf0000000, evt);
+	evt->min_delta_ns = clockevent_delta2ns(4, evt);
+
+	*__this_cpu_ptr(msm_evt.percpu_evt) = evt;
+	clockevents_register_device(evt);
+	enable_percpu_irq(evt->irq, 0);
+	return 0;
+}
+
+static void msm_local_timer_stop(struct clock_event_device *evt)
+{
+	evt->set_mode(CLOCK_EVT_MODE_UNUSED, evt);
+	disable_percpu_irq(evt->irq);
+}
+
+static struct local_timer_ops msm_local_timer_ops __cpuinitdata = {
+	.setup	= msm_local_timer_setup,
+	.stop	= msm_local_timer_stop,
+};
+#endif /* CONFIG_LOCAL_TIMERS */
+
 static void __init msm_timer_init(void)
 {
 	struct clock_event_device *ce = &msm_clockevent;
@@ -173,8 +212,12 @@ static void __init msm_timer_init(void)
 		*__this_cpu_ptr(msm_evt.percpu_evt) = ce;
 		res = request_percpu_irq(ce->irq, msm_timer_interrupt,
 					 ce->name, msm_evt.percpu_evt);
-		if (!res)
+		if (!res) {
 			enable_percpu_irq(ce->irq, 0);
+#ifdef CONFIG_LOCAL_TIMERS
+			local_timer_register(&msm_local_timer_ops);
+#endif
+		}
 	} else {
 		msm_evt.evt = ce;
 		res = request_irq(ce->irq, msm_timer_interrupt,
@@ -191,40 +234,6 @@ err:
 		pr_err("clocksource_register failed\n");
 }
 
-#ifdef CONFIG_LOCAL_TIMERS
-int __cpuinit local_timer_setup(struct clock_event_device *evt)
-{
-	/* Use existing clock_event for cpu 0 */
-	if (!smp_processor_id())
-		return 0;
-
-	writel_relaxed(0, event_base + TIMER_ENABLE);
-	writel_relaxed(0, event_base + TIMER_CLEAR);
-	writel_relaxed(~0, event_base + TIMER_MATCH_VAL);
-	evt->irq = msm_clockevent.irq;
-	evt->name = "local_timer";
-	evt->features = msm_clockevent.features;
-	evt->rating = msm_clockevent.rating;
-	evt->set_mode = msm_timer_set_mode;
-	evt->set_next_event = msm_timer_set_next_event;
-	evt->shift = msm_clockevent.shift;
-	evt->mult = div_sc(GPT_HZ, NSEC_PER_SEC, evt->shift);
-	evt->max_delta_ns = clockevent_delta2ns(0xf0000000, evt);
-	evt->min_delta_ns = clockevent_delta2ns(4, evt);
-
-	*__this_cpu_ptr(msm_evt.percpu_evt) = evt;
-	clockevents_register_device(evt);
-	enable_percpu_irq(evt->irq, 0);
-	return 0;
-}
-
-void local_timer_stop(struct clock_event_device *evt)
-{
-	evt->set_mode(CLOCK_EVT_MODE_UNUSED, evt);
-	disable_percpu_irq(evt->irq);
-}
-#endif /* CONFIG_LOCAL_TIMERS */
-
 struct sys_timer msm_timer = {
 	.init = msm_timer_init
 };
diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index bd76394..05c2ffc 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -23,7 +23,6 @@ obj-$(CONFIG_TWL4030_CORE) += omap_twl.o
 
 # SMP support ONLY available for OMAP4
 obj-$(CONFIG_SMP)			+= omap-smp.o omap-headsmp.o
-obj-$(CONFIG_LOCAL_TIMERS)		+= timer-mpu.o
 obj-$(CONFIG_HOTPLUG_CPU)		+= omap-hotplug.o
 obj-$(CONFIG_ARCH_OMAP4)		+= omap4-common.o omap-wakeupgen.o \
 					   sleep44xx.o
diff --git a/arch/arm/mach-omap2/timer-mpu.c b/arch/arm/mach-omap2/timer-mpu.c
deleted file mode 100644
index 31c0ac4..0000000
--- a/arch/arm/mach-omap2/timer-mpu.c
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * The MPU local timer source file. In OMAP4, both cortex-a9 cores have
- * own timer in it's MPU domain. These timers will be driving the
- * linux kernel SMP tick framework when active. These timers are not
- * part of the wake up domain.
- *
- * Copyright (C) 2009 Texas Instruments, Inc.
- *
- * Author:
- *      Santosh Shilimkar <santosh.shilimkar@ti.com>
- *
- * This file is based on arm realview smp platform file.
- * Copyright (C) 2002 ARM Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#include <linux/init.h>
-#include <linux/smp.h>
-#include <linux/clockchips.h>
-#include <asm/irq.h>
-#include <asm/smp_twd.h>
-#include <asm/localtimer.h>
-
-/*
- * Setup the local clock events for a CPU.
- */
-int __cpuinit local_timer_setup(struct clock_event_device *evt)
-{
-	/* Local timers are not supprted on OMAP4430 ES1.0 */
-	if (omap_rev() == OMAP4430_REV_ES1_0)
-		return -ENXIO;
-
-	evt->irq = OMAP44XX_IRQ_LOCALTIMER;
-	twd_timer_setup(evt);
-	return 0;
-}
-
diff --git a/arch/arm/mach-omap2/timer.c b/arch/arm/mach-omap2/timer.c
index 5c9acea..c512bac 100644
--- a/arch/arm/mach-omap2/timer.c
+++ b/arch/arm/mach-omap2/timer.c
@@ -39,7 +39,7 @@
 
 #include <asm/mach/time.h>
 #include <plat/dmtimer.h>
-#include <asm/localtimer.h>
+#include <asm/smp_twd.h>
 #include <asm/sched_clock.h>
 #include "common.h"
 #include <plat/omap_hwmod.h>
@@ -324,14 +324,26 @@ OMAP_SYS_TIMER(3_secure)
 #endif
 
 #ifdef CONFIG_ARCH_OMAP4
-static void __init omap4_timer_init(void)
-{
 #ifdef CONFIG_LOCAL_TIMERS
-	twd_base = ioremap(OMAP44XX_LOCAL_TWD_BASE, SZ_256);
-	BUG_ON(!twd_base);
+static DEFINE_TWD_LOCAL_TIMER(twd_local_timer,
+			      OMAP44XX_LOCAL_TWD_BASE,
+			      OMAP44XX_IRQ_LOCALTIMER);
 #endif
+
+static void __init omap4_timer_init(void)
+{
 	omap2_gp_clockevent_init(1, OMAP4_CLKEV_SOURCE);
 	omap2_gp_clocksource_init(2, OMAP4_MPU_SOURCE);
+#ifdef CONFIG_LOCAL_TIMERS
+	/* Local timers are not supprted on OMAP4430 ES1.0 */
+	if (omap_rev() != OMAP4430_REV_ES1_0) {
+		int err;
+
+		err = twd_local_timer_register(&twd_local_timer);
+		if (err)
+			pr_err("twd_local_timer_register failed %d\n", err);
+	}
+#endif
 }
 OMAP_SYS_TIMER(4)
 #endif
diff --git a/arch/arm/mach-realview/hotplug.c b/arch/arm/mach-realview/hotplug.c
index eb55f05..111d8dd 100644
--- a/arch/arm/mach-realview/hotplug.c
+++ b/arch/arm/mach-realview/hotplug.c
@@ -98,7 +98,7 @@ int platform_cpu_kill(unsigned int cpu)
  *
  * Called with IRQs disabled
  */
-void platform_cpu_die(unsigned int cpu)
+void __cpuinit platform_cpu_die(unsigned int cpu)
 {
 	int spurious = 0;
 
diff --git a/arch/arm/mach-realview/include/mach/irqs-pb1176.h b/arch/arm/mach-realview/include/mach/irqs-pb1176.h
index 5c3c625..708f841 100644
--- a/arch/arm/mach-realview/include/mach/irqs-pb1176.h
+++ b/arch/arm/mach-realview/include/mach/irqs-pb1176.h
@@ -40,6 +40,7 @@
 #define IRQ_DC1176_L2CC		(IRQ_DC1176_GIC_START + 13)
 #define IRQ_DC1176_RTC		(IRQ_DC1176_GIC_START + 14)
 #define IRQ_DC1176_CLCD		(IRQ_DC1176_GIC_START + 15)	/* CLCD controller */
+#define IRQ_DC1176_GPIO0	(IRQ_DC1176_GIC_START + 16)
 #define IRQ_DC1176_SSP		(IRQ_DC1176_GIC_START + 17)	/* SSP port */
 #define IRQ_DC1176_UART0	(IRQ_DC1176_GIC_START + 18)	/* UART 0 on development chip */
 #define IRQ_DC1176_UART1	(IRQ_DC1176_GIC_START + 19)	/* UART 1 on development chip */
@@ -73,7 +74,6 @@
 #define IRQ_PB1176_DMAC		(IRQ_PB1176_GIC_START + 24)	/* DMA controller */
 #define IRQ_PB1176_RTC		(IRQ_PB1176_GIC_START + 25)	/* Real Time Clock */
 
-#define IRQ_PB1176_GPIO0	-1
 #define IRQ_PB1176_SCTL		-1
 
 #define NR_GIC_PB1176		2
diff --git a/arch/arm/mach-realview/realview_eb.c b/arch/arm/mach-realview/realview_eb.c
index 9578145..b9b5434 100644
--- a/arch/arm/mach-realview/realview_eb.c
+++ b/arch/arm/mach-realview/realview_eb.c
@@ -36,7 +36,7 @@
 #include <asm/pgtable.h>
 #include <asm/hardware/gic.h>
 #include <asm/hardware/cache-l2x0.h>
-#include <asm/localtimer.h>
+#include <asm/smp_twd.h>
 
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
@@ -383,6 +383,23 @@ static void realview_eb11mp_fixup(void)
 	realview_eb_isp1761_resources[1].end	= IRQ_EB11MP_USB;
 }
 
+#ifdef CONFIG_HAVE_ARM_TWD
+static DEFINE_TWD_LOCAL_TIMER(twd_local_timer,
+			      REALVIEW_EB11MP_TWD_BASE,
+			      IRQ_LOCALTIMER);
+
+static void __init realview_eb_twd_init(void)
+{
+	if (core_tile_eb11mp() || core_tile_a9mp()) {
+		int err = twd_local_timer_register(&twd_local_timer);
+		if (err)
+			pr_err("twd_local_timer_register failed %d\n", err);
+	}
+}
+#else
+#define realview_eb_twd_init()	do { } while(0)
+#endif
+
 static void __init realview_eb_timer_init(void)
 {
 	unsigned int timer_irq;
@@ -392,15 +409,13 @@ static void __init realview_eb_timer_init(void)
 	timer2_va_base = __io_address(REALVIEW_EB_TIMER2_3_BASE);
 	timer3_va_base = __io_address(REALVIEW_EB_TIMER2_3_BASE) + 0x20;
 
-	if (core_tile_eb11mp() || core_tile_a9mp()) {
-#ifdef CONFIG_LOCAL_TIMERS
-		twd_base = __io_address(REALVIEW_EB11MP_TWD_BASE);
-#endif
+	if (core_tile_eb11mp() || core_tile_a9mp())
 		timer_irq = IRQ_EB11MP_TIMER0_1;
-	} else
+	else
 		timer_irq = IRQ_EB_TIMER0_1;
 
 	realview_timer_init(timer_irq);
+	realview_eb_twd_init();
 }
 
 static struct sys_timer realview_eb_timer = {
@@ -422,6 +437,21 @@ static void realview_eb_restart(char mode, const char *cmd)
 	dsb();
 }
 
+#ifdef CONFIG_CACHE_L2X0
+static int __init realview_eb_l2x0_init(void)
+{
+	if (machine_is_realview_eb_mp())
+		/*
+		 * 1MB (128KB/way), 8-way associativity, evmon/parity/share
+		 * Bits:  .... ...0 0111 1001 0000 .... .... ....
+		 */
+		l2x0_init(__io_address(REALVIEW_EB11MP_L220_BASE),
+			  0x00790000, 0xfe000fff);
+	return 0;
+}
+early_initcall(realview_eb_l2x0_init);
+#endif
+
 static void __init realview_eb_init(void)
 {
 	int i;
@@ -429,11 +459,6 @@ static void __init realview_eb_init(void)
 	if (core_tile_eb11mp() || core_tile_a9mp()) {
 		realview_eb11mp_fixup();
 
-#ifdef CONFIG_CACHE_L2X0
-		/* 1MB (128KB/way), 8-way associativity, evmon/parity/share enabled
-		 * Bits:  .... ...0 0111 1001 0000 .... .... .... */
-		l2x0_init(__io_address(REALVIEW_EB11MP_L220_BASE), 0x00790000, 0xfe000fff);
-#endif
 		platform_device_register(&pmu_device);
 	}
 
@@ -467,4 +492,5 @@ MACHINE_START(REALVIEW_EB, "ARM-RealView EB")
 	.dma_zone_size	= SZ_256M,
 #endif
 	.restart	= realview_eb_restart,
+	.nr_irqs	= NR_IRQS_LEGACY,
 MACHINE_END
diff --git a/arch/arm/mach-realview/realview_pb1176.c b/arch/arm/mach-realview/realview_pb1176.c
index e4abe94..37ee4d2 100644
--- a/arch/arm/mach-realview/realview_pb1176.c
+++ b/arch/arm/mach-realview/realview_pb1176.c
@@ -143,7 +143,7 @@ static struct pl022_ssp_controller ssp0_plat_data = {
 #define PB1176_CLCD_IRQ	{ IRQ_DC1176_CLCD, NO_IRQ }
 #define SCTL_IRQ	{ NO_IRQ, NO_IRQ }
 #define PB1176_WATCHDOG_IRQ	{ IRQ_DC1176_WATCHDOG, NO_IRQ }
-#define PB1176_GPIO0_IRQ	{ IRQ_PB1176_GPIO0, NO_IRQ }
+#define PB1176_GPIO0_IRQ	{ IRQ_DC1176_GPIO0, NO_IRQ }
 #define GPIO1_IRQ	{ IRQ_PB1176_GPIO1, NO_IRQ }
 #define PB1176_RTC_IRQ	{ IRQ_DC1176_RTC, NO_IRQ }
 #define SCI_IRQ		{ IRQ_PB1176_SCI, NO_IRQ }
@@ -395,4 +395,5 @@ MACHINE_START(REALVIEW_PB1176, "ARM-RealView PB1176")
 	.dma_zone_size	= SZ_256M,
 #endif
 	.restart	= realview_pb1176_restart,
+	.nr_irqs	= NR_IRQS_LEGACY,
 MACHINE_END
diff --git a/arch/arm/mach-realview/realview_pb11mp.c b/arch/arm/mach-realview/realview_pb11mp.c
index 2147335..605fc17 100644
--- a/arch/arm/mach-realview/realview_pb11mp.c
+++ b/arch/arm/mach-realview/realview_pb11mp.c
@@ -36,7 +36,7 @@
 #include <asm/pgtable.h>
 #include <asm/hardware/gic.h>
 #include <asm/hardware/cache-l2x0.h>
-#include <asm/localtimer.h>
+#include <asm/smp_twd.h>
 
 #include <asm/mach/arch.h>
 #include <asm/mach/flash.h>
@@ -290,6 +290,21 @@ static void __init gic_init_irq(void)
 	gic_cascade_irq(1, IRQ_TC11MP_PB_IRQ1);
 }
 
+#ifdef CONFIG_HAVE_ARM_TWD
+static DEFINE_TWD_LOCAL_TIMER(twd_local_timer,
+			      REALVIEW_TC11MP_TWD_BASE,
+			      IRQ_LOCALTIMER);
+
+static void __init realview_pb11mp_twd_init(void)
+{
+	int err = twd_local_timer_register(&twd_local_timer);
+	if (err)
+		pr_err("twd_local_timer_register failed %d\n", err);
+}
+#else
+#define realview_pb11mp_twd_init()	do {} while(0)
+#endif
+
 static void __init realview_pb11mp_timer_init(void)
 {
 	timer0_va_base = __io_address(REALVIEW_PB11MP_TIMER0_1_BASE);
@@ -297,10 +312,8 @@ static void __init realview_pb11mp_timer_init(void)
 	timer2_va_base = __io_address(REALVIEW_PB11MP_TIMER2_3_BASE);
 	timer3_va_base = __io_address(REALVIEW_PB11MP_TIMER2_3_BASE) + 0x20;
 
-#ifdef CONFIG_LOCAL_TIMERS
-	twd_base = __io_address(REALVIEW_TC11MP_TWD_BASE);
-#endif
 	realview_timer_init(IRQ_TC11MP_TIMER0_1);
+	realview_pb11mp_twd_init();
 }
 
 static struct sys_timer realview_pb11mp_timer = {
@@ -317,21 +330,30 @@ static void realview_pb11mp_restart(char mode, const char *cmd)
 	 * in the system FPGA
 	 */
 	__raw_writel(REALVIEW_SYS_LOCK_VAL, lock_ctrl);
-	__raw_writel(0x0000, reset_ctrl);
 	__raw_writel(0x0004, reset_ctrl);
 	dsb();
 }
 
+#ifdef CONFIG_CACHE_L2X0
+static int __init realview_pb11mp_l2x0_init(void)
+{
+	if (machine_is_realview_pb11mp()) {
+		/*
+		 * 1MB (128KB/way), 8-way associativity, evmon/parity/share
+		 * Bits:  .... ...0 0111 1001 0000 .... .... ....
+		 */
+		l2x0_init(__io_address(REALVIEW_TC11MP_L220_BASE),
+			  0x00790000, 0xfe000fff);
+	}
+	return 0;
+}
+early_initcall(realview_pb11mp_l2x0_init);
+#endif
+
 static void __init realview_pb11mp_init(void)
 {
 	int i;
 
-#ifdef CONFIG_CACHE_L2X0
-	/* 1MB (128KB/way), 8-way associativity, evmon/parity/share enabled
-	 * Bits:  .... ...0 0111 1001 0000 .... .... .... */
-	l2x0_init(__io_address(REALVIEW_TC11MP_L220_BASE), 0x00790000, 0xfe000fff);
-#endif
-
 	realview_flash_register(realview_pb11mp_flash_resource,
 				ARRAY_SIZE(realview_pb11mp_flash_resource));
 	realview_eth_register(NULL, realview_pb11mp_smsc911x_resources);
@@ -364,4 +386,5 @@ MACHINE_START(REALVIEW_PB11MP, "ARM-RealView PB11MPCore")
 	.dma_zone_size	= SZ_256M,
 #endif
 	.restart	= realview_pb11mp_restart,
+	.nr_irqs	= NR_IRQS_LEGACY,
 MACHINE_END
diff --git a/arch/arm/mach-realview/realview_pba8.c b/arch/arm/mach-realview/realview_pba8.c
index 25b2e59..4713bcf 100644
--- a/arch/arm/mach-realview/realview_pba8.c
+++ b/arch/arm/mach-realview/realview_pba8.c
@@ -319,4 +319,5 @@ MACHINE_START(REALVIEW_PBA8, "ARM-RealView PB-A8")
 	.dma_zone_size	= SZ_256M,
 #endif
 	.restart	= realview_pba8_restart,
+	.nr_irqs	= NR_IRQS_LEGACY,
 MACHINE_END
diff --git a/arch/arm/mach-realview/realview_pbx.c b/arch/arm/mach-realview/realview_pbx.c
index ac71564..ea586ea 100644
--- a/arch/arm/mach-realview/realview_pbx.c
+++ b/arch/arm/mach-realview/realview_pbx.c
@@ -298,6 +298,21 @@ static void __init gic_init_irq(void)
 	}
 }
 
+#ifdef CONFIG_HAVE_ARM_TWD
+static DEFINE_TWD_LOCAL_TIMER(twd_local_timer,
+			      REALVIEW_PBX_TILE_TWD_BASE,
+			      IRQ_LOCALTIMER);
+
+static void __init realview_pbx_twd_init(void)
+{
+	int err = twd_local_timer_register(&twd_local_timer);
+	if (err)
+		pr_err("twd_local_timer_register failed %d\n", err);
+}
+#else
+#define realview_pbx_twd_init()	do { } while(0)
+#endif
+
 static void __init realview_pbx_timer_init(void)
 {
 	timer0_va_base = __io_address(REALVIEW_PBX_TIMER0_1_BASE);
@@ -305,11 +320,8 @@ static void __init realview_pbx_timer_init(void)
 	timer2_va_base = __io_address(REALVIEW_PBX_TIMER2_3_BASE);
 	timer3_va_base = __io_address(REALVIEW_PBX_TIMER2_3_BASE) + 0x20;
 
-#ifdef CONFIG_LOCAL_TIMERS
-	if (core_tile_pbx11mp() || core_tile_pbxa9mp())
-		twd_base = __io_address(REALVIEW_PBX_TILE_TWD_BASE);
-#endif
 	realview_timer_init(IRQ_PBX_TIMER0_1);
+	realview_pbx_twd_init();
 }
 
 static struct sys_timer realview_pbx_timer = {
@@ -351,12 +363,10 @@ static void realview_pbx_restart(char mode, const char *cmd)
 	dsb();
 }
 
-static void __init realview_pbx_init(void)
-{
-	int i;
-
 #ifdef CONFIG_CACHE_L2X0
-	if (core_tile_pbxa9mp()) {
+static int __init realview_pbx_l2x0_init(void)
+{
+	if (machine_is_realview_pbx() && core_tile_pbxa9mp()) {
 		void __iomem *l2x0_base =
 			__io_address(REALVIEW_PBX_TILE_L220_BASE);
 
@@ -367,10 +377,17 @@ static void __init realview_pbx_init(void)
 		/* 16KB way size, 8-way associativity, parity disabled
 		 * Bits:  .. 0 0 0 0 1 00 1 0 1 001 0 000 0 .... .... .... */
 		l2x0_init(l2x0_base, 0x02520000, 0xc0000fff);
-		platform_device_register(&pmu_device);
 	}
+
+	return 0;
+}
+early_initcall(realview_pbx_l2x0_init);
 #endif
 
+static void __init realview_pbx_init(void)
+{
+	int i;
+
 	realview_flash_register(realview_pbx_flash_resources,
 				ARRAY_SIZE(realview_pbx_flash_resources));
 	realview_eth_register(NULL, realview_pbx_smsc911x_resources);
@@ -378,6 +395,9 @@ static void __init realview_pbx_init(void)
 	platform_device_register(&realview_cf_device);
 	realview_usb_register(realview_pbx_isp1761_resources);
 
+	if (machine_is_realview_pbx() && core_tile_pbxa9mp())
+		platform_device_register(&pmu_device);
+
 	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
 		struct amba_device *d = amba_devs[i];
 		amba_device_register(d, &iomem_resource);
@@ -402,4 +422,5 @@ MACHINE_START(REALVIEW_PBX, "ARM-RealView PBX")
 	.dma_zone_size	= SZ_256M,
 #endif
 	.restart	= realview_pbx_restart,
+	.nr_irqs	= NR_IRQS_LEGACY,
 MACHINE_END
diff --git a/arch/arm/mach-shmobile/Makefile b/arch/arm/mach-shmobile/Makefile
index 7ad6954..e7c2590 100644
--- a/arch/arm/mach-shmobile/Makefile
+++ b/arch/arm/mach-shmobile/Makefile
@@ -16,7 +16,6 @@ obj-$(CONFIG_ARCH_R8A7779)	+= setup-r8a7779.o clock-r8a7779.o intc-r8a7779.o
 # SMP objects
 smp-y				:= platsmp.o headsmp.o
 smp-$(CONFIG_HOTPLUG_CPU)	+= hotplug.o
-smp-$(CONFIG_LOCAL_TIMERS)	+= localtimer.o
 smp-$(CONFIG_ARCH_SH73A0)	+= smp-sh73a0.o
 smp-$(CONFIG_ARCH_R8A7779)	+= smp-r8a7779.o
 
diff --git a/arch/arm/mach-shmobile/include/mach/common.h b/arch/arm/mach-shmobile/include/mach/common.h
index e4b945e..9fde3eb 100644
--- a/arch/arm/mach-shmobile/include/mach/common.h
+++ b/arch/arm/mach-shmobile/include/mach/common.h
@@ -2,6 +2,8 @@
 #define __ARCH_MACH_COMMON_H
 
 extern struct sys_timer shmobile_timer;
+struct twd_local_timer;
+void shmobile_twd_init(struct twd_local_timer *twd_local_timer);
 extern void shmobile_setup_console(void);
 extern void shmobile_secondary_vector(void);
 extern int shmobile_platform_cpu_kill(unsigned int cpu);
diff --git a/arch/arm/mach-shmobile/localtimer.c b/arch/arm/mach-shmobile/localtimer.c
deleted file mode 100644
index ad9ccc9..0000000
--- a/arch/arm/mach-shmobile/localtimer.c
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * SMP support for R-Mobile / SH-Mobile - local timer portion
- *
- * Copyright (C) 2010  Magnus Damm
- *
- * Based on vexpress, Copyright (C) 2002 ARM Ltd, All Rights Reserved
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#include <linux/init.h>
-#include <linux/smp.h>
-#include <linux/clockchips.h>
-#include <asm/smp_twd.h>
-#include <asm/localtimer.h>
-
-/*
- * Setup the local clock events for a CPU.
- */
-int __cpuinit local_timer_setup(struct clock_event_device *evt)
-{
-	evt->irq = 29;
-	twd_timer_setup(evt);
-	return 0;
-}
diff --git a/arch/arm/mach-shmobile/platsmp.c b/arch/arm/mach-shmobile/platsmp.c
index 9933812..45fa392 100644
--- a/arch/arm/mach-shmobile/platsmp.c
+++ b/arch/arm/mach-shmobile/platsmp.c
@@ -17,7 +17,6 @@
 #include <linux/smp.h>
 #include <linux/io.h>
 #include <asm/hardware/gic.h>
-#include <asm/localtimer.h>
 #include <asm/mach-types.h>
 #include <mach/common.h>
 
diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 4fe2e9e..9bb7b857 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -64,6 +64,8 @@ static void __iomem *scu_base_addr(void)
 static DEFINE_SPINLOCK(scu_lock);
 static unsigned long tmp;
 
+static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, 0xf0000600, 29);
+
 static void modify_scu_cpu_psr(unsigned long set, unsigned long clr)
 {
 	void __iomem *scu_base = scu_base_addr();
@@ -82,11 +84,7 @@ unsigned int __init r8a7779_get_core_count(void)
 {
 	void __iomem *scu_base = scu_base_addr();
 
-#ifdef CONFIG_HAVE_ARM_TWD
-	/* twd_base needs to be initialized before percpu_timer_setup() */
-	twd_base = (void __iomem *)0xf0000600;
-#endif
-
+	shmobile_twd_init(&twd_local_timer);
 	return scu_get_core_count(scu_base);
 }
 
diff --git a/arch/arm/mach-shmobile/smp-sh73a0.c b/arch/arm/mach-shmobile/smp-sh73a0.c
index 2d0d421..c0a9093 100644
--- a/arch/arm/mach-shmobile/smp-sh73a0.c
+++ b/arch/arm/mach-shmobile/smp-sh73a0.c
@@ -42,6 +42,8 @@ static void __iomem *scu_base_addr(void)
 static DEFINE_SPINLOCK(scu_lock);
 static unsigned long tmp;
 
+static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, 0xf0000600, 29);
+
 static void modify_scu_cpu_psr(unsigned long set, unsigned long clr)
 {
 	void __iomem *scu_base = scu_base_addr();
@@ -60,11 +62,7 @@ unsigned int __init sh73a0_get_core_count(void)
 {
 	void __iomem *scu_base = scu_base_addr();
 
-#ifdef CONFIG_HAVE_ARM_TWD
-	/* twd_base needs to be initialized before percpu_timer_setup() */
-	twd_base = (void __iomem *)0xf0000600;
-#endif
-
+	shmobile_twd_init(&twd_local_timer);
 	return scu_get_core_count(scu_base);
 }
 
diff --git a/arch/arm/mach-shmobile/timer.c b/arch/arm/mach-shmobile/timer.c
index 895794b..be16231 100644
--- a/arch/arm/mach-shmobile/timer.c
+++ b/arch/arm/mach-shmobile/timer.c
@@ -20,6 +20,7 @@
  */
 #include <linux/platform_device.h>
 #include <asm/mach/time.h>
+#include <asm/smp_twd.h>
 
 static void __init shmobile_late_time_init(void)
 {
@@ -41,6 +42,15 @@ static void __init shmobile_timer_init(void)
 	late_time_init = shmobile_late_time_init;
 }
 
+void __init shmobile_twd_init(struct twd_local_timer *twd_local_timer)
+{
+#ifdef CONFIG_HAVE_ARM_TWD
+	int err = twd_local_timer_register(twd_local_timer);
+	if (err)
+		pr_err("twd_local_timer_register failed %d\n", err);
+#endif
+}
+
 struct sys_timer shmobile_timer = {
 	.init		= shmobile_timer_init,
 };
diff --git a/arch/arm/mach-sun6i/Kconfig b/arch/arm/mach-sun6i/Kconfig
new file mode 100644
index 0000000..d99d16e
--- /dev/null
+++ b/arch/arm/mach-sun6i/Kconfig
@@ -0,0 +1,34 @@
+
+choice
+	prompt "Allwinner Platform Type"
+	depends on ARCH_SUN6I || ARCH_SUN7I
+	default AW_PLATFORM_EVB
+
+config AW_FPGA_V4_PLATFORM
+       bool "FPGAv4 board"
+       help
+         Support for Allwinner's FPGAv4 board
+
+config AW_FPGA_V7_PLATFORM
+       bool "FPGAv7 board"
+       help
+         Support for Allwinner's FPGAv4 board
+
+config AW_ASIC_EVB_PLATFORM
+       bool "EVB board"
+       help
+         Support for Allwinner's EVB board
+
+endchoice
+
+config SUNXI_SYSFS
+	bool "Allwinner SUNXI Sysfs"
+    depends on ARCH_SUN6I
+	help
+	  Support /sys/class/sunxi for kernel.
+
+config SUNXI_POWER_SCENE
+	bool "support scene change notify"
+    depends on SUNXI_SYSFS
+	help
+	  Support /sys/class/sunxi/power/scene for kernel.
diff --git a/arch/arm/mach-sun6i/Makefile b/arch/arm/mach-sun6i/Makefile
new file mode 100644
index 0000000..528a765
--- /dev/null
+++ b/arch/arm/mach-sun6i/Makefile
@@ -0,0 +1,26 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-y=core.o printk.o devices.o timer.o sunxi_dump_reg.o  chips.o
+obj-y += clock/
+obj-y += dma/
+obj-y += gpio/
+obj-y += ar100/
+obj-y += sys_config.o
+obj-$(CONFIG_CPU_FREQ) += cpu-freq/
+obj-$(CONFIG_DEVFREQ_DRAM_FREQ) += dram-freq/
+obj-$(CONFIG_PM) += pm/
+obj-$(CONFIG_NET) += rf/
+obj-$(CONFIG_SUNXI_SYSFS) += sysfs/
+obj-$(CONFIG_AW_TIME_DELAY)	+= delay.o
+ifeq ($(CONFIG_SMP),y)
+obj-y += platsmp.o headsmp.o
+obj-$(CONFIG_HOTPLUG_CPU)		+= hotplug.o
+
+
+ifeq ($(CONFIG_LOCAL_TIMERS),y)
+obj-y += localtimer.o
+endif
+
+endif
diff --git a/arch/arm/mach-sun6i/Makefile.boot b/arch/arm/mach-sun6i/Makefile.boot
new file mode 100644
index 0000000..449994d
--- /dev/null
+++ b/arch/arm/mach-sun6i/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y	+= 0x40008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00800000
diff --git a/arch/arm/mach-sun6i/ar100/Makefile b/arch/arm/mach-sun6i/ar100/Makefile
new file mode 100644
index 0000000..84cc70d
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-y=ar100.o ar100_dram.o
+obj-y += hwmsgbox/
+obj-y += hwspinlock/
+obj-y += interfaces/
+obj-y += message_manager/
+obj-y += binary/
diff --git a/arch/arm/mach-sun6i/ar100/ar100.c b/arch/arm/mach-sun6i/ar100/ar100.c
new file mode 100644
index 0000000..ca95ece
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/ar100.c
@@ -0,0 +1,342 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/ar100.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ar100_i.h"
+#include <mach/sys_config.h>
+
+/* local functions */
+static int     ar100_wait_ready(unsigned int timeout);
+
+/* external vars */
+extern char *ar100_binary_start;
+extern char *ar100_binary_end;
+
+unsigned long ar100_sram_a2_vbase = (unsigned long)IO_ADDRESS(AW_SRAM_A2_BASE);
+unsigned int ar100_debug_baudrate = 57600;
+unsigned int ar100_debug_dram_crc_en = 0;
+unsigned int ar100_debug_dram_crc_srcaddr = 0x40000000;
+unsigned int ar100_debug_dram_crc_len = (1024 * 1024);
+unsigned int ar100_debug_dram_crc_error = 0;
+unsigned int ar100_debug_dram_crc_total_count = 0;
+unsigned int ar100_debug_dram_crc_error_count = 0;
+unsigned int ar100_debug_level = 2;
+
+
+ssize_t ar100_debug_mask_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	ssize_t size = 0;
+
+	size = sprintf(buf, "%u\n", ar100_debug_level);
+
+	return size;
+}
+
+ssize_t ar100_debug_mask_store(struct class *class, struct class_attribute *attr,
+			const char *buf, size_t size)
+{
+	u32 value = 0;
+
+	sscanf(buf, "%u", &value);
+	if ((value < 0) || (value > 3)) {
+		AR100_WRN("invalid ar100 debug mask [%d] to set\n", value);
+		return size;
+	}
+
+	ar100_debug_level = value;
+	ar100_set_debug_level(ar100_debug_level);
+	AR100_LOG("debug_mask change to %d\n", ar100_debug_level);
+
+	return size;
+}
+
+ssize_t ar100_debug_baudrate_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	ssize_t size = 0;
+
+	size = sprintf(buf, "%u\n", ar100_debug_baudrate);
+
+	return size;
+}
+
+ssize_t ar100_debug_baudrate_store(struct class *class, struct class_attribute *attr,
+			const char *buf, size_t size)
+{
+	u32 value = 0;
+
+	sscanf(buf, "%u", &value);
+	if ((value != 57600) && (value != 9600)) {
+		AR100_WRN("invalid ar100 uart baudrate [%d] to set\n", value);
+		return size;
+	}
+
+	ar100_debug_baudrate = value;
+	ar100_set_uart_baudrate(ar100_debug_baudrate);
+	AR100_LOG("debug_baudrate change to %d\n", ar100_debug_baudrate);
+
+	return size;
+}
+
+ssize_t ar100_dram_crc_paras_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	ssize_t size = 0;
+
+	size = sprintf(buf, "enable:0x%x srcaddr:0x%x lenght:0x%x\n", ar100_debug_dram_crc_en,
+			                 ar100_debug_dram_crc_srcaddr, ar100_debug_dram_crc_len);
+
+	return size;
+}
+
+ssize_t ar100_dram_crc_paras_store(struct class *class, struct class_attribute *attr,
+			const char *buf, size_t size)
+{
+	u32 dram_crc_en      = 0;
+	u32 dram_crc_srcaddr = 0;
+	u32 dram_crc_len     = 0;
+
+	sscanf(buf, "%x %x %x\n", &dram_crc_en, &dram_crc_srcaddr, &dram_crc_len);
+
+	if (((dram_crc_en != 0) && (dram_crc_en != 1)) ||
+	    ((dram_crc_srcaddr < 0x40000000) || (dram_crc_srcaddr > 0xc0000000)) ||
+	    ((dram_crc_len < 0) || (dram_crc_len > (0x80000000)))) {
+		AR100_WRN("invalid ar100 debug dram crc paras [%x] [%x] [%x] to set\n",
+		                          dram_crc_en, dram_crc_srcaddr, dram_crc_len);
+
+		return size;
+	}
+
+	ar100_debug_dram_crc_en = dram_crc_en;
+	ar100_debug_dram_crc_srcaddr = dram_crc_srcaddr;
+	ar100_debug_dram_crc_len = dram_crc_len;
+	ar100_set_dram_crc_paras(ar100_debug_dram_crc_en,
+	                         ar100_debug_dram_crc_srcaddr,
+	                         ar100_debug_dram_crc_len);
+	AR100_LOG("dram_crc_en=0x%x, dram_crc_srcaddr=0x%x, dram_crc_len=0x%x\n",
+	          ar100_debug_dram_crc_en, ar100_debug_dram_crc_srcaddr, ar100_debug_dram_crc_len);
+
+	return size;
+}
+
+ssize_t ar100_dram_crc_result_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	ssize_t size = 0;
+
+	ar100_query_dram_crc_result((unsigned long *)&ar100_debug_dram_crc_error,
+							    (unsigned long *)&ar100_debug_dram_crc_total_count,
+							    (unsigned long *)&ar100_debug_dram_crc_error_count);
+	size = sprintf(buf, "error:%u total count:%u error count:%u\n", ar100_debug_dram_crc_error,
+							ar100_debug_dram_crc_total_count, ar100_debug_dram_crc_error_count);
+
+	return size;
+}
+
+ssize_t ar100_dram_crc_result_store(struct class *class, struct class_attribute *attr,
+			const char *buf, size_t size)
+{
+	u32 error = 0;
+	u32 total_count = 0;
+	u32 error_count = 0;
+
+	sscanf(buf, "%u %u %u", &error, &total_count, &error_count);
+	if (((error != 0) && (error != 1)) || (total_count < 0) || (error_count < 0)) {
+		AR100_WRN("invalid ar100 dram crc result [%d] [%d] [%d] to set\n", error, total_count, error_count);
+		return size;
+	}
+
+	ar100_debug_dram_crc_error = error;
+	ar100_debug_dram_crc_total_count = total_count;
+	ar100_debug_dram_crc_error_count = error_count;
+	ar100_set_dram_crc_result((unsigned long)ar100_debug_dram_crc_error,
+							  (unsigned long)ar100_debug_dram_crc_total_count,
+							  (unsigned long)ar100_debug_dram_crc_error_count);
+	AR100_LOG("debug_dram_crc_result change to error:%u total count:%u error count:%u\n",
+			ar100_debug_dram_crc_error, ar100_debug_dram_crc_total_count, ar100_debug_dram_crc_error_count);
+
+	return size;
+}
+
+
+static struct class_attribute ar100_class_attrs[] = {
+	__ATTR(debug_mask, 	    0644, ar100_debug_mask_show,      ar100_debug_mask_store),
+	__ATTR(debug_baudrate,	0644, ar100_debug_baudrate_show,  ar100_debug_baudrate_store),
+	__ATTR(dram_crc_paras,	0644, ar100_dram_crc_paras_show,  ar100_dram_crc_paras_store),
+	__ATTR(dram_crc_result,	0644, ar100_dram_crc_result_show, ar100_dram_crc_result_store),
+	__ATTR_NULL,
+};
+
+static struct class ar100_class = {
+	.name		 = "ar100",
+	.owner		 = THIS_MODULE,
+	.class_attrs = ar100_class_attrs,
+};
+
+int ar100_init(void)
+{
+	int binary_len;
+	int ret;
+	script_item_u script_val;
+	script_item_value_type_e type;
+
+	AR100_INF("ar100 initialize\n");
+
+	/*
+	 * request ar100 resources:
+	 * p2wi/uart gpio...
+	 */
+	sw_gpio_setcfg(GPIOL(0), 3);	/* p2wi sck */
+	sw_gpio_setcfg(GPIOL(1), 3);	/* p2wi sda */
+
+	type = script_get_item("cpus_config_paras", "cpus_uart_debug_used", &script_val);
+	if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
+		AR100_WRN("ar100 uart debug config type err!");
+		script_val.val = 1;
+	}
+	if (script_val.val) {
+		sw_gpio_setcfg(GPIOL(2), 2);	/* uart tx */
+		sw_gpio_setcfg(GPIOL(3), 2);	/* uart rx */
+	}
+	AR100_INF("ar100 uart debug config [%s] [%s] : %d\n", "cpus_config_paras", "cpus_uart_debug_used", script_val.val);
+
+	AR100_INF("sram_a2 vaddr(%x)\n", (unsigned int)ar100_sram_a2_vbase);
+
+	/* clear sram_a2 area */
+	memset((void *)ar100_sram_a2_vbase, 0, AW_SRAM_A2_SIZE);
+
+	/* load ar100 system binary data to sram_a2 */
+	binary_len = (int)(&ar100_binary_end) - (int)(&ar100_binary_start);
+	memcpy((void *)ar100_sram_a2_vbase, (void *)(&ar100_binary_start), binary_len);
+	AR100_INF("move ar100 binary data [addr = %x, len = %x] to sram_a2 finished\n",
+	         (unsigned int)(&ar100_binary_start), (unsigned int)binary_len);
+
+	/* initialize hwspinlock */
+	AR100_INF("hwspinlock initialize\n");
+	ar100_hwspinlock_init();
+
+	/* initialize hwmsgbox */
+	AR100_INF("hwmsgbox initialize\n");
+	ar100_hwmsgbox_init();
+
+	/* initialize message manager */
+	AR100_INF("message manager initialize\n");
+	ar100_message_manager_init();
+
+	/* set ar100 cpu reset to de-assert state */
+	AR100_INF("set ar100 reset to de-assert state\n");
+	{
+		volatile unsigned long value;
+		value = readl((IO_ADDRESS(AW_R_CPUCFG_BASE) + 0x0));
+		value |= 1;
+		writel(value, (IO_ADDRESS(AW_R_CPUCFG_BASE) + 0x0));
+	}
+
+	/* wait ar100 ready */
+	AR100_INF("wait ar100 ready....\n");
+	if (ar100_wait_ready(10000)) {
+		AR100_LOG("ar100 startup failed\n");
+	}
+
+	/* enable ar100 asyn tx interrupt */
+	ar100_hwmsgbox_enable_receiver_int(AR100_HWMSGBOX_AR100_ASYN_TX_CH, AW_HWMSG_QUEUE_USER_AC327);
+
+	/* enable ar100 syn tx interrupt */
+	ar100_hwmsgbox_enable_receiver_int(AR100_HWMSGBOX_AR100_SYN_TX_CH, AW_HWMSG_QUEUE_USER_AC327);
+
+	/* config dvfs v-f table */
+	if (ar100_dvfs_cfg_vf_table()) {
+		AR100_WRN("config dvfs v-f table failed\n");
+	}
+
+	/* config dram config paras */
+	if (ar100_config_dram_paras()) {
+		AR100_WRN("config dram paras failed\n");
+	}
+
+	/* register ar100 debug device node */
+	ret = class_register(&ar100_class);
+	if (ret) {
+		AR100_WRN("register ar100 class failed\n");
+	}
+
+	/* ar100 initialize succeeded */
+	AR100_INF("ar100 startup succeeded, driver version : %d\n", AR100_VERSIONS);
+
+	return 0;
+}
+subsys_initcall(ar100_init);
+
+static int ar100_wait_ready(unsigned int timeout)
+{
+	unsigned long          expire;
+
+	expire = msecs_to_jiffies(timeout) + jiffies;
+
+	/* wait ar100 startup ready */
+	while (1) {
+		/*
+		 * linux cpu interrupt is disable now,
+		 * we should query message by hand.
+		 */
+		struct ar100_message *pmessage = ar100_hwmsgbox_query_message();
+		if (pmessage == NULL) {
+			if (time_is_before_eq_jiffies(expire)) {
+				return -ETIMEDOUT;
+			}
+			/* try to query again */
+			continue;
+		}
+		/* query valid message */
+		if (pmessage->type == AR100_STARTUP_NOTIFY) {
+			/* check ar100 software and driver version match or not */
+			if (pmessage->paras[0] != AR100_VERSIONS) {
+				AR100_ERR("ar100 firmware and driver version not matched\n");
+				return -EINVAL;
+			}
+			/* received ar100 startup ready message */
+			AR100_INF("ar100 startup ready\n");
+			if ((pmessage->attr & AR100_MESSAGE_ATTR_SOFTSYN) ||
+				(pmessage->attr & AR100_MESSAGE_ATTR_HARDSYN)) {
+				/* synchronous message, just feedback it */
+				AR100_INF("ar100 startup notify message feedback\n");
+				ar100_hwmsgbox_feedback_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+			} else {
+				/* asyn message, free message directly */
+				AR100_INF("ar100 startup notify message free directly\n");
+				ar100_message_free(pmessage);
+			}
+			break;
+		}
+		/*
+		 * invalid message detected, ignore it.
+		 * by sunny at 2012-7-6 18:34:38.
+		 */
+		AR100_WRN("ar100 startup waiting ignore message\n");
+		if ((pmessage->attr & AR100_MESSAGE_ATTR_SOFTSYN) ||
+			(pmessage->attr & AR100_MESSAGE_ATTR_HARDSYN)) {
+			/* synchronous message, just feedback it */
+			ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+		} else {
+			/* asyn message, free message directly */
+			ar100_message_free(pmessage);
+		}
+		/* we need waiting continue */
+	}
+
+	return 0;
+}
diff --git a/arch/arm/mach-sun6i/ar100/ar100_dram.c b/arch/arm/mach-sun6i/ar100/ar100_dram.c
new file mode 100644
index 0000000..41720f0
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/ar100_dram.c
@@ -0,0 +1,298 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/ar100_dram.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ar100_i.h"
+#include <mach/sys_config.h>
+#include <asm/cacheflush.h>
+
+typedef struct __DRAM_PARA
+{
+	//normal configuration
+	unsigned int        dram_clk;
+	unsigned int        dram_type; //dram_type DDR2: 2 DDR3: 3 LPDDR2: 6 DDR3L: 31
+    unsigned int        dram_zq;
+    unsigned int		dram_odt_en;
+
+	//control configuration
+	unsigned int		dram_para1;
+    unsigned int		dram_para2;
+
+	//timing configuration
+	unsigned int		dram_mr0;
+    unsigned int		dram_mr1;
+    unsigned int		dram_mr2;
+    unsigned int		dram_mr3;
+    unsigned int		dram_tpr0;
+    unsigned int		dram_tpr1;
+    unsigned int		dram_tpr2;
+    unsigned int		dram_tpr3;
+    unsigned int		dram_tpr4;
+    unsigned int		dram_tpr5;
+	unsigned int		dram_tpr6;
+
+    //reserved for future use
+    unsigned int		dram_tpr7;
+    unsigned int		dram_tpr8;
+    unsigned int		dram_tpr9;
+    unsigned int		dram_tpr10;
+    unsigned int		dram_tpr11;
+    unsigned int		dram_tpr12;
+    unsigned int		dram_tpr13;
+
+}__dram_para_t;
+
+__dram_para_t ar100_dram_paras;
+
+int ar100_get_dram_cfg(void)
+{
+	script_item_u val;
+	script_item_value_type_e type;
+
+	type = script_get_item("dram_para", "dram_clk", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_clk is %#x\n", val.val);
+	ar100_dram_paras.dram_clk = val.val;
+
+	type = script_get_item("dram_para", "dram_type", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_type is %#x\n", val.val);
+	ar100_dram_paras.dram_type = val.val;
+
+	type = script_get_item("dram_para", "dram_zq", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_zq is %#x\n", val.val);
+	ar100_dram_paras.dram_zq = val.val;
+
+	type = script_get_item("dram_para", "dram_odt_en", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_odt_en is %#x\n", val.val);
+	ar100_dram_paras.dram_odt_en = val.val;
+
+	type = script_get_item("dram_para", "dram_para1", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_para1 is %#x\n", val.val);
+	ar100_dram_paras.dram_para1 = val.val;
+
+	type = script_get_item("dram_para", "dram_para2", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_para2 is %#x\n", val.val);
+	ar100_dram_paras.dram_para2 = val.val;
+
+	type = script_get_item("dram_para", "dram_mr0", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_mr0 is %#x\n", val.val);
+	ar100_dram_paras.dram_mr0 = val.val;
+
+	type = script_get_item("dram_para", "dram_mr1", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_mr1 is %#x\n", val.val);
+	ar100_dram_paras.dram_mr1 = val.val;
+
+	type = script_get_item("dram_para", "dram_mr2", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_mr2 is %#x\n", val.val);
+	ar100_dram_paras.dram_mr2 = val.val;
+
+	type = script_get_item("dram_para", "dram_mr3", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_mr3 is %#x\n", val.val);
+	ar100_dram_paras.dram_mr3 = val.val;
+
+	type = script_get_item("dram_para", "dram_tpr0", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_tpr0 is %#x\n", val.val);
+	ar100_dram_paras.dram_tpr0 = val.val;
+
+	type = script_get_item("dram_para", "dram_tpr1", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_tpr1 is %#x\n", val.val);
+	ar100_dram_paras.dram_tpr1 = val.val;
+
+	type = script_get_item("dram_para", "dram_tpr2", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_tpr2 is %#x\n", val.val);
+	ar100_dram_paras.dram_tpr2 = val.val;
+
+	type = script_get_item("dram_para", "dram_tpr3", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_tpr3 is %#x\n", val.val);
+	ar100_dram_paras.dram_tpr3 = val.val;
+
+	type = script_get_item("dram_para", "dram_tpr4", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_tpr4 is %#x\n", val.val);
+	ar100_dram_paras.dram_tpr4 = val.val;
+
+	type = script_get_item("dram_para", "dram_tpr5", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_tpr5 is %#x\n", val.val);
+	ar100_dram_paras.dram_tpr5 = val.val;
+
+	type = script_get_item("dram_para", "dram_tpr6", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_tpr6 is %#x\n", val.val);
+	ar100_dram_paras.dram_tpr6 = val.val;
+
+	type = script_get_item("dram_para", "dram_tpr7", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_tpr7 is %#x\n", val.val);
+	ar100_dram_paras.dram_tpr7 = val.val;
+
+	type = script_get_item("dram_para", "dram_tpr8", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_tpr8 is %#x\n", val.val);
+	ar100_dram_paras.dram_tpr8 = val.val;
+
+	type = script_get_item("dram_para", "dram_tpr9", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_tpr9 is %#x\n", val.val);
+	ar100_dram_paras.dram_tpr9 = val.val;
+
+	type = script_get_item("dram_para", "dram_tpr10", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_tpr10 is %#x\n", val.val);
+	ar100_dram_paras.dram_tpr10 = val.val;
+
+	type = script_get_item("dram_para", "dram_tpr11", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_tpr11 is %#x\n", val.val);
+	ar100_dram_paras.dram_tpr11 = val.val;
+
+	type = script_get_item("dram_para", "dram_tpr12", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_tpr12 is %#x\n", val.val);
+	ar100_dram_paras.dram_tpr12 = val.val;
+
+	type = script_get_item("dram_para", "dram_tpr13", &val);
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != type)
+	{
+		AR100_ERR("dram para type err %d!", __LINE__);
+	}
+	AR100_INF("dram_tpr13 is %#x\n", val.val);
+	ar100_dram_paras.dram_tpr13 = val.val;
+
+	return 0;
+}
+
+int ar100_config_dram_paras(void)
+{
+	struct ar100_message *pmessage;
+	u32 *dram_para;
+	u32 index;
+
+	/* parse dram config paras */
+	ar100_get_dram_cfg();
+
+	/* update dram config paras to ar100 system */
+	pmessage = ar100_message_allocate(0);
+	if (pmessage == NULL) {
+		AR100_WRN("allocate message failed\n");
+		return -ENOMEM;
+	}
+	dram_para = (u32 *)(&ar100_dram_paras);
+	for (index = 0; index < (sizeof(ar100_dram_paras) / 4); index++) {
+		/* initialize message */
+		pmessage->type       = AR100_SET_DRAM_PARAS;
+		pmessage->attr       = AR100_MESSAGE_ATTR_HARDSYN;
+		pmessage->paras[0]   = index;
+		pmessage->paras[1]   = 1;
+		pmessage->paras[2]   = dram_para[index];
+		pmessage->state      = AR100_MESSAGE_INITIALIZED;
+		pmessage->cb.handler = NULL;
+		pmessage->cb.arg     = NULL;
+
+		/* send message */
+		ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+	}
+	/* free message */
+	ar100_message_free(pmessage);
+
+	return 0;
+}
diff --git a/arch/arm/mach-sun6i/ar100/ar100_i.h b/arch/arm/mach-sun6i/ar100/ar100_i.h
new file mode 100644
index 0000000..fe1592c
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/ar100_i.h
@@ -0,0 +1,37 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/ar100_i.h
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__AR100_I_H__
+#define	__AR100_I_H__
+
+#include "./include/ar100_includes.h"
+#include <mach/ar100.h>
+//add by superm
+#include <linux/sysfs.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+
+
+//local functions
+extern int ar100_config_dram_paras(void);
+
+#endif	//__AR100_I_H__
diff --git a/arch/arm/mach-sun6i/ar100/binary/Makefile b/arch/arm/mach-sun6i/ar100/binary/Makefile
new file mode 100644
index 0000000..45ac7cf
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/binary/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the linux kernel.
+#
+$(obj)/ar100_binary.o: $(obj)/ar100.code
+
+obj-y=ar100_binary.o
diff --git a/arch/arm/mach-sun6i/ar100/binary/ar100.code b/arch/arm/mach-sun6i/ar100/binary/ar100.code
new file mode 100644
index 0000000..47344a0
Binary files /dev/null and b/arch/arm/mach-sun6i/ar100/binary/ar100.code differ
diff --git a/arch/arm/mach-sun6i/ar100/binary/ar100_binary.S b/arch/arm/mach-sun6i/ar100/binary/ar100_binary.S
new file mode 100644
index 0000000..d933c6f
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/binary/ar100_binary.S
@@ -0,0 +1,6 @@
+	.globl	ar100_binary_start
+	.globl	ar100_binary_end
+ar100_binary_start:
+	.incbin	"arch/arm/mach-sun6i/ar100/binary/ar100.code"
+ar100_binary_end:
+	.align	2
diff --git a/arch/arm/mach-sun6i/ar100/hwmsgbox/Makefile b/arch/arm/mach-sun6i/ar100/hwmsgbox/Makefile
new file mode 100644
index 0000000..b73b16c
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/hwmsgbox/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-y=hwmsgbox.o
diff --git a/arch/arm/mach-sun6i/ar100/hwmsgbox/hwmsgbox.c b/arch/arm/mach-sun6i/ar100/hwmsgbox/hwmsgbox.c
new file mode 100644
index 0000000..545ce1e
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/hwmsgbox/hwmsgbox.c
@@ -0,0 +1,463 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/hwmsgbox/hwmsgbox.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "hwmsgbox_i.h"
+
+/* spinlock for syn and asyn channel */
+static spinlock_t syn_channel_lock;
+static spinlock_t asyn_channel_lock;
+
+
+/**
+ * initialize hwmsgbox.
+ * @para:  none.
+ *
+ * returns:  0 if initialize hwmsgbox succeeded, others if failed.
+ */
+int ar100_hwmsgbox_init(void)
+{
+	int ret;
+
+	/* register msgbox interrupt */
+	ret = request_irq(AW_IRQ_MBOX, ar100_hwmsgbox_int_handler,
+			IRQF_DISABLED, "ar100_hwmsgbox_irq", NULL);
+	if (ret) {
+		AR100_ERR("request_irq error, return %d\n", ret);
+		return ret;
+	}
+
+	/* initialize syn and asyn spinlock */
+	spin_lock_init(&(syn_channel_lock));
+	spin_lock_init(&(asyn_channel_lock));
+
+	return 0;
+}
+
+/**
+ * exit hwmsgbox.
+ * @para:  none.
+ *
+ * returns:  0 if exit hwmsgbox succeeded, others if failed.
+ */
+int ar100_hwmsgbox_exit(void)
+{
+	return 0;
+}
+
+/**
+ * send one message to another processor by hwmsgbox.
+ * @pmessage:  the pointer of sended message frame.
+ * @timeout:   the wait time limit when message fifo is full,							  it is valid only when parameter mode = HWMSG_SEND_WAIT_TIMEOUT.
+ *
+ * returns:   0 if send message succeeded, other if failed.
+ */
+int ar100_hwmsgbox_send_message(struct ar100_message *pmessage, unsigned int timeout)
+{
+	volatile unsigned long value;
+	unsigned long          expire;
+
+	expire = msecs_to_jiffies(timeout) + jiffies;
+
+	if (pmessage == NULL) {
+		return -EINVAL;
+	}
+	if (pmessage->attr & AR100_MESSAGE_ATTR_HARDSYN) {
+		/* use ac327 hwsyn transmit channel */
+		spin_lock(&syn_channel_lock);
+		while (readl(IO_ADDRESS(AW_MSGBOX_FIFO_STATUS_REG(AR100_HWMSGBOX_AC327_SYN_TX_CH))) == 1) {
+			/* message-queue fifo is full */
+			if (time_is_before_eq_jiffies(expire)) {
+				AR100_ERR("hw message queue fifo full timeout\n");
+				spin_unlock(&syn_channel_lock);
+				return -ETIMEDOUT;
+			}
+		}
+		value = ((volatile unsigned long)pmessage) - ar100_sram_a2_vbase;
+		AR100_INF("ac327 send hard syn message : %x\n", (unsigned int)value);
+		writel(value, IO_ADDRESS(AW_MSGBOX_MSG_REG(AR100_HWMSGBOX_AC327_SYN_TX_CH)));
+
+		/* hwsyn messsage must feedback use syn rx channel */
+		while (readl(IO_ADDRESS(AW_MSGBOX_MSG_STATUS_REG(AR100_HWMSGBOX_AC327_SYN_RX_CH))) == 0) {
+			if (time_is_before_eq_jiffies(expire)) {
+				AR100_ERR("wait hard syn message time out\n");
+				spin_unlock(&syn_channel_lock);
+				return -ETIMEDOUT;
+			}
+		}
+		/* check message valid */
+		if (value != (readl(IO_ADDRESS(AW_MSGBOX_MSG_REG(AR100_HWMSGBOX_AC327_SYN_RX_CH))))) {
+			AR100_ERR("hard syn message error [%x, %x]\n", (u32)value, (u32)(readl(IO_ADDRESS(AW_MSGBOX_MSG_REG(AR100_HWMSGBOX_AC327_SYN_RX_CH)))));
+			spin_unlock(&syn_channel_lock);
+			return -EINVAL;
+		}
+		AR100_INF("ac327 hard syn message [%x, %x] feedback\n", (unsigned int)value, (unsigned int)pmessage->type);
+		/* if error call the callback function. by superm */
+		if(pmessage->result != 0) {
+			if (pmessage->cb.handler == NULL) {
+				AR100_WRN("callback not install\n");
+			} else {
+				/* call callback function */
+				AR100_WRN("call the callback function\n");
+				(*(pmessage->cb.handler))(pmessage->cb.arg);
+			}
+		}
+		spin_unlock(&syn_channel_lock);
+		return 0;
+	}
+
+	/* use ac327 asyn transmit channel */
+	spin_lock(&asyn_channel_lock);
+	while (readl(IO_ADDRESS(AW_MSGBOX_FIFO_STATUS_REG(AR100_HWMSGBOX_AR100_ASYN_RX_CH))) == 1) {
+		/* message-queue fifo is full */
+		if (time_is_before_eq_jiffies(expire)) {
+			AR100_ERR("wait asyn message time out\n");
+			spin_unlock(&asyn_channel_lock);
+			return -ETIMEDOUT;
+		}
+	}
+	/* write message to message-queue fifo */
+	value = ((volatile unsigned long)pmessage) - ar100_sram_a2_vbase;
+	AR100_INF("ac327 send message : %x\n", (unsigned int)value);
+	writel(value, IO_ADDRESS(AW_MSGBOX_MSG_REG(AR100_HWMSGBOX_AR100_ASYN_RX_CH)));
+
+	spin_unlock(&asyn_channel_lock);
+
+	/* syn messsage must wait message feedback */
+	if (pmessage->attr & AR100_MESSAGE_ATTR_SOFTSYN) {
+		ar100_hwmsgbox_wait_message_feedback(pmessage);
+	}
+	return 0;
+}
+
+int ar100_hwmsgbox_feedback_message(struct ar100_message *pmessage, unsigned int timeout)
+{
+	volatile unsigned long value;
+	unsigned long          expire;
+
+	expire = msecs_to_jiffies(timeout) + jiffies;
+
+	if (pmessage->attr & AR100_MESSAGE_ATTR_HARDSYN) {
+		/* use ac327 hard syn receiver channel */
+		spin_lock(&syn_channel_lock);
+		while (readl(IO_ADDRESS(AW_MSGBOX_FIFO_STATUS_REG(AR100_HWMSGBOX_AR100_SYN_RX_CH))) == 1) {
+			/* message-queue fifo is full */
+			if (time_is_before_eq_jiffies(expire)) {
+				AR100_ERR("wait syn message-queue fifo full timeout\n");
+				return -ETIMEDOUT;
+			}
+		}
+		value = ((volatile unsigned long)pmessage) - ar100_sram_a2_vbase;
+		AR100_INF("ar100 feedback hard syn message : %x\n", (unsigned int)value);
+		writel(value, IO_ADDRESS(AW_MSGBOX_MSG_REG(AR100_HWMSGBOX_AR100_SYN_RX_CH)));
+		spin_unlock(&syn_channel_lock);
+		return 0;
+	}
+	/* soft syn use asyn tx channel */
+	if (pmessage->attr & AR100_MESSAGE_ATTR_SOFTSYN) {
+		spin_lock(&asyn_channel_lock);
+		while (readl(IO_ADDRESS(AW_MSGBOX_FIFO_STATUS_REG(AR100_HWMSGBOX_AR100_ASYN_RX_CH))) == 1) {
+			/* fifo is full */
+			if (time_is_before_eq_jiffies(expire)) {
+				AR100_ERR("wait asyn message-queue fifo full timeout\n");
+				return -ETIMEDOUT;
+			}
+		}
+		/* write message to message-queue fifo */
+		value = ((volatile unsigned long)pmessage) - ar100_sram_a2_vbase;
+		AR100_INF("ar100 send asyn or soft syn message : %x\n", (unsigned int)value);
+		writel(value, IO_ADDRESS(AW_MSGBOX_MSG_REG(AR100_HWMSGBOX_AR100_ASYN_RX_CH)));
+		spin_unlock(&asyn_channel_lock);
+		return 0;
+	}
+
+	/* invalid syn message */
+	return -EINVAL;
+}
+
+/**
+ * enbale the receiver interrupt of message-queue.
+ * @queue:  the number of message-queue which we want to enable interrupt.
+ * @user:   the user which we want to enable interrupt.
+ *
+ * returns:  0 if enable interrupt succeeded, others if failed.
+ */
+int ar100_hwmsgbox_enable_receiver_int(int queue, int user)
+{
+	volatile unsigned int value;
+
+	value  =  readl(IO_ADDRESS(AW_MSGBOX_IRQ_EN_REG(user)));
+	value &= ~(0x1 << (queue * 2));
+	value |=  (0x1 << (queue * 2));
+	writel(value, IO_ADDRESS(AW_MSGBOX_IRQ_EN_REG(user)));
+
+	return 0;
+}
+
+/**
+ * disbale the receiver interrupt of message-queue.
+ * @queue:  the number of message-queue which we want to enable interrupt.
+ * @user:   the user which we want to enable interrupt.
+ *
+ * returns:  0 if disable interrupt succeeded, others if failed.
+ */
+int ar100_hwmsgbox_disable_receiver_int(int queue, int user)
+{
+	volatile unsigned int value;
+
+	value  =  readl(IO_ADDRESS(AW_MSGBOX_IRQ_EN_REG(user)));
+	value &= ~(0x1 << (queue * 2));
+	writel(value, IO_ADDRESS(AW_MSGBOX_IRQ_EN_REG(user)));
+
+	return 0;
+}
+
+/**
+ * query the receiver interrupt pending of message-queue.
+ * @queue:  the number of message-queue which we want to query.
+ * @user:   the user which we want to query.
+ *
+ * returns:  0 if query pending succeeded, others if failed.
+ */
+int ar100_hwmsgbox_query_receiver_pending(int queue, int user)
+{
+	volatile unsigned long value;
+
+	value  =  readl(IO_ADDRESS((AW_MSGBOX_IRQ_STATUS_REG(user))));
+
+	return value & (0x1 << (queue * 2));
+}
+
+/**
+ * clear the receiver interrupt pending of message-queue.
+ * @queue:  the number of message-queue which we want to clear.
+ * @user:   the user which we want to clear.
+ *
+ * returns:  0 if clear pending succeeded, others if failed.
+ */
+int ar100_hwmsgbox_clear_receiver_pending(int queue, int user)
+{
+	writel((0x1 << (queue * 2)), IO_ADDRESS(AW_MSGBOX_IRQ_STATUS_REG(user)));
+
+	return 0;
+}
+
+/**
+ * the interrupt handler for message-queue 1 receiver.
+ * @parg: the argument of this handler.
+ *
+ * returns:  TRUE if handle interrupt succeeded, others if failed.
+ */
+irqreturn_t ar100_hwmsgbox_int_handler(int irq, void *dev)
+{
+	AR100_INF("ac327 msgbox interrupt handler...\n");
+
+	/* process ac327 asyn received channel, process all received messages */
+	while (readl(IO_ADDRESS(AW_MSGBOX_MSG_STATUS_REG(AR100_HWMSGBOX_AR100_ASYN_TX_CH)))) {
+		volatile unsigned long value;
+		struct ar100_message *pmessage;
+		value = readl(IO_ADDRESS(AW_MSGBOX_MSG_REG(AR100_HWMSGBOX_AR100_ASYN_TX_CH))) + ar100_sram_a2_vbase;
+		pmessage = (struct ar100_message *)value;
+		if (ar100_message_valid(pmessage)) {
+			/* message state switch */
+			if (pmessage->state == AR100_MESSAGE_PROCESSED) {
+				/* if error call the callback function. by superm */
+				if (pmessage->result != 0) {
+					if (pmessage->cb.handler == NULL) {
+						AR100_WRN("message [%x] error, callback not install\n",
+								  (unsigned int)pmessage->type);
+					} else {
+						/* call callback function */
+						AR100_WRN("messgae [%x] error, call message callback function\n",
+								  (unsigned int)pmessage->type);
+						(*(pmessage->cb.handler))(pmessage->cb.arg);
+					}
+				}
+				/*
+				 * AR100_MESSAGE_PROCESSED->AR100_MESSAGE_FEEDBACKED,
+				 * process feedback message
+				 */
+				pmessage->state = AR100_MESSAGE_FEEDBACKED;
+				if (pmessage->attr & AR100_MESSAGE_ATTR_SOFTSYN)
+					ar100_hwmsgbox_message_feedback(pmessage);
+				else if (pmessage->attr == 0)
+					ar100_message_free(pmessage);
+			} else {
+				/*
+				 * AR100_MESSAGE_INITIALIZED->AR100_MESSAGE_RECEIVED,
+				 * notify new message coming.
+				 */
+				pmessage->state = AR100_MESSAGE_RECEIVED;
+				ar100_message_coming_notify(pmessage);
+			}
+		} else {
+			AR100_ERR("invalid message received: pmessage = 0x%x. \n", (__u32)pmessage);
+		}
+	}
+	/* clear pending */
+	ar100_hwmsgbox_clear_receiver_pending(AR100_HWMSGBOX_AR100_ASYN_TX_CH, AW_HWMSG_QUEUE_USER_AC327);
+
+	/* process ac327 syn received channel, process only one message */
+	if (readl(IO_ADDRESS(AW_MSGBOX_MSG_STATUS_REG(AR100_HWMSGBOX_AR100_SYN_TX_CH)))) {
+		volatile unsigned long value;
+		struct ar100_message *pmessage;
+		value = readl(IO_ADDRESS(AW_MSGBOX_MSG_REG(AR100_HWMSGBOX_AR100_SYN_TX_CH))) + ar100_sram_a2_vbase;
+		pmessage = (struct ar100_message *)value;
+		if (ar100_message_valid(pmessage)) {
+			/* message state switch */
+			if (pmessage->state == AR100_MESSAGE_PROCESSED) {
+				/*
+				 * AR100_MESSAGE_PROCESSED->AR100_MESSAGE_FEEDBACKED,
+				 * process feedback message.
+				 */
+				pmessage->state = AR100_MESSAGE_FEEDBACKED;
+				ar100_hwmsgbox_message_feedback(pmessage);
+			} else {
+				/*
+				 * AR100_MESSAGE_INITIALIZED->AR100_MESSAGE_RECEIVED,
+				 * notify new message coming.
+				 */
+				pmessage->state = AR100_MESSAGE_RECEIVED;
+				ar100_message_coming_notify(pmessage);
+			}
+		} else {
+			AR100_ERR("invalid message received: pmessage = 0x%x. \n", (__u32)pmessage);
+		}
+	}
+	/* clear pending */
+	ar100_hwmsgbox_clear_receiver_pending(AR100_HWMSGBOX_AR100_SYN_TX_CH, AW_HWMSG_QUEUE_USER_AC327);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * query message of hwmsgbox by hand, mainly for.
+ * @para:  none.
+ *
+ * returns:  the point of message, NULL if timeout.
+ */
+struct ar100_message *ar100_hwmsgbox_query_message(void)
+{
+	struct ar100_message *pmessage = NULL;
+
+	/* query ac327 asyn received channel */
+	if (readl(IO_ADDRESS(AW_MSGBOX_MSG_STATUS_REG(AR100_HWMSGBOX_AR100_ASYN_TX_CH)))) {
+		volatile unsigned long value;
+		value = readl(IO_ADDRESS(AW_MSGBOX_MSG_REG(AR100_HWMSGBOX_AR100_ASYN_TX_CH)));
+		pmessage = (struct ar100_message *)(value + ar100_sram_a2_vbase);
+
+		if (ar100_message_valid(pmessage)) {
+			/* message state switch */
+			if (pmessage->state == AR100_MESSAGE_PROCESSED) {
+				/* AR100_MESSAGE_PROCESSED->AR100_MESSAGE_FEEDBACKED */
+				pmessage->state = AR100_MESSAGE_FEEDBACKED;
+			} else {
+				/* AR100_MESSAGE_INITIALIZED->AR100_MESSAGE_RECEIVED */
+				pmessage->state = AR100_MESSAGE_RECEIVED;
+			}
+		} else {
+			AR100_ERR("invalid message received: pmessage = 0x%x. \n", (__u32)pmessage);
+			return NULL;
+		}
+		/* clear pending */
+		ar100_hwmsgbox_clear_receiver_pending(AR100_HWMSGBOX_AR100_ASYN_TX_CH, AW_HWMSG_QUEUE_USER_AC327);
+		return pmessage;
+	}
+	/* query ac327 syn received channel */
+	if (readl(IO_ADDRESS(AW_MSGBOX_MSG_STATUS_REG(AR100_HWMSGBOX_AR100_SYN_TX_CH)))) {
+		volatile unsigned long value;
+		value = readl(IO_ADDRESS(AW_MSGBOX_MSG_REG(AR100_HWMSGBOX_AR100_SYN_TX_CH)));
+		pmessage = (struct ar100_message *)(value + ar100_sram_a2_vbase);
+		if (ar100_message_valid(pmessage)) {
+			/* message state switch */
+			if (pmessage->state == AR100_MESSAGE_PROCESSED) {
+				/* AR100_MESSAGE_PROCESSED->AR100_MESSAGE_FEEDBACKED */
+				pmessage->state = AR100_MESSAGE_FEEDBACKED;
+			} else {
+				/* AR100_MESSAGE_INITIALIZED->AR100_MESSAGE_RECEIVED */
+				pmessage->state = AR100_MESSAGE_RECEIVED;
+			}
+		} else {
+			AR100_ERR("invalid message received: pmessage = 0x%x. \n", (__u32)pmessage);
+			return NULL;
+		}
+		ar100_hwmsgbox_clear_receiver_pending(AR100_HWMSGBOX_AR100_SYN_TX_CH, AW_HWMSG_QUEUE_USER_AC327);
+		return pmessage;
+	}
+
+	/* no valid message now */
+	return NULL;
+}
+
+int ar100_hwmsgbox_wait_message_feedback(struct ar100_message *pmessage)
+{
+	/* linux method: wait semaphore flag to set */
+	AR100_INF("down semaphore for message feedback, semp=0x%x.\n",
+			   (unsigned int)(pmessage->private));
+	down((struct semaphore *)(pmessage->private));
+
+	AR100_INF("message : %x finished\n", (unsigned int)pmessage);
+
+	return 0;
+}
+
+int ar100_hwmsgbox_message_feedback(struct ar100_message *pmessage)
+{
+	/* linux method: wait semaphore flag to set */
+	AR100_INF("up semaphore for message feedback, sem=0x%x.\n",
+			   (unsigned int)(pmessage->private));
+	up((struct semaphore *)(pmessage->private));
+
+	return 0;
+}
+
+int ar100_message_valid(struct ar100_message *pmessage)
+{
+	if ((((u32)pmessage) >= (AR100_MESSAGE_POOL_START + ar100_sram_a2_vbase)) &&
+		(((u32)pmessage) <  (AR100_MESSAGE_POOL_END   + ar100_sram_a2_vbase))) {
+
+		/* valid message */
+		return 1;
+	}
+
+	return 0;
+}
+
+int ar100_hwmsgbox_standby_suspend(void)
+{
+	/* enable ar100 asyn tx interrupt */
+	ar100_hwmsgbox_disable_receiver_int(AR100_HWMSGBOX_AR100_ASYN_TX_CH, AW_HWMSG_QUEUE_USER_AC327);
+
+	/* enable ar100 syn tx interrupt */
+	ar100_hwmsgbox_disable_receiver_int(AR100_HWMSGBOX_AR100_SYN_TX_CH, AW_HWMSG_QUEUE_USER_AC327);
+
+	return 0;
+}
+
+int ar100_hwmsgbox_standby_resume(void)
+{
+	/* enable ar100 asyn tx interrupt */
+	ar100_hwmsgbox_enable_receiver_int(AR100_HWMSGBOX_AR100_ASYN_TX_CH, AW_HWMSG_QUEUE_USER_AC327);
+
+	/* enable ar100 syn tx interrupt */
+	ar100_hwmsgbox_enable_receiver_int(AR100_HWMSGBOX_AR100_SYN_TX_CH, AW_HWMSG_QUEUE_USER_AC327);
+
+	return 0;
+}
diff --git a/arch/arm/mach-sun6i/ar100/hwmsgbox/hwmsgbox_i.h b/arch/arm/mach-sun6i/ar100/hwmsgbox/hwmsgbox_i.h
new file mode 100644
index 0000000..986a5a1
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/hwmsgbox/hwmsgbox_i.h
@@ -0,0 +1,38 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/hwmsgbox/hwmsgbox_i.h
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__AR100_HWMSGBOX_I_H
+#define	__AR100_HWMSGBOX_I_H
+
+#include "../include/ar100_includes.h"
+
+/* local functions */
+irqreturn_t ar100_hwmsgbox_int_handler(int irq, void *dev);
+int ar100_hwmsgbox_clear_receiver_pending(int queue, int user);
+int ar100_hwmsgbox_query_receiver_pending(int queue, int user);
+int ar100_hwmsgbox_enable_receiver_int(int queue, int user);
+int ar100_hwmsgbox_set_receiver(int queue, int user);
+int ar100_hwmsgbox_set_transmitter(int queue, int user);
+int ar100_hwmsgbox_wait_message_feedback(struct ar100_message *pmessage);
+int ar100_hwmsgbox_message_feedback(struct ar100_message *pmessage);
+int ar100_message_valid(struct ar100_message *pmessage);
+
+#endif	/* __AR100_HWMSGBOX_I_H */
diff --git a/arch/arm/mach-sun6i/ar100/hwspinlock/Makefile b/arch/arm/mach-sun6i/ar100/hwspinlock/Makefile
new file mode 100644
index 0000000..175abf4
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/hwspinlock/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-y=hwspinlock.o
diff --git a/arch/arm/mach-sun6i/ar100/hwspinlock/hwspinlock.c b/arch/arm/mach-sun6i/ar100/hwspinlock/hwspinlock.c
new file mode 100644
index 0000000..abe7455
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/hwspinlock/hwspinlock.c
@@ -0,0 +1,127 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/hwspinlock/hwspinlock.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "hwspinlock_i.h"
+
+struct ar100_hwspinlock ar100_hwspinlocks[AR100_HW_SPINLOCK_NUM];
+
+/**
+ * initialize hwspinlock.
+ * @para:  none.
+ *
+ * returns:  0 if initialize hwspinlock succeeded, others if failed.
+ */
+int ar100_hwspinlock_init(void)
+{
+	int index;
+
+	for (index = 0; index < AR100_HW_SPINLOCK_NUM; index++)
+		spin_lock_init(&(ar100_hwspinlocks[index].lock));
+
+	return 0;
+}
+
+/**
+ * exit hwspinlock.
+ * @para:none.
+ *
+ * returns:  0 if exit hwspinlock succeeded, others if failed.
+ */
+int ar100_hwspinlock_exit(void)
+{
+	return 0;
+}
+
+/**
+ * lock an hwspinlock with timeout limit.
+ * @hwid: an hwspinlock id which we want to lock.
+ *
+ * returns:  0 if lock hwspinlock succeeded, other if failed.
+ */
+int ar100_hwspin_lock_timeout(int hwid, unsigned int timeout)
+{
+	ar100_hwspinlock_t *spinlock;
+	unsigned long       expire;
+
+	expire = msecs_to_jiffies(timeout) + jiffies;
+
+	if (hwid >= AR100_HW_SPINLOCK_NUM) {
+		AR100_ERR("invalid hwspinlock id [%d] for trylock\n", hwid);
+		return -EINVAL;
+	}
+	spinlock = &(ar100_hwspinlocks[hwid]);
+
+	/* is lock already taken by another context on the local cpu ? */
+	while (!(spin_trylock_irqsave(&(spinlock->lock), spinlock->flags))) {
+		if (time_is_before_eq_jiffies(expire)) {
+			AR100_ERR("try to take spinlock fail\n");
+			return -EBUSY;
+		}
+	}
+
+	/* try to take spinlock */
+	while (readl(IO_ADDRESS(AW_SPINLOCK_LOCK_REG(hwid))) == AW_SPINLOCK_TAKEN) {
+		/*
+		 * The lock is already taken, let's check if the user wants
+		 * us to try again
+		 */
+		if (time_is_before_eq_jiffies(expire)) {
+			AR100_ERR("try to take hwspinlock timeout\n");
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * unlock a specific hwspinlock.
+ * hwid:  an hwspinlock id which we want to unlock.
+ *
+ * returns:  0 if unlock hwspinlock succeeded, other if failed.
+ */
+int ar100_hwspin_unlock(int hwid)
+{
+	ar100_hwspinlock_t *spinlock;
+
+	if (hwid >= AR100_HW_SPINLOCK_NUM) {
+		AR100_ERR("invalid hwspinlock id [%d] for unlock\n", hwid);
+		return -EINVAL;
+	}
+	spinlock = &(ar100_hwspinlocks[hwid]);
+
+	/* untaken the spinlock */
+	writel(0x0, IO_ADDRESS(AW_SPINLOCK_LOCK_REG(hwid)));
+
+	spin_unlock_irqrestore(&(spinlock->lock), spinlock->flags);
+
+	return 0;
+}
+
+int ar100_hwspinlock_standby_suspend(void)
+{
+	return 0;
+}
+
+int ar100_hwspinlock_standby_resume(void)
+{
+	return 0;
+}
diff --git a/arch/arm/mach-sun6i/ar100/hwspinlock/hwspinlock_i.h b/arch/arm/mach-sun6i/ar100/hwspinlock/hwspinlock_i.h
new file mode 100644
index 0000000..ae17b9f
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/hwspinlock/hwspinlock_i.h
@@ -0,0 +1,37 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/hwspinlock/hwspinlock-i.h
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__HW_SPINLOCK_I_H
+#define	__HW_SPINLOCK_I_H
+
+#include "../include/ar100_includes.h"
+
+/* the used state of spinlock */
+#define SPINLOCK_FREE		(0)
+#define SPINLOCK_USED		(1)
+
+typedef struct ar100_hwspinlock
+{
+	unsigned long flags;
+	spinlock_t    lock;
+} ar100_hwspinlock_t;
+
+#endif	/* __HW_SPINLOCK_I_H */
diff --git a/arch/arm/mach-sun6i/ar100/include/ar100_cfgs.h b/arch/arm/mach-sun6i/ar100/include/ar100_cfgs.h
new file mode 100644
index 0000000..9a476b9
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/include/ar100_cfgs.h
@@ -0,0 +1,56 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/include/ar100_cfgs.h
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__AR100_CFGS_H
+#define __AR100_CFGS_H
+
+/* ar100 software version number */
+#define	AR100_VERSIONS				(100)
+
+/* debugger system */
+#define AR100_DEBUG_ON
+#define	AR100_DEBUG_LEVEL			(3)	/* debug level */
+
+/* the max number of cached message frame */
+#define	AR100_MESSAGE_CACHED_MAX	(4)
+
+/* the start address of message pool */
+#define AR100_MESSAGE_POOL_START	(0x13000)
+#define AR100_MESSAGE_POOL_END		(0x14000)
+
+/* spinlock max timeout, base on ms */
+#define AR100_SPINLOCK_TIMEOUT		(100)
+
+/* send message max timeout, base on ms */
+#define AR100_SEND_MSG_TIMEOUT		(4000)
+
+/* hwmsgbox channels configure */
+#define	AR100_HWMSGBOX_AR100_ASYN_TX_CH	(0)
+#define	AR100_HWMSGBOX_AR100_ASYN_RX_CH	(1)
+#define	AR100_HWMSGBOX_AR100_SYN_TX_CH	(2)
+#define	AR100_HWMSGBOX_AR100_SYN_RX_CH	(3)
+#define	AR100_HWMSGBOX_AC327_SYN_TX_CH	(4)
+#define	AR100_HWMSGBOX_AC327_SYN_RX_CH	(5)
+
+/* dvfs config */
+#define AR100_DVFS_VF_TABLE_MAX			(16)
+
+#endif /* __AR100_CFGS_H */
diff --git a/arch/arm/mach-sun6i/ar100/include/ar100_dbgs.h b/arch/arm/mach-sun6i/ar100/include/ar100_dbgs.h
new file mode 100644
index 0000000..e788dde
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/include/ar100_dbgs.h
@@ -0,0 +1,66 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/include/ar100_dbgs.h
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__AR100_DBGS_H
+#define	__AR100_DBGS_H
+
+extern unsigned int ar100_debug_level;
+/*
+ * debug level define,
+ * level 0 : dump debug information--none;
+ * level 1 : dump debug information--error;
+ * level 2 : dump debug information--error+warning;
+ * level 3 : dump debug information--error+warning+information;
+ * extern void printk(const char *, ...);
+ */
+
+#ifdef AR100_DEBUG_ON
+/* debug levels */
+#define DEBUG_LEVEL_INF    ((u32)1 << 0)
+#define DEBUG_LEVEL_WRN    ((u32)1 << 1)
+#define DEBUG_LEVEL_ERR    ((u32)1 << 2)
+#define DEBUG_LEVEL_LOG    ((u32)1 << 3)
+
+#define	AR100_INF(...)							\
+	if(DEBUG_LEVEL_INF & (0xf0 >> (ar100_debug_level +1))) 	\
+	printk(__VA_ARGS__)
+
+#define	AR100_WRN(format, args...)							\
+	if(DEBUG_LEVEL_WRN & (0xf0 >> (ar100_debug_level +1)))	\
+	printk(KERN_ERR "AR100 WARING :"format,##args);
+
+#define	AR100_ERR(format, args...)                          \
+	if(DEBUG_LEVEL_ERR & (0xf0 >> (ar100_debug_level +1)))	\
+	printk(KERN_ERR "AR100 ERROR :"format,##args);
+
+#define	AR100_LOG(...)                                      \
+	if(DEBUG_LEVEL_LOG & (0xf0 >> (ar100_debug_level +1)))	\
+	printk(__VA_ARGS__)
+
+#else /* AR100_DEBUG_ON */
+#define	AR100_INF(...)
+#define	AR100_WRN(...)
+#define	AR100_ERR(...)
+#define	AR100_LOG(...)
+
+#endif /* AR100_DEBUG_ON */
+
+#endif /* __AR100_DBGS_H */
diff --git a/arch/arm/mach-sun6i/ar100/include/ar100_hwmsgbox.h b/arch/arm/mach-sun6i/ar100/include/ar100_hwmsgbox.h
new file mode 100644
index 0000000..6c9f477
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/include/ar100_hwmsgbox.h
@@ -0,0 +1,67 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/include/ar100_hwmsgbox.h
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__AR100_HWMSGBOX_H
+#define	__AR100_HWMSGBOX_H
+
+/**
+ * initialize hwmsgbox.
+ * @para:  none.
+ *
+ * returns:  OK if initialize hwmsgbox succeeded, others if failed.
+ */
+int ar100_hwmsgbox_init(void);
+
+/**
+ * exit hwmsgbox.
+ * @para:  none.
+ *
+ * returns:  OK if exit hwmsgbox succeeded, others if failed.
+ */
+int ar100_hwmsgbox_exit(void);
+
+/**
+ * send one message to another processor by hwmsgbox.
+ * @pmessage:  the pointer of sended message frame.
+ * @timeout:   the wait time limit when message fifo is full,
+ * it is valid only when parameter mode = SEND_MESSAGE_WAIT_TIMEOUT.
+ *
+ * returns:  OK if send message succeeded, other if failed.
+ */
+int ar100_hwmsgbox_send_message(struct ar100_message *pmessage, unsigned int timeout);
+
+/**
+ * Description: 	query message of hwmsgbox by hand, mainly for.
+ * @para:  none.
+ *
+ * returns:  the point of message, NULL if timeout.
+ */
+struct ar100_message *ar100_hwmsgbox_query_message(void);
+
+int ar100_hwmsgbox_enable_receiver_int(int queue, int user);
+int ar100_hwmsgbox_disable_receiver_int(int queue, int user);
+
+int ar100_hwmsgbox_feedback_message(struct ar100_message *pmessage, unsigned int timeout);
+
+int ar100_hwmsgbox_standby_resume(void);
+int ar100_hwmsgbox_standby_suspend(void);
+
+#endif	/* __AR100_HWMSGBOX_H */
diff --git a/arch/arm/mach-sun6i/ar100/include/ar100_hwspinlock.h b/arch/arm/mach-sun6i/ar100/include/ar100_hwspinlock.h
new file mode 100644
index 0000000..a9ce16d
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/include/ar100_hwspinlock.h
@@ -0,0 +1,63 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/include/ar100_hwspinlock.h
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__AR100_HW_SPINLOCK_H
+#define	__AR100_HW_SPINLOCK_H
+
+/* the max number of hardware spinlock */
+#define	AR100_HW_SPINLOCK_NUM		(32)
+
+/**
+ * initialize hwspinlock.
+ * @para:  none.
+ *
+ * returns:  OK if initialize hwspinlock succeeded, others if failed.
+ */
+int ar100_hwspinlock_init(void);
+
+/**
+ * exit hwspinlock.
+ * @para:  none.
+ *
+ * returns:  OK if exit hwspinlock succeeded, others if failed.
+ */
+int ar100_hwspinlock_exit(void);
+
+/**
+ * lock an hwspinlock with timeout limit.
+ * @hwid : an hwspinlock id which we want to lock.
+ *
+ * returns:  OK if lock hwspinlock succeeded, other if failed.
+ */
+int ar100_hwspin_lock_timeout(int hwid, unsigned int timeout);
+
+/**
+ * unlock a specific hwspinlock.
+ * @hwid : an hwspinlock id which we want to unlock.
+ *
+ * returns:  OK if unlock hwspinlock succeeded, other if failed.
+ */
+int ar100_hwspin_unlock(int hwid);
+
+int ar100_hwspinlock_standby_suspend(void);
+int ar100_hwspinlock_standby_resume(void);
+
+#endif	/* __AR100_HW_SPINLOCK_H */
diff --git a/arch/arm/mach-sun6i/ar100/include/ar100_includes.h b/arch/arm/mach-sun6i/ar100/include/ar100_includes.h
new file mode 100644
index 0000000..d0e4df0
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/include/ar100_includes.h
@@ -0,0 +1,63 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/include/ar100_includes.h
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__AR100_INCLUDES_H
+#define __AR100_INCLUDES_H
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/spinlock.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/semaphore.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <mach/irqs-sun6i.h>
+#include <mach/hwmsgbox.h>
+#include <mach/hwspinlock.h>
+#include <mach/hardware.h>
+#include <mach/platform.h>
+
+/* configure and debugger */
+#include "./ar100_cfgs.h"
+#include "./ar100_dbgs.h"
+
+/* messages define */
+#include "./ar100_messages.h"
+#include "./ar100_message_manager.h"
+
+/* driver headers */
+#include "./ar100_hwmsgbox.h"
+#include "./ar100_hwspinlock.h"
+
+/* global functions */
+extern int ar100_axp_int_notify(struct ar100_message *pmessage);
+extern int ar100_set_debug_level(unsigned int level);
+extern int ar100_dvfs_cfg_vf_table(void);
+extern int ar100_set_uart_baudrate(u32 baudrate);
+extern int ar100_set_dram_crc_paras(unsigned int dram_crc_en, unsigned int dram_crc_srcaddr, unsigned int dram_crc_len);
+
+/* global vars */
+extern unsigned long ar100_sram_a2_vbase;
+
+#endif /* __AR100_INCLUDES_H */
diff --git a/arch/arm/mach-sun6i/ar100/include/ar100_message_manager.h b/arch/arm/mach-sun6i/ar100/include/ar100_message_manager.h
new file mode 100644
index 0000000..17eacd3
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/include/ar100_message_manager.h
@@ -0,0 +1,67 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/include/ar100_message_manager.h
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__AR100_MESSAGE_MANAGER_H
+#define	__AR100_MESSAGE_MANAGER_H
+
+/**
+ * initialize message manager.
+ * @para:  none.
+ *
+ * returns:  OK if initialize succeeded, others if failed.
+ */
+int ar100_message_manager_init(void);
+
+/**
+ * exit message manager.
+ * para:  none.
+ *
+ * returns:  OK if exit succeeded, others if failed.
+ */
+int ar100_message_manager_exit(void);
+
+/**
+ * allocate one message frame. mainly use for send message by message-box,
+ * the message frame allocate form messages pool shared memory area.
+ * @para:  none.
+ *
+ * returns:  the pointer of allocated message frame, NULL if failed;
+ */
+struct ar100_message *ar100_message_allocate(unsigned int msg_attr);
+
+/**
+ * free one message frame. mainly use for process message finished,
+ * free it to messages pool or add to free message queue.
+ * @pmessage:  the pointer of free message frame.
+ *
+ * returns:  none.
+ */
+void ar100_message_free(struct ar100_message *pmessage);
+
+/**
+ * notify system that one message coming.
+ * @pmessage : the pointer of coming message frame.
+ *
+ * returns:  OK if notify succeeded, other if failed.
+ */
+int ar100_message_coming_notify(struct ar100_message *pmessage);
+
+#endif	/* __MESSAGE_MANAGER_H */
diff --git a/arch/arm/mach-sun6i/ar100/include/ar100_messages.h b/arch/arm/mach-sun6i/ar100/include/ar100_messages.h
new file mode 100644
index 0000000..8b757b0
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/include/ar100_messages.h
@@ -0,0 +1,100 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/include/ar100_messages.h
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#ifndef	__AR100_MESSAGES_H__
+#define	__AR100_MESSAGES_H__
+
+#include <mach/ar100.h>
+
+/* message attributes(only use 8bit) */
+#define	AR100_MESSAGE_ATTR_SOFTSYN		(1<<0)	/* need soft syn with another cpu */
+#define	AR100_MESSAGE_ATTR_HARDSYN		(1<<1)	/* need hard syn with another cpu */
+
+/* message states */
+#define	AR100_MESSAGE_FREED             (0x0)	/* freed state       */
+#define	AR100_MESSAGE_ALLOCATED		(0x1)	/* allocated state   */
+#define AR100_MESSAGE_INITIALIZED	(0x2)	/* initialized state */
+#define	AR100_MESSAGE_RECEIVED		(0x3)	/* received state    */
+#define	AR100_MESSAGE_PROCESSING	(0x4)	/* processing state  */
+#define	AR100_MESSAGE_PROCESSED		(0x5)	/* processed state   */
+#define	AR100_MESSAGE_FEEDBACKED	(0x6)	/* feedback state    */
+
+/* call back struct */
+typedef struct ar100_msg_cb
+{
+	ar100_cb_t   handler;
+	void        *arg;
+} ar100_msg_cb_t;
+
+/*
+ * the structure of message frame,
+ * this structure will transfer between ar100 and ac327.
+ * sizeof(struct message) : 64Byte.
+ */
+typedef struct ar100_message
+{
+	unsigned char   		 state;		/* identify the used status of message frame */
+	unsigned char   		 attr;		/* message attribute : SYN OR ASYN           */
+	unsigned char   		 type;		/* message type : DVFS_REQ                   */
+	unsigned char   		 result;	/* message process result                    */
+	struct ar100_message	*next;		/* pointer of next message frame             */
+	struct ar100_msg_cb		 cb;		/* the callback function and arg of message  */
+	void    	   			*private;	/* message private data                      */
+	unsigned int   			 paras[11];	/* the parameters of message                 */
+} ar100_message_t;
+
+/* the base of messages */
+#define	AR100_MESSAGE_BASE		 	(0x10)
+
+/* standby commands */
+#define	AR100_SSTANDBY_ENTER_REQ         (AR100_MESSAGE_BASE + 0x00)  /* request to enter       (ac327 to ar100) */
+#define	AR100_SSTANDBY_RESTORE_NOTIFY    (AR100_MESSAGE_BASE + 0x01)  /* restore finished       (ac327 to ar100) */
+#define	AR100_NSTANDBY_ENTER_REQ         (AR100_MESSAGE_BASE + 0x02)  /* request to enter       (ac327 to ar100) */
+#define	AR100_NSTANDBY_WAKEUP_NOTIFY     (AR100_MESSAGE_BASE + 0x03)  /* wakeup notify          (ar100 to ac327) */
+#define	AR100_NSTANDBY_RESTORE_REQ       (AR100_MESSAGE_BASE + 0x04)  /* request to restore     (ac327 to ar100) */
+#define	AR100_NSTANDBY_RESTORE_COMPLETE  (AR100_MESSAGE_BASE + 0x05)  /* ar100 restore complete (ar100 to ac327) */
+#define	AR100_TSTANDBY_ENTER_REQ	 	 (AR100_MESSAGE_BASE + 0x06)  /* request to enter(ac327 to ar100)        */
+#define	AR100_TSTANDBY_RESTORE_NOTIFY    (AR100_MESSAGE_BASE + 0x07)  /* restore finished(ac327 to ar100)		 */
+#define	AR100_FAKE_POWER_OFF_REQ         (AR100_MESSAGE_BASE + 0x08)  /* request to enter(ac327 to ar100)        */
+
+/* dvfs commands */
+#define	AR100_CPUX_DVFS_REQ              (AR100_MESSAGE_BASE + 0x20)  /* request dvfs           (ac327 to ar100) */
+#define	AR100_CPUX_DVFS_CFG_VF_REQ       (AR100_MESSAGE_BASE + 0x21)  /* request config dvfs v-f table(ac327 to ar100) */
+
+/* pmu commands */
+#define	AR100_AXP_READ_REGS              (AR100_MESSAGE_BASE + 0x41)  /* read registers	        (ac327 to ar100) */
+#define	AR100_AXP_WRITE_REGS             (AR100_MESSAGE_BASE + 0x42)  /* write registers        (ac327 to ar100) */
+#define AR100_AXP_INT_COMING_NOTIFY      (AR100_MESSAGE_BASE + 0x45)  /* interrupt coming notify(ar100 to ac327) */
+#define AR100_AXP_DISABLE_IRQ            (AR100_MESSAGE_BASE + 0x46)  /* disable axp irq of ar100                */
+#define AR100_AXP_ENABLE_IRQ             (AR100_MESSAGE_BASE + 0x47)  /* enable axp irq of ar100                 */
+
+/* set ar100 debug level commands */
+#define AR100_SET_DEBUG_LEVEL            (AR100_MESSAGE_BASE + 0x50)  /* set ar100 debug level  (ac327 to ar100) */
+#define AR100_MESSAGE_LOOPBACK           (AR100_MESSAGE_BASE + 0x51)  /* loopback message  (ac327 to ar100) */
+#define AR100_SET_UART_BAUDRATE          (AR100_MESSAGE_BASE + 0x52)  /* set uart baudrate (ac327 to ar100) */
+#define AR100_SET_DRAM_PARAS			 (AR100_MESSAGE_BASE + 0x53)  /* config dram parameter (ac327 to ar100) */
+#define AR100_SET_DEBUG_DRAM_CRC_PARAS	 (AR100_MESSAGE_BASE + 0x54)  /* config dram crc parameters (ac327 to ar100) */
+
+/* ar100 initialize state notify commands */
+#define AR100_STARTUP_NOTIFY             (AR100_MESSAGE_BASE + 0x80)  /* ar100 init state notify(ar100 to ac327) */
+
+#endif	/* __AR100_MESSAGES_H */
diff --git a/arch/arm/mach-sun6i/ar100/interfaces/Makefile b/arch/arm/mach-sun6i/ar100/interfaces/Makefile
new file mode 100644
index 0000000..b3f5e89
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/interfaces/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-y=ar100_axp.o ar100_dvfs.o ar100_standby.o ar100_debug_level.o ar100_loopback.o ar100_dram_crc.o
diff --git a/arch/arm/mach-sun6i/ar100/interfaces/ar100_axp.c b/arch/arm/mach-sun6i/ar100/interfaces/ar100_axp.c
new file mode 100644
index 0000000..f8e9175
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/interfaces/ar100_axp.c
@@ -0,0 +1,297 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/ar100_axp.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "../ar100_i.h"
+
+typedef struct axp_isr
+{
+	ar100_cb_t   handler;
+	void        *arg;
+} axp_isr_t;
+
+/* pmu isr node, record current pmu interrupt handler and argument */
+axp_isr_t axp_isr_node;
+
+/**
+ * read axp register data.
+ * @addr:    point of registers address;
+ * @data:    point of registers data;
+ * @len :    number of read registers, max len:8;
+ *
+ * return: result, 0 - read register successed,
+ *                !0 - read register failed or the len more then max len;
+ */
+int ar100_axp_read_reg(unsigned char *addr, unsigned char *data, unsigned long len)
+{
+	int                   i;
+	int					  result;
+	struct ar100_message *pmessage;
+
+	if ((addr == NULL) || (data == NULL) || (len > AXP_TRANS_BYTE_MAX)) {
+		AR100_WRN("pmu read reg para error\n");
+		return -EINVAL;
+	}
+
+	/* allocate a message frame */
+	pmessage = ar100_message_allocate(AR100_MESSAGE_ATTR_SOFTSYN);
+	if (pmessage == NULL) {
+		AR100_WRN("allocate message failed\n");
+		return -ENOMEM;
+	}
+
+	/* initialize message */
+	pmessage->type       = AR100_AXP_READ_REGS;
+	pmessage->attr       = AR100_MESSAGE_ATTR_SOFTSYN;
+	pmessage->state      = AR100_MESSAGE_INITIALIZED;
+	pmessage->cb.handler = NULL;
+	pmessage->cb.arg     = NULL;
+
+	/*
+	 * package address and data to message->paras,
+	 * message->paras data layout:
+	 * |para[0]|para[1]|para[2]|para[3]|para[4]|
+	 * |addr0~3|addr4~7|data0~3|data4~7|  len  |
+	 */
+	pmessage->paras[0] = 0;
+	pmessage->paras[1] = 0;
+	pmessage->paras[2] = 0;
+	pmessage->paras[3] = 0;
+	//memset(pmessage->paras, 0, sizeof(pmessage->paras));
+	//memset(pmessage->paras, 0, sizeof(unsigned int) * 4);
+	pmessage->paras[4] = len;
+	for (i = 0; i < len; i++) {
+		if (i < 4) {
+			/* pack 8bit addr0~addr3 into 32bit paras[0] */
+			pmessage->paras[0] |= (addr[i] << (i * 8));
+		} else {
+			/* pack 8bit addr4~addr7 into 32bit paras[1] */
+			pmessage->paras[1] |= (addr[i] << ((i - 4) * 8));
+		}
+	}
+
+	/* send message use hwmsgbox */
+	ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+
+	/* copy message readout data to user data buffer */
+	for (i = 0; i < len; i++) {
+		if (i < 4) {
+			data[i] = ((pmessage->paras[2]) >> (i * 8)) & 0xff;
+		} else {
+			data[i] = ((pmessage->paras[3]) >> ((i - 4) * 8)) & 0xff;
+		}
+	}
+
+	/* free message */
+	result = pmessage->result;
+	ar100_message_free(pmessage);
+
+	return result;
+}
+EXPORT_SYMBOL(ar100_axp_read_reg);
+
+
+/**
+ * write axp register data.
+ * addr:     point of registers address;
+ * data:     point of registers data;
+ * len :     number of write registers, max len:8;
+ *
+ * return: result, 0 - write register successed,
+ *                !0 - write register failedor the len more then max len;
+ */
+int ar100_axp_write_reg(unsigned char *addr, unsigned char *data, unsigned long len)
+{
+	int                   i;
+	int					  result;
+	struct ar100_message *pmessage;
+
+	if ((addr == NULL) || (data == NULL) || (len > AXP_TRANS_BYTE_MAX)) {
+		AR100_WRN("pmu write reg para error\n");
+		return -EINVAL;
+	}
+
+	/* allocate a message frame */
+	pmessage = ar100_message_allocate(AR100_MESSAGE_ATTR_SOFTSYN);
+	if (pmessage == NULL) {
+		AR100_WRN("allocate message failed\n");
+		return -ENOMEM;
+	}
+	/* initialize message */
+	pmessage->type       = AR100_AXP_WRITE_REGS;
+	pmessage->attr       = AR100_MESSAGE_ATTR_SOFTSYN;
+	pmessage->state      = AR100_MESSAGE_INITIALIZED;
+	pmessage->cb.handler = NULL;
+	pmessage->cb.arg     = NULL;
+
+	/*
+	 * package address and data to message->paras,
+	 * message->paras data layout:
+	 * |para[0]|para[1]|para[2]|para[3]|para[4]|
+	 * |addr0~3|addr4~7|data0~3|data4~7|  len  |
+	 */
+	pmessage->paras[0] = 0;
+	pmessage->paras[1] = 0;
+	pmessage->paras[2] = 0;
+	pmessage->paras[3] = 0;
+	//memset(pmessage->paras, 0, sizeof(pmessage->paras));
+	//memset(pmessage->paras, 0, sizeof(unsigned int) * 4);
+	pmessage->paras[4] = len;
+	for (i = 0; i < len; i++) {
+		if (i < 4) {
+			/* pack 8bit addr0~addr3 into 32bit paras[0] */
+			pmessage->paras[0] |= (addr[i] << (i * 8));
+
+			/* pack 8bit data0~data3 into 32bit paras[2] */
+			pmessage->paras[2] |= (data[i] << (i * 8));
+		} else {
+			/* pack 8bit addr4~addr7 into 32bit paras[1] */
+			pmessage->paras[1] |= (addr[i] << ((i - 4) * 8));
+
+			/* pack 8bit data4~data7 into 32bit paras[3] */
+			pmessage->paras[3] |= (data[i] << ((i - 4) * 8));
+		}
+	}
+	/* send message use hwmsgbox */
+	ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+
+	/* free message */
+	result = pmessage->result;
+	ar100_message_free(pmessage);
+
+	return result;
+}
+EXPORT_SYMBOL(ar100_axp_write_reg);
+
+/**
+ * register call-back function, call-back function is for ar100 notify some event to ac327,
+ * axp interrupt for external interrupt NMI.
+ * @func:  call-back function;
+ * @para:  parameter for call-back function;
+ *
+ * @return: result, 0 - register call-back function successed;
+ *                 !0 - register call-back function failed;
+ * NOTE: the function is like "int callback(void *para)";
+ *       this function will execute in system ISR.
+ */
+int ar100_axp_cb_register(ar100_cb_t func, void *para)
+{
+	if (axp_isr_node.handler) {
+		if(func == axp_isr_node.handler) {
+			AR100_WRN("pmu interrupt handler register already\n");
+			return 0;
+		}
+		/* just output warning message, overlay handler */
+		AR100_WRN("pmu interrupt handler register already\n");
+		return -EINVAL;
+	}
+	axp_isr_node.handler = func;
+	axp_isr_node.arg     = para;
+
+	return 0;
+}
+EXPORT_SYMBOL(ar100_axp_cb_register);
+
+
+/**
+ * unregister call-back function.
+ * @func:  call-back function which need be unregister;
+ */
+void ar100_axp_cb_unregister(ar100_cb_t func)
+{
+	if ((u32)(axp_isr_node.handler) != (u32)(func)) {
+		/* invalid handler */
+		AR100_WRN("invalid handler for unreg\n\n");
+		return ;
+	}
+	axp_isr_node.handler = NULL;
+	axp_isr_node.arg     = NULL;
+}
+EXPORT_SYMBOL(ar100_axp_cb_unregister);
+
+int ar100_disable_axp_irq(void)
+{
+	int					  result;
+	struct ar100_message *pmessage;
+
+	/* allocate a message frame */
+	pmessage = ar100_message_allocate(AR100_MESSAGE_ATTR_HARDSYN);
+	if (pmessage == NULL) {
+		AR100_WRN("allocate message failed\n");
+		return -ENOMEM;
+	}
+
+	/* initialize message */
+	pmessage->type       = AR100_AXP_DISABLE_IRQ;
+	pmessage->attr       = AR100_MESSAGE_ATTR_HARDSYN;
+	pmessage->state      = AR100_MESSAGE_INITIALIZED;
+	pmessage->cb.handler = NULL;
+	pmessage->cb.arg     = NULL;
+
+	/* send message use hwmsgbox */
+	ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+
+	/* free message */
+	result = pmessage->result;
+	ar100_message_free(pmessage);
+
+	return result;
+}
+EXPORT_SYMBOL(ar100_disable_axp_irq);
+
+int ar100_enable_axp_irq(void)
+{
+	int					  result;
+	struct ar100_message *pmessage;
+
+	/* allocate a message frame */
+	pmessage = ar100_message_allocate(AR100_MESSAGE_ATTR_HARDSYN);
+	if (pmessage == NULL) {
+		AR100_WRN("allocate message failed\n");
+		return -ENOMEM;
+	}
+
+	/* initialize message */
+	pmessage->type       = AR100_AXP_ENABLE_IRQ;
+	pmessage->attr       = AR100_MESSAGE_ATTR_HARDSYN;
+	pmessage->state      = AR100_MESSAGE_INITIALIZED;
+	pmessage->cb.handler = NULL;
+	pmessage->cb.arg     = NULL;
+
+	/* send message use hwmsgbox */
+	ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+
+	/* free message */
+	result = pmessage->result;
+	ar100_message_free(pmessage);
+
+	return result;
+}
+EXPORT_SYMBOL(ar100_enable_axp_irq);
+
+int ar100_axp_int_notify(struct ar100_message *pmessage)
+{
+	/* call pmu interrupt handler */
+	if (axp_isr_node.handler == NULL) {
+		AR100_WRN("axp irq handler not install\n");
+		return 1;
+	}
+	return (*(axp_isr_node.handler))(axp_isr_node.arg);
+}
diff --git a/arch/arm/mach-sun6i/ar100/interfaces/ar100_debug_level.c b/arch/arm/mach-sun6i/ar100/interfaces/ar100_debug_level.c
new file mode 100644
index 0000000..222edb8
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/interfaces/ar100_debug_level.c
@@ -0,0 +1,51 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/interfaces/ar100_debug_level.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * Superm (superm@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "../ar100_i.h"
+
+/**
+ * set ar100 debug level.
+ * @level: ar100 debug level;
+ *
+ * return: 0 - set ar100 debug level successed, !0 - set ar100 debug level failed;
+ */
+int ar100_set_debug_level(unsigned int level)
+{
+	struct ar100_message *pmessage;
+
+	/* allocate a message frame */
+	pmessage = ar100_message_allocate(0);
+	if (pmessage == NULL) {
+		AR100_ERR("allocate message for power management request failed\n");
+		return -ENOMEM;
+	}
+
+	/* initialize message */
+	pmessage->type     = AR100_SET_DEBUG_LEVEL;
+	pmessage->attr     = 0;
+	pmessage->paras[0] = level;
+	pmessage->state    = AR100_MESSAGE_INITIALIZED;
+
+	/* send set debug level request to ar100 */
+	ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+
+	return 0;
+}
diff --git a/arch/arm/mach-sun6i/ar100/interfaces/ar100_dram_crc.c b/arch/arm/mach-sun6i/ar100/interfaces/ar100_dram_crc.c
new file mode 100644
index 0000000..7879586
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/interfaces/ar100_dram_crc.c
@@ -0,0 +1,55 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/interfaces/ar100_dram_crc.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * Superm (superm@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "../ar100_i.h"
+
+/**
+ * set ar100 debug dram crc paras.
+ * @dram_crc_en: ar100 debug dram crc enable or disable;
+ * @dram_crc_srcaddr: source address of dram crc area
+ * @dram_crc_len: lenght of dram crc area
+ *
+ * return: 0 - set ar100 debug dram crc paras successed, !0 - set ar100 debug dram crc paras failed;
+ */
+int ar100_set_dram_crc_paras(unsigned int dram_crc_en, unsigned int dram_crc_srcaddr, unsigned int dram_crc_len)
+{
+	struct ar100_message *pmessage;
+
+	/* allocate a message frame */
+	pmessage = ar100_message_allocate(0);
+	if (pmessage == NULL) {
+		AR100_ERR("allocate message for seting dram crc paras request failed\n");
+		return -ENOMEM;
+	}
+
+	/* initialize message */
+	pmessage->type     = AR100_SET_DEBUG_DRAM_CRC_PARAS;
+	pmessage->attr     = 0;
+	pmessage->paras[0] = dram_crc_en;
+	pmessage->paras[1] = dram_crc_srcaddr;
+	pmessage->paras[2] = dram_crc_len;
+	pmessage->state    = AR100_MESSAGE_INITIALIZED;
+
+	/* send set debug level request to ar100 */
+	ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+
+	return 0;
+}
diff --git a/arch/arm/mach-sun6i/ar100/interfaces/ar100_dvfs.c b/arch/arm/mach-sun6i/ar100/interfaces/ar100_dvfs.c
new file mode 100644
index 0000000..af96a03
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/interfaces/ar100_dvfs.c
@@ -0,0 +1,180 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/interface/ar100_dvfs.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "../ar100_i.h"
+#include <mach/sys_config.h>
+
+typedef struct ar100_freq_voltage
+{
+    u32 freq;   	//cpu frequency
+    u32 voltage;   	//voltage for the frequency
+    u32 axi_div;	//the divide ratio of axi bus
+} ar100_freq_voltage_t;
+
+//cpu voltage-freq table
+static struct ar100_freq_voltage ar100_vf_table[AR100_DVFS_VF_TABLE_MAX] =
+{
+	//freq       	//voltage	//axi_div
+    {900000000,  	1200, 		3}, //cpu0 vdd is 1.20v if cpu freq is (600Mhz, 1008Mhz]
+    {600000000,  	1200, 		3}, //cpu0 vdd is 1.20v if cpu freq is (420Mhz, 600Mhz]
+    {420000000,  	1200, 		3}, //cpu0 vdd is 1.20v if cpu freq is (360Mhz, 420Mhz]
+    {360000000,  	1200, 		3}, //cpu0 vdd is 1.20v if cpu freq is (300Mhz, 360Mhz]
+    {300000000,  	1200, 		3}, //cpu0 vdd is 1.20v if cpu freq is (240Mhz, 300Mhz]
+    {240000000,  	1200, 		3}, //cpu0 vdd is 1.20v if cpu freq is (120Mhz, 240Mhz]
+    {120000000,  	1200, 		3}, //cpu0 vdd is 1.20v if cpu freq is (60Mhz,  120Mhz]
+    {60000000,      1200, 		3}, //cpu0 vdd is 1.20v if cpu freq is (0Mhz,   60Mhz]
+    {0,             1200, 		3}, //end of cpu dvfs table
+    {0,             1200, 		3}, //end of cpu dvfs table
+    {0,             1200, 		3}, //end of cpu dvfs table
+    {0,             1200, 		3}, //end of cpu dvfs table
+    {0,             1200, 		3}, //end of cpu dvfs table
+    {0,             1200, 		3}, //end of cpu dvfs table
+    {0,             1200, 		3}, //end of cpu dvfs table
+    {0,             1200, 		3}, //end of cpu dvfs table
+};
+
+int ar100_dvfs_get_cfg(char *main, char *sub, u32 *val)
+{
+	script_item_u script_val;
+	script_item_value_type_e type;
+	type = script_get_item(main, sub, &script_val);
+	if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
+		AR100_ERR("ar100 dvfs config type err!");
+		return -EINVAL;
+	}
+	*val = script_val.val;
+	AR100_INF("ar100 dvfs config [%s] [%s] : %d\n", main, sub, *val);
+	return 0;
+}
+
+int ar100_dvfs_cfg_vf_table(void)
+{
+	u32    value = 0;
+	int    index = 0;
+	int    result = 0;
+	int    vf_table_size = 0;
+	char   vf_table_key[256];
+	struct ar100_message *pmessage;
+
+	/* parse system config v-f table information */
+	if (ar100_dvfs_get_cfg("dvfs_table", "LV_count", &vf_table_size)) {
+		AR100_WRN("parse system config dvfs_table size fail\n");
+	}
+	for (index = 0; index < vf_table_size; index++) {
+		sprintf(vf_table_key, "LV%d_freq", index + 1);
+		if (ar100_dvfs_get_cfg("dvfs_table", vf_table_key, &value) == 0) {
+			ar100_vf_table[index].freq = value;
+		}
+		sprintf(vf_table_key, "LV%d_volt", index + 1);
+		if (ar100_dvfs_get_cfg("dvfs_table", vf_table_key, &value) == 0) {
+			if (value > 1400) {
+				/* cpu_vdd must < 1.4V */
+				AR100_WRN("v-f table voltage [%d] > 1400mV\n", value);
+				value = 1400;
+			}
+			ar100_vf_table[index].voltage = value;
+		}
+	}
+
+	/* allocate a message frame */
+	pmessage = ar100_message_allocate(AR100_MESSAGE_ATTR_HARDSYN);
+	if (pmessage == NULL) {
+		AR100_WRN("allocate message failed\n");
+		return -ENOMEM;
+	}
+	for (index = 0; index < AR100_DVFS_VF_TABLE_MAX; index++) {
+		/* initialize message */
+		pmessage->type       = AR100_CPUX_DVFS_CFG_VF_REQ;
+		pmessage->attr       = AR100_MESSAGE_ATTR_HARDSYN;
+		pmessage->paras[0]   = index;
+		pmessage->paras[1]   = ar100_vf_table[index].freq;
+		pmessage->paras[2]   = ar100_vf_table[index].voltage;
+		pmessage->paras[3]   = ar100_vf_table[index].axi_div;
+		pmessage->state      = AR100_MESSAGE_INITIALIZED;
+		pmessage->cb.handler = NULL;
+		pmessage->cb.arg     = NULL;
+
+		AR100_INF("v-f table: index %d freq %d vol %d axi_div %d\n",
+		pmessage->paras[0], pmessage->paras[1], pmessage->paras[2], pmessage->paras[3]);
+
+		/* send request message */
+		ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+
+		//check config fail or not
+		if (pmessage->result) {
+			AR100_WRN("config dvfs v-f table [%d] fail\n", index);
+			result = -EINVAL;
+			break;
+		}
+	}
+	/* free allocated message */
+	ar100_message_free(pmessage);
+
+	return result;
+}
+
+/*
+ * set target frequency.
+ * @freq:    target frequency to be set, based on KHZ;
+ * @mode:    the attribute of message, whether syn or asyn;
+ * @cb:      callback handler;
+ * @cb_arg:  callback handler arguments;
+ *
+ * return: result, 0 - set frequency successed,
+ *                !0 - set frequency failed;
+ */
+int ar100_dvfs_set_cpufreq(unsigned int freq, unsigned long mode, ar100_cb_t cb, void *cb_arg)
+{
+	unsigned int          msg_attr = 0;
+	struct ar100_message *pmessage;
+	int                   result = 0;
+
+	if (mode & AR100_DVFS_SYN) {
+		msg_attr |= AR100_MESSAGE_ATTR_HARDSYN;
+	}
+
+	/* allocate a message frame */
+	pmessage = ar100_message_allocate(msg_attr);
+	if (pmessage == NULL) {
+		AR100_WRN("allocate message failed\n");
+		return -ENOMEM;
+	}
+
+	/* initialize message */
+	pmessage->type       = AR100_CPUX_DVFS_REQ;
+	pmessage->attr       = (unsigned char)msg_attr;
+	pmessage->paras[0]   = freq;
+	pmessage->state      = AR100_MESSAGE_INITIALIZED;
+	pmessage->cb.handler = cb;
+	pmessage->cb.arg     = cb_arg;
+
+	AR100_INF("ar100 dvfs request : %d\n", freq);
+	ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+
+	/* dvfs mode : syn or not */
+	if (mode & AR100_DVFS_SYN) {
+		result = pmessage->result;
+		ar100_message_free(pmessage);
+	}
+
+	return result;
+}
+EXPORT_SYMBOL(ar100_dvfs_set_cpufreq);
diff --git a/arch/arm/mach-sun6i/ar100/interfaces/ar100_loopback.c b/arch/arm/mach-sun6i/ar100/interfaces/ar100_loopback.c
new file mode 100644
index 0000000..93e4791
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/interfaces/ar100_loopback.c
@@ -0,0 +1,82 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/ar100_loopback.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "../ar100_i.h"
+
+int ar100_message_loopback(void)
+{
+	int					  result;
+	struct ar100_message *pmessage;
+
+	/* allocate a message frame */
+	pmessage = ar100_message_allocate(AR100_MESSAGE_ATTR_HARDSYN);
+	if (pmessage == NULL) {
+		AR100_WRN("allocate message failed\n");
+		return -ENOMEM;
+	}
+
+	/* initialize message */
+	pmessage->type       = AR100_MESSAGE_LOOPBACK;
+	pmessage->attr       = AR100_MESSAGE_ATTR_HARDSYN;
+	pmessage->state      = AR100_MESSAGE_INITIALIZED;
+	pmessage->cb.handler = NULL;
+	pmessage->cb.arg     = NULL;
+
+	/* send message use hwmsgbox */
+	ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+
+	/* free message */
+	result = pmessage->result;
+	ar100_message_free(pmessage);
+
+	return result;
+}
+EXPORT_SYMBOL(ar100_message_loopback);
+
+int ar100_set_uart_baudrate(u32 baudrate)
+{
+	int					  result;
+	struct ar100_message *pmessage;
+
+	/* allocate a message frame */
+	pmessage = ar100_message_allocate(AR100_MESSAGE_ATTR_HARDSYN);
+	if (pmessage == NULL) {
+		AR100_WRN("allocate message failed\n");
+		return -ENOMEM;
+	}
+
+	/* initialize message */
+	pmessage->type       = AR100_SET_UART_BAUDRATE;
+	pmessage->attr       = AR100_MESSAGE_ATTR_HARDSYN;
+	pmessage->state      = AR100_MESSAGE_INITIALIZED;
+	pmessage->paras[0]   = baudrate;
+	pmessage->cb.handler = NULL;
+	pmessage->cb.arg     = NULL;
+
+	/* send message use hwmsgbox */
+	ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+
+	/* free message */
+	result = pmessage->result;
+	ar100_message_free(pmessage);
+
+	return result;
+}
diff --git a/arch/arm/mach-sun6i/ar100/interfaces/ar100_standby.c b/arch/arm/mach-sun6i/ar100/interfaces/ar100_standby.c
new file mode 100644
index 0000000..f8721a5
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/interfaces/ar100_standby.c
@@ -0,0 +1,274 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/ar100_standby.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "..//ar100_i.h"
+#include <asm/tlbflush.h>
+#include <asm/cacheflush.h>
+#include <mach/sys_config.h>
+
+/* record super-standby wakeup event */
+static unsigned long wakeup_event = 0;
+static unsigned long dram_crc_error = 0;
+static unsigned long dram_crc_total_count = 0;
+static unsigned long dram_crc_error_count = 0;
+
+extern unsigned int ar100_debug_dram_crc_en;
+
+/**
+ * enter super standby.
+ * @para:  parameter for enter normal standby.
+ *
+ * return: result, 0 - super standby successed,
+ *                !0 - super standby failed;
+ */
+int ar100_standby_super(struct super_standby_para *para, ar100_cb_t cb, void *cb_arg)
+{
+	struct ar100_message *pmessage;
+
+	/* allocate a message frame */
+	pmessage = ar100_message_allocate(AR100_MESSAGE_ATTR_HARDSYN);
+	if (pmessage == NULL) {
+		AR100_ERR("allocate message for super-standby request failed\n");
+		return -ENOMEM;
+	}
+
+	/* check super_standby_para size valid or not */
+	if (sizeof(struct super_standby_para) > sizeof(pmessage->paras)) {
+		AR100_ERR("super-standby parameters number too long\n");
+		return -EINVAL;
+	}
+
+	/* initialize message */
+	pmessage->type       = AR100_SSTANDBY_ENTER_REQ;
+	pmessage->attr       = 0;
+	pmessage->cb.handler = cb;
+	pmessage->cb.arg     = cb_arg;
+	memcpy(pmessage->paras, para, sizeof(struct super_standby_para));
+	pmessage->state      = AR100_MESSAGE_INITIALIZED;
+
+	/* send enter super-standby request to ar100 */
+	ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+
+	return 0;
+}
+EXPORT_SYMBOL(ar100_standby_super);
+
+
+/**
+ * query super-standby wakeup source.
+ * @para:  point of buffer to store wakeup event informations.
+ *
+ * return: result, 0 - query successed,
+ *                !0 - query failed;
+ */
+int ar100_query_wakeup_source(unsigned long *event)
+{
+	*event = wakeup_event;
+
+	return 0;
+}
+EXPORT_SYMBOL(ar100_query_wakeup_source);
+
+/**
+ * query super-standby dram crc result.
+ * @para:  point of buffer to store dram crc result informations.
+ *
+ * return: result, 0 - query successed,
+ *                !0 - query failed;
+ */
+int ar100_query_dram_crc_result(unsigned long *perror, unsigned long *ptotal_count,
+	unsigned long *perror_count)
+{
+	*perror = dram_crc_error;
+	*ptotal_count = dram_crc_total_count;
+	*perror_count = dram_crc_error_count;
+
+	return 0;
+}
+EXPORT_SYMBOL(ar100_query_dram_crc_result);
+
+int ar100_set_dram_crc_result(unsigned long error, unsigned long total_count,
+	unsigned long error_count)
+{
+	dram_crc_error = error;
+	dram_crc_total_count = total_count;
+	dram_crc_error_count = error_count;
+
+	return 0;
+}
+EXPORT_SYMBOL(ar100_set_dram_crc_result);
+
+/**
+ * notify ar100 cpux restored.
+ * @para:  none.
+ *
+ * return: result, 0 - notify successed, !0 - notify failed;
+ */
+int ar100_cpux_ready_notify(void)
+{
+	struct ar100_message *pmessage;
+
+	/* notify hwspinlock and hwmsgbox resume first */
+	ar100_hwmsgbox_standby_resume();
+	ar100_hwspinlock_standby_resume();
+
+	/* allocate a message frame */
+	pmessage = ar100_message_allocate(AR100_MESSAGE_ATTR_HARDSYN);
+	if (pmessage == NULL) {
+		AR100_WRN("allocate message failed\n");
+		return -ENOMEM;
+	}
+
+	/* initialize message */
+	pmessage->type     = AR100_SSTANDBY_RESTORE_NOTIFY;
+	pmessage->attr     = AR100_MESSAGE_ATTR_HARDSYN;
+	pmessage->state    = AR100_MESSAGE_INITIALIZED;
+
+	ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+
+	/* record wakeup event */
+	wakeup_event   = pmessage->paras[0];
+	if (ar100_debug_dram_crc_en) {
+		dram_crc_error = pmessage->paras[1];
+		dram_crc_total_count++;
+		dram_crc_error_count += (dram_crc_error ? 1 : 0);
+	}
+
+	/* free message */
+	ar100_message_free(pmessage);
+
+	return 0;
+}
+EXPORT_SYMBOL(ar100_cpux_ready_notify);
+
+/**
+ * enter talk standby.
+ * @para:  parameter for enter talk standby.
+ *
+ * return: result, 0 - talk standby successed,
+ *                !0 - talk standby failed;
+ */
+int ar100_standby_talk(struct super_standby_para *para, ar100_cb_t cb, void *cb_arg)
+{
+	struct ar100_message *pmessage;
+
+	/* allocate a message frame */
+	pmessage = ar100_message_allocate(AR100_MESSAGE_ATTR_HARDSYN);
+	if (pmessage == NULL) {
+		AR100_ERR("allocate message for talk-standby request failed\n");
+		return -ENOMEM;
+	}
+
+	/* check super_standby_para size valid or not */
+	if (sizeof(struct super_standby_para) > sizeof(pmessage->paras)) {
+		AR100_ERR("talk-standby parameters number too long\n");
+		return -EINVAL;
+	}
+
+	/* initialize message */
+	pmessage->type       = AR100_TSTANDBY_ENTER_REQ;
+	pmessage->attr       = 0;
+	pmessage->cb.handler = cb;
+	pmessage->cb.arg     = cb_arg;
+	memcpy(pmessage->paras, para, sizeof(struct super_standby_para));
+	pmessage->state      = AR100_MESSAGE_INITIALIZED;
+
+	/* send enter super-standby request to ar100 */
+	ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+
+	return 0;
+}
+EXPORT_SYMBOL(ar100_standby_talk);
+
+/**
+ * notify ar100 cpux talk-standby restored.
+ * @para:  none.
+ *
+ * return: result, 0 - notify successed, !0 - notify failed;
+ */
+int ar100_cpux_talkstandby_ready_notify(void)
+{
+	struct ar100_message *pmessage;
+
+	/* notify hwspinlock and hwmsgbox resume first */
+	ar100_hwmsgbox_standby_resume();
+	ar100_hwspinlock_standby_resume();
+
+	/* allocate a message frame */
+	pmessage = ar100_message_allocate(AR100_MESSAGE_ATTR_HARDSYN);
+	if (pmessage == NULL) {
+		AR100_WRN("allocate message failed\n");
+		return -ENOMEM;
+	}
+
+	/* initialize message */
+	pmessage->type     = AR100_TSTANDBY_RESTORE_NOTIFY;
+	pmessage->attr     = AR100_MESSAGE_ATTR_HARDSYN;
+	pmessage->state    = AR100_MESSAGE_INITIALIZED;
+
+	ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+
+	/* record wakeup event */
+	wakeup_event   = pmessage->paras[0];
+	if (ar100_debug_dram_crc_en) {
+		dram_crc_error = pmessage->paras[1];
+		dram_crc_total_count++;
+		dram_crc_error_count += (dram_crc_error ? 1 : 0);
+	}
+
+	/* free message */
+	ar100_message_free(pmessage);
+
+	return 0;
+}
+EXPORT_SYMBOL(ar100_cpux_talkstandby_ready_notify);
+
+/**
+ * enter fake power off.
+ */
+void ar100_fake_power_off(void)
+{
+	struct ar100_message *pmessage;
+	script_item_u script_val;
+	script_item_value_type_e type;
+
+	/* allocate a message frame */
+	pmessage = ar100_message_allocate(AR100_MESSAGE_ATTR_HARDSYN);
+	if (pmessage == NULL) {
+		AR100_ERR("allocate message for fake power off request failed\n");
+	}
+
+	type = script_get_item("pmu_para", "pmu_ir_power_key_code", &script_val);
+	if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
+		printk("get ir power off key config type err!");
+		script_val.val = 0;
+	}
+
+	/* initialize message */
+	pmessage->type       = AR100_FAKE_POWER_OFF_REQ;
+	pmessage->attr       = 0;
+	pmessage->state      = AR100_MESSAGE_INITIALIZED;
+	pmessage->paras[0]   = script_val.val;
+
+	/* send enter fake power off request to ar100 */
+	ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+}
+EXPORT_SYMBOL(ar100_fake_power_off);
diff --git a/arch/arm/mach-sun6i/ar100/message_manager/Makefile b/arch/arm/mach-sun6i/ar100/message_manager/Makefile
new file mode 100644
index 0000000..d0ddb9e
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/message_manager/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-y=message_manager.o
diff --git a/arch/arm/mach-sun6i/ar100/message_manager/message_manager.c b/arch/arm/mach-sun6i/ar100/message_manager/message_manager.c
new file mode 100644
index 0000000..f166260
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/message_manager/message_manager.c
@@ -0,0 +1,323 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/message_manager/message_manager.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#include "message_manager_i.h"
+
+/* the start and end of message pool */
+static struct ar100_message *message_start;
+static struct ar100_message *message_end;
+
+/* spinlock for this module */
+static spinlock_t    msg_mgr_lock;
+static unsigned long msg_mgr_flag;
+
+/* message cache manager */
+static struct ar100_message_cache message_cache;
+
+/* semaphore cache manager */
+static struct ar100_semaphore_cache sem_cache;
+
+/**
+ * initialize message manager.
+ * @para:  none.
+ *
+ * returns:  0 if initialize succeeded, others if failed.
+ */
+int ar100_message_manager_init(void)
+{
+	int i;
+
+	/* initialize message pool start and end */
+	message_start = (struct ar100_message *)(ar100_sram_a2_vbase + AR100_MESSAGE_POOL_START);
+	message_end   = (struct ar100_message *)(ar100_sram_a2_vbase + AR100_MESSAGE_POOL_END);
+
+	/* initialize message_cache */
+	for (i = 0; i < AR100_MESSAGE_CACHED_MAX; i++) {
+		message_cache.cache[i] = NULL;
+	}
+	atomic_set(&(message_cache.number), 0);
+
+	/* initialzie semaphore allocator */
+	for (i = 0; i < AR100_SEM_CACHE_MAX; i++) {
+		sem_cache.cache[i] = NULL;
+	}
+	atomic_set(&(sem_cache.number), 0);
+
+	/* initialize message manager spinlock */
+	spin_lock_init(&(msg_mgr_lock));
+	msg_mgr_flag = 0;
+
+	return 0;
+}
+
+/**
+ * exit message manager.
+ * @para:  none.
+ *
+ * returns:  0 if exit succeeded, others if failed.
+ */
+int ar100_message_manager_exit(void)
+{
+	return 0;
+}
+
+static int ar100_semaphore_invalid(struct semaphore *psemaphore)
+{
+	/* semaphore use system kmalloc, valid range check */
+	//if ((psemaphore >= ((struct semaphore *)(0xC0000000))) &&
+	//	(psemaphore <  ((struct semaphore *)(0xF0000000))))
+	if (psemaphore) {
+		/* valid ar100 semaphore */
+		return 0;
+	}
+	/* invalid ar100 semaphore */
+	return 1;
+}
+
+static struct semaphore *ar100_semaphore_allocate(void)
+{
+	struct semaphore *sem = NULL;
+
+	/* try to allocate from cache first */
+	spin_lock_irqsave(&(msg_mgr_lock), msg_mgr_flag);
+	if (atomic_read(&(sem_cache.number))) {
+		atomic_dec(&(sem_cache.number));
+		sem = sem_cache.cache[atomic_read(&(sem_cache.number))];
+		sem_cache.cache[atomic_read(&(sem_cache.number))] = NULL;
+		if (ar100_semaphore_invalid(sem)) {
+			AR100_ERR("allocate cache semaphore [%x] invalid\n", (u32)sem);
+		}
+	}
+	spin_unlock_irqrestore(&(msg_mgr_lock), msg_mgr_flag);
+
+	if (ar100_semaphore_invalid(sem)) {
+		/* cache allocate fail, allocate from kmem */
+		sem = kmalloc(sizeof(struct semaphore), GFP_KERNEL);
+	}
+	/* check allocate semaphore valid or not */
+	if (ar100_semaphore_invalid(sem)) {
+		AR100_ERR("allocate semaphore [%x] invalid\n", (u32)sem);
+		return NULL;
+	}
+
+	/* initialize allocated semaphore */
+	sema_init(sem, 0);
+
+	return sem;
+}
+
+static int ar100_semaphore_free(struct semaphore *sem)
+{
+	struct semaphore *free_sem = sem;
+
+	if (ar100_semaphore_invalid(free_sem)) {
+		AR100_ERR("free semaphore [%x] invalid\n", (u32)free_sem);
+		return -1;
+	}
+
+	/* try to free semaphore to cache */
+	spin_lock_irqsave(&(msg_mgr_lock), msg_mgr_flag);
+	if (atomic_read(&(sem_cache.number)) < AR100_SEM_CACHE_MAX) {
+		sem_cache.cache[atomic_read(&(sem_cache.number))] = free_sem;
+		atomic_inc(&(sem_cache.number));
+		free_sem = NULL;
+	}
+	spin_unlock_irqrestore(&(msg_mgr_lock), msg_mgr_flag);
+
+	/* try to free semaphore to kmem if free to cache fail */
+	if (free_sem) {
+		/* free to kmem */
+		kfree(free_sem);
+	}
+	return 0;
+}
+
+static int ar100_message_invalid(struct ar100_message *pmessage)
+{
+	if ((pmessage >= message_start) &&
+		(pmessage < message_end)) {
+		/* valid ar100 message */
+		return 0;
+	}
+	/* invalid ar100 message */
+	return 1;
+}
+
+/**
+ * allocate one message frame. mainly use for send message by message-box,
+ * the message frame allocate form messages pool shared memory area.
+ * @para:  none.
+ *
+ * returns:  the pointer of allocated message frame, NULL if failed;
+ */
+struct ar100_message *ar100_message_allocate(unsigned int msg_attr)
+{
+	struct ar100_message *pmessage = NULL;
+	struct ar100_message *palloc   = NULL;
+
+	/* first find in message_cache */
+	spin_lock_irqsave(&(msg_mgr_lock), msg_mgr_flag);
+	if (atomic_read(&(message_cache.number))) {
+		AR100_INF("ar100 message_cache.number = 0x%x.\n", atomic_read(&(message_cache.number)));
+		atomic_dec(&(message_cache.number));
+		palloc = message_cache.cache[atomic_read(&(message_cache.number))];
+		AR100_INF("message [%x] allocate from message_cache\n", (u32)palloc);
+		if (ar100_message_invalid(palloc)) {
+			AR100_ERR("allocate cache message [%x] invalid\n", (u32)palloc);
+		}
+	}
+	spin_unlock_irqrestore(&(msg_mgr_lock), msg_mgr_flag);
+	if (ar100_message_invalid(palloc)) {
+		/*
+		 * cached message_cache finded fail,
+		 * use spinlock 0 to exclusive with ar100.
+		 */
+		ar100_hwspin_lock_timeout(0, AR100_SPINLOCK_TIMEOUT);
+
+		/* seach from the start of message pool every time. */
+		pmessage = message_start;
+		while (pmessage < message_end) {
+			if (pmessage->state == AR100_MESSAGE_FREED) {
+				/* find free message in message pool, allocate it */
+				palloc = pmessage;
+				palloc->state = AR100_MESSAGE_ALLOCATED;
+				AR100_INF("message [%x] allocate from message pool\n", (u32)palloc);
+				break;
+			}
+			/* next message frame */
+			pmessage++;
+		}
+		/* unlock hwspinlock 0 */
+		ar100_hwspin_unlock(0);
+	}
+	if (ar100_message_invalid(palloc)) {
+		AR100_ERR("allocate message [%x] frame is invalid\n", (u32)palloc);
+		return NULL;
+	}
+	/* initialize messgae frame */
+	palloc->next = 0;
+	palloc->attr = msg_attr;
+	if (msg_attr & AR100_MESSAGE_ATTR_SOFTSYN) {
+		/* syn message,allocate one semaphore for private */
+		palloc->private = ar100_semaphore_allocate();
+	} else {
+		palloc->private = NULL;
+	}
+	return palloc;
+}
+
+/**
+ * free one message frame. mainly use for process message finished,
+ * free it to messages pool or add to free message queue.
+ * @pmessage:  the pointer of free message frame.
+ *
+ * returns:  none.
+ */
+void ar100_message_free(struct ar100_message *pmessage)
+{
+	struct ar100_message *free_message = pmessage;
+
+	/* check this message valid or not */
+	if (ar100_message_invalid(free_message)) {
+		AR100_ERR("free invalid ar100 message [%x]\n", (u32)free_message);
+		return;
+	}
+	if (free_message->attr & AR100_MESSAGE_ATTR_SOFTSYN) {
+		/* free message semaphore first */
+		ar100_semaphore_free((struct semaphore *)(free_message->private));
+		free_message->private = NULL;
+	}
+	/* try to free to free_list first */
+	spin_lock_irqsave(&(msg_mgr_lock), msg_mgr_flag);
+	if (atomic_read(&(message_cache.number)) < AR100_MESSAGE_CACHED_MAX) {
+		AR100_INF("insert message [%x] to message_cache\n", (unsigned int)free_message);
+		AR100_INF("message_cache number : %d\n", atomic_read(&(message_cache.number)));
+		/* cached this message, message state: ALLOCATED */
+		message_cache.cache[atomic_read(&(message_cache.number))] = free_message;
+		atomic_inc(&(message_cache.number));
+		free_message->next = NULL;
+		free_message->state = AR100_MESSAGE_ALLOCATED;
+		free_message = NULL;
+	}
+	spin_unlock_irqrestore(&(msg_mgr_lock), msg_mgr_flag);
+
+	/* 	try to free message to pool if free to cache fail */
+	if (free_message) {
+		/* free to message pool,set message state as FREED. */
+		ar100_hwspin_lock_timeout(0, AR100_SPINLOCK_TIMEOUT);
+		free_message->state = AR100_MESSAGE_FREED;
+		free_message->next  = NULL;
+		ar100_hwspin_unlock(0);
+	}
+}
+
+/**
+ * notify system that one message coming.
+ * @pmessage:  the pointer of coming message frame.
+ *
+ * returns:  0 if notify succeeded, other if failed.
+ */
+int ar100_message_coming_notify(struct ar100_message *pmessage)
+{
+	int   ret;
+
+	/* ac327 receive message to ar100 */
+	AR100_INF("-------------------------------------------------------------\n");
+	AR100_INF("                MESSAGE FROM AR100                           \n");
+	AR100_INF("message addr : %x\n", (u32)pmessage);
+	AR100_INF("message type : %x\n", pmessage->type);
+	AR100_INF("message attr : %x\n", pmessage->attr);
+	AR100_INF("-------------------------------------------------------------\n");
+
+	/* message per-process */
+	pmessage->state = AR100_MESSAGE_PROCESSING;
+
+	/* process message */
+	switch (pmessage->type) {
+		case AR100_AXP_INT_COMING_NOTIFY: {
+			AR100_INF("pmu interrupt coming notify\n");
+			ret = ar100_axp_int_notify(pmessage);
+			pmessage->result = ret;
+			break;
+		}
+		default : {
+			AR100_ERR("invalid message type for ac327 process\n");
+			ret = -EINVAL;
+			break;
+		}
+	}
+	/* message post process */
+	pmessage->state = AR100_MESSAGE_PROCESSED;
+	if ((pmessage->attr & AR100_MESSAGE_ATTR_SOFTSYN) ||
+		(pmessage->attr & AR100_MESSAGE_ATTR_HARDSYN)) {
+		/* synchronous message, should feedback process result */
+		ar100_hwmsgbox_feedback_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+	} else {
+		/*
+		 * asyn message, no need feedback message result,
+		 * free message directly.
+		 */
+		ar100_message_free(pmessage);
+	}
+
+	return ret;
+}
diff --git a/arch/arm/mach-sun6i/ar100/message_manager/message_manager_i.h b/arch/arm/mach-sun6i/ar100/message_manager/message_manager_i.h
new file mode 100644
index 0000000..a6ad615
--- /dev/null
+++ b/arch/arm/mach-sun6i/ar100/message_manager/message_manager_i.h
@@ -0,0 +1,46 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/message_manager/message_manager_i.h
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__AR100_MESSAGE_MANAGER_I_H
+#define	__AR100_MESSAGE_MANAGER_I_H
+
+#include "../include/ar100_includes.h"
+#include <asm/atomic.h>
+
+#define AR100_SEM_CACHE_MAX	(8)
+
+struct ar100_semaphore_cache
+{
+	atomic_t          number;
+	struct semaphore *cache[AR100_SEM_CACHE_MAX];
+};
+
+/*
+ *the strcuture of message cache,
+ *main for messages cache management.
+ */
+typedef struct ar100_message_cache
+{
+	atomic_t              number;							/* valid message number */
+	struct ar100_message *cache[AR100_MESSAGE_CACHED_MAX];	/* message cache table */
+} ar100_message_cache_t;
+
+#endif	/* __AR100_MESSAGE_MANAGER_I_H */
diff --git a/arch/arm/mach-sun6i/chips.c b/arch/arm/mach-sun6i/chips.c
new file mode 100644
index 0000000..f7a6ddd
--- /dev/null
+++ b/arch/arm/mach-sun6i/chips.c
@@ -0,0 +1,64 @@
+#include <mach/system.h>
+
+
+#define CCMU_REG_BASE   0xf1c20000
+#define SSCTL_REG_BASE  0xf1c15000
+#define RTC_REG_BASE    0xf1f00000
+#undef uint32
+
+typedef unsigned int uint32;
+#undef mctl_read_w
+#undef mctl_write_w
+#define mctl_read_w(reg)        (*(volatile uint32 *)(reg))
+#define mctl_write_w(reg, val)  (*(volatile uint32 *)(reg)) = (val)
+
+enum sw_ic_ver sw_get_ic_ver(void)
+{
+    uint32 reg_val;
+    uint32 id;
+
+    //enable SS working clock
+    reg_val = mctl_read_w(CCMU_REG_BASE + 0x9C); //CCM_SS_SCLK_CTRL
+    //24MHz
+    reg_val &= ~(0x3<<24);
+    reg_val &= ~(0x3<<16);
+    reg_val &= ~(0xf);
+    reg_val |= 0x0<<16;
+    reg_val |= 0;
+    reg_val |= 0x1U<<31;
+    mctl_write_w(CCMU_REG_BASE + 0x9C, reg_val);
+
+    //enable SS AHB clock
+    reg_val = mctl_read_w(CCMU_REG_BASE + 0x60);    //CCM_AHB1_GATE0_CTRL
+    reg_val |= 0x1<<5;                              //SS AHB clock on
+    mctl_write_w(CCMU_REG_BASE + 0x60, reg_val);
+
+    reg_val = mctl_read_w(SSCTL_REG_BASE + 0x00);   //SS_CTL
+    reg_val >>=16;
+    reg_val &=0x3;
+    mctl_write_w(SSCTL_REG_BASE + 0x00,reg_val);
+
+    id = reg_val;
+
+    reg_val = mctl_read_w(SSCTL_REG_BASE + 0x00);   //SS_CTL
+    reg_val &= ~0x1;
+    mctl_write_w(SSCTL_REG_BASE + 0x00,reg_val);
+
+    if(id == 0) {
+        reg_val = mctl_read_w(RTC_REG_BASE + 0x20c);
+        reg_val |= 0x01;
+        mctl_write_w(RTC_REG_BASE + 0x20c,reg_val);
+        reg_val = mctl_read_w(RTC_REG_BASE + 0x20c);
+        if(reg_val & 0x01){
+            return MAGIC_VER_A31A;
+        } else {
+            return MAGIC_VER_A31B;
+        }
+    }
+    else if(id == 1)
+        return MAGIC_VER_A31S;
+    else if(id == 2)
+        return MAGIC_VER_A3XP;
+    else
+        return MAGIC_VER_UNKNOWN;
+}
diff --git a/arch/arm/mach-sun6i/clock/Makefile b/arch/arm/mach-sun6i/clock/Makefile
new file mode 100644
index 0000000..12ffd9a
--- /dev/null
+++ b/arch/arm/mach-sun6i/clock/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-y=clock.o ccm.o mod_clk.o sys_clk.o pll_cfg.o ccu_dbg.o ccu_sysfs.o
diff --git a/arch/arm/mach-sun6i/clock/ccm.c b/arch/arm/mach-sun6i/clock/ccm.c
new file mode 100644
index 0000000..bec6e6b
--- /dev/null
+++ b/arch/arm/mach-sun6i/clock/ccm.c
@@ -0,0 +1,376 @@
+/*
+ *  arch/arm/mach-sun6i/clock/ccm.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * kevin.z.m (kevin@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <mach/platform.h>
+#include <mach/clock.h>
+#include <mach/hardware.h>
+#include <asm/delay.h>
+#include "ccm_i.h"
+
+#define make_aw_clk_inf(clk_id, clk_name)   {.id = clk_id, .name = clk_name}
+__ccmu_reg_list_t       *aw_ccu_reg;
+__ccmu_reg_cpu0_list_t  *aw_cpus_reg;
+
+__aw_ccu_clk_t aw_ccu_clk_tbl[] =
+{
+    make_aw_clk_inf(AW_SYS_CLK_NONE,        "sys_none"          ),
+    make_aw_clk_inf(AW_SYS_CLK_LOSC,        CLK_SYS_LOSC        ),
+    make_aw_clk_inf(AW_SYS_CLK_HOSC,        CLK_SYS_HOSC        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL1,        CLK_SYS_PLL1        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL2,        CLK_SYS_PLL2        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL3,        CLK_SYS_PLL3        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL4,        CLK_SYS_PLL4        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL5,        CLK_SYS_PLL5        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL6,        CLK_SYS_PLL6        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL7,        CLK_SYS_PLL7        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL8,        CLK_SYS_PLL8        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL9,        CLK_SYS_PLL9        ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL10,       CLK_SYS_PLL10       ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL2X8,      CLK_SYS_PLL2X8      ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL3X2,      CLK_SYS_PLL3X2      ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL6x2,      CLK_SYS_PLL6X2      ),
+    make_aw_clk_inf(AW_SYS_CLK_PLL7X2,      CLK_SYS_PLL7X2      ),
+    make_aw_clk_inf(AW_SYS_CLK_MIPIPLL,     CLK_SYS_MIPI_PLL    ),
+    make_aw_clk_inf(AW_SYS_CLK_AC327,       CLK_SYS_AC327       ),
+    make_aw_clk_inf(AW_SYS_CLK_AR100,       CLK_SYS_AR100       ),
+    make_aw_clk_inf(AW_SYS_CLK_AXI,         CLK_SYS_AXI         ),
+    make_aw_clk_inf(AW_SYS_CLK_AHB0,        CLK_SYS_AHB0        ),
+    make_aw_clk_inf(AW_SYS_CLK_AHB1,        CLK_SYS_AHB1        ),
+    make_aw_clk_inf(AW_SYS_CLK_APB0,        CLK_SYS_APB0        ),
+    make_aw_clk_inf(AW_SYS_CLK_APB1,        CLK_SYS_APB1        ),
+    make_aw_clk_inf(AW_SYS_CLK_APB2,        CLK_SYS_APB2        ),
+    make_aw_clk_inf(AW_CCU_CLK_NULL,        "null"              ),
+    make_aw_clk_inf(AW_MOD_CLK_NAND0,       CLK_MOD_NAND0       ),
+    make_aw_clk_inf(AW_MOD_CLK_NAND1,       CLK_MOD_NAND1       ),
+    make_aw_clk_inf(AW_MOD_CLK_SDC0,        CLK_MOD_SDC0        ),
+    make_aw_clk_inf(AW_MOD_CLK_SDC1,        CLK_MOD_SDC1        ),
+    make_aw_clk_inf(AW_MOD_CLK_SDC2,        CLK_MOD_SDC2        ),
+    make_aw_clk_inf(AW_MOD_CLK_SDC3,        CLK_MOD_SDC3        ),
+    make_aw_clk_inf(AW_MOD_CLK_TS,          CLK_MOD_TS          ),
+    make_aw_clk_inf(AW_MOD_CLK_SS,          CLK_MOD_SS          ),
+    make_aw_clk_inf(AW_MOD_CLK_SPI0,        CLK_MOD_SPI0        ),
+    make_aw_clk_inf(AW_MOD_CLK_SPI1,        CLK_MOD_SPI1        ),
+    make_aw_clk_inf(AW_MOD_CLK_SPI2,        CLK_MOD_SPI2        ),
+    make_aw_clk_inf(AW_MOD_CLK_SPI3,        CLK_MOD_SPI3        ),
+    make_aw_clk_inf(AW_MOD_CLK_I2S0,        CLK_MOD_I2S0        ),
+    make_aw_clk_inf(AW_MOD_CLK_I2S1,        CLK_MOD_I2S1        ),
+    make_aw_clk_inf(AW_MOD_CLK_SPDIF,       CLK_MOD_SPDIF       ),
+    make_aw_clk_inf(AW_MOD_CLK_USBPHY0,     CLK_MOD_USBPHY0     ),
+    make_aw_clk_inf(AW_MOD_CLK_USBPHY1,     CLK_MOD_USBPHY1     ),
+    make_aw_clk_inf(AW_MOD_CLK_USBPHY2,     CLK_MOD_USBPHY2     ),
+    make_aw_clk_inf(AW_MOD_CLK_USBEHCI0,    CLK_MOD_USBEHCI0    ),
+    make_aw_clk_inf(AW_MOD_CLK_USBEHCI1,    CLK_MOD_USBEHCI1    ),
+    make_aw_clk_inf(AW_MOD_CLK_USBOHCI0,    CLK_MOD_USBOHCI0    ),
+    make_aw_clk_inf(AW_MOD_CLK_USBOHCI1,    CLK_MOD_USBOHCI1    ),
+    make_aw_clk_inf(AW_MOD_CLK_USBOHCI2,    CLK_MOD_USBOHCI2    ),
+    make_aw_clk_inf(AW_MOD_CLK_USBOTG,      CLK_MOD_USBOTG      ),
+    make_aw_clk_inf(AW_MOD_CLK_MDFS,        CLK_MOD_MDFS        ),
+    make_aw_clk_inf(AW_MOD_CLK_DEBE0,       CLK_MOD_DEBE0       ),
+    make_aw_clk_inf(AW_MOD_CLK_DEBE1,       CLK_MOD_DEBE1       ),
+    make_aw_clk_inf(AW_MOD_CLK_DEFE0,       CLK_MOD_DEFE0       ),
+    make_aw_clk_inf(AW_MOD_CLK_DEFE1,       CLK_MOD_DEFE1       ),
+    make_aw_clk_inf(AW_MOD_CLK_DEMIX,       CLK_MOD_DEMP        ),
+    make_aw_clk_inf(AW_MOD_CLK_LCD0CH0,     CLK_MOD_LCD0CH0     ),
+    make_aw_clk_inf(AW_MOD_CLK_LCD0CH1,     CLK_MOD_LCD0CH1     ),
+    make_aw_clk_inf(AW_MOD_CLK_LCD1CH0,     CLK_MOD_LCD1CH0     ),
+    make_aw_clk_inf(AW_MOD_CLK_LCD1CH1,     CLK_MOD_LCD1CH1     ),
+    make_aw_clk_inf(AW_MOD_CLK_CSI0S,       CLK_MOD_CSI0S       ),
+    make_aw_clk_inf(AW_MOD_CLK_CSI0M,       CLK_MOD_CSI0M       ),
+    make_aw_clk_inf(AW_MOD_CLK_CSI1S,       CLK_MOD_CSI1S       ),
+    make_aw_clk_inf(AW_MOD_CLK_CSI1M,       CLK_MOD_CSI1M       ),
+    make_aw_clk_inf(AW_MOD_CLK_VE,          CLK_MOD_VE          ),
+    make_aw_clk_inf(AW_MOD_CLK_ADDA,        CLK_MOD_ADDA        ),
+    make_aw_clk_inf(AW_MOD_CLK_AVS,         CLK_MOD_AVS         ),
+    make_aw_clk_inf(AW_MOD_CLK_DMIC,        CLK_MOD_DMIC        ),
+    make_aw_clk_inf(AW_MOD_CLK_HDMI,        CLK_MOD_HDMI        ),
+    make_aw_clk_inf(AW_MOD_CLK_HDMI_DDC,    CLK_MOD_HDMI_DDC    ),
+    make_aw_clk_inf(AW_MOD_CLK_PS,          CLK_MOD_PS          ),
+    make_aw_clk_inf(AW_MOD_CLK_MTCACC,      CLK_MOD_MTCACC      ),
+    make_aw_clk_inf(AW_MOD_CLK_MBUS0,       CLK_MOD_MBUS0       ),
+    make_aw_clk_inf(AW_MOD_CLK_MBUS1,       CLK_MOD_MBUS1       ),
+    make_aw_clk_inf(AW_MOD_CLK_DRAM,        CLK_MOD_DRAM        ),
+    make_aw_clk_inf(AW_MOD_CLK_MIPIDSIS,    CLK_MOD_MIPIDSIS    ),
+    make_aw_clk_inf(AW_MOD_CLK_MIPIDSIP,    CLK_MOD_MIPIDSIP    ),
+    make_aw_clk_inf(AW_MOD_CLK_MIPICSIS,    CLK_MOD_MIPICSIS    ),
+    make_aw_clk_inf(AW_MOD_CLK_MIPICSIP,    CLK_MOD_MIPICSIP    ),
+    make_aw_clk_inf(AW_MOD_CLK_IEPDRC0,     CLK_MOD_IEPDRC0     ),
+    make_aw_clk_inf(AW_MOD_CLK_IEPDRC1,     CLK_MOD_IEPDRC1     ),
+    make_aw_clk_inf(AW_MOD_CLK_IEPDEU0,     CLK_MOD_IEPDEU0     ),
+    make_aw_clk_inf(AW_MOD_CLK_IEPDEU1,     CLK_MOD_IEPDEU1     ),
+    make_aw_clk_inf(AW_MOD_CLK_GPUCORE,     CLK_MOD_GPUCORE     ),
+    make_aw_clk_inf(AW_MOD_CLK_GPUMEM,      CLK_MOD_GPUMEM      ),
+    make_aw_clk_inf(AW_MOD_CLK_GPUHYD,      CLK_MOD_GPUHYD      ),
+    make_aw_clk_inf(AW_MOD_CLK_TWI0,        CLK_MOD_TWI0        ),
+    make_aw_clk_inf(AW_MOD_CLK_TWI1,        CLK_MOD_TWI1        ),
+    make_aw_clk_inf(AW_MOD_CLK_TWI2,        CLK_MOD_TWI2        ),
+    make_aw_clk_inf(AW_MOD_CLK_TWI3,        CLK_MOD_TWI3        ),
+    make_aw_clk_inf(AW_MOD_CLK_UART0,       CLK_MOD_UART0       ),
+    make_aw_clk_inf(AW_MOD_CLK_UART1,       CLK_MOD_UART1       ),
+    make_aw_clk_inf(AW_MOD_CLK_UART2,       CLK_MOD_UART2       ),
+    make_aw_clk_inf(AW_MOD_CLK_UART3,       CLK_MOD_UART3       ),
+    make_aw_clk_inf(AW_MOD_CLK_UART4,       CLK_MOD_UART4       ),
+    make_aw_clk_inf(AW_MOD_CLK_UART5,       CLK_MOD_UART5       ),
+    make_aw_clk_inf(AW_MOD_CLK_GMAC,        CLK_MOD_GMAC        ),
+    make_aw_clk_inf(AW_MOD_CLK_DMA,         CLK_MOD_DMA         ),
+    make_aw_clk_inf(AW_MOD_CLK_HSTMR,       CLK_MOD_HSTMR       ),
+    make_aw_clk_inf(AW_MOD_CLK_MSGBOX,      CLK_MOD_MSGBOX      ),
+    make_aw_clk_inf(AW_MOD_CLK_SPINLOCK,    CLK_MOD_SPINLOCK    ),
+    make_aw_clk_inf(AW_MOD_CLK_LVDS,        CLK_MOD_LVDS        ),
+    make_aw_clk_inf(AW_MOD_CLK_SMPTWD,      CLK_SMP_TWD         ),
+    make_aw_clk_inf(AW_MOD_CLK_R_TWI,       CLK_MOD_R_TWI       ),
+    make_aw_clk_inf(AW_MOD_CLK_R_1WIRE,     CLK_MOD_R_1WIRE     ),
+    make_aw_clk_inf(AW_MOD_CLK_R_UART,      CLK_MOD_R_UART      ),
+    make_aw_clk_inf(AW_MOD_CLK_R_P2WI,      CLK_MOD_R_P2WI      ),
+    make_aw_clk_inf(AW_MOD_CLK_R_TMR,       CLK_MOD_R_TMR       ),
+    make_aw_clk_inf(AW_MOD_CLK_R_CIR,       CLK_MOD_R_CIR       ),
+    make_aw_clk_inf(AW_MOD_CLK_R_PIO,       CLK_MOD_R_PIO       ),
+    make_aw_clk_inf(AW_AXI_CLK_DRAM,        "axi_dram"          ),
+    make_aw_clk_inf(AW_AHB_CLK_MIPICSI,     CLK_AHB_MIPICSI     ),
+    make_aw_clk_inf(AW_AHB_CLK_MIPIDSI,     CLK_AHB_MIPIDSI     ),
+    make_aw_clk_inf(AW_AHB_CLK_SS,          CLK_AHB_SS          ),
+    make_aw_clk_inf(AW_AHB_CLK_DMA,         CLK_AHB_DMA         ),
+    make_aw_clk_inf(AW_AHB_CLK_SDMMC0,      CLK_AHB_SDMMC0      ),
+    make_aw_clk_inf(AW_AHB_CLK_SDMMC1,      CLK_AHB_SDMMC1      ),
+    make_aw_clk_inf(AW_AHB_CLK_SDMMC2,      CLK_AHB_SDMMC2      ),
+    make_aw_clk_inf(AW_AHB_CLK_SDMMC3,      CLK_AHB_SDMMC3      ),
+    make_aw_clk_inf(AW_AHB_CLK_NAND1,       CLK_AHB_NAND1       ),
+    make_aw_clk_inf(AW_AHB_CLK_NAND0,       CLK_AHB_NAND0       ),
+    make_aw_clk_inf(AW_AHB_CLK_SDRAM,       CLK_AHB_SDRAM       ),
+    make_aw_clk_inf(AW_AHB_CLK_GMAC,        CLK_AHB_GMAC        ),
+    make_aw_clk_inf(AW_AHB_CLK_TS,          CLK_AHB_TS          ),
+    make_aw_clk_inf(AW_AHB_CLK_HSTMR,       CLK_AHB_HSTMR       ),
+    make_aw_clk_inf(AW_AHB_CLK_SPI0,        CLK_AHB_SPI0        ),
+    make_aw_clk_inf(AW_AHB_CLK_SPI1,        CLK_AHB_SPI1        ),
+    make_aw_clk_inf(AW_AHB_CLK_SPI2,        CLK_AHB_SPI2        ),
+    make_aw_clk_inf(AW_AHB_CLK_SPI3,        CLK_AHB_SPI3        ),
+    make_aw_clk_inf(AW_AHB_CLK_OTG,         CLK_AHB_OTG         ),
+    make_aw_clk_inf(AW_AHB_CLK_EHCI0,       CLK_AHB_EHCI0       ),
+    make_aw_clk_inf(AW_AHB_CLK_EHCI1,       CLK_AHB_EHCI1       ),
+    make_aw_clk_inf(AW_AHB_CLK_OHCI0,       CLK_AHB_OHCI0       ),
+    make_aw_clk_inf(AW_AHB_CLK_OHCI1,       CLK_AHB_OHCI1       ),
+    make_aw_clk_inf(AW_AHB_CLK_OHCI2,       CLK_AHB_OHCI2       ),
+    make_aw_clk_inf(AW_AHB_CLK_VE,          CLK_AHB_VE          ),
+    make_aw_clk_inf(AW_AHB_CLK_LCD0,        CLK_AHB_LCD0        ),
+    make_aw_clk_inf(AW_AHB_CLK_LCD1,        CLK_AHB_LCD1        ),
+    make_aw_clk_inf(AW_AHB_CLK_CSI0,        CLK_AHB_CSI0        ),
+    make_aw_clk_inf(AW_AHB_CLK_CSI1,        CLK_AHB_CSI1        ),
+    make_aw_clk_inf(AW_AHB_CLK_HDMI ,       CLK_AHB_HDMI        ),
+    make_aw_clk_inf(AW_AHB_CLK_DEBE0,       CLK_AHB_DEBE0       ),
+    make_aw_clk_inf(AW_AHB_CLK_DEBE1,       CLK_AHB_DEBE1       ),
+    make_aw_clk_inf(AW_AHB_CLK_DEFE0,       CLK_AHB_DEFE0       ),
+    make_aw_clk_inf(AW_AHB_CLK_DEFE1,       CLK_AHB_DEFE1       ),
+    make_aw_clk_inf(AW_AHB_CLK_MP,          CLK_AHB_MP          ),
+    make_aw_clk_inf(AW_AHB_CLK_GPU,         CLK_AHB_GPU         ),
+    make_aw_clk_inf(AW_AHB_CLK_MSGBOX,      CLK_AHB_MSGBOX      ),
+    make_aw_clk_inf(AW_AHB_CLK_SPINLOCK,    CLK_AHB_SPINLOCK    ),
+    make_aw_clk_inf(AW_AHB_CLK_DEU0,        CLK_AHB_DEU0        ),
+    make_aw_clk_inf(AW_AHB_CLK_DEU1,        CLK_AHB_DEU1        ),
+    make_aw_clk_inf(AW_AHB_CLK_DRC0,        CLK_AHB_DRC0        ),
+    make_aw_clk_inf(AW_AHB_CLK_DRC1,        CLK_AHB_DRC1        ),
+    make_aw_clk_inf(AW_AHB_CLK_MTCACC,      CLK_AHB_MTCACC      ),
+    make_aw_clk_inf(AW_APB_CLK_ADDA,        CLK_APB_ADDA        ),
+    make_aw_clk_inf(AW_APB_CLK_SPDIF,       CLK_APB_SPDIF       ),
+    make_aw_clk_inf(AW_APB_CLK_PIO,         CLK_APB_PIO         ),
+    make_aw_clk_inf(AW_APB_CLK_I2S0,        CLK_APB_I2S0        ),
+    make_aw_clk_inf(AW_APB_CLK_I2S1,        CLK_APB_I2S1        ),
+    make_aw_clk_inf(AW_APB_CLK_TWI0,        CLK_APB_TWI0        ),
+    make_aw_clk_inf(AW_APB_CLK_TWI1,        CLK_APB_TWI1        ),
+    make_aw_clk_inf(AW_APB_CLK_TWI2,        CLK_APB_TWI2        ),
+    make_aw_clk_inf(AW_APB_CLK_TWI3,        CLK_APB_TWI3        ),
+    make_aw_clk_inf(AW_APB_CLK_UART0,       CLK_APB_UART0       ),
+    make_aw_clk_inf(AW_APB_CLK_UART1,       CLK_APB_UART1       ),
+    make_aw_clk_inf(AW_APB_CLK_UART2,       CLK_APB_UART2       ),
+    make_aw_clk_inf(AW_APB_CLK_UART3,       CLK_APB_UART3       ),
+    make_aw_clk_inf(AW_APB_CLK_UART4,       CLK_APB_UART4       ),
+    make_aw_clk_inf(AW_APB_CLK_UART5,       CLK_APB_UART5       ),
+    make_aw_clk_inf(AW_DRAM_CLK_VE,         CLK_DRAM_VE         ),
+    make_aw_clk_inf(AW_DRAM_CLK_CSI_ISP,    CLK_DRAM_CSI_ISP    ),
+    make_aw_clk_inf(AW_DRAM_CLK_TS,         CLK_DRAM_TS         ),
+    make_aw_clk_inf(AW_DRAM_CLK_DRC0,       CLK_DRAM_DRC0       ),
+    make_aw_clk_inf(AW_DRAM_CLK_DRC1,       CLK_DRAM_DRC1       ),
+    make_aw_clk_inf(AW_DRAM_CLK_DEU0,       CLK_DRAM_DEU0       ),
+    make_aw_clk_inf(AW_DRAM_CLK_DEU1,       CLK_DRAM_DEU1       ),
+    make_aw_clk_inf(AW_DRAM_CLK_DEFE0,      CLK_DRAM_DEFE0      ),
+    make_aw_clk_inf(AW_DRAM_CLK_DEFE1,      CLK_DRAM_DEFE1      ),
+    make_aw_clk_inf(AW_DRAM_CLK_DEBE0,      CLK_DRAM_DEBE0      ),
+    make_aw_clk_inf(AW_DRAM_CLK_DEBE1,      CLK_DRAM_DEBE1      ),
+    make_aw_clk_inf(AW_DRAM_CLK_MP,         CLK_DRAM_MP         ),
+    make_aw_clk_inf(AW_CCU_CLK_CNT,         "count"             ),
+};
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_init
+*
+*Description: initialise clock mangement unit;
+*
+*Arguments  : none
+*
+*Return     : result,
+*               AW_CCMU_OK,     initialise ccu successed;
+*               AW_CCMU_FAIL,   initialise ccu failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+int aw_ccu_init(void)
+{
+    CCU_DBG("%s\n", __func__);
+
+    /* initialise the CCU io base */
+    aw_ccu_reg = (__ccmu_reg_list_t *)IO_ADDRESS(AW_CCM_BASE);
+    aw_cpus_reg = (__ccmu_reg_cpu0_list_t *)IO_ADDRESS(AW_R_PRCM_BASE);
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_exit
+*
+*Description: exit clock managment unit;
+*
+*Arguments  : none
+*
+*Return     : result,
+*               AW_CCMU_OK,     exit ccu successed;
+*               AW_CCMU_FAIL,   exit ccu failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+int aw_ccu_exit(void)
+{
+    CCU_DBG("%s\n", __func__);
+    aw_ccu_reg = NULL;
+    aw_cpus_reg = NULL;
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_get__clk
+*
+*Description: get clock information by clock id.
+*
+*Arguments  : id    clock id;
+*
+*Return     : clock handle, return NULL if get clock information failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+int aw_ccu_get_clk(__aw_ccu_clk_id_e id, __ccu_clk_t *clk)
+{
+    __aw_ccu_clk_t  *tmp_clk;
+
+    if(clk && (id < AW_CCU_CLK_NULL)) {
+        tmp_clk = &aw_ccu_clk_tbl[id];
+
+        /* set clock operation handle */
+        clk->ops = &sys_clk_ops;
+        clk->aw_clk = tmp_clk;
+
+        /* query system clock information from hardware */
+        tmp_clk->parent = sys_clk_ops.get_parent(id);
+        tmp_clk->onoff  = sys_clk_ops.get_status(id);
+        tmp_clk->rate   = sys_clk_ops.get_rate(id);
+        tmp_clk->hash   = ccu_clk_calc_hash(tmp_clk->name);
+    }
+    else if(clk && (id < AW_CCU_CLK_CNT)) {
+        tmp_clk = &aw_ccu_clk_tbl[id];
+
+        /* set clock operation handle */
+        clk->ops = &mod_clk_ops;
+        clk->aw_clk = tmp_clk;
+
+        /* query system clock information from hardware */
+        tmp_clk->parent = mod_clk_ops.get_parent(id);
+        tmp_clk->onoff  = mod_clk_ops.get_status(id);
+        tmp_clk->reset  = mod_clk_ops.get_reset(id);
+        tmp_clk->rate   = mod_clk_ops.get_rate(id);
+        tmp_clk->hash   = ccu_clk_calc_hash(tmp_clk->name);
+    }
+    else {
+        CCU_ERR("clock id is invalid when get clk info!\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_switch_ahb_2_pll6
+*
+*Description: switch ahb to pll6
+*
+*Arguments  : void
+*
+*Return     :
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+int aw_ccu_switch_ahb_2_pll6(void)
+{
+    aw_ccu_reg->Ahb1Div.Ahb1PreDiv = 3;
+    aw_ccu_reg->Ahb1Div.Ahb1Div = 3;
+    __delay(2000);
+    aw_ccu_reg->Ahb1Div.Ahb1ClkSrc = 3;
+    __delay(5000);
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_ccu_switch_apb_2_pll6
+*
+*Description: switch ahb to pll6
+*
+*Arguments  : void
+*
+*Return     :
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+int aw_ccu_switch_apb_2_pll6(void)
+{
+    aw_ccu_reg->Apb2Div.DivN = 3;
+    aw_ccu_reg->Apb2Div.DivM = 4;
+    __delay(2000);
+    aw_ccu_reg->Apb2Div.ClkSrc = 2;
+    __delay(5000);
+
+    return 0;
+}
diff --git a/arch/arm/mach-sun6i/clock/ccm_i.h b/arch/arm/mach-sun6i/clock/ccm_i.h
new file mode 100644
index 0000000..00c5a074
--- /dev/null
+++ b/arch/arm/mach-sun6i/clock/ccm_i.h
@@ -0,0 +1,399 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : ccm_i.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-13 18:50
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __AW_CCMU_I_H__
+#define __AW_CCMU_I_H__
+
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <asm/div64.h>
+#include <mach/ccmu.h>
+#include <mach/clock.h>
+
+#define CCMU_DBG_LEVEL  (1)
+
+#if (CCMU_DBG_LEVEL == 0 )
+    #define CCU_DBG(...)
+    #define CCU_INF(...)
+    #define CCU_ERR(...)
+#elif(CCMU_DBG_LEVEL == 1)
+    #define CCU_DBG(...)
+    #define CCU_INF(...)
+    #define CCU_ERR(format,args...)   printk("[ccmu] "format,##args)
+#elif(CCMU_DBG_LEVEL == 2)
+    #define CCU_DBG(...)
+    #define CCU_INF(format,args...)   printk("[ccmu] "format,##args)
+    #define CCU_ERR(format,args...)   printk("[ccmu] "format,##args)
+#elif(CCMU_DBG_LEVEL == 3)
+    #define CCU_DBG(format,args...)   printk("[ccmu] "format,##args)
+    #define CCU_INF(format,args...)   printk("[ccmu] "format,##args)
+    #define CCU_ERR(format,args...)   printk("[ccmu] "format,##args)
+#endif
+
+#define AHB1_FREQ_MAX   (200000000)
+
+
+/* define system clock id       */
+typedef enum __AW_CCU_CLK_ID
+{
+    AW_SYS_CLK_NONE=0,  /* invalid clock id                     */
+
+    /* OSC */
+    AW_SYS_CLK_LOSC,    /* "sys_losc"   ,LOSC, 32768 hz clock   */
+    AW_SYS_CLK_HOSC,    /* "sys_hosc"   ,HOSC, 24Mhz clock      */
+
+    /* PLL */
+    AW_SYS_CLK_PLL1,    /* "sys_pll1"   ,PLL1 clock             */
+    AW_SYS_CLK_PLL2,    /* "sys_pll2"   ,PLL2 clock             */
+    AW_SYS_CLK_PLL3,    /* "sys_pll3"   ,PLL3 clock             */
+    AW_SYS_CLK_PLL4,    /* "sys_pll4"   ,PLL4 clock             */
+    AW_SYS_CLK_PLL5,    /* "sys_pll5"   ,PLL5 clock             */
+    AW_SYS_CLK_PLL6,    /* "sys_pll6"   ,PLL6 clock,            */
+    AW_SYS_CLK_PLL7,    /* "sys_pll7"   ,PLL7 clock             */
+    AW_SYS_CLK_PLL8,    /* "sys_pll8"   ,PLL8 clock             */
+    AW_SYS_CLK_PLL9,    /* "sys_pll9"   ,PLL9 clock             */
+    AW_SYS_CLK_PLL10,   /* "sys_pll10"  ,PLL10 clock            */
+
+    /* related PLL */
+    AW_SYS_CLK_PLL2X8,  /* "sys_pll2X8"   ,PLL2 8X clock        */
+    AW_SYS_CLK_PLL3X2,  /* "sys_pll3X2"   ,PLL3 X2 clock        */
+    AW_SYS_CLK_PLL6x2,  /* "sys_pll6X2"   ,PLL6 X2 clock        */
+    AW_SYS_CLK_PLL7X2,  /* "sys_pll7X2"   ,PLL7 X2 clock        */
+    AW_SYS_CLK_MIPIPLL, /* "sys_mipi_pll" ,MIPI PLL clock       */
+
+    /* CPU & BUS */
+    AW_SYS_CLK_AC327,   /* "sys_ac327"  ,CPU clock              */
+    AW_SYS_CLK_AR100,   /* "sys_ar100"  ,CPU clock              */
+    AW_SYS_CLK_AXI,     /* "sys_axi"    ,AXI clock              */
+    AW_SYS_CLK_AHB0,    /* "sys_ahb0"   ,AHB0 clock             */
+    AW_SYS_CLK_AHB1,    /* "sys_ahb1"   ,AHB1 clock             */
+    AW_SYS_CLK_APB0,    /* "sys_apb0"   ,APB0 clock             */
+    AW_SYS_CLK_APB1,    /* "sys_apb1"   ,APB1 clock             */
+    AW_SYS_CLK_APB2,    /* "sys_apb2"   ,APB2 clock             */
+
+    AW_CCU_CLK_NULL,    /* null module clock id                 */
+
+    /* module clock */
+    AW_MOD_CLK_NAND0,       /* "mod_nand0"                      */
+    AW_MOD_CLK_NAND1,       /* "mod_nand1"                      */
+    AW_MOD_CLK_SDC0,        /* "mod_sdc0"                       */
+    AW_MOD_CLK_SDC1,        /* "mod_sdc1"                       */
+    AW_MOD_CLK_SDC2,        /* "mod_sdc2"                       */
+    AW_MOD_CLK_SDC3,        /* "mod_sdc3"                       */
+    AW_MOD_CLK_TS,          /* "mod_ts"                         */
+    AW_MOD_CLK_SS,          /* "mod_ss"                         */
+    AW_MOD_CLK_SPI0,        /* "mod_spi0"                       */
+    AW_MOD_CLK_SPI1,        /* "mod_spi1"                       */
+    AW_MOD_CLK_SPI2,        /* "mod_spi2"                       */
+    AW_MOD_CLK_SPI3,        /* "mod_spi3"                       */
+    AW_MOD_CLK_I2S0,        /* "mod_i2s0"                       */
+    AW_MOD_CLK_I2S1,        /* "mod_i2s1"                       */
+    AW_MOD_CLK_SPDIF,       /* "mod_spdif"                      */
+    AW_MOD_CLK_USBPHY0,     /* "mod_usbphy0"                    */
+    AW_MOD_CLK_USBPHY1,     /* "mod_usbphy1"                    */
+    AW_MOD_CLK_USBPHY2,     /* "mod_usbphy2"                    */
+    AW_MOD_CLK_USBEHCI0,    /* "mod_usbehci0"                   */
+    AW_MOD_CLK_USBEHCI1,    /* "mod_usbehci1"                   */
+    AW_MOD_CLK_USBOHCI0,    /* "mod_usbohci0"                   */
+    AW_MOD_CLK_USBOHCI1,    /* "mod_usbohci1"                   */
+    AW_MOD_CLK_USBOHCI2,    /* "mod_usbohci2"                   */
+    AW_MOD_CLK_USBOTG,      /* "mod_usbotg"                     */
+    AW_MOD_CLK_MDFS,        /* "mod_mdfs"                       */
+    AW_MOD_CLK_DEBE0,       /* "mod_debe0"                      */
+    AW_MOD_CLK_DEBE1,       /* "mod_debe1"                      */
+    AW_MOD_CLK_DEFE0,       /* "mod_defe0"                      */
+    AW_MOD_CLK_DEFE1,       /* "mod_defe1"                      */
+    AW_MOD_CLK_DEMIX,       /* "mod_demp"                       */
+    AW_MOD_CLK_LCD0CH0,     /* "mod_lcd0ch0"                    */
+    AW_MOD_CLK_LCD0CH1,     /* "mod_lcd0ch1"                    */
+    AW_MOD_CLK_LCD1CH0,     /* "mod_lcd1ch0"                    */
+    AW_MOD_CLK_LCD1CH1,     /* "mod_lcd1ch1"                    */
+    AW_MOD_CLK_CSI0S,       /* "mod_csi0s"                      */
+    AW_MOD_CLK_CSI0M,       /* "mod_csi0m"                      */
+    AW_MOD_CLK_CSI1S,       /* "mod_csi1s"                      */
+    AW_MOD_CLK_CSI1M,       /* "mod_csi1m"                      */
+    AW_MOD_CLK_VE,          /* "mod_ve"                         */
+    AW_MOD_CLK_ADDA,        /* "mod_adda"                       */
+    AW_MOD_CLK_AVS,         /* "mod_avs"                        */
+    AW_MOD_CLK_DMIC,        /* "mod_dmic"                       */
+    AW_MOD_CLK_HDMI,        /* "mod_hdmi"                       */
+    AW_MOD_CLK_HDMI_DDC,    /* "mod_hdmi_ddc"                   */
+    AW_MOD_CLK_PS,          /* "mod_ps"                         */
+    AW_MOD_CLK_MTCACC,      /* "mod_mtcacc"                     */
+    AW_MOD_CLK_MBUS0,       /* "mod_mbus0"                      */
+    AW_MOD_CLK_MBUS1,       /* "mod_mbus1"                      */
+    AW_MOD_CLK_DRAM,        /* "mod_dram"                       */
+    AW_MOD_CLK_MIPIDSIS,    /* "mod_mipidsis"                   */
+    AW_MOD_CLK_MIPIDSIP,    /* "mod_mipidsip"                   */
+    AW_MOD_CLK_MIPICSIS,    /* "mod_mipicsis"                   */
+    AW_MOD_CLK_MIPICSIP,    /* "mod_mipicsip"                   */
+    AW_MOD_CLK_IEPDRC0,     /* "mod_iepdrc0"                    */
+    AW_MOD_CLK_IEPDRC1,     /* "mod_iepdrc1"                    */
+    AW_MOD_CLK_IEPDEU0,     /* "mod_iepdeu0"                    */
+    AW_MOD_CLK_IEPDEU1,     /* "mod_iepdeu1"                    */
+    AW_MOD_CLK_GPUCORE,     /* "mod_gpucore"                    */
+    AW_MOD_CLK_GPUMEM,      /* "mod_gpumem"                     */
+    AW_MOD_CLK_GPUHYD,      /* "mod_gpuhyd"                     */
+    AW_MOD_CLK_TWI0,        /* "mod_twi0"                       */
+    AW_MOD_CLK_TWI1,        /* "mod_twi1"                       */
+    AW_MOD_CLK_TWI2,        /* "mod_twi2"                       */
+    AW_MOD_CLK_TWI3,        /* "mod_twi3"                       */
+    AW_MOD_CLK_UART0,       /* "mod_uart0"                      */
+    AW_MOD_CLK_UART1,       /* "mod_uart1"                      */
+    AW_MOD_CLK_UART2,       /* "mod_uart2"                      */
+    AW_MOD_CLK_UART3,       /* "mod_uart3"                      */
+    AW_MOD_CLK_UART4,       /* "mod_uart4"                      */
+    AW_MOD_CLK_UART5,       /* "mod_uart5"                      */
+    AW_MOD_CLK_GMAC,        /* "mod_gmac"                       */
+    AW_MOD_CLK_DMA,         /* "mod_dma"                        */
+    AW_MOD_CLK_HSTMR,       /* "mod_hstmr"                      */
+    AW_MOD_CLK_MSGBOX,      /* "mod_msgbox"                     */
+    AW_MOD_CLK_SPINLOCK,    /* "mod_spinlock"                   */
+    AW_MOD_CLK_LVDS,        /* "mod_lvds"                       */
+    AW_MOD_CLK_SMPTWD,      /* "smp_twd"                        */
+    AW_MOD_CLK_R_TWI,       /* "mod_r_twi"                      */
+    AW_MOD_CLK_R_1WIRE,     /* "mod_r_1wire"                    */
+    AW_MOD_CLK_R_UART,      /* "mod_r_uart"                     */
+    AW_MOD_CLK_R_P2WI,      /* "mod_r_p2wi"                     */
+    AW_MOD_CLK_R_TMR,       /* "mod_r_tmr"                      */
+    AW_MOD_CLK_R_CIR,       /* "mod_r_cir"                      */
+    AW_MOD_CLK_R_PIO,       /* "mod_r_pio"                      */
+
+    /* axi module gating */
+    AW_AXI_CLK_DRAM,        /* "axi_dram"                       */
+
+    /* ahb module gating */
+    AW_AHB_CLK_MIPICSI,     /* "ahb_mipicsi"                    */
+    AW_AHB_CLK_MIPIDSI,     /* "ahb_mipidsi"                    */
+    AW_AHB_CLK_SS,          /* "ahb_ss"                         */
+    AW_AHB_CLK_DMA,         /* "ahb_dma"                        */
+    AW_AHB_CLK_SDMMC0,      /* "ahb_sdmmc0"                     */
+    AW_AHB_CLK_SDMMC1,      /* "ahb_sdmmc1"                     */
+    AW_AHB_CLK_SDMMC2,      /* "ahb_sdmmc2"                     */
+    AW_AHB_CLK_SDMMC3,      /* "ahb_sdmmc3"                     */
+    AW_AHB_CLK_NAND1,       /* "ahb_nand1"                      */
+    AW_AHB_CLK_NAND0,       /* "ahb_nand0"                      */
+    AW_AHB_CLK_SDRAM,       /* "ahb_sdram"                      */
+    AW_AHB_CLK_GMAC,        /* "ahb_gmac"                       */
+    AW_AHB_CLK_TS,          /* "ahb_ts"                         */
+    AW_AHB_CLK_HSTMR,       /* "ahb_hstmr"                      */
+    AW_AHB_CLK_SPI0,        /* "ahb_spi0"                       */
+    AW_AHB_CLK_SPI1,        /* "ahb_spi1"                       */
+    AW_AHB_CLK_SPI2,        /* "ahb_spi2"                       */
+    AW_AHB_CLK_SPI3,        /* "ahb_spi3"                       */
+    AW_AHB_CLK_OTG,         /* "ahb_otg"                        */
+    AW_AHB_CLK_EHCI0,       /* "ahb_ehci0"                      */
+    AW_AHB_CLK_EHCI1,       /* "ahb_ehci1"                      */
+    AW_AHB_CLK_OHCI0,       /* "ahb_ohci0"                      */
+    AW_AHB_CLK_OHCI1,       /* "ahb_ohci1"                      */
+    AW_AHB_CLK_OHCI2,       /* "ahb_ohci2"                      */
+    AW_AHB_CLK_VE,          /* "ahb_ve"                         */
+    AW_AHB_CLK_LCD0,        /* "ahb_lcd0"                       */
+    AW_AHB_CLK_LCD1,        /* "ahb_lcd1"                       */
+    AW_AHB_CLK_CSI0,        /* "ahb_csi0"                       */
+    AW_AHB_CLK_CSI1,        /* "ahb_csi1"                       */
+    AW_AHB_CLK_HDMI,        /* "ahb_hdmi"                       */
+    AW_AHB_CLK_DEBE0,       /* "ahb_debe0"                      */
+    AW_AHB_CLK_DEBE1,       /* "ahb_debe1"                      */
+    AW_AHB_CLK_DEFE0,       /* "ahb_defe0"                      */
+    AW_AHB_CLK_DEFE1,       /* "ahb_defe1"                      */
+    AW_AHB_CLK_MP,          /* "ahb_mp"                         */
+    AW_AHB_CLK_GPU,         /* "ahb_gpu"                        */
+    AW_AHB_CLK_MSGBOX,      /* "ahb_msgbox"                     */
+    AW_AHB_CLK_SPINLOCK,    /* "ahb_spinlock"                   */
+    AW_AHB_CLK_DEU0,        /* "ahb_deu0"                       */
+    AW_AHB_CLK_DEU1,        /* "ahb_deu1"                       */
+    AW_AHB_CLK_DRC0,        /* "ahb_drc0"                       */
+    AW_AHB_CLK_DRC1,        /* "ahb_drc1"                       */
+    AW_AHB_CLK_MTCACC,      /* "ahb_mtcacc"                     */
+
+    /* apb module gating */
+    AW_APB_CLK_ADDA,        /* "apb_adda"                       */
+    AW_APB_CLK_SPDIF,       /* "apb_spdif"                      */
+    AW_APB_CLK_PIO,         /* "apb_pio"                        */
+    AW_APB_CLK_I2S0,        /* "apb_i2s0"                       */
+    AW_APB_CLK_I2S1,        /* "apb_i2s1"                       */
+    AW_APB_CLK_TWI0,        /* "apb_twi0"                       */
+    AW_APB_CLK_TWI1,        /* "apb_twi1"                       */
+    AW_APB_CLK_TWI2,        /* "apb_twi2"                       */
+    AW_APB_CLK_TWI3,        /* "apb_twi3"                       */
+    AW_APB_CLK_UART0,       /* "apb_uart0"                      */
+    AW_APB_CLK_UART1,       /* "apb_uart1"                      */
+    AW_APB_CLK_UART2,       /* "apb_uart2"                      */
+    AW_APB_CLK_UART3,       /* "apb_uart3"                      */
+    AW_APB_CLK_UART4,       /* "apb_uart4"                      */
+    AW_APB_CLK_UART5,       /* "apb_uart5"                      */
+
+    /* dram module gating */
+    AW_DRAM_CLK_VE,         /* "dram_ve"                        */
+    AW_DRAM_CLK_CSI_ISP,    /* "dram_csi_isp"                   */
+    AW_DRAM_CLK_TS,         /* "dram_ts"                        */
+    AW_DRAM_CLK_DRC0,       /* "dram_drc0"                      */
+    AW_DRAM_CLK_DRC1,       /* "dram_drc1"                      */
+    AW_DRAM_CLK_DEU0,       /* "dram_deu0"                      */
+    AW_DRAM_CLK_DEU1,       /* "dram_deu1"                      */
+    AW_DRAM_CLK_DEFE0,      /* "dram_defe0"                     */
+    AW_DRAM_CLK_DEFE1,      /* "dram_defe1"                     */
+    AW_DRAM_CLK_DEBE0,      /* "dram_debe0"                     */
+    AW_DRAM_CLK_DEBE1,      /* "dram_debe1"                     */
+    AW_DRAM_CLK_MP,         /* "dram_mp"                        */
+
+    AW_CCU_CLK_CNT          /* invalid id, for calc count       */
+
+} __aw_ccu_clk_id_e;
+
+
+/* define handle for moduel clock   */
+typedef struct __AW_CCU_CLK
+{
+    __aw_ccu_clk_id_e       id;     /* clock id         */
+    __aw_ccu_clk_id_e       parent; /* parent clock id  */
+    char                    *name;  /* clock name       */
+    __aw_ccu_clk_onff_e     onoff;  /* on/off status    */
+    __aw_ccu_clk_reset_e    reset;  /* reset status     */
+    __u64                   rate;   /* clock rate, frequency for system clock, division for module clock */
+    __s32                   hash;   /* hash value, for fast search without string compare   */
+
+}__aw_ccu_clk_t;
+
+
+typedef struct clk_ops
+{
+    int     (*set_status)(__aw_ccu_clk_id_e id, __aw_ccu_clk_onff_e status);
+    __aw_ccu_clk_onff_e (*get_status)(__aw_ccu_clk_id_e id);
+    int     (*set_parent)(__aw_ccu_clk_id_e id, __aw_ccu_clk_id_e parent);
+    __aw_ccu_clk_id_e (*get_parent)(__aw_ccu_clk_id_e id);
+    int     (*set_rate)(__aw_ccu_clk_id_e id, __u64 rate);
+    __u64   (*round_rate)(__aw_ccu_clk_id_e id, __u64 rate);
+    __u64   (*get_rate)(__aw_ccu_clk_id_e id);
+    int     (*set_reset)(__aw_ccu_clk_id_e id, __aw_ccu_clk_reset_e);
+    __aw_ccu_clk_reset_e (*get_reset)(__aw_ccu_clk_id_e id);
+
+} __clk_ops_t;
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_calc_hash
+*
+*Description: calculate hash value of a string;
+*
+*Arguments  : string    string whose hash value need be calculate;
+*
+*Return     : hash value
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static inline __s32 ccu_clk_calc_hash(char *string)
+{
+    __s32   tmpLen, i, tmpHash = 0;
+
+    if(!string) {
+        return 0;
+    }
+
+    tmpLen = strlen(string);
+    for(i=0; i<tmpLen; i++) {
+        tmpHash += string[i];
+    }
+
+    return tmpHash;
+}
+
+
+#define PLL1_ENBLE      (aw_ccu_reg->Pll1Ctl.PLLEn)
+#define PLL2_ENBLE      (aw_ccu_reg->Pll2Ctl.PLLEn)
+#define PLL3_ENBLE      (aw_ccu_reg->Pll3Ctl.PLLEn)
+#define PLL4_ENBLE      (aw_ccu_reg->Pll4Ctl.PLLEn)
+#define PLL5_ENBLE      (aw_ccu_reg->Pll5Ctl.PLLEn)
+#define PLL6_ENBLE      (aw_ccu_reg->Pll6Ctl.PLLEn)
+#define PLL7_ENBLE      (aw_ccu_reg->Pll7Ctl.PLLEn)
+#define PLL8_ENBLE      (aw_ccu_reg->Pll8Ctl.PLLEn)
+#define PLL9_ENBLE      (aw_ccu_reg->Pll9Ctl.PLLEn)
+#define PLL10_ENBLE     (aw_ccu_reg->Pll10Ctl.PLLEn)
+
+#define PLL1_FACTOR_N   (aw_ccu_reg->Pll1Ctl.FactorN+1)
+#define PLL1_FACTOR_K   (aw_ccu_reg->Pll1Ctl.FactorK+1)
+#define PLL1_FACTOR_M   (aw_ccu_reg->Pll1Ctl.FactorM+1)
+
+#define PLL2_FACTOR_N   (aw_ccu_reg->Pll2Ctl.FactorN+1)
+#define PLL2_FACTOR_K   (aw_ccu_reg->Pll2Ctl.FactorK+1)
+#define PLL2_FACTOR_M   (aw_ccu_reg->Pll2Ctl.FactorM+1)
+
+#define PLL3_FACTOR_N   (aw_ccu_reg->Pll3Ctl.FactorN+1)
+#define PLL3_FACTOR_K   (aw_ccu_reg->Pll3Ctl.FactorK+1)
+#define PLL3_FACTOR_M   (aw_ccu_reg->Pll3Ctl.FactorM+1)
+
+#define PLL4_FACTOR_N   (aw_ccu_reg->Pll4Ctl.FactorN+1)
+#define PLL4_FACTOR_K   (aw_ccu_reg->Pll4Ctl.FactorK+1)
+#define PLL4_FACTOR_M   (aw_ccu_reg->Pll4Ctl.FactorM+1)
+
+#define PLL5_FACTOR_N   (aw_ccu_reg->Pll5Ctl.FactorN+1)
+#define PLL5_FACTOR_K   (aw_ccu_reg->Pll5Ctl.FactorK+1)
+#define PLL5_FACTOR_M   (aw_ccu_reg->Pll5Ctl.FactorM+1)
+
+#define PLL6_FACTOR_N   (aw_ccu_reg->Pll6Ctl.FactorN+1)
+#define PLL6_FACTOR_K   (aw_ccu_reg->Pll6Ctl.FactorK+1)
+#define PLL6_FACTOR_M   (aw_ccu_reg->Pll6Ctl.FactorM+1)
+
+#define PLL7_FACTOR_N   (aw_ccu_reg->Pll7Ctl.FactorN+1)
+#define PLL7_FACTOR_K   (aw_ccu_reg->Pll7Ctl.FactorK+1)
+#define PLL7_FACTOR_M   (aw_ccu_reg->Pll7Ctl.FactorM+1)
+
+#define PLL8_FACTOR_N   (aw_ccu_reg->Pll8Ctl.FactorN+1)
+#define PLL8_FACTOR_K   (aw_ccu_reg->Pll8Ctl.FactorK+1)
+#define PLL8_FACTOR_M   (aw_ccu_reg->Pll8Ctl.FactorM+1)
+
+#define PLL9_FACTOR_N   (aw_ccu_reg->Pll9Ctl.FactorN+1)
+#define PLL9_FACTOR_K   (aw_ccu_reg->Pll9Ctl.FactorK+1)
+#define PLL9_FACTOR_M   (aw_ccu_reg->Pll9Ctl.FactorM+1)
+
+#define PLL10_FACTOR_N  (aw_ccu_reg->Pll10Ctl.FactorN+1)
+#define PLL10_FACTOR_K  (aw_ccu_reg->Pll10Ctl.FactorK+1)
+#define PLL10_FACTOR_M  (aw_ccu_reg->Pll10Ctl.FactorM+1)
+
+#define AC327_CLK_DIV   (1)
+#define AR100_CLK_DIV   (1)
+#define AXI_CLK_DIV     (aw_ccu_reg->SysClkDiv.AXIClkDiv+1)
+#define AHB0_CLK_DIV    (1)
+#define AHB1_CLK_DIV    ((aw_ccu_reg->Ahb1Div.Ahb1PreDiv + 1)*(1<<aw_ccu_reg->Ahb1Div.Ahb1Div))
+#define APB0_CLK_DIV    (aw_cpus_reg->Apb0Div.Div? (1<<aw_cpus_reg->Apb0Div.Div) : 2)
+#define APB1_CLK_DIV    (aw_ccu_reg->Ahb1Div.Apb1Div? (1<<aw_ccu_reg->Ahb1Div.Apb1Div) : 2)
+#define APB2_CLK_DIV    ((aw_ccu_reg->Apb2Div.DivM+1)*(1<<aw_ccu_reg->Apb2Div.DivN))
+
+
+extern __aw_ccu_clk_t aw_ccu_clk_tbl[];
+extern __ccu_clk_t    aw_clock[];
+
+extern __ccmu_reg_list_t   *aw_ccu_reg;
+extern __ccmu_reg_cpu0_list_t  *aw_cpus_reg;
+extern __clk_ops_t sys_clk_ops;
+extern __clk_ops_t mod_clk_ops;
+
+int aw_ccu_init(void);
+int aw_ccu_exit(void);
+int aw_ccu_get_clk(__aw_ccu_clk_id_e id, __ccu_clk_t *clk);
+int aw_ccu_switch_ahb_2_pll6(void);
+int aw_ccu_switch_apb_2_pll6(void);
+
+int ccm_get_pll1_para(__ccmu_pll1_reg0000_t *factor, __u64 rate);
+int ccm_get_pllx_para(__ccmu_media_pll_t *factor, __u64 rate);
+
+
+#endif /* #ifndef __AW_CCMU_I_H__ */
diff --git a/arch/arm/mach-sun6i/clock/ccu_dbg.c b/arch/arm/mach-sun6i/clock/ccu_dbg.c
new file mode 100644
index 0000000..a081849
--- /dev/null
+++ b/arch/arm/mach-sun6i/clock/ccu_dbg.c
@@ -0,0 +1,893 @@
+/*
+ *  arch/arm/mach-sun6i/clock/ccu_dbg.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * kevin.z.m (kevin@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include "ccm_i.h"
+
+
+#define print_clk_inf(x, y)     do{printk(#x"."#y":%d\n", aw_ccu_reg->x.y);}while(0)
+
+static void print_module0_clock(char *name, volatile __ccmu_module0_clk_t *reg)
+{
+    printk("\n%s clk infor:(0x%x)\n", name, (unsigned int)reg);
+    printk("%s.DivM:%d\n", name, reg->DivM);
+    printk("%s.OutClkCtrl:%d\n", name, reg->OutClkCtrl);
+    printk("%s.DivN:%d\n", name, reg->DivN);
+    printk("%s.SampClkCtrl:%d\n", name, reg->SampClkCtrl);
+    printk("%s.ClkSrc:%d\n", name, reg->ClkSrc);
+    printk("%s.ClkGate:%d\n", name, reg->ClkGate);
+}
+
+static void print_module1_clock(char *name, volatile __ccmu_module1_clk_t *reg)
+{
+    printk("\n%s clk infor:(0x%x)\n", name,(unsigned int)reg);
+    printk("%s.ClkSrc:%d\n", name, reg->ClkSrc);
+    printk("%s.ClkGate:%d\n", name, reg->ClkGate);
+}
+
+
+static void print_disp_clock(char *name, volatile __ccmu_disp_clk_t *reg)
+{
+    printk("\n%s clk infor:(0x%x)\n", name,(unsigned int)reg);
+    printk("%s.DivM:%d\n", name, reg->DivM);
+    printk("%s.ClkSrc:%d\n", name, reg->ClkSrc);
+    printk("%s.ClkGate:%d\n", name, reg->ClkGate);
+}
+
+
+static void print_mediapll_clock(char *name, volatile __ccmu_media_pll_t *reg)
+{
+    printk("\n%s clk infor:(0x%x)\n", name,(unsigned int)reg);
+    printk("%s.FactorM:%d\n", name, reg->FactorM);
+    printk("%s.FactorN:%d\n", name, reg->FactorN);
+    printk("%s.SdmEn:%d\n", name, reg->SdmEn);
+    printk("%s.ModeSel:%d\n", name, reg->ModeSel);
+    printk("%s.FracMod:%d\n", name, reg->FracMod);
+    printk("%s.Lock:%d\n", name, reg->Lock);
+    printk("%s.CtlMode:%d\n", name, reg->CtlMode);
+    printk("%s.PLLEn:%d\n", name, reg->PLLEn);
+}
+
+
+void clk_dbg_inf(void)
+{
+    printk("---------------------------------------------\n");
+    printk("    dump clock information                   \n");
+    printk("---------------------------------------------\n");
+
+    printk("\nPLL1 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Pll1Ctl);
+    print_clk_inf(Pll1Ctl, FactorM  );
+    print_clk_inf(Pll1Ctl, FactorK  );
+    print_clk_inf(Pll1Ctl, FactorN  );
+    print_clk_inf(Pll1Ctl, SigmaEn  );
+    print_clk_inf(Pll1Ctl, Lock     );
+    print_clk_inf(Pll1Ctl, PLLEn    );
+
+    printk("\nPLL2 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Pll2Ctl);
+    print_clk_inf(Pll2Ctl, FactorM  );
+    print_clk_inf(Pll2Ctl, FactorN  );
+    print_clk_inf(Pll2Ctl, FactorP  );
+    print_clk_inf(Pll2Ctl, SdmEn    );
+    print_clk_inf(Pll2Ctl, Lock     );
+    print_clk_inf(Pll2Ctl, PLLEn    );
+
+    printk("\nPLL3 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Pll3Ctl);
+    print_clk_inf(Pll3Ctl, FactorM  );
+    print_clk_inf(Pll3Ctl, FactorN  );
+    print_clk_inf(Pll3Ctl, SdmEn    );
+    print_clk_inf(Pll3Ctl, ModeSel  );
+    print_clk_inf(Pll3Ctl, FracMod  );
+    print_clk_inf(Pll3Ctl, Lock     );
+    print_clk_inf(Pll3Ctl, CtlMode  );
+    print_clk_inf(Pll3Ctl, PLLEn    );
+
+    print_mediapll_clock("Pll4Ctl", &aw_ccu_reg->Pll4Ctl);
+
+    printk("\nPll5Ctl clk infor(0x%x)\n", (unsigned int)&aw_ccu_reg->Pll5Ctl);
+    print_clk_inf(Pll5Ctl, FactorM      );
+    print_clk_inf(Pll5Ctl, FactorK      );
+    print_clk_inf(Pll5Ctl, FactorN      );
+    print_clk_inf(Pll5Ctl, PLLCfgUpdate );
+    print_clk_inf(Pll5Ctl, SigmaDeltaEn );
+    print_clk_inf(Pll5Ctl, Lock         );
+    print_clk_inf(Pll5Ctl, PLLEn        );
+
+    printk("\nPll6Ctl clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Pll6Ctl);
+    print_clk_inf(Pll6Ctl, FactorM      );
+    print_clk_inf(Pll6Ctl, FactorK      );
+    print_clk_inf(Pll6Ctl, FactorN      );
+    print_clk_inf(Pll6Ctl, Pll24MPdiv   );
+    print_clk_inf(Pll6Ctl, Pll24MOutEn  );
+    print_clk_inf(Pll6Ctl, PllClkOutEn  );
+    print_clk_inf(Pll6Ctl, PLLBypass    );
+    print_clk_inf(Pll6Ctl, Lock         );
+    print_clk_inf(Pll6Ctl, PLLEn        );
+
+    print_mediapll_clock("Pll7Ctl", &aw_ccu_reg->Pll7Ctl);
+    print_mediapll_clock("Pll8Ctl", &aw_ccu_reg->Pll8Ctl);
+
+    printk("\nMipiPllCtl clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->MipiPllCtl);
+    print_clk_inf(MipiPllCtl, FactorM   );
+    print_clk_inf(MipiPllCtl, FactorK   );
+    print_clk_inf(MipiPllCtl, FactorN   );
+    print_clk_inf(MipiPllCtl, VfbSel    );
+    print_clk_inf(MipiPllCtl, FeedBackDiv   );
+    print_clk_inf(MipiPllCtl, SdmEn     );
+    print_clk_inf(MipiPllCtl, PllSrc    );
+    print_clk_inf(MipiPllCtl, Ldo2En    );
+    print_clk_inf(MipiPllCtl, Ldo1En    );
+    print_clk_inf(MipiPllCtl, Sel625Or750   );
+    print_clk_inf(MipiPllCtl, SDiv2     );
+    print_clk_inf(MipiPllCtl, FracMode  );
+    print_clk_inf(MipiPllCtl, Lock      );
+    print_clk_inf(MipiPllCtl, PLLEn     );
+
+    print_mediapll_clock("Pll9Ctl", &aw_ccu_reg->Pll9Ctl);
+    print_mediapll_clock("Pll10Ctl", &aw_ccu_reg->Pll10Ctl);
+
+    printk("\nSysClkDiv clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->SysClkDiv);
+    print_clk_inf(SysClkDiv, AXIClkDiv   );
+    print_clk_inf(SysClkDiv, CpuClkSrc   );
+
+    printk("\nAhb1Div clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Ahb1Div);
+    print_clk_inf(Ahb1Div, Ahb1Div      );
+    print_clk_inf(Ahb1Div, Ahb1PreDiv   );
+    print_clk_inf(Ahb1Div, Apb1Div      );
+    print_clk_inf(Ahb1Div, Ahb1ClkSrc   );
+
+    printk("\nApb2Div clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Apb2Div);
+    print_clk_inf(Apb2Div, DivM      );
+    print_clk_inf(Apb2Div, DivN      );
+    print_clk_inf(Apb2Div, ClkSrc      );
+
+    printk("\nAxiGate clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->AxiGate);
+    print_clk_inf(AxiGate, Sdram      );
+
+    printk("\nAhbGate0 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->AhbGate0);
+    print_clk_inf(AhbGate0, MipiCsi      );
+    print_clk_inf(AhbGate0, MipiDsi );
+    print_clk_inf(AhbGate0, Ss      );
+    print_clk_inf(AhbGate0, Dma     );
+    print_clk_inf(AhbGate0, Sd0     );
+    print_clk_inf(AhbGate0, Sd1     );
+    print_clk_inf(AhbGate0, Sd2     );
+    print_clk_inf(AhbGate0, Sd3     );
+    print_clk_inf(AhbGate0, Nand1   );
+    print_clk_inf(AhbGate0, Nand0   );
+    print_clk_inf(AhbGate0, Dram    );
+    print_clk_inf(AhbGate0, Gmac    );
+    print_clk_inf(AhbGate0, Ts      );
+    print_clk_inf(AhbGate0, HsTmr   );
+    print_clk_inf(AhbGate0, Spi0    );
+    print_clk_inf(AhbGate0, Spi1    );
+    print_clk_inf(AhbGate0, Spi2    );
+    print_clk_inf(AhbGate0, Spi3    );
+    print_clk_inf(AhbGate0, Otg     );
+    print_clk_inf(AhbGate0, Ehci0   );
+    print_clk_inf(AhbGate0, Ehci1   );
+    print_clk_inf(AhbGate0, Ohci0   );
+    print_clk_inf(AhbGate0, Ohci1   );
+    print_clk_inf(AhbGate0, Ohci2   );
+
+    printk("\nAhbGate1 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->AhbGate1);
+    print_clk_inf(AhbGate1, Ve      );
+    print_clk_inf(AhbGate1, Lcd0);
+    print_clk_inf(AhbGate1, Lcd1);
+    print_clk_inf(AhbGate1, Csi0);
+    print_clk_inf(AhbGate1, Csi1);
+    print_clk_inf(AhbGate1, Hdmi);
+    print_clk_inf(AhbGate1, Be0);
+    print_clk_inf(AhbGate1, Be1);
+    print_clk_inf(AhbGate1, Fe0);
+    print_clk_inf(AhbGate1, Fe1);
+    print_clk_inf(AhbGate1, Mp);
+    print_clk_inf(AhbGate1, Gpu);
+    print_clk_inf(AhbGate1, MsgBox);
+    print_clk_inf(AhbGate1, SpinLock);
+    print_clk_inf(AhbGate1, Deu0);
+    print_clk_inf(AhbGate1, Deu1);
+    print_clk_inf(AhbGate1, Drc0);
+    print_clk_inf(AhbGate1, Drc1);
+    print_clk_inf(AhbGate1, MtcAcc);
+
+    printk("\nApb1Gate clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Apb1Gate);
+    print_clk_inf(Apb1Gate, Adda      );
+    print_clk_inf(Apb1Gate, Spdif);
+    print_clk_inf(Apb1Gate, Pio);
+    print_clk_inf(Apb1Gate, I2s0);
+    print_clk_inf(Apb1Gate, I2s1);
+
+    printk("\nApb2Gate clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Apb2Gate);
+    print_clk_inf(Apb2Gate, Twi0      );
+    print_clk_inf(Apb2Gate, Twi1);
+    print_clk_inf(Apb2Gate, Twi2);
+    print_clk_inf(Apb2Gate, Twi3);
+    print_clk_inf(Apb2Gate, Uart0);
+    print_clk_inf(Apb2Gate, Uart1);
+    print_clk_inf(Apb2Gate, Uart2);
+    print_clk_inf(Apb2Gate, Uart3);
+    print_clk_inf(Apb2Gate, Uart4);
+    print_clk_inf(Apb2Gate, Uart5);
+
+    print_module0_clock("Nand0", &aw_ccu_reg->Nand0);
+    print_module0_clock("Nand1", &aw_ccu_reg->Nand1);
+    print_module0_clock("Sd0", &aw_ccu_reg->Sd0);
+    print_module0_clock("Sd1", &aw_ccu_reg->Sd1);
+    print_module0_clock("Sd2", &aw_ccu_reg->Sd2);
+    print_module0_clock("Sd3", &aw_ccu_reg->Sd3);
+    print_module0_clock("Ts", &aw_ccu_reg->Ts);
+    print_module0_clock("Ss", &aw_ccu_reg->Ss);
+    print_module0_clock("Spi0", &aw_ccu_reg->Spi0);
+    print_module0_clock("Spi1", &aw_ccu_reg->Spi1);
+    print_module0_clock("Spi2", &aw_ccu_reg->Spi2);
+    print_module0_clock("Spi3", &aw_ccu_reg->Spi3);
+
+    print_module1_clock("I2s0", &aw_ccu_reg->I2s0);
+    print_module1_clock("I2s1", &aw_ccu_reg->I2s1);
+    print_module1_clock("Spdif", &aw_ccu_reg->Spdif);
+
+    printk("\nUsb clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Usb);
+    print_clk_inf(Usb, UsbPhy0Rst      );
+    print_clk_inf(Usb, UsbPhy1Rst);
+    print_clk_inf(Usb, UsbPhy2Rst);
+    print_clk_inf(Usb, Phy0Gate);
+    print_clk_inf(Usb, Phy1Gate);
+    print_clk_inf(Usb, Phy2Gate);
+    print_clk_inf(Usb, Ohci0Gate);
+    print_clk_inf(Usb, Ohci1Gate);
+    print_clk_inf(Usb, Ohci2Gate);
+
+    print_module0_clock("Mdfs", &aw_ccu_reg->Mdfs);
+
+    printk("\nDramCfg clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->DramCfg);
+    print_clk_inf(DramCfg, Div1M      );
+    print_clk_inf(DramCfg, ClkSrc1);
+    print_clk_inf(DramCfg, Div0M);
+    print_clk_inf(DramCfg, ClkSrc0);
+    print_clk_inf(DramCfg, SdrClkUpd);
+    print_clk_inf(DramCfg, CtrlerRst);
+
+    printk("\nDramGate clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->DramGate);
+    print_clk_inf(DramGate, Ve      );
+    print_clk_inf(DramGate, CsiIsp);
+    print_clk_inf(DramGate, Ts);
+    print_clk_inf(DramGate, Drc0);
+    print_clk_inf(DramGate, Drc1);
+    print_clk_inf(DramGate, Deu0);
+    print_clk_inf(DramGate, Deu1);
+    print_clk_inf(DramGate, Fe0);
+    print_clk_inf(DramGate, Fe1);
+    print_clk_inf(DramGate, Be0);
+    print_clk_inf(DramGate, Be1);
+    print_clk_inf(DramGate, Mp);
+
+    print_disp_clock("Be0", &aw_ccu_reg->Be0);
+    print_disp_clock("Be1", &aw_ccu_reg->Be1);
+    print_disp_clock("Fe0", &aw_ccu_reg->Fe0);
+    print_disp_clock("Fe1", &aw_ccu_reg->Fe1);
+    print_disp_clock("Mp", &aw_ccu_reg->Mp);
+    print_disp_clock("Lcd0Ch0", &aw_ccu_reg->Lcd0Ch0);
+    print_disp_clock("Lcd0Ch1", &aw_ccu_reg->Lcd0Ch1);
+    print_disp_clock("Lcd1Ch0", &aw_ccu_reg->Lcd1Ch0);
+    print_disp_clock("Lcd1Ch1", &aw_ccu_reg->Lcd1Ch1);
+
+    printk("\nCsi0 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Csi0);
+    print_clk_inf(Csi0, MClkDiv      );
+    print_clk_inf(Csi0, MClkSrc);
+    print_clk_inf(Csi0, MClkGate);
+    print_clk_inf(Csi0, SClkDiv);
+    print_clk_inf(Csi0, SClkSrc);
+    print_clk_inf(Csi0, SClkGate);
+
+    printk("\nCsi1 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Csi1);
+    print_clk_inf(Csi1, MClkDiv      );
+    print_clk_inf(Csi1, MClkSrc);
+    print_clk_inf(Csi1, MClkGate);
+    print_clk_inf(Csi1, SClkDiv);
+    print_clk_inf(Csi1, SClkSrc);
+    print_clk_inf(Csi1, SClkGate);
+
+    printk("\nVe clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Ve);
+    print_clk_inf(Ve, ClkDiv      );
+    print_clk_inf(Ve, ClkGate      );
+
+    print_module1_clock("Adda", &aw_ccu_reg->Adda);
+    print_module1_clock("Avs", (volatile __ccmu_module1_clk_t *)&aw_ccu_reg->Avs);
+
+    printk("\nHdmi clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Hdmi);
+    print_clk_inf(Hdmi, ClkDiv);
+    print_clk_inf(Hdmi, ClkSrc);
+    print_clk_inf(Hdmi, DDCGate);
+    print_clk_inf(Hdmi, ClkGate);
+
+    print_module1_clock("Ps", &aw_ccu_reg->Ps);
+    print_module0_clock("MtcAcc", &aw_ccu_reg->MtcAcc);
+    print_module0_clock("MBus0", &aw_ccu_reg->MBus0);
+    print_module0_clock("MBus1", &aw_ccu_reg->MBus1);
+
+    printk("\nMipiDsi clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->MipiDsi);
+    print_clk_inf(MipiDsi, PClkDiv);
+    print_clk_inf(MipiDsi, PClkSrc);
+    print_clk_inf(MipiDsi, PClkGate);
+    print_clk_inf(MipiDsi, SClkDiv);
+    print_clk_inf(MipiDsi, SClkSrc);
+    print_clk_inf(MipiDsi, SClkGate);
+
+    printk("\nMipiCsi clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->MipiCsi);
+    print_clk_inf(MipiCsi, PClkDiv);
+    print_clk_inf(MipiCsi, PClkSrc);
+    print_clk_inf(MipiCsi, PClkGate);
+    print_clk_inf(MipiCsi, SClkDiv);
+    print_clk_inf(MipiCsi, SClkSrc);
+    print_clk_inf(MipiCsi, SClkGate);
+
+    print_module0_clock("IepDrc0", &aw_ccu_reg->IepDrc0);
+    print_module0_clock("IepDrc1", &aw_ccu_reg->IepDrc1);
+    print_module0_clock("IepDeu0", &aw_ccu_reg->IepDeu0);
+    print_module0_clock("IepDeu1", &aw_ccu_reg->IepDeu1);
+    print_module0_clock("GpuCore", &aw_ccu_reg->GpuCore);
+    print_module0_clock("GpuMem", &aw_ccu_reg->GpuMem);
+    print_module0_clock("GpuHyd", &aw_ccu_reg->GpuHyd);
+
+    printk("\nPllLock clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->PllLock);
+    print_clk_inf(PllLock, LockTime);
+
+    printk("\nAhbReset0 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->AhbReset0);
+    print_clk_inf(AhbReset0, MipiDsi);
+    print_clk_inf(AhbReset0, Ss);
+    print_clk_inf(AhbReset0, Dma);
+    print_clk_inf(AhbReset0, Sd0);
+    print_clk_inf(AhbReset0, Sd1);
+    print_clk_inf(AhbReset0, Sd2);
+    print_clk_inf(AhbReset0, Sd3);
+    print_clk_inf(AhbReset0, Nand1);
+    print_clk_inf(AhbReset0, Nand0);
+    print_clk_inf(AhbReset0, Sdram);
+    print_clk_inf(AhbReset0, Gmac);
+    print_clk_inf(AhbReset0, Ts);
+    print_clk_inf(AhbReset0, HsTmr);
+    print_clk_inf(AhbReset0, Spi0);
+    print_clk_inf(AhbReset0, Spi1);
+    print_clk_inf(AhbReset0, Spi2);
+    print_clk_inf(AhbReset0, Spi3);
+    print_clk_inf(AhbReset0, Otg);
+    print_clk_inf(AhbReset0, Ehci0);
+    print_clk_inf(AhbReset0, Ehci1);
+    print_clk_inf(AhbReset0, Ohci0);
+    print_clk_inf(AhbReset0, Ohci1);
+    print_clk_inf(AhbReset0, Ohci2);
+
+    printk("\nAhbReset1 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->AhbReset1);
+    print_clk_inf(AhbReset1, Ve);
+    print_clk_inf(AhbReset1, Lcd0);
+    print_clk_inf(AhbReset1, Lcd1);
+    print_clk_inf(AhbReset1, Csi0);
+    print_clk_inf(AhbReset1, Csi1);
+    print_clk_inf(AhbReset1, Hdmi);
+    print_clk_inf(AhbReset1, Be0);
+    print_clk_inf(AhbReset1, Be1);
+    print_clk_inf(AhbReset1, Fe0);
+    print_clk_inf(AhbReset1, Fe1);
+    print_clk_inf(AhbReset1, Mp);
+    print_clk_inf(AhbReset1, Gpu);
+    print_clk_inf(AhbReset1, MsgBox);
+    print_clk_inf(AhbReset1, SpinLock);
+    print_clk_inf(AhbReset1, Deu0);
+    print_clk_inf(AhbReset1, Deu1);
+    print_clk_inf(AhbReset1, Drc0);
+    print_clk_inf(AhbReset1, Drc1);
+    print_clk_inf(AhbReset1, MtcAcc);
+
+    printk("\nAhbReset2 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->AhbReset2);
+    print_clk_inf(AhbReset2, Lvds);
+
+    printk("\nApb1Reset clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Apb1Reset);
+    print_clk_inf(Apb1Reset, Adda);
+    print_clk_inf(Apb1Reset, Spdif);
+    print_clk_inf(Apb1Reset, Pio);
+    print_clk_inf(Apb1Reset, I2s0);
+    print_clk_inf(Apb1Reset, I2s1);
+
+    printk("\nApb2Reset clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Apb2Reset);
+    print_clk_inf(Apb2Reset, Twi0);
+    print_clk_inf(Apb2Reset, Twi1);
+    print_clk_inf(Apb2Reset, Twi2);
+    print_clk_inf(Apb2Reset, Twi3);
+    print_clk_inf(Apb2Reset, Uart0);
+    print_clk_inf(Apb2Reset, Uart1);
+    print_clk_inf(Apb2Reset, Uart2);
+    print_clk_inf(Apb2Reset, Uart3);
+    print_clk_inf(Apb2Reset, Uart4);
+    print_clk_inf(Apb2Reset, Uart5);
+
+    printk("\nClkOutA clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->ClkOutA);
+    print_clk_inf(ClkOutA, DivM);
+    print_clk_inf(ClkOutA, DivN);
+    print_clk_inf(ClkOutA, ClkSrc);
+    print_clk_inf(ClkOutA, ClkEn);
+
+    printk("\nClkOutB clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->ClkOutB);
+    print_clk_inf(ClkOutB, DivM);
+    print_clk_inf(ClkOutB, DivN);
+    print_clk_inf(ClkOutB, ClkSrc);
+    print_clk_inf(ClkOutB, ClkEn);
+
+    printk("\nClkOutC clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->ClkOutC);
+    print_clk_inf(ClkOutC, DivM);
+    print_clk_inf(ClkOutC, DivN);
+    print_clk_inf(ClkOutC, ClkSrc);
+    print_clk_inf(ClkOutC, ClkEn);
+}
+EXPORT_SYMBOL(clk_dbg_inf);
+
+#ifdef CONFIG_PROC_FS
+
+#define sprintf_clk_inf(buf, x, y)     do{seq_printf(buf, "\t"#x"."#y":%d\n", aw_ccu_reg->x.y);}while(0)
+
+static void sprintf_module0_clock(struct seq_file *buf, char *name, volatile __ccmu_module0_clk_t *reg)
+{
+    seq_printf(buf, "\n%s clk infor:(0x%x)\n", name,(unsigned int)reg);
+    seq_printf(buf, "%s.DivM:%d\n", name, reg->DivM);
+    seq_printf(buf, "%s.OutClkCtrl:%d\n", name, reg->OutClkCtrl);
+    seq_printf(buf, "%s.DivN:%d\n", name, reg->DivN);
+    seq_printf(buf, "%s.SampClkCtrl:%d\n", name, reg->SampClkCtrl);
+    seq_printf(buf, "%s.ClkSrc:%d\n", name, reg->ClkSrc);
+    seq_printf(buf, "%s.ClkGate:%d\n", name, reg->ClkGate);
+}
+
+static void sprintf_module1_clock(struct seq_file *buf, char *name, volatile __ccmu_module1_clk_t *reg)
+{
+    seq_printf(buf, "\n%s clk infor:(0x%x)\n", name,(unsigned int)reg);
+    seq_printf(buf, "%s.ClkSrc:%d\n", name, reg->ClkSrc);
+    seq_printf(buf, "%s.ClkGate:%d\n", name, reg->ClkGate);
+}
+
+
+static void sprintf_disp_clock(struct seq_file *buf, char *name, volatile __ccmu_disp_clk_t *reg)
+{
+    seq_printf(buf, "\n%s clk infor:(0x%x)\n", name,(unsigned int)reg);
+    seq_printf(buf, "%s.DivM:%d\n", name, reg->DivM);
+    seq_printf(buf, "%s.ClkSrc:%d\n", name, reg->ClkSrc);
+    seq_printf(buf, "%s.ClkGate:%d\n", name, reg->ClkGate);
+}
+
+
+static void sprintf_mediapll_clock(struct seq_file *buf, char *name, volatile __ccmu_media_pll_t *reg)
+{
+    seq_printf(buf, "\n%s clk infor:(0x%x)\n", name,(unsigned int)reg);
+    seq_printf(buf, "%s.FactorM:%d\n", name, reg->FactorM);
+    seq_printf(buf, "%s.FactorN:%d\n", name, reg->FactorN);
+    seq_printf(buf, "%s.SdmEn:%d\n", name, reg->SdmEn);
+    seq_printf(buf, "%s.ModeSel:%d\n", name, reg->ModeSel);
+    seq_printf(buf, "%s.FracMod:%d\n", name, reg->FracMod);
+    seq_printf(buf, "%s.Lock:%d\n", name, reg->Lock);
+    seq_printf(buf, "%s.CtlMode:%d\n", name, reg->CtlMode);
+    seq_printf(buf, "%s.PLLEn:%d\n", name, reg->PLLEn);
+}
+
+
+static int ccmu_stats_show(struct seq_file *m, void *unused)
+{
+    seq_printf(m, "---------------------------------------------\n");
+    seq_printf(m, "clock information:                           \n");
+    seq_printf(m, "---------------------------------------------\n");
+
+    seq_printf(m, "\nPLL1 infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Pll1Ctl);
+    sprintf_clk_inf(m, Pll1Ctl, FactorM  );
+    sprintf_clk_inf(m, Pll1Ctl, FactorK  );
+    sprintf_clk_inf(m, Pll1Ctl, FactorN  );
+    sprintf_clk_inf(m, Pll1Ctl, SigmaEn  );
+    sprintf_clk_inf(m, Pll1Ctl, Lock     );
+    sprintf_clk_inf(m, Pll1Ctl, PLLEn    );
+
+    seq_printf(m, "\nPLL2 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Pll2Ctl);
+    sprintf_clk_inf(m, Pll2Ctl, FactorM  );
+    sprintf_clk_inf(m, Pll2Ctl, FactorN  );
+    sprintf_clk_inf(m, Pll2Ctl, FactorP  );
+    sprintf_clk_inf(m, Pll2Ctl, SdmEn    );
+    sprintf_clk_inf(m, Pll2Ctl, Lock     );
+    sprintf_clk_inf(m, Pll2Ctl, PLLEn    );
+
+    seq_printf(m, "\nPLL3 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Pll3Ctl);
+    sprintf_clk_inf(m, Pll3Ctl, FactorM  );
+    sprintf_clk_inf(m, Pll3Ctl, FactorN  );
+    sprintf_clk_inf(m, Pll3Ctl, SdmEn    );
+    sprintf_clk_inf(m, Pll3Ctl, ModeSel  );
+    sprintf_clk_inf(m, Pll3Ctl, FracMod  );
+    sprintf_clk_inf(m, Pll3Ctl, Lock     );
+    sprintf_clk_inf(m, Pll3Ctl, CtlMode  );
+    sprintf_clk_inf(m, Pll3Ctl, PLLEn    );
+
+    sprintf_mediapll_clock(m, "Pll4Ctl", &aw_ccu_reg->Pll4Ctl);
+
+    seq_printf(m, "\nPll5Ctl clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Pll5Ctl);
+    sprintf_clk_inf(m, Pll5Ctl, FactorM      );
+    sprintf_clk_inf(m, Pll5Ctl, FactorK      );
+    sprintf_clk_inf(m, Pll5Ctl, FactorN      );
+    sprintf_clk_inf(m, Pll5Ctl, PLLCfgUpdate );
+    sprintf_clk_inf(m, Pll5Ctl, SigmaDeltaEn );
+    sprintf_clk_inf(m, Pll5Ctl, Lock         );
+    sprintf_clk_inf(m, Pll5Ctl, PLLEn        );
+
+    seq_printf(m, "\nPll6Ctl clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Pll6Ctl);
+    sprintf_clk_inf(m, Pll6Ctl, FactorM      );
+    sprintf_clk_inf(m, Pll6Ctl, FactorK      );
+    sprintf_clk_inf(m, Pll6Ctl, FactorN      );
+    sprintf_clk_inf(m, Pll6Ctl, Pll24MPdiv   );
+    sprintf_clk_inf(m, Pll6Ctl, Pll24MOutEn  );
+    sprintf_clk_inf(m, Pll6Ctl, PllClkOutEn  );
+    sprintf_clk_inf(m, Pll6Ctl, PLLBypass    );
+    sprintf_clk_inf(m, Pll6Ctl, Lock         );
+    sprintf_clk_inf(m, Pll6Ctl, PLLEn        );
+
+    sprintf_mediapll_clock(m, "Pll7Ctl", &aw_ccu_reg->Pll7Ctl);
+    sprintf_mediapll_clock(m, "Pll8Ctl", &aw_ccu_reg->Pll8Ctl);
+
+    seq_printf(m, "\nMipiPllCtl clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->MipiPllCtl);
+    sprintf_clk_inf(m, MipiPllCtl, FactorM   );
+    sprintf_clk_inf(m, MipiPllCtl, FactorK   );
+    sprintf_clk_inf(m, MipiPllCtl, FactorN   );
+    sprintf_clk_inf(m, MipiPllCtl, VfbSel    );
+    sprintf_clk_inf(m, MipiPllCtl, FeedBackDiv   );
+    sprintf_clk_inf(m, MipiPllCtl, SdmEn     );
+    sprintf_clk_inf(m, MipiPllCtl, PllSrc    );
+    sprintf_clk_inf(m, MipiPllCtl, Ldo2En    );
+    sprintf_clk_inf(m, MipiPllCtl, Ldo1En    );
+    sprintf_clk_inf(m, MipiPllCtl, Sel625Or750   );
+    sprintf_clk_inf(m, MipiPllCtl, SDiv2     );
+    sprintf_clk_inf(m, MipiPllCtl, FracMode  );
+    sprintf_clk_inf(m, MipiPllCtl, Lock      );
+    sprintf_clk_inf(m, MipiPllCtl, PLLEn     );
+
+    sprintf_mediapll_clock(m, "Pll9Ctl", &aw_ccu_reg->Pll9Ctl);
+    sprintf_mediapll_clock(m, "Pll10Ctl", &aw_ccu_reg->Pll10Ctl);
+
+    seq_printf(m, "\nSysClkDiv clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->SysClkDiv);
+    sprintf_clk_inf(m, SysClkDiv, AXIClkDiv   );
+    sprintf_clk_inf(m, SysClkDiv, CpuClkSrc   );
+
+    seq_printf(m, "\nAhb1Div clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Ahb1Div);
+    sprintf_clk_inf(m, Ahb1Div, Ahb1Div      );
+    sprintf_clk_inf(m, Ahb1Div, Ahb1PreDiv   );
+    sprintf_clk_inf(m, Ahb1Div, Apb1Div      );
+    sprintf_clk_inf(m, Ahb1Div, Ahb1ClkSrc   );
+
+    seq_printf(m, "\nApb2Div clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Apb2Div);
+    sprintf_clk_inf(m, Apb2Div, DivM      );
+    sprintf_clk_inf(m, Apb2Div, DivN      );
+    sprintf_clk_inf(m, Apb2Div, ClkSrc      );
+
+    seq_printf(m, "\nAxiGate clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->AxiGate);
+    sprintf_clk_inf(m, AxiGate, Sdram      );
+
+    seq_printf(m, "\nAhbGate0 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->AhbGate0);
+    sprintf_clk_inf(m, AhbGate0, MipiCsi      );
+    sprintf_clk_inf(m, AhbGate0, MipiDsi );
+    sprintf_clk_inf(m, AhbGate0, Ss      );
+    sprintf_clk_inf(m, AhbGate0, Dma     );
+    sprintf_clk_inf(m, AhbGate0, Sd0     );
+    sprintf_clk_inf(m, AhbGate0, Sd1     );
+    sprintf_clk_inf(m, AhbGate0, Sd2     );
+    sprintf_clk_inf(m, AhbGate0, Sd3     );
+    sprintf_clk_inf(m, AhbGate0, Nand1   );
+    sprintf_clk_inf(m, AhbGate0, Nand0   );
+    sprintf_clk_inf(m, AhbGate0, Dram    );
+    sprintf_clk_inf(m, AhbGate0, Gmac    );
+    sprintf_clk_inf(m, AhbGate0, Ts      );
+    sprintf_clk_inf(m, AhbGate0, HsTmr   );
+    sprintf_clk_inf(m, AhbGate0, Spi0    );
+    sprintf_clk_inf(m, AhbGate0, Spi1    );
+    sprintf_clk_inf(m, AhbGate0, Spi2    );
+    sprintf_clk_inf(m, AhbGate0, Spi3    );
+    sprintf_clk_inf(m, AhbGate0, Otg     );
+    sprintf_clk_inf(m, AhbGate0, Ehci0   );
+    sprintf_clk_inf(m, AhbGate0, Ehci1   );
+    sprintf_clk_inf(m, AhbGate0, Ohci0   );
+    sprintf_clk_inf(m, AhbGate0, Ohci1   );
+    sprintf_clk_inf(m, AhbGate0, Ohci2   );
+
+    seq_printf(m, "\nAhbGate1 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->AhbGate1);
+    sprintf_clk_inf(m, AhbGate1, Ve      );
+    sprintf_clk_inf(m, AhbGate1, Lcd0);
+    sprintf_clk_inf(m, AhbGate1, Lcd1);
+    sprintf_clk_inf(m, AhbGate1, Csi0);
+    sprintf_clk_inf(m, AhbGate1, Csi1);
+    sprintf_clk_inf(m, AhbGate1, Hdmi);
+    sprintf_clk_inf(m, AhbGate1, Be0);
+    sprintf_clk_inf(m, AhbGate1, Be1);
+    sprintf_clk_inf(m, AhbGate1, Fe0);
+    sprintf_clk_inf(m, AhbGate1, Fe1);
+    sprintf_clk_inf(m, AhbGate1, Mp);
+    sprintf_clk_inf(m, AhbGate1, Gpu);
+    sprintf_clk_inf(m, AhbGate1, MsgBox);
+    sprintf_clk_inf(m, AhbGate1, SpinLock);
+    sprintf_clk_inf(m, AhbGate1, Deu0);
+    sprintf_clk_inf(m, AhbGate1, Deu1);
+    sprintf_clk_inf(m, AhbGate1, Drc0);
+    sprintf_clk_inf(m, AhbGate1, Drc1);
+    sprintf_clk_inf(m, AhbGate1, MtcAcc);
+
+    seq_printf(m, "\nApb1Gate clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Apb1Gate);
+    sprintf_clk_inf(m, Apb1Gate, Adda      );
+    sprintf_clk_inf(m, Apb1Gate, Spdif);
+    sprintf_clk_inf(m, Apb1Gate, Pio);
+    sprintf_clk_inf(m, Apb1Gate, I2s0);
+    sprintf_clk_inf(m, Apb1Gate, I2s1);
+
+    seq_printf(m, "\nApb2Gate clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Apb2Gate);
+    sprintf_clk_inf(m, Apb2Gate, Twi0      );
+    sprintf_clk_inf(m, Apb2Gate, Twi1);
+    sprintf_clk_inf(m, Apb2Gate, Twi2);
+    sprintf_clk_inf(m, Apb2Gate, Twi3);
+    sprintf_clk_inf(m, Apb2Gate, Uart0);
+    sprintf_clk_inf(m, Apb2Gate, Uart1);
+    sprintf_clk_inf(m, Apb2Gate, Uart2);
+    sprintf_clk_inf(m, Apb2Gate, Uart3);
+    sprintf_clk_inf(m, Apb2Gate, Uart4);
+    sprintf_clk_inf(m, Apb2Gate, Uart5);
+
+    sprintf_module0_clock(m, "Nand0", &aw_ccu_reg->Nand0);
+    sprintf_module0_clock(m, "Nand1", &aw_ccu_reg->Nand1);
+    sprintf_module0_clock(m, "Sd0", &aw_ccu_reg->Sd0);
+    sprintf_module0_clock(m, "Sd1", &aw_ccu_reg->Sd1);
+    sprintf_module0_clock(m, "Sd2", &aw_ccu_reg->Sd2);
+    sprintf_module0_clock(m, "Sd3", &aw_ccu_reg->Sd3);
+    sprintf_module0_clock(m, "Ts", &aw_ccu_reg->Ts);
+    sprintf_module0_clock(m, "Ss", &aw_ccu_reg->Ss);
+    sprintf_module0_clock(m, "Spi0", &aw_ccu_reg->Spi0);
+    sprintf_module0_clock(m, "Spi1", &aw_ccu_reg->Spi1);
+    sprintf_module0_clock(m, "Spi2", &aw_ccu_reg->Spi2);
+    sprintf_module0_clock(m, "Spi3", &aw_ccu_reg->Spi3);
+
+    sprintf_module1_clock(m, "I2s0", &aw_ccu_reg->I2s0);
+    sprintf_module1_clock(m, "I2s1", &aw_ccu_reg->I2s1);
+    sprintf_module1_clock(m, "Spdif", &aw_ccu_reg->Spdif);
+
+    seq_printf(m, "\nUsb clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Usb);
+    sprintf_clk_inf(m, Usb, UsbPhy0Rst      );
+    sprintf_clk_inf(m, Usb, UsbPhy1Rst);
+    sprintf_clk_inf(m, Usb, UsbPhy2Rst);
+    sprintf_clk_inf(m, Usb, Phy0Gate);
+    sprintf_clk_inf(m, Usb, Phy1Gate);
+    sprintf_clk_inf(m, Usb, Phy2Gate);
+    sprintf_clk_inf(m, Usb, Ohci0Gate);
+    sprintf_clk_inf(m, Usb, Ohci1Gate);
+    sprintf_clk_inf(m, Usb, Ohci2Gate);
+
+    sprintf_module0_clock(m, "Mdfs", &aw_ccu_reg->Mdfs);
+
+    seq_printf(m, "\nDramCfg clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->DramCfg);
+    sprintf_clk_inf(m, DramCfg, Div1M      );
+    sprintf_clk_inf(m, DramCfg, ClkSrc1);
+    sprintf_clk_inf(m, DramCfg, Div0M);
+    sprintf_clk_inf(m, DramCfg, ClkSrc0);
+    sprintf_clk_inf(m, DramCfg, SdrClkUpd);
+    sprintf_clk_inf(m, DramCfg, CtrlerRst);
+
+    seq_printf(m, "\nDramGate clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->DramGate);
+    sprintf_clk_inf(m, DramGate, Ve      );
+    sprintf_clk_inf(m, DramGate, CsiIsp);
+    sprintf_clk_inf(m, DramGate, Ts);
+    sprintf_clk_inf(m, DramGate, Drc0);
+    sprintf_clk_inf(m, DramGate, Drc1);
+    sprintf_clk_inf(m, DramGate, Deu0);
+    sprintf_clk_inf(m, DramGate, Deu1);
+    sprintf_clk_inf(m, DramGate, Fe0);
+    sprintf_clk_inf(m, DramGate, Fe1);
+    sprintf_clk_inf(m, DramGate, Be0);
+    sprintf_clk_inf(m, DramGate, Be1);
+    sprintf_clk_inf(m, DramGate, Mp);
+
+    sprintf_disp_clock(m, "Be0", &aw_ccu_reg->Be0);
+    sprintf_disp_clock(m, "Be1", &aw_ccu_reg->Be1);
+    sprintf_disp_clock(m, "Fe0", &aw_ccu_reg->Fe0);
+    sprintf_disp_clock(m, "Fe1", &aw_ccu_reg->Fe1);
+    sprintf_disp_clock(m, "Mp", &aw_ccu_reg->Mp);
+    sprintf_disp_clock(m, "Lcd0Ch0", &aw_ccu_reg->Lcd0Ch0);
+    sprintf_disp_clock(m, "Lcd0Ch1", &aw_ccu_reg->Lcd0Ch1);
+    sprintf_disp_clock(m, "Lcd1Ch0", &aw_ccu_reg->Lcd1Ch0);
+    sprintf_disp_clock(m, "Lcd1Ch1", &aw_ccu_reg->Lcd1Ch1);
+
+    seq_printf(m, "\nCsi0 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Csi0);
+    sprintf_clk_inf(m, Csi0, MClkDiv      );
+    sprintf_clk_inf(m, Csi0, MClkSrc);
+    sprintf_clk_inf(m, Csi0, MClkGate);
+    sprintf_clk_inf(m, Csi0, SClkDiv);
+    sprintf_clk_inf(m, Csi0, SClkSrc);
+    sprintf_clk_inf(m, Csi0, SClkGate);
+
+    seq_printf(m, "\nCsi1 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Csi1);
+    sprintf_clk_inf(m, Csi1, MClkDiv      );
+    sprintf_clk_inf(m, Csi1, MClkSrc);
+    sprintf_clk_inf(m, Csi1, MClkGate);
+    sprintf_clk_inf(m, Csi1, SClkDiv);
+    sprintf_clk_inf(m, Csi1, SClkSrc);
+    sprintf_clk_inf(m, Csi1, SClkGate);
+
+    seq_printf(m, "\nVe clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Ve);
+    sprintf_clk_inf(m, Ve, ClkDiv      );
+    sprintf_clk_inf(m, Ve, ClkGate      );
+
+    sprintf_module1_clock(m, "Adda", &aw_ccu_reg->Adda);
+    sprintf_module1_clock(m, "Avs", (volatile __ccmu_module1_clk_t *)&aw_ccu_reg->Avs);
+
+    seq_printf(m, "\nHdmi clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Hdmi);
+    sprintf_clk_inf(m, Hdmi, ClkDiv);
+    sprintf_clk_inf(m, Hdmi, ClkSrc);
+    sprintf_clk_inf(m, Hdmi, DDCGate);
+    sprintf_clk_inf(m, Hdmi, ClkGate);
+
+    sprintf_module1_clock(m, "Ps", &aw_ccu_reg->Ps);
+    sprintf_module0_clock(m, "MtcAcc", &aw_ccu_reg->MtcAcc);
+    sprintf_module0_clock(m, "MBus0", &aw_ccu_reg->MBus0);
+    sprintf_module0_clock(m, "MBus1", &aw_ccu_reg->MBus1);
+
+    seq_printf(m, "\nMipiDsi clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->MipiDsi);
+    sprintf_clk_inf(m, MipiDsi, PClkDiv);
+    sprintf_clk_inf(m, MipiDsi, PClkSrc);
+    sprintf_clk_inf(m, MipiDsi, PClkGate);
+    sprintf_clk_inf(m, MipiDsi, SClkDiv);
+    sprintf_clk_inf(m, MipiDsi, SClkSrc);
+    sprintf_clk_inf(m, MipiDsi, SClkGate);
+
+    seq_printf(m, "\nMipiCsi clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->MipiCsi);
+    sprintf_clk_inf(m, MipiCsi, PClkDiv);
+    sprintf_clk_inf(m, MipiCsi, PClkSrc);
+    sprintf_clk_inf(m, MipiCsi, PClkGate);
+    sprintf_clk_inf(m, MipiCsi, SClkDiv);
+    sprintf_clk_inf(m, MipiCsi, SClkSrc);
+    sprintf_clk_inf(m, MipiCsi, SClkGate);
+
+    sprintf_module0_clock(m, "IepDrc0", &aw_ccu_reg->IepDrc0);
+    sprintf_module0_clock(m, "IepDrc1", &aw_ccu_reg->IepDrc1);
+    sprintf_module0_clock(m, "IepDeu0", &aw_ccu_reg->IepDeu0);
+    sprintf_module0_clock(m, "IepDeu1", &aw_ccu_reg->IepDeu1);
+    sprintf_module0_clock(m, "GpuCore", &aw_ccu_reg->GpuCore);
+    sprintf_module0_clock(m, "GpuMem", &aw_ccu_reg->GpuMem);
+    sprintf_module0_clock(m, "GpuHyd", &aw_ccu_reg->GpuHyd);
+
+    seq_printf(m, "\nPllLock clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->PllLock);
+    sprintf_clk_inf(m, PllLock, LockTime);
+
+    seq_printf(m, "\nAhbReset0 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->AhbReset0);
+    sprintf_clk_inf(m, AhbReset0, MipiDsi);
+    sprintf_clk_inf(m, AhbReset0, Ss);
+    sprintf_clk_inf(m, AhbReset0, Dma);
+    sprintf_clk_inf(m, AhbReset0, Sd0);
+    sprintf_clk_inf(m, AhbReset0, Sd1);
+    sprintf_clk_inf(m, AhbReset0, Sd2);
+    sprintf_clk_inf(m, AhbReset0, Sd3);
+    sprintf_clk_inf(m, AhbReset0, Nand1);
+    sprintf_clk_inf(m, AhbReset0, Nand0);
+    sprintf_clk_inf(m, AhbReset0, Sdram);
+    sprintf_clk_inf(m, AhbReset0, Gmac);
+    sprintf_clk_inf(m, AhbReset0, Ts);
+    sprintf_clk_inf(m, AhbReset0, HsTmr);
+    sprintf_clk_inf(m, AhbReset0, Spi0);
+    sprintf_clk_inf(m, AhbReset0, Spi1);
+    sprintf_clk_inf(m, AhbReset0, Spi2);
+    sprintf_clk_inf(m, AhbReset0, Spi3);
+    sprintf_clk_inf(m, AhbReset0, Otg);
+    sprintf_clk_inf(m, AhbReset0, Ehci0);
+    sprintf_clk_inf(m, AhbReset0, Ehci1);
+    sprintf_clk_inf(m, AhbReset0, Ohci0);
+    sprintf_clk_inf(m, AhbReset0, Ohci1);
+    sprintf_clk_inf(m, AhbReset0, Ohci2);
+
+    seq_printf(m, "\nAhbReset1 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->AhbReset1);
+    sprintf_clk_inf(m, AhbReset1, Ve);
+    sprintf_clk_inf(m, AhbReset1, Lcd0);
+    sprintf_clk_inf(m, AhbReset1, Lcd1);
+    sprintf_clk_inf(m, AhbReset1, Csi0);
+    sprintf_clk_inf(m, AhbReset1, Csi1);
+    sprintf_clk_inf(m, AhbReset1, Hdmi);
+    sprintf_clk_inf(m, AhbReset1, Be0);
+    sprintf_clk_inf(m, AhbReset1, Be1);
+    sprintf_clk_inf(m, AhbReset1, Fe0);
+    sprintf_clk_inf(m, AhbReset1, Fe1);
+    sprintf_clk_inf(m, AhbReset1, Mp);
+    sprintf_clk_inf(m, AhbReset1, Gpu);
+    sprintf_clk_inf(m, AhbReset1, MsgBox);
+    sprintf_clk_inf(m, AhbReset1, SpinLock);
+    sprintf_clk_inf(m, AhbReset1, Deu0);
+    sprintf_clk_inf(m, AhbReset1, Deu1);
+    sprintf_clk_inf(m, AhbReset1, Drc0);
+    sprintf_clk_inf(m, AhbReset1, Drc1);
+    sprintf_clk_inf(m, AhbReset1, MtcAcc);
+
+    seq_printf(m, "\nAhbReset2 clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->AhbReset2);
+    sprintf_clk_inf(m, AhbReset2, Lvds);
+
+    seq_printf(m, "\nApb1Reset clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Apb1Reset);
+    sprintf_clk_inf(m, Apb1Reset, Adda);
+    sprintf_clk_inf(m, Apb1Reset, Spdif);
+    sprintf_clk_inf(m, Apb1Reset, Pio);
+    sprintf_clk_inf(m, Apb1Reset, I2s0);
+    sprintf_clk_inf(m, Apb1Reset, I2s1);
+
+    seq_printf(m, "\nApb2Reset clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->Apb2Reset);
+    sprintf_clk_inf(m, Apb2Reset, Twi0);
+    sprintf_clk_inf(m, Apb2Reset, Twi1);
+    sprintf_clk_inf(m, Apb2Reset, Twi2);
+    sprintf_clk_inf(m, Apb2Reset, Twi3);
+    sprintf_clk_inf(m, Apb2Reset, Uart0);
+    sprintf_clk_inf(m, Apb2Reset, Uart1);
+    sprintf_clk_inf(m, Apb2Reset, Uart2);
+    sprintf_clk_inf(m, Apb2Reset, Uart3);
+    sprintf_clk_inf(m, Apb2Reset, Uart4);
+    sprintf_clk_inf(m, Apb2Reset, Uart5);
+
+    seq_printf(m, "\nClkOutA clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->ClkOutA);
+    sprintf_clk_inf(m, ClkOutA, DivM);
+    sprintf_clk_inf(m, ClkOutA, DivN);
+    sprintf_clk_inf(m, ClkOutA, ClkSrc);
+    sprintf_clk_inf(m, ClkOutA, ClkEn);
+
+    seq_printf(m, "\nClkOutB clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->ClkOutB);
+    sprintf_clk_inf(m, ClkOutB, DivM);
+    sprintf_clk_inf(m, ClkOutB, DivN);
+    sprintf_clk_inf(m, ClkOutB, ClkSrc);
+    sprintf_clk_inf(m, ClkOutB, ClkEn);
+
+    seq_printf(m, "\nClkOutC clk infor:(0x%x)\n", (unsigned int)&aw_ccu_reg->ClkOutC);
+    sprintf_clk_inf(m, ClkOutC, DivM);
+    sprintf_clk_inf(m, ClkOutC, DivN);
+    sprintf_clk_inf(m, ClkOutC, ClkSrc);
+    sprintf_clk_inf(m, ClkOutC, ClkEn);
+
+	return 0;
+}
+
+
+static int ccmu_stats_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ccmu_stats_show, NULL);
+}
+
+static const struct file_operations ccmu_dbg_fops = {
+	.owner = THIS_MODULE,
+	.open = ccmu_stats_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int __init ccu_dbg_init(void)
+{
+	proc_create("ccmu", S_IRUGO, NULL, &ccmu_dbg_fops);
+	return 0;
+}
+
+static void  __exit ccu_dbg_exit(void)
+{
+	remove_proc_entry("ccmu", NULL);
+}
+
+core_initcall(ccu_dbg_init);
+module_exit(ccu_dbg_exit);
+#endif
diff --git a/arch/arm/mach-sun6i/clock/ccu_sysfs.c b/arch/arm/mach-sun6i/clock/ccu_sysfs.c
new file mode 100644
index 0000000..97e6d40
--- /dev/null
+++ b/arch/arm/mach-sun6i/clock/ccu_sysfs.c
@@ -0,0 +1,492 @@
+/*
+ * arch/arm/mach-sun6i/clock/ccu_sysfs.c
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i ccu sysfs driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/kdev_t.h>
+#include <linux/clk.h>
+
+#include "ccm_i.h"
+#include "ccu_sysfs.h"
+
+/* __ccu_export/export_store/ccu_attr_group/clk_get */
+
+static DEFINE_MUTEX(sysfs_lock);
+
+/* clock handle for sunxi clock */
+struct ccu_sysfs_handle {
+	bool 	exported;
+	char	name[256];
+	__aw_ccu_clk_id_e id;
+	struct clk *clk;
+};
+static struct ccu_sysfs_handle g_clk_handle[AW_CCU_CLK_CNT];
+
+ssize_t ccu_export_store(struct class *class,
+				struct class_attribute *attr,
+				const char *buf, size_t len);
+ssize_t ccu_unexport_store(struct class *class,
+				struct class_attribute *attr,
+				const char *buf, size_t len);
+
+static struct class_attribute ccu_class_attrs[] = {
+	__ATTR(export, 0200, NULL, ccu_export_store),
+	__ATTR(unexport, 0200, NULL, ccu_unexport_store),
+	__ATTR_NULL,
+};
+
+static struct class ccu_class = {
+	.name =		"ccu",
+	.owner =	THIS_MODULE,
+
+	.class_attrs =	ccu_class_attrs,
+};
+
+static __aw_ccu_clk_id_e __get_clock_id(char *clock_name)
+{
+	u32 	i = 0;
+
+	for(i = 0; i < (u32)AW_CCU_CLK_CNT; i++)
+		//if(0 == strcmp(aw_ccu_clk_tbl[i].name, (const char *)clock_name))
+		if(true == sysfs_streq(aw_ccu_clk_tbl[i].name, (const char *)clock_name))
+			return aw_ccu_clk_tbl[i].id;
+
+	CCU_ERR("%s err: could not find id for clock %s\n", __func__, clock_name);
+	return AW_SYS_CLK_NONE;
+}
+
+#if 0
+static bool __get_clock_name(__aw_ccu_clk_id_e clock_id, char *clock_name)
+{
+	u32 i = 0;
+
+	for(i = 0; i < (u32)AW_CCU_CLK_CNT; i++)
+		if(aw_ccu_clk_tbl[i].id == clock_id) {
+			strcpy(clock_name, aw_ccu_clk_tbl[i].name);
+			return true;
+		}
+	return false;
+}
+#endif
+
+static int __match_export(struct device *dev, void *data)
+{
+	return dev_get_drvdata(dev) == data;
+}
+
+static ssize_t ccu_rate_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	unsigned long rate = 0;
+	struct ccu_sysfs_handle	*pclk_handle = dev_get_drvdata(dev);
+
+	if(NULL == pclk_handle->clk) {
+		CCU_ERR("%s err, line %d\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	rate = clk_get_rate(pclk_handle->clk);
+	CCU_DBG("%s: get rate %d\n", __func__, (int)rate);
+
+	return sprintf(buf, "%d\n", (int)rate);
+}
+
+static ssize_t ccu_rate_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	u32 	usign = 0;
+	long 	itemp = 0;
+	struct ccu_sysfs_handle	*pclk_handle = dev_get_drvdata(dev);
+
+	CCU_ASSERT_GOTO(NULL != pclk_handle->clk, usign, end);
+
+	CCU_ASSERT_GOTO(strict_strtol(buf, 0, &itemp) >= 0, usign, end);
+	CCU_DBG("%s: rate to set is %d\n", __func__, (int)itemp);
+
+	CCU_ASSERT_GOTO(0 == clk_set_rate(pclk_handle->clk, itemp), usign, end);
+	CCU_DBG("%s: clk_set_rate success\n", __func__);
+
+end:
+	if(0 != usign) {
+		CCU_ERR("%s err, line %d\n", __func__, usign);
+		return -EINVAL;
+	}
+	return size;
+}
+static DEVICE_ATTR(rate, 0666, ccu_rate_show, ccu_rate_store);
+
+static ssize_t ccu_reset_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	u32 	usign = 0;
+	long 	itemp = 0;
+	struct ccu_sysfs_handle	*pclk_handle = dev_get_drvdata(dev);
+
+	CCU_ASSERT_GOTO(NULL != pclk_handle->clk, usign, end);
+
+	CCU_ASSERT_GOTO(strict_strtol(buf, 0, &itemp) >= 0, usign, end);
+	CCU_DBG("%s: para itemp is %d\n", __func__, (int)itemp);
+
+	switch(itemp) {
+	case 1: /* reset */
+		CCU_ASSERT_GOTO(0 == clk_reset(pclk_handle->clk, AW_CCU_CLK_RESET), usign, end);
+		CCU_DBG("%s: clk_reset - RESET success\n", __func__);
+		break;
+	case 0: /* nreset */
+		CCU_ASSERT_GOTO(0 == clk_reset(pclk_handle->clk, AW_CCU_CLK_NRESET), usign, end);
+		CCU_DBG("%s: clk_reset - NRESET success\n", __func__);
+		break;
+	default:
+		usign = __LINE__;
+		break;
+	}
+
+end:
+	if(0 != usign) {
+		CCU_ERR("%s err, line %d\n", __func__, (int)usign);
+		return -EINVAL;
+	}
+	return size;
+}
+static DEVICE_ATTR(reset, 0222, NULL, ccu_reset_store);
+
+static ssize_t ccu_enable_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	u32 	usign = 0;
+	long 	itemp = 0;
+	struct ccu_sysfs_handle	*pclk_handle = dev_get_drvdata(dev);
+
+	CCU_ASSERT_GOTO(NULL != pclk_handle->clk, usign, end);
+
+	CCU_ASSERT_GOTO(strict_strtol(buf, 0, &itemp) >= 0, usign, end);
+	CCU_DBG("%s: para itemp is %d\n", __func__, (int)itemp);
+
+	switch(itemp) {
+	case 1: /* enable clock */
+		CCU_ASSERT_GOTO(0 == clk_enable(pclk_handle->clk), usign, end);
+		CCU_DBG("%s: clk_enable success\n", __func__);
+		break;
+	case 0: /* disable clock */
+		clk_disable(pclk_handle->clk);
+		break;
+	default:
+		usign = __LINE__;
+		break;
+	}
+
+end:
+	if(0 != usign) {
+		CCU_ERR("%s err, line %d\n", __func__, (int)usign);
+		return -EINVAL;
+	}
+	return size;
+}
+static DEVICE_ATTR(enable, 0222, NULL, ccu_enable_store);
+
+static ssize_t ccu_parent_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 	usign = 0;
+	struct clk *clk_parent = NULL;
+	struct ccu_sysfs_handle	*pclk_handle = dev_get_drvdata(dev);
+
+	if(NULL == pclk_handle->clk) {
+		usign = __LINE__;
+		goto err;
+	}
+
+	clk_parent = clk_get_parent(pclk_handle->clk);
+	if(NULL == clk_parent) {
+		usign = __LINE__;
+		goto err;
+	}
+	CCU_DBG("%s: get parent name %s\n", __func__, clk_parent->aw_clk->name);
+
+	return sprintf(buf, "%s\n", clk_parent->aw_clk->name);
+
+err:
+	CCU_ERR("%s err, line %d\n", __func__, (int)usign);
+	return -EINVAL;
+}
+
+static ssize_t ccu_parent_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	u32 		usign = 0;
+	struct clk 	*parent = NULL;
+	__aw_ccu_clk_id_e 	clk_id = AW_SYS_CLK_NONE;
+	struct ccu_sysfs_handle	*pclk_handle = dev_get_drvdata(dev);
+
+	if(NULL == pclk_handle->clk) {
+		usign = __LINE__;
+		goto end;
+	}
+
+	clk_id = __get_clock_id((char *)buf);
+	if(AW_SYS_CLK_NONE == clk_id) {
+		usign = __LINE__;
+		goto end;
+	}
+	CCU_DBG("%s: parent name %s, id %d\n", __func__, buf, (int)clk_id);
+
+	parent = &aw_clock[clk_id];
+	if(0 != clk_set_parent(pclk_handle->clk, parent)) {
+		usign = __LINE__;
+		goto end;
+	}
+	CCU_DBG("%s: clk_set_parent success\n", __func__);
+
+end:
+	if(0 != usign) {
+		CCU_ERR("%s err, line %d\n", __func__, (int)usign);
+		return -EINVAL;
+	}
+	return size;
+}
+static DEVICE_ATTR(parent, 0666, ccu_parent_show, ccu_parent_store);
+
+static ssize_t ccu_get_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int 		i = -1;
+	struct ccu_sysfs_handle	*pclk_handle = dev_get_drvdata(dev);
+
+	if (strict_strtol(buf, 0, (long *)&i) < 0) {
+		CCU_ERR("%s err: strict_strtol %s failed\n", __func__, buf);
+		return -EINVAL;
+	}
+
+	if(0 == i) { /* to clk_put */
+		if(NULL == pclk_handle->clk) {
+			CCU_ERR("%s err: clock %s not got yet\n", __func__, pclk_handle->name);
+			return -EINVAL;
+		} else {
+			clk_put(pclk_handle->clk);
+			pclk_handle->clk = NULL;
+		}
+	} else if(1 == i) { /* to clk_get */
+		if(NULL != pclk_handle->clk) {
+			CCU_ERR("%s err: clock %s already got, handle 0x%08x\n", __func__,
+				pclk_handle->name, (u32)pclk_handle->clk);
+			return -EINVAL;
+		} else {
+			pclk_handle->clk = clk_get(NULL, pclk_handle->name);
+			if(IS_ERR(pclk_handle->clk)) {
+				CCU_ERR("%s err: get clock %s failed\n", __func__, pclk_handle->name);
+				return -EINVAL;
+			}
+			CCU_DBG("%s: clk_get %s success, ret 0x%08x\n", __func__, pclk_handle->name, (u32)pclk_handle->clk);
+		}
+	} else {
+		CCU_ERR("%s err: para %s invalid\n", __func__, buf);
+		return -EINVAL;
+	}
+
+	return size;
+}
+static DEVICE_ATTR(get, 0222, NULL, ccu_get_store);
+
+static const struct attribute *ccu_attrs[] = {
+	&dev_attr_get.attr,
+	&dev_attr_parent.attr,
+	&dev_attr_rate.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_reset.attr,
+	NULL,
+};
+
+static const struct attribute_group ccu_attr_group = {
+	.attrs = (struct attribute **)ccu_attrs,
+};
+
+bool __ccu_export(char *clock_name, __aw_ccu_clk_id_e clock_id)
+{
+	int	status = -EINVAL;
+	struct device	*dev = NULL;
+
+	/* get clock id and name for g_clk_handle[i] */
+	g_clk_handle[clock_id].id = clock_id;
+	strcpy(g_clk_handle[clock_id].name, clock_name);
+	CCU_DBG("%s: g_clk_handle[i] - id %d, name %s\n", __func__,
+		(int)clock_id, g_clk_handle[clock_id].name);
+
+	/* create device dir */
+	dev = device_create(&ccu_class, NULL, MKDEV(0, 0), (void *)&g_clk_handle[clock_id], clock_name);
+	if(!IS_ERR(dev)) {
+		status = sysfs_create_group(&dev->kobj,	&ccu_attr_group);
+		if (status != 0) {
+			device_unregister(dev);
+			CCU_ERR("%s err: sysfs_create_group failed, status %d\n", __func__, status);
+		}
+	} else
+		status = PTR_ERR(dev);
+
+	if(status) {
+		CCU_ERR("%s %s err, status %d\n", __func__, clock_name, status);
+		return false;
+	}
+
+	CCU_DBG("%s %s success\n", __func__, clock_name);
+	return true;
+}
+
+bool __ccu_unexport(char *clk_name, __aw_ccu_clk_id_e clk_id)
+{
+	u32 	usign = 0;
+	struct device	*dev = NULL;
+
+	/* must release clock handle first, echo 0 > get */
+	CCU_ASSERT_GOTO(NULL == g_clk_handle[clk_id].clk, usign, end);
+
+	dev = class_find_device(&ccu_class, NULL, &g_clk_handle[clk_id], __match_export);
+	if(dev) {
+		CCU_DBG("%s: class_find_device success\n", __func__);
+		put_device(dev);
+		device_unregister(dev);
+	} else {
+		usign = __LINE__;
+		goto end;
+	}
+
+end:
+	if(0 != usign) {
+		CCU_ERR("%s err, line %d\n", __func__, (int)usign);
+		return false;
+	}
+	return true;
+}
+
+/**
+ * sysfs_to_str - convert sysfs buf string to standard string
+ * @old_str:	old sysf string, end up with '\n'
+ * @new_str: 	store the new string converted.
+ * @new_buf_size: length of new_str buffer.
+ *
+ * return true if success, false if failed.
+ */
+bool inline sysfs_to_str(const char *old_str, char *new_str, int new_buf_size)
+{
+	int 	i = 0;
+
+	while('\0' != *old_str && '\n' != *old_str) {
+		*new_str++ = *old_str++;
+		if(++i >= new_buf_size)
+			return false;
+	}
+	*new_str = '\0';
+	return true;
+}
+
+ssize_t ccu_export_store(struct class *class,
+				struct class_attribute *attr,
+				const char *buf, size_t len)
+{
+	char 	buf_temp[256] = {0};
+	__aw_ccu_clk_id_e clk_id = AW_SYS_CLK_NONE;
+
+	/* get clock id and name(convert from sysfs str) */
+	if(false == sysfs_to_str(buf, buf_temp, sizeof(buf_temp))) {
+		CCU_ERR("%s err: sysfs_to_str failed, buf %s\n", __func__, buf);
+		return -EINVAL;
+	}
+	clk_id = __get_clock_id(buf_temp);
+	if(AW_SYS_CLK_NONE == clk_id) {
+		CCU_ERR("%s: invalid clock name %s\n", __func__, buf_temp);
+		return -EINVAL;
+	}
+	CCU_DBG("%s: clock name %s, clock id %d\n", __func__, buf_temp, (int)clk_id);
+
+	mutex_lock(&sysfs_lock);
+
+	/* check if exported */
+	if(true == g_clk_handle[clk_id].exported) {
+		mutex_unlock(&sysfs_lock);
+		CCU_ERR("%s err: clock %s already exported\n", __func__, buf_temp);
+		return -EINVAL;
+	}
+
+	/* export clock */
+	if(false == __ccu_export(buf_temp, clk_id)) {
+		mutex_unlock(&sysfs_lock);
+		CCU_ERR("%s: __ccu_export clock %s err\n", __func__, buf_temp);
+		return -EINVAL;
+	}
+
+	/* change exported flag to true */
+	g_clk_handle[clk_id].exported = true;
+
+	mutex_unlock(&sysfs_lock);
+	CCU_DBG("%s %s success\n", __func__, buf_temp);
+	return len;
+}
+
+ssize_t ccu_unexport_store(struct class *class,
+				struct class_attribute *attr,
+				const char *buf, size_t len)
+{
+	char 	buf_temp[256] = {0};
+	__aw_ccu_clk_id_e clk_id = AW_SYS_CLK_NONE;
+
+	/* get clock id and name(convert from sysfs str) */
+	if(false == sysfs_to_str(buf, buf_temp, sizeof(buf_temp))) {
+		CCU_ERR("%s err: sysfs_to_str failed, buf %s\n", __func__, buf);
+		return -EINVAL;
+	}
+	clk_id = __get_clock_id(buf_temp);
+	if (AW_SYS_CLK_NONE == clk_id) {
+		CCU_ERR("%s: invalid clock name %s\n", __func__, buf_temp);
+		return -EINVAL;
+	}
+	CCU_DBG("%s: clock name %s, clock id %d\n", __func__, buf_temp, (int)clk_id);
+
+	mutex_lock(&sysfs_lock);
+
+	/* check if unexported */
+	if(false == g_clk_handle[clk_id].exported) {
+		mutex_unlock(&sysfs_lock);
+		CCU_ERR("%s err: clock %s already un-exported\n", __func__, buf_temp);
+		return -EINVAL;
+	}
+
+	/* unexport clock */
+	if(false == __ccu_unexport(buf_temp, clk_id)) {
+		mutex_unlock(&sysfs_lock);
+		CCU_ERR("%s: __ccu_unexport clock %s err\n", __func__, buf_temp);
+		return -EINVAL;
+	}
+
+	/* change exported flag to false */
+	g_clk_handle[clk_id].exported = false;
+
+	mutex_unlock(&sysfs_lock);
+	CCU_DBG("%s: clock %s success\n", __func__, buf_temp);
+	return len;
+}
+
+static int __init ccu_sysfs_init(void)
+{
+	int		status;
+
+	status = class_register(&ccu_class);
+	if(status < 0)
+		CCU_ERR("%s err, status %d\n", __func__, status);
+	else
+		CCU_DBG("%s successfully\n", __func__);
+
+	return status;
+}
+postcore_initcall(ccu_sysfs_init);
diff --git a/arch/arm/mach-sun6i/clock/ccu_sysfs.h b/arch/arm/mach-sun6i/clock/ccu_sysfs.h
new file mode 100644
index 0000000..01458c8
--- /dev/null
+++ b/arch/arm/mach-sun6i/clock/ccu_sysfs.h
@@ -0,0 +1,21 @@
+/*
+ * arch/arm/mach-sun6i/clock/ccu_sysfs.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i ccu sysfs head file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __CCU_SYSFS_H
+#define __CCU_SYSFS_H
+
+#define CCU_ASSERT_GOTO(x, errline, pos) if(!(x)) {errline = __LINE__; goto pos;}
+
+#endif /* __CCU_SYSFS_H */
diff --git a/arch/arm/mach-sun6i/clock/clock.c b/arch/arm/mach-sun6i/clock/clock.c
new file mode 100644
index 0000000..616da42
--- /dev/null
+++ b/arch/arm/mach-sun6i/clock/clock.c
@@ -0,0 +1,383 @@
+/*
+ *  arch/arm/mach-sun6i/clock/clock.c
+ *
+ * Copyright (c) Allwinner.  All rights reserved.
+ * kevin.z.m (kevin@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/debugfs.h>
+#include <mach/clock.h>
+#include <mach/sys_config.h>
+#include "ccm_i.h"
+
+// alloc memory for store clock informatioin
+__ccu_clk_t          aw_clock[AW_CCU_CLK_CNT];
+static struct clk_lookup    lookups[AW_CCU_CLK_CNT];
+
+/*
+*********************************************************************************************************
+*                           clk_init
+*
+*Description: clock management initialise.
+*
+*Arguments  : none
+*
+*Return     : result
+*               0,  initialise successed;
+*              -1,  initialise failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+int clk_init(void)
+{
+    int             i;
+    struct clk      *clk;
+    __u64           rate;
+    script_item_u   script_item;
+
+    CCU_DBG("aw clock manager init!\n");
+
+    //initialise clock controller unit
+    aw_ccu_init();
+    //clear the data structure
+    memset((void *)aw_clock, 0, sizeof(aw_clock));
+    memset((void *)lookups, 0, sizeof(lookups));
+    for(i=0; i<AW_CCU_CLK_CNT; i++) {
+        /* initiate clk */
+        if(aw_ccu_get_clk(i, &aw_clock[i]) != 0) {
+            CCU_ERR("try toc get clock(id:%d) informaiton failed!\n", i);
+        }
+#ifdef CCU_LOCK_LIUGANG_20120930
+	/* init clk spin lock */
+	CCU_LOCK_INIT(&aw_clock[i].lock);
+#endif /* CCU_LOCK_LIUGANG_20120930 */
+        /* register clk device */
+        lookups[i].con_id = aw_clock[i].aw_clk->name;
+        lookups[i].clk    = &aw_clock[i];
+        clkdev_add(&lookups[i]);
+    }
+    /* initiate some clocks */
+    lookups[AW_MOD_CLK_SMPTWD].dev_id = "smp_twd";
+
+    /* config plls */
+    if(script_get_item("clock", "pll3", &script_item) == SCIRPT_ITEM_VALUE_TYPE_INT) {
+        CCU_INF("script config pll3 to %d Mhz\n", script_item.val);
+        if(!((script_item.val < 30) || (script_item.val > 600))) {
+            clk = &aw_clock[AW_SYS_CLK_PLL3];
+            clk_enable(clk);
+            clk_set_rate(clk, script_item.val*1000000);
+        }
+    }
+    if(script_get_item("clock", "pll4", &script_item) == SCIRPT_ITEM_VALUE_TYPE_INT) {
+        CCU_INF("script config pll4 to %d Mhz\n", script_item.val);
+        if(!((script_item.val < 30) || (script_item.val > 600))) {
+            clk = &aw_clock[AW_SYS_CLK_PLL4];
+            clk_enable(clk);
+            clk_set_rate(clk, script_item.val*1000000);
+        }
+    }
+
+    clk = &aw_clock[AW_SYS_CLK_PLL6];
+    if(script_get_item("clock", "pll6", &script_item) == SCIRPT_ITEM_VALUE_TYPE_INT) {
+        CCU_INF("script config pll6 to %d Mhz\n", script_item.val);
+        if((script_item.val < 30) || (script_item.val > 1800)) {
+            script_item.val = 600;
+        }
+    } else{
+        script_item.val = 600;
+    }
+    clk_enable(clk);
+    clk_set_rate(clk, script_item.val*1000000);
+
+
+    if(script_get_item("clock", "pll7", &script_item) == SCIRPT_ITEM_VALUE_TYPE_INT) {
+        CCU_INF("script config pll7 to %d Mhz\n", script_item.val);
+        if(!((script_item.val < 30) || (script_item.val > 600))) {
+            clk = &aw_clock[AW_SYS_CLK_PLL7];
+            clk_enable(clk);
+            clk_set_rate(clk, script_item.val*1000000);
+        }
+    }
+    if(script_get_item("clock", "pll8", &script_item) == SCIRPT_ITEM_VALUE_TYPE_INT) {
+        CCU_INF("script config pll8 to %d Mhz\n", script_item.val);
+        if(!((script_item.val < 30) || (script_item.val > 600))) {
+            clk = &aw_clock[AW_SYS_CLK_PLL8];
+            clk_enable(clk);
+            clk_set_rate(clk, script_item.val*1000000);
+        }
+    }
+    if(script_get_item("clock", "pll9", &script_item) == SCIRPT_ITEM_VALUE_TYPE_INT) {
+        CCU_INF("script config pll9 to %d Mhz\n", script_item.val);
+        if(!((script_item.val < 30) || (script_item.val > 600))) {
+            clk = &aw_clock[AW_SYS_CLK_PLL9];
+            clk_enable(clk);
+            clk_set_rate(clk, script_item.val*1000000);
+        }
+    }
+    if(script_get_item("clock", "pll10", &script_item) == SCIRPT_ITEM_VALUE_TYPE_INT) {
+        CCU_INF("script config pll10 to %d Mhz\n", script_item.val);
+        if(!((script_item.val < 30) || (script_item.val > 600))) {
+            clk = &aw_clock[AW_SYS_CLK_PLL10];
+            clk_enable(clk);
+            clk_set_rate(clk, script_item.val*1000000);
+        }
+    }
+
+    /* switch ahb clock to pll6 */
+    aw_ccu_switch_ahb_2_pll6();
+    clk = &aw_clock[AW_SYS_CLK_AHB1];
+    rate = clk_round_rate(clk, AHB1_FREQ_MAX);
+    clk_set_rate(clk, rate);
+
+    if(script_get_item("clock", "apb2", &script_item) == SCIRPT_ITEM_VALUE_TYPE_INT) {
+        CCU_INF("script config apb2 to %d Mhz\n", script_item.val);
+        if(!((script_item.val < 5) || (script_item.val > 120))) {
+            aw_ccu_switch_apb_2_pll6();
+            clk = &aw_clock[AW_SYS_CLK_APB2];
+            rate = clk_round_rate(clk, script_item.val*1000000);
+            clk_set_rate(clk, rate);
+            clk_enable(clk);
+        }
+    }
+
+    return 0;
+}
+arch_initcall(clk_init);
+
+
+int __clk_get(struct clk *hclk)
+{
+    /* just noitify, do nothing now, if you want record if the clock used count, you can add code here */
+    return 1;
+}
+
+
+void __clk_put(struct clk *clk)
+{
+    /* just noitify, do nothing now, if you want record if the clock used count, you can add code here */
+    return;
+}
+
+
+int clk_enable(struct clk *clk)
+{
+    DEFINE_FLAGS(flags);
+
+    if((clk == NULL) || IS_ERR(clk))
+        return -EINVAL;
+    if(!clk->ops || !clk->ops->set_status)
+        return 0;
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->aw_clk->name);
+
+    CCU_LOCK(&clk->lock, flags);
+
+    if(!clk->enable) {
+        clk->ops->set_status(clk->aw_clk->id, AW_CCU_CLK_ON);
+    }
+    clk->enable++;
+
+    CCU_UNLOCK(&clk->lock, flags);
+    return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+
+void clk_disable(struct clk *clk)
+{
+    DEFINE_FLAGS(flags);
+
+    if(clk == NULL || IS_ERR(clk) || !clk->enable)
+        return;
+    if(!clk->ops || !clk->ops->set_status)
+        return;
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->aw_clk->name);
+
+    CCU_LOCK(&clk->lock, flags);
+
+    clk->enable--;
+    if(clk->enable){
+        CCU_UNLOCK(&clk->lock, flags);
+        return;
+    }
+    clk->ops->set_status(clk->aw_clk->id, AW_CCU_CLK_OFF);
+
+    CCU_UNLOCK(&clk->lock, flags);
+    return;
+}
+EXPORT_SYMBOL(clk_disable);
+
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+    unsigned long ret = 0;
+    DEFINE_FLAGS(flags);
+
+    if((clk == NULL) || IS_ERR(clk))
+        return 0;
+    if(!clk->ops || !clk->ops->get_rate)
+        return 0;
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->aw_clk->name);
+
+    CCU_LOCK(&clk->lock, flags);
+
+    clk->aw_clk->rate = clk->ops->get_rate(clk->aw_clk->id);
+    ret = (unsigned long)clk->aw_clk->rate;
+
+    CCU_UNLOCK(&clk->lock, flags);
+
+    CCU_DBG("%s:%d:%s: %s (rate = %lu) !\n", __FILE__, __LINE__, __FUNCTION__, clk->aw_clk->name, ret);
+
+    return ret;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+    unsigned long ret;
+
+    DEFINE_FLAGS(flags);
+
+    if(clk == NULL || IS_ERR(clk))
+        return -1;
+    if(!clk->ops || !clk->ops->round_rate)
+        return rate;
+
+    CCU_DBG("%s:%d:%s: %s (rate = %lu)!\n", __FILE__, __LINE__, __FUNCTION__, clk->aw_clk->name, rate);
+
+    CCU_LOCK(&clk->lock, flags);
+    ret = clk->ops->round_rate(clk->aw_clk->id, rate);
+    CCU_UNLOCK(&clk->lock, flags);
+
+    CCU_DBG("%s:%d:%s: %s (result = %lu)!\n", __FILE__, __LINE__, __FUNCTION__, clk->aw_clk->name, ret);
+
+    return ret;
+}
+EXPORT_SYMBOL(clk_round_rate);
+
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+    DEFINE_FLAGS(flags);
+
+    if(clk == NULL || IS_ERR(clk))
+        return -1;
+    if(!clk->ops || !clk->ops->get_rate || !clk->ops->set_rate)
+        return 0;
+
+    CCU_DBG("%s:%d:%s: %s (rate = %lu)!\n", __FILE__, __LINE__, __FUNCTION__, clk->aw_clk->name, rate);
+
+    CCU_LOCK(&clk->lock, flags);
+
+    if(clk->ops->set_rate(clk->aw_clk->id, rate) == 0) {
+        clk->aw_clk->rate = clk->ops->get_rate(clk->aw_clk->id);
+        CCU_UNLOCK(&clk->lock, flags);
+        return 0;
+    }
+
+    CCU_UNLOCK(&clk->lock, flags);
+    return -1;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+
+struct clk *clk_get_parent(struct clk *clk)
+{
+    struct clk *clk_ret = NULL;
+    DEFINE_FLAGS(flags);
+
+    if((clk == NULL) || IS_ERR(clk)) {
+        return NULL;
+    }
+
+    CCU_DBG("%s:%d:%s: %s !\n", __FILE__, __LINE__, __FUNCTION__, clk->aw_clk->name);
+
+    CCU_LOCK(&clk->lock, flags);
+
+    clk_ret = &aw_clock[clk->aw_clk->parent];
+
+    CCU_UNLOCK(&clk->lock, flags);
+
+    CCU_DBG("%s:%d:%s: %s (parent:%s)!\n", __FILE__, __LINE__, __FUNCTION__, clk->aw_clk->name, clk_ret->aw_clk->name);
+
+    return clk_ret;
+}
+EXPORT_SYMBOL(clk_get_parent);
+
+
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+    DEFINE_FLAGS(flags);
+
+    if((clk == NULL) || IS_ERR(clk) || (parent == NULL) || IS_ERR(parent)) {
+        return -1;
+    }
+    if(!clk->ops || !clk->ops->get_parent || !clk->ops->set_parent || !clk->ops->get_rate)
+        return 0;
+
+    CCU_DBG("%s:%d:%s: %s (parent:%s)!\n", __FILE__, __LINE__, __FUNCTION__, clk->aw_clk->name, parent->aw_clk->name);
+
+    CCU_LOCK(&clk->lock, flags);
+
+    if(clk->ops->set_parent(clk->aw_clk->id, parent->aw_clk->id) == 0) {
+        clk->aw_clk->parent = clk->ops->get_parent(clk->aw_clk->id);
+        clk->aw_clk->rate   = clk->ops->get_rate(clk->aw_clk->id);
+
+        CCU_UNLOCK(&clk->lock, flags);
+        return 0;
+    }
+
+    CCU_UNLOCK(&clk->lock, flags);
+    return -1;
+}
+EXPORT_SYMBOL(clk_set_parent);
+
+
+int clk_reset(struct clk *clk, __aw_ccu_clk_reset_e reset)
+{
+    DEFINE_FLAGS(flags);
+
+    if((clk == NULL) || IS_ERR(clk)) {
+        return -EINVAL;
+    }
+    if(!clk->ops || !clk->ops->set_reset)
+        return 0;
+
+    CCU_DBG("%s:%d:%s: %s (rese:%d)!\n", __FILE__, __LINE__, __FUNCTION__, clk->aw_clk->name, reset);
+
+    CCU_LOCK(&clk->lock, flags);
+
+    clk->ops->set_reset(clk->aw_clk->id, reset);
+    clk->aw_clk->reset = reset;
+
+    CCU_UNLOCK(&clk->lock, flags);
+    return 0;
+}
+EXPORT_SYMBOL(clk_reset);
diff --git a/arch/arm/mach-sun6i/clock/mod_clk.c b/arch/arm/mach-sun6i/clock/mod_clk.c
new file mode 100644
index 0000000..bdbcbb9
--- /dev/null
+++ b/arch/arm/mach-sun6i/clock/mod_clk.c
@@ -0,0 +1,2666 @@
+/*
+ *  arch/arm/mach-sun6i/clock/ccmu/ccm_mod_clk.c
+ *
+ * Copyright 2012 (c) Allwinner
+ * kevin (kevin@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <mach/clock.h>
+#include "ccm_i.h"
+
+struct module0_div_tbl{
+    __u8    FactorM;
+    __u8    FactorN;
+    __u16   Div;
+};
+static struct module0_div_tbl module0_clk_div_tbl[] = {
+    {0 , 0, 1  },
+    {1 , 0, 2  },
+    {2 , 0, 3  },
+    {3 , 0, 4  },
+    {4 , 0, 5  },
+    {5 , 0, 6  },
+    {6 , 0, 7  },
+    {7 , 0, 8  },
+    {8 , 0, 9  },
+    {9 , 0, 10 },
+    {10, 0, 11 },
+    {11, 0, 12 },
+    {12, 0, 13 },
+    {13, 0, 14 },
+    {14, 0, 15 },
+    {15, 0, 16 },
+    {8 , 1, 18 },
+    {9 , 1, 20 },
+    {10, 1, 22 },
+    {11, 1, 24 },
+    {12, 1, 26 },
+    {13, 1, 28 },
+    {14, 1, 30 },
+    {15, 1, 32 },
+    {8 , 2, 36 },
+    {9 , 2, 40 },
+    {10, 2, 44 },
+    {11, 2, 48 },
+    {12, 2, 52 },
+    {13, 2, 56 },
+    {14, 2, 60 },
+    {15, 2, 64 },
+    {8 , 3, 72 },
+    {9 , 3, 80 },
+    {10, 3, 88 },
+    {11, 3, 96 },
+    {12, 3, 104},
+    {13, 3, 112},
+    {14, 3, 120},
+    {15, 3, 128},
+};
+static struct module0_div_tbl mmc_clk_div_tbl[] = {
+    {0 , 0, 1  },
+    {1 , 0, 2  },
+    {2 , 0, 3  },
+    {3 , 0, 4  },
+    {4 , 0, 5  },
+    {5 , 0, 6  },
+    {6 , 0, 7  },
+    {7 , 0, 8  },
+    {9 , 0, 9  },
+    {9 , 0, 10 },
+    {11, 0, 11 },
+    {11, 0, 12 },
+    {13, 0, 13 },
+    {13, 0, 14 },
+    {15, 0, 15 },
+    {15, 0, 16 },
+    {9 , 1, 18 },
+    {9 , 1, 20 },
+    {11, 1, 22 },
+    {11, 1, 24 },
+    {13, 1, 26 },
+    {13, 1, 28 },
+    {15, 1, 30 },
+    {15, 1, 32 },
+    {9 , 2, 36 },
+    {9 , 2, 40 },
+    {11, 2, 44 },
+    {11, 2, 48 },
+    {13, 2, 52 },
+    {13, 2, 56 },
+    {15, 2, 60 },
+    {15, 2, 64 },
+    {9 , 3, 72 },
+    {9 , 3, 80 },
+    {11, 3, 88 },
+    {11, 3, 96 },
+    {13, 3, 104},
+    {13, 3, 112},
+    {15, 3, 120},
+    {15, 3, 128},
+};
+struct onewire_div_tbl{
+    __u8    FactorM;
+    __u8    FactorN;
+    __u16   Div;
+};
+static struct onewire_div_tbl onewire_clk_div_tbl[] = {
+    {0,  0, 1   },
+    {1,  0, 2   },
+    {2,  0, 3   },
+    {3,  0, 4   },
+    {4,  0, 5   },
+    {5,  0, 6   },
+    {6,  0, 7   },
+    {7,  0, 8   },
+    {8,  0, 9   },
+    {9,  0, 10  },
+    {10, 0, 11  },
+    {11, 0, 12  },
+    {12, 0, 13  },
+    {13, 0, 14  },
+    {14, 0, 15  },
+    {15, 0, 16  },
+    {16, 0, 17  },
+    {17, 0, 18  },
+    {18, 0, 19  },
+    {19, 0, 20  },
+    {20, 0, 21  },
+    {21, 0, 22  },
+    {22, 0, 23  },
+    {23, 0, 24  },
+    {24, 0, 25  },
+    {25, 0, 26  },
+    {26, 0, 27  },
+    {27, 0, 28  },
+    {28, 0, 29  },
+    {29, 0, 30  },
+    {30, 0, 31  },
+    {31, 0, 32  },
+    {16, 1, 34  },
+    {17, 1, 36  },
+    {18, 1, 38  },
+    {19, 1, 40  },
+    {20, 1, 42  },
+    {21, 1, 44  },
+    {22, 1, 46  },
+    {23, 1, 48  },
+    {24, 1, 50  },
+    {25, 1, 52  },
+    {26, 1, 54  },
+    {27, 1, 56  },
+    {28, 1, 58  },
+    {29, 1, 60  },
+    {30, 1, 62  },
+    {31, 1, 64  },
+    {16, 2, 68  },
+    {17, 2, 72  },
+    {18, 2, 76  },
+    {19, 2, 80  },
+    {20, 2, 84  },
+    {21, 2, 88  },
+    {22, 2, 92  },
+    {23, 2, 96  },
+    {24, 2, 100 },
+    {25, 2, 104 },
+    {26, 2, 108 },
+    {27, 2, 112 },
+    {28, 2, 116 },
+    {29, 2, 120 },
+    {30, 2, 124 },
+    {31, 2, 128 },
+    {16, 3, 136 },
+    {17, 3, 144 },
+    {18, 3, 152 },
+    {19, 3, 160 },
+    {20, 3, 168 },
+    {21, 3, 176 },
+    {22, 3, 184 },
+    {23, 3, 192 },
+    {24, 3, 200 },
+    {25, 3, 208 },
+    {26, 3, 216 },
+    {27, 3, 224 },
+    {28, 3, 232 },
+    {29, 3, 240 },
+    {30, 3, 248 },
+    {31, 3, 256 },
+};
+
+static inline __aw_ccu_clk_id_e _get_module0_clk_src(volatile __ccmu_module0_clk_t *reg)
+{
+    if(reg->ClkSrc == 0)
+        return AW_SYS_CLK_HOSC;
+    else if(reg->ClkSrc == 1)
+        return AW_SYS_CLK_PLL6;
+    else
+        return AW_SYS_CLK_NONE;
+}
+static inline __s32 _set_module0_clk_src(volatile __ccmu_module0_clk_t *reg, __aw_ccu_clk_id_e parent)
+{
+    if(parent == AW_SYS_CLK_HOSC)
+        reg->ClkSrc = 0;
+    else if(parent == AW_SYS_CLK_PLL6)
+        reg->ClkSrc = 1;
+    else
+        return -1;
+    return 0;
+}
+
+
+static inline __s32 _get_module1_clk_src(volatile __ccmu_module1_clk_t *reg)
+{
+    if(reg->ClkSrc == 0)
+        return AW_SYS_CLK_PLL2X8;
+    else if(reg->ClkSrc == 3)
+        return AW_SYS_CLK_PLL2;
+    else
+        return AW_SYS_CLK_NONE;
+}
+static inline __s32 _set_module1_clk_src(volatile __ccmu_module1_clk_t *reg, __aw_ccu_clk_id_e parent)
+{
+    if(parent == AW_SYS_CLK_PLL2X8)
+        reg->ClkSrc = 0;
+    else if(parent == AW_SYS_CLK_PLL2)
+        reg->ClkSrc = 3;
+    else
+        return -1;
+    return 0;
+}
+
+
+#define DE_BE_INDX          (0)
+#define DE_FE_INDX          (1)
+#define DE_MP_INDX          (2)
+#define LCD_CH0_INDX        (3)
+#define LCD_CH1_INDX        (4)
+
+
+static inline __s32 _get_disp_clk_src(volatile __ccmu_disp_clk_t *reg, int index)
+{
+    switch(index){
+        case DE_BE_INDX:
+        case DE_FE_INDX:
+        {
+            if(reg->ClkSrc == 0)
+                return AW_SYS_CLK_PLL3;
+            else if(reg->ClkSrc == 1)
+                return AW_SYS_CLK_PLL7;
+            else if(reg->ClkSrc == 2)
+                return AW_SYS_CLK_PLL6x2;
+            else if(reg->ClkSrc == 3)
+                return AW_SYS_CLK_PLL8;
+            else if(reg->ClkSrc == 4)
+                return AW_SYS_CLK_PLL9;
+            else if(reg->ClkSrc == 5)
+                return AW_SYS_CLK_PLL10;
+            else
+                return AW_SYS_CLK_NONE;
+        }
+
+        case DE_MP_INDX:
+        {
+            if(reg->ClkSrc == 0)
+                return AW_SYS_CLK_PLL3;
+            else if(reg->ClkSrc == 1)
+                return AW_SYS_CLK_PLL7;
+            else if(reg->ClkSrc == 2)
+                return AW_SYS_CLK_PLL9;
+            else if(reg->ClkSrc == 3)
+                return AW_SYS_CLK_PLL10;
+            else
+                return AW_SYS_CLK_NONE;
+        }
+
+        case LCD_CH0_INDX:
+        {
+            if(reg->ClkSrc == 0)
+                return AW_SYS_CLK_PLL3;
+            else if(reg->ClkSrc == 1)
+                return AW_SYS_CLK_PLL7;
+            else if(reg->ClkSrc == 2)
+                return AW_SYS_CLK_PLL3X2;
+            else if(reg->ClkSrc == 3)
+                return AW_SYS_CLK_PLL7X2;
+            else if(reg->ClkSrc == 4)
+                return AW_SYS_CLK_MIPIPLL;
+            else
+                return AW_SYS_CLK_NONE;
+        }
+
+        case LCD_CH1_INDX:
+        {
+            if(reg->ClkSrc == 0)
+                return AW_SYS_CLK_PLL3;
+            else if(reg->ClkSrc == 1)
+                return AW_SYS_CLK_PLL7;
+            else if(reg->ClkSrc == 2)
+                return AW_SYS_CLK_PLL3X2;
+            else if(reg->ClkSrc == 3)
+                return AW_SYS_CLK_PLL7X2;
+            else
+                return AW_SYS_CLK_NONE;
+        }
+
+        default:
+            return AW_SYS_CLK_NONE;
+    }
+
+    return AW_SYS_CLK_NONE;
+}
+
+static inline __s32 _set_disp_clk_src(volatile __ccmu_disp_clk_t *reg, __aw_ccu_clk_id_e parent, int index)
+{
+    switch(index){
+        case DE_BE_INDX:
+        case DE_FE_INDX:
+        {
+            if(parent == AW_SYS_CLK_PLL3)
+                reg->ClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                reg->ClkSrc = 1;
+            else if(parent == AW_SYS_CLK_PLL6x2)
+                reg->ClkSrc = 2;
+            else if(parent == AW_SYS_CLK_PLL8)
+                reg->ClkSrc = 3;
+            else if(parent == AW_SYS_CLK_PLL9)
+                reg->ClkSrc = 4;
+            else if(parent == AW_SYS_CLK_PLL10)
+                reg->ClkSrc = 5;
+            else
+                return -1;
+	    return 0;
+        }
+
+        case DE_MP_INDX:
+        {
+            if(parent == AW_SYS_CLK_PLL3)
+                reg->ClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                reg->ClkSrc = 1;
+            else if(parent == AW_SYS_CLK_PLL9)
+                reg->ClkSrc = 2;
+            else if(parent == AW_SYS_CLK_PLL10)
+                reg->ClkSrc = 3;
+            else
+                return -1;
+	    return 0;
+        }
+
+        case LCD_CH0_INDX:
+        {
+            if(parent == AW_SYS_CLK_PLL3)
+                reg->ClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                reg->ClkSrc = 1;
+            else if(parent == AW_SYS_CLK_PLL3X2)
+                reg->ClkSrc = 2;
+            else if(parent == AW_SYS_CLK_PLL7X2)
+                reg->ClkSrc = 3;
+            else if(parent == AW_SYS_CLK_MIPIPLL)
+                reg->ClkSrc = 4;
+            else
+                return -1;
+	    return 0;
+        }
+
+        case LCD_CH1_INDX:
+        {
+            if(parent == AW_SYS_CLK_PLL3)
+                reg->ClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                reg->ClkSrc = 1;
+            else if(parent == AW_SYS_CLK_PLL3X2)
+                reg->ClkSrc = 2;
+            else if(parent == AW_SYS_CLK_PLL7X2)
+                reg->ClkSrc = 3;
+            else
+                return -1;
+	    return 0;
+        }
+
+        default:
+            return -1;
+    }
+
+     return -1;
+}
+
+
+static inline __aw_ccu_clk_onff_e _get_module_clk_status(volatile __ccmu_module_clk_t *reg)
+{
+    return reg->ClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+}
+static inline __s32 _set_module_clk_status(volatile __ccmu_module0_clk_t *reg, __aw_ccu_clk_onff_e status)
+{
+    reg->ClkGate = (status == AW_CCU_CLK_OFF)? 0 : 1;
+    return 0;
+}
+
+
+static inline __u32 _get_module0_clk_rate(volatile __ccmu_module0_clk_t *reg)
+{
+    return (1<<reg->DivN)*(reg->DivM+1);
+}
+static inline __s32 _set_module0_clk_rate(volatile __ccmu_module0_clk_t *reg, __s64 rate)
+{
+    int     low, high;
+
+    low = 0;
+    high = sizeof(module0_clk_div_tbl)/sizeof(struct module0_div_tbl) - 1;
+
+    while(low<=high){
+        if(module0_clk_div_tbl[(low+high)/2].Div < rate) {
+            low = (low+high)/2+1;
+        } else if(module0_clk_div_tbl[(low+high)/2].Div > rate) {
+            high = (low+high)/2-1;
+        } else {
+            low = (low+high)/2;
+            reg->DivM = module0_clk_div_tbl[low].FactorM;
+            reg->DivN = module0_clk_div_tbl[low].FactorN;
+            return 0;
+        }
+    }
+
+    CCU_ERR("%s:%d, set rate of (%x) to %llu failed", __FILE__, __LINE__, (int)reg, rate);
+    return -1;
+}
+static inline __s32 _set_mmc_clk_rate(volatile __ccmu_module0_clk_t *reg, __s64 rate)
+{
+    int     low, high;
+
+    low = 0;
+    high = sizeof(mmc_clk_div_tbl)/sizeof(struct module0_div_tbl) - 1;
+
+    while(low<=high){
+        if(mmc_clk_div_tbl[(low+high)/2].Div < rate) {
+            low = (low+high)/2+1;
+        } else if(mmc_clk_div_tbl[(low+high)/2].Div > rate) {
+            high = (low+high)/2-1;
+        } else {
+            low = (low+high)/2;
+            reg->DivM = mmc_clk_div_tbl[low].FactorM;
+            reg->DivN = mmc_clk_div_tbl[low].FactorN;
+            return 0;
+        }
+    }
+
+    CCU_ERR("%s:%d, set rate of (%x) to %llu failed", __FILE__, __LINE__, (int)reg, rate);
+    return -1;
+}
+static inline __s32 _set_onewire_clk_rate(volatile __ccmu_onewire_clk_reg0050_t *reg, __s64 rate)
+{
+    int     low, high;
+
+    low = 0;
+    high = sizeof(onewire_clk_div_tbl)/sizeof(struct onewire_div_tbl) - 1;
+
+    while(low<=high){
+        if(onewire_clk_div_tbl[(low+high)/2].Div < rate) {
+            low = (low+high)/2+1;
+        } else if(onewire_clk_div_tbl[(low+high)/2].Div > rate) {
+            high = (low+high)/2-1;
+        } else {
+            low = (low+high)/2;
+            reg->DivM = onewire_clk_div_tbl[low].FactorM;
+            reg->DivN = onewire_clk_div_tbl[low].FactorN;
+            return 0;
+        }
+    }
+
+    CCU_ERR("%s:%d, set rate of (%x) to %llu failed", __FILE__, __LINE__, (int)reg, rate);
+    return -1;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_get_parent
+*
+*Description: get clock parent for module clock;
+*
+*Arguments  : id        module clock id;
+*
+*Return     : parent clock id;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __aw_ccu_clk_id_e mod_clk_get_parent(__aw_ccu_clk_id_e id)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NAND0:
+            return _get_module0_clk_src(&aw_ccu_reg->Nand0);
+        case AW_MOD_CLK_NAND1:
+            return _get_module0_clk_src(&aw_ccu_reg->Nand1);
+        case AW_MOD_CLK_SDC0:
+            return _get_module0_clk_src(&aw_ccu_reg->Sd0);
+        case AW_MOD_CLK_SDC1:
+            return _get_module0_clk_src(&aw_ccu_reg->Sd1);
+        case AW_MOD_CLK_SDC2:
+            return _get_module0_clk_src(&aw_ccu_reg->Sd2);
+        case AW_MOD_CLK_SDC3:
+            return _get_module0_clk_src(&aw_ccu_reg->Sd3);
+        case AW_MOD_CLK_TS:
+            return _get_module0_clk_src(&aw_ccu_reg->Ts);
+        case AW_MOD_CLK_SS:
+            return _get_module0_clk_src(&aw_ccu_reg->Ss);
+        case AW_MOD_CLK_SPI0:
+            return _get_module0_clk_src(&aw_ccu_reg->Spi0);
+        case AW_MOD_CLK_SPI1:
+            return _get_module0_clk_src(&aw_ccu_reg->Spi1);
+        case AW_MOD_CLK_SPI2:
+            return _get_module0_clk_src(&aw_ccu_reg->Spi2);
+        case AW_MOD_CLK_SPI3:
+            return _get_module0_clk_src(&aw_ccu_reg->Spi3);
+        case AW_MOD_CLK_I2S0:
+            return _get_module1_clk_src(&aw_ccu_reg->I2s0);
+        case AW_MOD_CLK_I2S1:
+            return _get_module1_clk_src(&aw_ccu_reg->I2s1);
+        case AW_MOD_CLK_SPDIF:
+            return _get_module1_clk_src(&aw_ccu_reg->Spdif);
+        case AW_MOD_CLK_MDFS:
+        {
+            if(aw_ccu_reg->Mdfs.ClkSrc == 0)
+                return AW_SYS_CLK_PLL5;
+            else if(aw_ccu_reg->Mdfs.ClkSrc == 1)
+                return AW_SYS_CLK_PLL6;
+            else
+            {
+                aw_ccu_reg->Mdfs.ClkSrc = 0;
+                return AW_SYS_CLK_PLL5;
+            }
+        }
+        case AW_MOD_CLK_DEBE0:
+            return _get_disp_clk_src(&aw_ccu_reg->Be0, DE_BE_INDX);
+        case AW_MOD_CLK_DEBE1:
+            return _get_disp_clk_src(&aw_ccu_reg->Be1, DE_BE_INDX);
+        case AW_MOD_CLK_DEFE0:
+            return _get_disp_clk_src(&aw_ccu_reg->Fe0, DE_FE_INDX);
+        case AW_MOD_CLK_DEFE1:
+            return _get_disp_clk_src(&aw_ccu_reg->Fe1, DE_FE_INDX);
+        case AW_MOD_CLK_DEMIX:
+            return _get_disp_clk_src(&aw_ccu_reg->Mp, DE_MP_INDX);
+        case AW_MOD_CLK_LCD0CH0:
+            return _get_disp_clk_src(&aw_ccu_reg->Lcd0Ch0, LCD_CH0_INDX);
+        case AW_MOD_CLK_LCD0CH1:
+            return _get_disp_clk_src(&aw_ccu_reg->Lcd0Ch1, LCD_CH1_INDX);
+        case AW_MOD_CLK_LCD1CH0:
+            return _get_disp_clk_src(&aw_ccu_reg->Lcd1Ch0, LCD_CH0_INDX);
+        case AW_MOD_CLK_LCD1CH1:
+            return _get_disp_clk_src(&aw_ccu_reg->Lcd1Ch1, LCD_CH1_INDX);
+        case AW_MOD_CLK_VE:
+            return AW_SYS_CLK_PLL4;
+        case AW_MOD_CLK_ADDA:
+            return _get_module1_clk_src(&aw_ccu_reg->Adda);
+        case AW_MOD_CLK_AVS:
+            return AW_SYS_CLK_HOSC;
+        case AW_MOD_CLK_PS:
+            return _get_module1_clk_src(&aw_ccu_reg->Ps);
+        case AW_MOD_CLK_MTCACC:
+            return _get_module0_clk_src(&aw_ccu_reg->MtcAcc);
+        case AW_MOD_CLK_MBUS0:
+        {
+            if(aw_ccu_reg->MBus0.ClkSrc == 0)
+                return AW_SYS_CLK_HOSC;
+            else if(aw_ccu_reg->MBus0.ClkSrc == 1)
+                return AW_SYS_CLK_PLL6;
+            else if(aw_ccu_reg->MBus0.ClkSrc == 2)
+                return AW_SYS_CLK_PLL5;
+            else
+            {
+                aw_ccu_reg->MBus0.ClkSrc = 2;
+                return AW_SYS_CLK_PLL5;
+            }
+        }
+        case AW_MOD_CLK_MBUS1:
+        {
+            if(aw_ccu_reg->MBus1.ClkSrc == 0)
+                return AW_SYS_CLK_HOSC;
+            else if(aw_ccu_reg->MBus1.ClkSrc == 1)
+                return AW_SYS_CLK_PLL6;
+            else if(aw_ccu_reg->MBus1.ClkSrc == 2)
+                return AW_SYS_CLK_PLL5;
+            else
+            {
+                aw_ccu_reg->MBus1.ClkSrc = 2;
+                return AW_SYS_CLK_PLL5;
+            }
+        }
+        case AW_MOD_CLK_IEPDRC0:
+        {
+            if(aw_ccu_reg->IepDrc0.ClkSrc == 0)
+                return AW_SYS_CLK_PLL3;
+            else if(aw_ccu_reg->IepDrc0.ClkSrc == 1)
+                return AW_SYS_CLK_PLL7;
+            else if(aw_ccu_reg->IepDrc0.ClkSrc == 3)
+                return AW_SYS_CLK_PLL8;
+            else if(aw_ccu_reg->IepDrc0.ClkSrc == 4)
+                return AW_SYS_CLK_PLL9;
+            else if(aw_ccu_reg->IepDrc0.ClkSrc == 5)
+                return AW_SYS_CLK_PLL10;
+            else
+
+            {
+                aw_ccu_reg->IepDrc0.ClkSrc = 0;
+                return AW_SYS_CLK_PLL3;
+            }
+        }
+        case AW_MOD_CLK_IEPDRC1:
+        {
+            if(aw_ccu_reg->IepDrc1.ClkSrc == 0)
+                return AW_SYS_CLK_PLL3;
+            else if(aw_ccu_reg->IepDrc1.ClkSrc == 1)
+                return AW_SYS_CLK_PLL7;
+            else if(aw_ccu_reg->IepDrc1.ClkSrc == 3)
+                return AW_SYS_CLK_PLL8;
+            else if(aw_ccu_reg->IepDrc1.ClkSrc == 4)
+                return AW_SYS_CLK_PLL9;
+            else if(aw_ccu_reg->IepDrc1.ClkSrc == 5)
+                return AW_SYS_CLK_PLL10;
+            else
+
+            {
+                aw_ccu_reg->IepDrc1.ClkSrc = 0;
+                return AW_SYS_CLK_PLL3;
+            }
+        }
+        case AW_MOD_CLK_IEPDEU0:
+        {
+            if(aw_ccu_reg->IepDeu0.ClkSrc == 0)
+                return AW_SYS_CLK_PLL3;
+            else if(aw_ccu_reg->IepDeu0.ClkSrc == 1)
+                return AW_SYS_CLK_PLL7;
+            else if(aw_ccu_reg->IepDeu0.ClkSrc == 3)
+                return AW_SYS_CLK_PLL8;
+            else if(aw_ccu_reg->IepDeu0.ClkSrc == 4)
+                return AW_SYS_CLK_PLL9;
+            else if(aw_ccu_reg->IepDeu0.ClkSrc == 5)
+                return AW_SYS_CLK_PLL10;
+            else
+
+            {
+                aw_ccu_reg->IepDeu0.ClkSrc = 0;
+                return AW_SYS_CLK_PLL3;
+            }
+        }
+        case AW_MOD_CLK_IEPDEU1:
+        {
+            if(aw_ccu_reg->IepDeu1.ClkSrc == 0)
+                return AW_SYS_CLK_PLL3;
+            else if(aw_ccu_reg->IepDeu1.ClkSrc == 1)
+                return AW_SYS_CLK_PLL7;
+            else if(aw_ccu_reg->IepDeu1.ClkSrc == 3)
+                return AW_SYS_CLK_PLL8;
+            else if(aw_ccu_reg->IepDeu1.ClkSrc == 4)
+                return AW_SYS_CLK_PLL9;
+            else if(aw_ccu_reg->IepDeu1.ClkSrc == 5)
+                return AW_SYS_CLK_PLL10;
+            else
+
+            {
+                aw_ccu_reg->IepDeu1.ClkSrc = 0;
+                return AW_SYS_CLK_PLL3;
+            }
+        }
+        case AW_MOD_CLK_GPUCORE:
+        {
+            if(aw_ccu_reg->GpuCore.ClkSrc == 0)
+                return AW_SYS_CLK_PLL8;
+            else if(aw_ccu_reg->GpuCore.ClkSrc == 2)
+                return AW_SYS_CLK_PLL3;
+            else if(aw_ccu_reg->GpuCore.ClkSrc == 3)
+                return AW_SYS_CLK_PLL7;
+            else if(aw_ccu_reg->GpuCore.ClkSrc == 4)
+                return AW_SYS_CLK_PLL9;
+            else if(aw_ccu_reg->GpuCore.ClkSrc == 5)
+                return AW_SYS_CLK_PLL10;
+            else
+
+            {
+                aw_ccu_reg->GpuCore.ClkSrc = 0;
+                return AW_SYS_CLK_PLL8;
+            }
+        }
+        case AW_MOD_CLK_GPUMEM:
+        {
+            if(aw_ccu_reg->GpuMem.ClkSrc == 0)
+                return AW_SYS_CLK_PLL8;
+            else if(aw_ccu_reg->GpuMem.ClkSrc == 2)
+                return AW_SYS_CLK_PLL3;
+            else if(aw_ccu_reg->GpuMem.ClkSrc == 3)
+                return AW_SYS_CLK_PLL7;
+            else if(aw_ccu_reg->GpuMem.ClkSrc == 4)
+                return AW_SYS_CLK_PLL9;
+            else if(aw_ccu_reg->GpuMem.ClkSrc == 5)
+                return AW_SYS_CLK_PLL10;
+            else
+
+            {
+                aw_ccu_reg->GpuMem.ClkSrc = 0;
+                return AW_SYS_CLK_PLL8;
+            }
+        }
+        case AW_MOD_CLK_GPUHYD:
+        {
+            if(aw_ccu_reg->GpuHyd.ClkSrc == 0)
+                return AW_SYS_CLK_PLL8;
+            else if(aw_ccu_reg->GpuHyd.ClkSrc == 2)
+                return AW_SYS_CLK_PLL3;
+            else if(aw_ccu_reg->GpuHyd.ClkSrc == 3)
+                return AW_SYS_CLK_PLL7;
+            else if(aw_ccu_reg->GpuHyd.ClkSrc == 4)
+                return AW_SYS_CLK_PLL9;
+            else if(aw_ccu_reg->GpuHyd.ClkSrc == 5)
+                return AW_SYS_CLK_PLL10;
+            else
+
+            {
+                aw_ccu_reg->GpuHyd.ClkSrc = 0;
+                return AW_SYS_CLK_PLL8;
+            }
+        }
+        case AW_MOD_CLK_HDMI:
+            if(aw_ccu_reg->Hdmi.ClkSrc == 0)
+                return AW_SYS_CLK_PLL3;
+            else if(aw_ccu_reg->Hdmi.ClkSrc == 1)
+                return AW_SYS_CLK_PLL7;
+            else if(aw_ccu_reg->Hdmi.ClkSrc == 2)
+                return AW_SYS_CLK_PLL3X2;
+            else
+                return AW_SYS_CLK_PLL7X2;
+
+        case AW_MOD_CLK_CSI0S:
+            if(aw_ccu_reg->Csi0.SClkSrc == 0)
+                return AW_SYS_CLK_PLL3;
+            else if(aw_ccu_reg->Csi0.SClkSrc == 1)
+                return AW_SYS_CLK_PLL7;
+            else if(aw_ccu_reg->Csi0.SClkSrc == 2)
+                return AW_SYS_CLK_PLL3X2;
+            else if(aw_ccu_reg->Csi0.SClkSrc == 3)
+                return AW_SYS_CLK_PLL7X2;
+            else if(aw_ccu_reg->Csi0.SClkSrc == 4)
+                return AW_SYS_CLK_MIPIPLL;
+            else if(aw_ccu_reg->Csi0.SClkSrc == 5)
+                return AW_SYS_CLK_PLL4;
+            else
+                return AW_SYS_CLK_NONE;
+        case AW_MOD_CLK_CSI0M:
+            if(aw_ccu_reg->Csi0.MClkSrc == 0)
+                return AW_SYS_CLK_PLL3;
+            else if(aw_ccu_reg->Csi0.MClkSrc == 1)
+                return AW_SYS_CLK_PLL7;
+            else if(aw_ccu_reg->Csi0.MClkSrc == 5)
+                return AW_SYS_CLK_HOSC;
+            else
+                return AW_SYS_CLK_NONE;
+        case AW_MOD_CLK_CSI1S:
+            if(aw_ccu_reg->Csi1.SClkSrc == 0)
+                return AW_SYS_CLK_PLL3;
+            else if(aw_ccu_reg->Csi1.SClkSrc == 1)
+                return AW_SYS_CLK_PLL7;
+            else if(aw_ccu_reg->Csi1.SClkSrc == 2)
+                return AW_SYS_CLK_PLL3X2;
+            else if(aw_ccu_reg->Csi1.SClkSrc == 3)
+                return AW_SYS_CLK_PLL7X2;
+            else if(aw_ccu_reg->Csi1.SClkSrc == 4)
+                return AW_SYS_CLK_MIPIPLL;
+            else if(aw_ccu_reg->Csi1.SClkSrc == 5)
+                return AW_SYS_CLK_PLL4;
+            else
+                return AW_SYS_CLK_NONE;
+        case AW_MOD_CLK_CSI1M:
+            if(aw_ccu_reg->Csi1.MClkSrc == 0)
+                return AW_SYS_CLK_PLL3;
+            else if(aw_ccu_reg->Csi1.MClkSrc == 1)
+                return AW_SYS_CLK_PLL7;
+            else if(aw_ccu_reg->Csi1.MClkSrc == 5)
+                return AW_SYS_CLK_HOSC;
+            else
+                return AW_SYS_CLK_NONE;
+
+        case AW_MOD_CLK_MIPIDSIS:
+            if(aw_ccu_reg->MipiDsi.SClkSrc == 0)
+                return AW_SYS_CLK_PLL3;
+            else if(aw_ccu_reg->MipiDsi.SClkSrc == 1)
+                return AW_SYS_CLK_PLL7;
+            else if(aw_ccu_reg->MipiDsi.SClkSrc == 2)
+                return AW_SYS_CLK_PLL3X2;
+            else
+                return AW_SYS_CLK_PLL7X2;
+        case AW_MOD_CLK_MIPIDSIP:
+            if(aw_ccu_reg->MipiDsi.PClkSrc == 0)
+                return AW_SYS_CLK_PLL3;
+            else if(aw_ccu_reg->MipiDsi.PClkSrc == 1)
+                return AW_SYS_CLK_PLL7;
+            else if(aw_ccu_reg->MipiDsi.PClkSrc == 2)
+                return AW_SYS_CLK_PLL3X2;
+            else
+                return AW_SYS_CLK_PLL7X2;
+        case AW_MOD_CLK_MIPICSIS:
+            if(aw_ccu_reg->MipiCsi.SClkSrc == 0)
+                return AW_SYS_CLK_PLL3;
+            else if(aw_ccu_reg->MipiCsi.SClkSrc == 1)
+                return AW_SYS_CLK_PLL7;
+            else if(aw_ccu_reg->MipiCsi.SClkSrc == 2)
+                return AW_SYS_CLK_PLL3X2;
+            else
+                return AW_SYS_CLK_PLL7X2;
+        case AW_MOD_CLK_MIPICSIP:
+            if(aw_ccu_reg->MipiCsi.PClkSrc == 0)
+                return AW_SYS_CLK_PLL3;
+            else if(aw_ccu_reg->MipiCsi.PClkSrc == 1)
+                return AW_SYS_CLK_PLL7;
+            else if(aw_ccu_reg->MipiCsi.PClkSrc == 2)
+                return AW_SYS_CLK_PLL3X2;
+            else
+                return AW_SYS_CLK_PLL7X2;
+
+        case AW_MOD_CLK_TWI0:
+        case AW_MOD_CLK_TWI1:
+        case AW_MOD_CLK_TWI2:
+        case AW_MOD_CLK_TWI3:
+        case AW_MOD_CLK_UART0:
+        case AW_MOD_CLK_UART1:
+        case AW_MOD_CLK_UART2:
+        case AW_MOD_CLK_UART3:
+        case AW_MOD_CLK_UART4:
+        case AW_MOD_CLK_UART5:
+            return AW_SYS_CLK_APB2;
+
+        case AW_MOD_CLK_R_1WIRE:
+        {
+            if(aw_cpus_reg->OneWire.ClkSrc == 0) {
+                return AW_SYS_CLK_LOSC;
+            } else if(aw_cpus_reg->OneWire.ClkSrc == 1) {
+                return AW_SYS_CLK_HOSC;
+            } else {
+                aw_cpus_reg->OneWire.ClkSrc = 0;
+                return AW_SYS_CLK_LOSC;
+            }
+        }
+        case AW_MOD_CLK_R_CIR:
+        {
+            if(aw_cpus_reg->Cir.ClkSrc == 0) {
+                return AW_SYS_CLK_LOSC;
+            } else if(aw_cpus_reg->Cir.ClkSrc == 1) {
+                return AW_SYS_CLK_HOSC;
+            } else {
+                aw_cpus_reg->Cir.ClkSrc = 0;
+                return AW_SYS_CLK_LOSC;
+            }
+        }
+
+        case AW_MOD_CLK_R_TWI:
+        case AW_MOD_CLK_R_UART:
+        case AW_MOD_CLK_R_P2WI:
+        case AW_MOD_CLK_R_TMR:
+        case AW_MOD_CLK_R_PIO:
+            return AW_SYS_CLK_APB0;
+
+        default:
+            return AW_SYS_CLK_NONE;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_get_status
+*
+*Description: get module clock on/off status;
+*
+*Arguments  : id    module clock id;
+*
+*Return     : result;
+*               AW_CCU_CLK_OFF, module clock is off;
+*               AW_CCU_CLK_ON,  module clock is on;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+#define GET_CLK_STATUS(reg)     (((__ccmu_module_clk_t *)(reg))->ClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF)
+static __aw_ccu_clk_onff_e mod_clk_get_status(__aw_ccu_clk_id_e id)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NAND0:
+            return GET_CLK_STATUS(&aw_ccu_reg->Nand0);
+        case AW_MOD_CLK_NAND1:
+            return GET_CLK_STATUS(&aw_ccu_reg->Nand1);
+        case AW_MOD_CLK_SDC0:
+            return GET_CLK_STATUS(&aw_ccu_reg->Sd0);
+        case AW_MOD_CLK_SDC1:
+            return GET_CLK_STATUS(&aw_ccu_reg->Sd1);
+        case AW_MOD_CLK_SDC2:
+            return GET_CLK_STATUS(&aw_ccu_reg->Sd2);
+        case AW_MOD_CLK_SDC3:
+            return GET_CLK_STATUS(&aw_ccu_reg->Sd3);
+        case AW_MOD_CLK_TS:
+            return GET_CLK_STATUS(&aw_ccu_reg->Ts);
+        case AW_MOD_CLK_SS:
+            return GET_CLK_STATUS(&aw_ccu_reg->Ss);
+        case AW_MOD_CLK_SPI0:
+            return GET_CLK_STATUS(&aw_ccu_reg->Spi0);
+        case AW_MOD_CLK_SPI1:
+            return GET_CLK_STATUS(&aw_ccu_reg->Spi1);
+        case AW_MOD_CLK_SPI2:
+            return GET_CLK_STATUS(&aw_ccu_reg->Spi2);
+        case AW_MOD_CLK_SPI3:
+            return GET_CLK_STATUS(&aw_ccu_reg->Spi3);
+        case AW_MOD_CLK_I2S0:
+            return GET_CLK_STATUS(&aw_ccu_reg->I2s0);
+        case AW_MOD_CLK_I2S1:
+            return GET_CLK_STATUS(&aw_ccu_reg->I2s1);
+        case AW_MOD_CLK_SPDIF:
+            return GET_CLK_STATUS(&aw_ccu_reg->Spdif);
+        case AW_MOD_CLK_USBPHY0:
+            return aw_ccu_reg->Usb.Phy0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBPHY1:
+            return aw_ccu_reg->Usb.Phy1Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBPHY2:
+            return aw_ccu_reg->Usb.Phy2Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBOHCI0:
+            return aw_ccu_reg->Usb.Phy0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBOHCI1:
+            return aw_ccu_reg->Usb.Phy0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_USBOHCI2:
+            return aw_ccu_reg->Usb.Phy0Gate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_MDFS:
+            return GET_CLK_STATUS(&aw_ccu_reg->Mdfs);
+        case AW_MOD_CLK_DEBE0:
+            return GET_CLK_STATUS(&aw_ccu_reg->Be0);
+        case AW_MOD_CLK_DEBE1:
+            return GET_CLK_STATUS(&aw_ccu_reg->Be1);
+        case AW_MOD_CLK_DEFE0:
+            return GET_CLK_STATUS(&aw_ccu_reg->Fe0);
+        case AW_MOD_CLK_DEFE1:
+            return GET_CLK_STATUS(&aw_ccu_reg->Fe1);
+        case AW_MOD_CLK_DEMIX:
+            return GET_CLK_STATUS(&aw_ccu_reg->Mp);
+        case AW_MOD_CLK_LCD0CH0:
+            return GET_CLK_STATUS(&aw_ccu_reg->Lcd0Ch0);
+        case AW_MOD_CLK_LCD0CH1:
+            return GET_CLK_STATUS(&aw_ccu_reg->Lcd0Ch1);
+        case AW_MOD_CLK_LCD1CH0:
+            return GET_CLK_STATUS(&aw_ccu_reg->Lcd1Ch0);
+        case AW_MOD_CLK_LCD1CH1:
+            return GET_CLK_STATUS(&aw_ccu_reg->Lcd1Ch1);
+        case AW_MOD_CLK_CSI0S:
+            return aw_ccu_reg->Csi0.SClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_CSI0M:
+            return aw_ccu_reg->Csi0.MClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_CSI1S:
+            return aw_ccu_reg->Csi1.SClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_CSI1M:
+            return aw_ccu_reg->Csi1.MClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_VE:
+            return aw_ccu_reg->Ve.ClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_ADDA:
+            return GET_CLK_STATUS(&aw_ccu_reg->Adda);
+        case AW_MOD_CLK_AVS:
+            return GET_CLK_STATUS(&aw_ccu_reg->Avs);
+        case AW_MOD_CLK_DMIC:
+            return GET_CLK_STATUS(&aw_ccu_reg->Dmic);
+        case AW_MOD_CLK_HDMI:
+            return GET_CLK_STATUS(&aw_ccu_reg->Hdmi);
+        case AW_MOD_CLK_HDMI_DDC:
+            return aw_ccu_reg->Hdmi.DDCGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_PS:
+            return GET_CLK_STATUS(&aw_ccu_reg->Ps);
+        case AW_MOD_CLK_MTCACC:
+            return GET_CLK_STATUS(&aw_ccu_reg->MtcAcc);
+        case AW_MOD_CLK_MBUS0:
+            return GET_CLK_STATUS(&aw_ccu_reg->MBus0);
+        case AW_MOD_CLK_MBUS1:
+            return GET_CLK_STATUS(&aw_ccu_reg->MBus1);
+        case AW_MOD_CLK_MIPIDSIS:
+            return aw_ccu_reg->MipiDsi.SClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_MIPIDSIP:
+            return aw_ccu_reg->MipiDsi.PClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_MIPICSIS:
+            return aw_ccu_reg->MipiCsi.SClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_MIPICSIP:
+            return aw_ccu_reg->MipiCsi.PClkGate? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_IEPDRC0:
+            return GET_CLK_STATUS(&aw_ccu_reg->IepDrc0);
+        case AW_MOD_CLK_IEPDRC1:
+            return GET_CLK_STATUS(&aw_ccu_reg->IepDrc1);
+        case AW_MOD_CLK_IEPDEU0:
+            return GET_CLK_STATUS(&aw_ccu_reg->IepDeu0);
+        case AW_MOD_CLK_IEPDEU1:
+            return GET_CLK_STATUS(&aw_ccu_reg->IepDeu1);
+        case AW_MOD_CLK_GPUCORE:
+            return GET_CLK_STATUS(&aw_ccu_reg->GpuCore);
+        case AW_MOD_CLK_GPUMEM:
+            return GET_CLK_STATUS(&aw_ccu_reg->GpuMem);
+        case AW_MOD_CLK_GPUHYD:
+            return GET_CLK_STATUS(&aw_ccu_reg->GpuHyd);
+        case AW_AXI_CLK_DRAM:
+            return aw_ccu_reg->AxiGate.Sdram? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_MIPICSI:
+            return aw_ccu_reg->AhbGate0.MipiCsi? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_MIPIDSI:
+            return aw_ccu_reg->AhbGate0.MipiDsi? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SS:
+            return aw_ccu_reg->AhbGate0.Ss? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_DMA:
+            return aw_ccu_reg->AhbGate0.Dma? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SDMMC0:
+            return aw_ccu_reg->AhbGate0.Sd0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SDMMC1:
+            return aw_ccu_reg->AhbGate0.Sd1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SDMMC2:
+            return aw_ccu_reg->AhbGate0.Sd2? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SDMMC3:
+            return aw_ccu_reg->AhbGate0.Sd3? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_NAND1:
+            return aw_ccu_reg->AhbGate0.Nand1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_NAND0:
+            return aw_ccu_reg->AhbGate0.Nand0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SDRAM:
+            return aw_ccu_reg->AhbGate0.Dram? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_GMAC:
+            return aw_ccu_reg->AhbGate0.Gmac? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_TS:
+            return aw_ccu_reg->AhbGate0.Ts? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_HSTMR:
+            return aw_ccu_reg->AhbGate0.HsTmr? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SPI0:
+            return aw_ccu_reg->AhbGate0.Spi0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SPI1:
+            return aw_ccu_reg->AhbGate0.Spi1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SPI2:
+            return aw_ccu_reg->AhbGate0.Spi2? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SPI3:
+            return aw_ccu_reg->AhbGate0.Spi3? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_OTG:
+            return aw_ccu_reg->AhbGate0.Otg? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_EHCI0:
+            return aw_ccu_reg->AhbGate0.Ehci0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_EHCI1:
+            return aw_ccu_reg->AhbGate0.Ehci1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_OHCI0:
+            return aw_ccu_reg->AhbGate0.Ohci0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_OHCI1:
+            return aw_ccu_reg->AhbGate0.Ohci1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_OHCI2:
+            return aw_ccu_reg->AhbGate0.Ohci2? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_VE:
+            return aw_ccu_reg->AhbGate1.Ve? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_LCD0:
+            return aw_ccu_reg->AhbGate1.Lcd0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_LCD1:
+            return aw_ccu_reg->AhbGate1.Lcd1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_CSI0:
+            return aw_ccu_reg->AhbGate1.Csi0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_CSI1:
+            return aw_ccu_reg->AhbGate1.Csi1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_HDMI:
+            return aw_ccu_reg->AhbGate1.Hdmi? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_DEBE0:
+            return aw_ccu_reg->AhbGate1.Be0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_DEBE1:
+            return aw_ccu_reg->AhbGate1.Be1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_DEFE0:
+            return aw_ccu_reg->AhbGate1.Fe0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_DEFE1:
+            return aw_ccu_reg->AhbGate1.Fe1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_MP:
+            return aw_ccu_reg->AhbGate1.Mp? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_GPU:
+            return aw_ccu_reg->AhbGate1.Gpu? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_MSGBOX:
+            return aw_ccu_reg->AhbGate1.MsgBox? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_SPINLOCK:
+            return aw_ccu_reg->AhbGate1.SpinLock? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_DEU0:
+            return aw_ccu_reg->AhbGate1.Deu0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_DEU1:
+            return aw_ccu_reg->AhbGate1.Deu1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_DRC0:
+            return aw_ccu_reg->AhbGate1.Drc0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_DRC1:
+            return aw_ccu_reg->AhbGate1.Drc1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_AHB_CLK_MTCACC:
+            return aw_ccu_reg->AhbGate1.MtcAcc? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_ADDA:
+            return aw_ccu_reg->Apb1Gate.Adda? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_SPDIF:
+            return aw_ccu_reg->Apb1Gate.Spdif? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_PIO:
+            return aw_ccu_reg->Apb1Gate.Pio? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_I2S0:
+            return aw_ccu_reg->Apb1Gate.I2s0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_I2S1:
+            return aw_ccu_reg->Apb1Gate.I2s1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_TWI0:
+            return aw_ccu_reg->Apb2Gate.Twi0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_TWI1:
+            return aw_ccu_reg->Apb2Gate.Twi1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_TWI2:
+            return aw_ccu_reg->Apb2Gate.Twi2? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_TWI3:
+            return aw_ccu_reg->Apb2Gate.Twi3? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_UART0:
+            return aw_ccu_reg->Apb2Gate.Uart0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_UART1:
+            return aw_ccu_reg->Apb2Gate.Uart1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_UART2:
+            return aw_ccu_reg->Apb2Gate.Uart2? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_UART3:
+            return aw_ccu_reg->Apb2Gate.Uart3? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_UART4:
+            return aw_ccu_reg->Apb2Gate.Uart4? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_APB_CLK_UART5:
+            return aw_ccu_reg->Apb2Gate.Uart5? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_VE:
+            return aw_ccu_reg->DramGate.Ve? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_CSI_ISP:
+            return aw_ccu_reg->DramGate.CsiIsp? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_TS:
+            return aw_ccu_reg->DramGate.Ts? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_DRC0:
+            return aw_ccu_reg->DramGate.Drc0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_DRC1:
+            return aw_ccu_reg->DramGate.Drc1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_DEU0:
+            return aw_ccu_reg->DramGate.Deu0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_DEU1:
+            return aw_ccu_reg->DramGate.Deu1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_DEFE0:
+            return aw_ccu_reg->DramGate.Fe0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_DEFE1:
+            return aw_ccu_reg->DramGate.Fe1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_DEBE0:
+            return aw_ccu_reg->DramGate.Be0? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_DEBE1:
+            return aw_ccu_reg->DramGate.Be1? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_DRAM_CLK_MP:
+            return aw_ccu_reg->DramGate.Mp? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+
+        case AW_MOD_CLK_R_1WIRE:
+            return (aw_cpus_reg->Apb0Gate.OneWire && aw_cpus_reg->OneWire.ClkGate)? \
+                        AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_R_CIR:
+            return (aw_cpus_reg->Apb0Gate.Cir && aw_cpus_reg->Cir.ClkGate)?     \
+                        AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_R_TWI:
+            return aw_cpus_reg->Apb0Gate.Twi? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_R_UART:
+            return aw_cpus_reg->Apb0Gate.Uart? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_R_P2WI:
+            return aw_cpus_reg->Apb0Gate.P2wi? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_R_TMR:
+            return aw_cpus_reg->Apb0Gate.Tmr? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_MOD_CLK_R_PIO:
+            return aw_cpus_reg->Apb0Gate.Pio? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+
+        default:
+            return AW_CCU_CLK_ON;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_get_rate
+*
+*Description: get module clock rate;
+*
+*Arguments  : id    module clock id;
+*
+*Return     : module clock division;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s64 mod_clk_get_rate(__aw_ccu_clk_id_e id)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NAND0:
+            return _get_module0_clk_rate(&aw_ccu_reg->Nand0);
+        case AW_MOD_CLK_NAND1:
+            return _get_module0_clk_rate(&aw_ccu_reg->Nand1);
+        case AW_MOD_CLK_SDC0:
+            return _get_module0_clk_rate(&aw_ccu_reg->Sd0);
+        case AW_MOD_CLK_SDC1:
+            return _get_module0_clk_rate(&aw_ccu_reg->Sd1);
+        case AW_MOD_CLK_SDC2:
+            return _get_module0_clk_rate(&aw_ccu_reg->Sd2);
+        case AW_MOD_CLK_SDC3:
+            return _get_module0_clk_rate(&aw_ccu_reg->Sd3);
+        case AW_MOD_CLK_TS:
+            return _get_module0_clk_rate(&aw_ccu_reg->Ts);
+        case AW_MOD_CLK_SS:
+            return _get_module0_clk_rate(&aw_ccu_reg->Ss);
+        case AW_MOD_CLK_SPI0:
+            return _get_module0_clk_rate(&aw_ccu_reg->Spi0);
+        case AW_MOD_CLK_SPI1:
+            return _get_module0_clk_rate(&aw_ccu_reg->Spi1);
+        case AW_MOD_CLK_SPI2:
+            return _get_module0_clk_rate(&aw_ccu_reg->Spi2);
+        case AW_MOD_CLK_SPI3:
+            return _get_module0_clk_rate(&aw_ccu_reg->Spi3);
+        case AW_MOD_CLK_MDFS:
+            return _get_module0_clk_rate(&aw_ccu_reg->Mdfs);
+        case AW_MOD_CLK_DEBE0:
+            return aw_ccu_reg->Be0.DivM+1;
+        case AW_MOD_CLK_DEBE1:
+            return aw_ccu_reg->Be1.DivM+1;
+        case AW_MOD_CLK_DEFE0:
+            return aw_ccu_reg->Fe0.DivM+1;
+        case AW_MOD_CLK_DEFE1:
+            return aw_ccu_reg->Fe1.DivM+1;
+        case AW_MOD_CLK_DEMIX:
+            return aw_ccu_reg->Mp.DivM+1;
+        case AW_MOD_CLK_LCD0CH0:
+            return aw_ccu_reg->Lcd0Ch0.DivM+1;
+        case AW_MOD_CLK_LCD0CH1:
+            return aw_ccu_reg->Lcd0Ch1.DivM+1;
+        case AW_MOD_CLK_LCD1CH0:
+            return aw_ccu_reg->Lcd1Ch0.DivM+1;
+        case AW_MOD_CLK_LCD1CH1:
+            return aw_ccu_reg->Lcd1Ch1.DivM+1;
+        case AW_MOD_CLK_HDMI:
+	    return aw_ccu_reg->Hdmi.ClkDiv+1;
+        case AW_MOD_CLK_CSI0S:
+            return aw_ccu_reg->Csi0.SClkDiv+1;
+        case AW_MOD_CLK_CSI0M:
+            return aw_ccu_reg->Csi0.MClkDiv+1;
+        case AW_MOD_CLK_CSI1S:
+            return aw_ccu_reg->Csi1.SClkDiv+1;
+        case AW_MOD_CLK_CSI1M:
+            return aw_ccu_reg->Csi1.MClkDiv+1;
+        case AW_MOD_CLK_VE:
+            return aw_ccu_reg->Ve.ClkDiv+1;
+        case AW_MOD_CLK_MTCACC:
+            return _get_module0_clk_rate(&aw_ccu_reg->MtcAcc);
+        case AW_MOD_CLK_MBUS0:
+            return _get_module0_clk_rate(&aw_ccu_reg->MBus0);
+        case AW_MOD_CLK_MBUS1:
+            return _get_module0_clk_rate(&aw_ccu_reg->MBus1);
+        case AW_MOD_CLK_MIPIDSIS:
+            return aw_ccu_reg->MipiDsi.SClkDiv+1;
+        case AW_MOD_CLK_MIPIDSIP:
+            return aw_ccu_reg->MipiDsi.PClkDiv+1;
+        case AW_MOD_CLK_MIPICSIS:
+            return aw_ccu_reg->MipiCsi.SClkDiv+1;
+        case AW_MOD_CLK_MIPICSIP:
+            return aw_ccu_reg->MipiCsi.PClkDiv+1;
+        case AW_MOD_CLK_IEPDRC0:
+            return _get_module0_clk_rate(&aw_ccu_reg->IepDrc0);
+        case AW_MOD_CLK_IEPDRC1:
+            return _get_module0_clk_rate(&aw_ccu_reg->IepDrc1);
+        case AW_MOD_CLK_IEPDEU0:
+            return _get_module0_clk_rate(&aw_ccu_reg->IepDeu0);
+        case AW_MOD_CLK_IEPDEU1:
+            return _get_module0_clk_rate(&aw_ccu_reg->IepDeu1);
+        case AW_MOD_CLK_GPUCORE:
+            return _get_module0_clk_rate(&aw_ccu_reg->GpuCore);
+        case AW_MOD_CLK_GPUMEM:
+            return _get_module0_clk_rate(&aw_ccu_reg->GpuMem);
+        case AW_MOD_CLK_GPUHYD:
+            return _get_module0_clk_rate(&aw_ccu_reg->GpuHyd);
+
+        case AW_MOD_CLK_R_1WIRE:
+	    return (1<<aw_cpus_reg->OneWire.DivN)*(aw_cpus_reg->OneWire.DivM+1);
+        case AW_MOD_CLK_R_CIR:
+            return _get_module0_clk_rate(&aw_cpus_reg->Cir);
+
+        default:
+            return 1;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_set_parent
+*
+*Description: set clock parent id for module clock;
+*
+*Arguments  : id        module clock id;
+*             parent    parent clock id;
+*
+*Return     : result;
+*               0,  set parent successed;
+*              !0,  set parent failed;
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 mod_clk_set_parent(__aw_ccu_clk_id_e id, __aw_ccu_clk_id_e parent)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NAND0:
+            return _set_module0_clk_src(&aw_ccu_reg->Nand0, parent);
+        case AW_MOD_CLK_NAND1:
+            return _set_module0_clk_src(&aw_ccu_reg->Nand1, parent);
+        case AW_MOD_CLK_SDC0:
+            return _set_module0_clk_src(&aw_ccu_reg->Sd0, parent);
+        case AW_MOD_CLK_SDC1:
+            return _set_module0_clk_src(&aw_ccu_reg->Sd1, parent);
+        case AW_MOD_CLK_SDC2:
+            return _set_module0_clk_src(&aw_ccu_reg->Sd2, parent);
+        case AW_MOD_CLK_SDC3:
+            return _set_module0_clk_src(&aw_ccu_reg->Sd3, parent);
+        case AW_MOD_CLK_TS:
+            return _set_module0_clk_src(&aw_ccu_reg->Ts, parent);
+        case AW_MOD_CLK_SS:
+            return _set_module0_clk_src(&aw_ccu_reg->Ss, parent);
+        case AW_MOD_CLK_SPI0:
+            return _set_module0_clk_src(&aw_ccu_reg->Spi0, parent);
+        case AW_MOD_CLK_SPI1:
+            return _set_module0_clk_src(&aw_ccu_reg->Spi1, parent);
+        case AW_MOD_CLK_SPI2:
+            return _set_module0_clk_src(&aw_ccu_reg->Spi2, parent);
+        case AW_MOD_CLK_SPI3:
+            return _set_module0_clk_src(&aw_ccu_reg->Spi3, parent);
+        case AW_MOD_CLK_I2S0:
+            return _set_module1_clk_src(&aw_ccu_reg->I2s0, parent);
+        case AW_MOD_CLK_I2S1:
+            return _set_module1_clk_src(&aw_ccu_reg->I2s1, parent);
+        case AW_MOD_CLK_SPDIF:
+            return _set_module1_clk_src(&aw_ccu_reg->Spdif, parent);
+        case AW_MOD_CLK_MDFS:
+        {
+            if(parent == AW_SYS_CLK_PLL5)
+                aw_ccu_reg->Mdfs.ClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL6)
+                aw_ccu_reg->Mdfs.ClkSrc = 1;
+            else
+            {
+                CCU_ERR("set clock source failed! set AW_MOD_CLK_MDFS to %d!\n", parent);
+                return -1;
+            }
+            return 0;
+        }
+        case AW_MOD_CLK_DEBE0:
+            return _set_disp_clk_src(&aw_ccu_reg->Be0, parent, DE_BE_INDX);
+        case AW_MOD_CLK_DEBE1:
+            return _set_disp_clk_src(&aw_ccu_reg->Be1, parent, DE_BE_INDX);
+        case AW_MOD_CLK_DEFE0:
+            return _set_disp_clk_src(&aw_ccu_reg->Fe0, parent, DE_FE_INDX);
+        case AW_MOD_CLK_DEFE1:
+            return _set_disp_clk_src(&aw_ccu_reg->Fe1, parent, DE_FE_INDX);
+        case AW_MOD_CLK_DEMIX:
+            return _set_disp_clk_src(&aw_ccu_reg->Mp, parent, DE_MP_INDX);
+        case AW_MOD_CLK_LCD0CH0:
+            return _set_disp_clk_src(&aw_ccu_reg->Lcd0Ch0, parent, LCD_CH0_INDX);
+        case AW_MOD_CLK_LCD0CH1:
+            return _set_disp_clk_src(&aw_ccu_reg->Lcd0Ch1, parent, LCD_CH1_INDX);
+        case AW_MOD_CLK_LCD1CH0:
+            return _set_disp_clk_src(&aw_ccu_reg->Lcd1Ch0, parent, LCD_CH0_INDX);
+        case AW_MOD_CLK_LCD1CH1:
+            return _set_disp_clk_src(&aw_ccu_reg->Lcd1Ch1, parent, LCD_CH1_INDX);
+        case AW_MOD_CLK_ADDA:
+            return _set_module1_clk_src(&aw_ccu_reg->Adda, parent);
+        case AW_MOD_CLK_AVS:
+            return parent == AW_SYS_CLK_HOSC? 0 : -1;
+        case AW_MOD_CLK_PS:
+            return _set_module1_clk_src(&aw_ccu_reg->Ps, parent);
+        case AW_MOD_CLK_MTCACC:
+            return _set_module0_clk_src(&aw_ccu_reg->MtcAcc, parent);
+        case AW_MOD_CLK_MBUS0:
+        {
+            if(parent == AW_SYS_CLK_HOSC)
+                aw_ccu_reg->MBus0.ClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL6)
+                aw_ccu_reg->MBus0.ClkSrc = 1;
+            else if(parent == AW_SYS_CLK_PLL5)
+                aw_ccu_reg->MBus0.ClkSrc = 2;
+            else
+            {
+                CCU_ERR("set clock source failed! set AW_MOD_CLK_MBUS0 to %d!\n", parent);
+                return -1;
+            }
+            return 0;
+        }
+        case AW_MOD_CLK_MBUS1:
+        {
+            if(parent == AW_SYS_CLK_HOSC)
+                aw_ccu_reg->MBus1.ClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL6)
+                aw_ccu_reg->MBus1.ClkSrc = 1;
+            else if(parent == AW_SYS_CLK_PLL5)
+                aw_ccu_reg->MBus1.ClkSrc = 2;
+            else
+            {
+                CCU_ERR("set clock source failed! set AW_MOD_CLK_MBUS1 to %d!\n", parent);
+                return -1;
+            }
+            return 0;
+        }
+        case AW_MOD_CLK_IEPDRC0:
+        {
+            if(parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->IepDrc0.ClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->IepDrc0.ClkSrc = 1;
+            else if(parent == AW_SYS_CLK_PLL8)
+                aw_ccu_reg->IepDrc0.ClkSrc = 3;
+            else if(parent == AW_SYS_CLK_PLL9)
+                aw_ccu_reg->IepDrc0.ClkSrc = 4;
+            else if(parent == AW_SYS_CLK_PLL10)
+                aw_ccu_reg->IepDrc0.ClkSrc = 5;
+            else
+            {
+                CCU_ERR("set clock source failed! set AW_MOD_CLK_IEPDRC0 to %d!\n", parent);
+                return -1;
+            }
+            return 0;
+        }
+        case AW_MOD_CLK_IEPDRC1:
+        {
+            if(parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->IepDrc1.ClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->IepDrc1.ClkSrc = 1;
+            else if(parent == AW_SYS_CLK_PLL8)
+                aw_ccu_reg->IepDrc1.ClkSrc = 3;
+            else if(parent == AW_SYS_CLK_PLL9)
+                aw_ccu_reg->IepDrc1.ClkSrc = 4;
+            else if(parent == AW_SYS_CLK_PLL10)
+                aw_ccu_reg->IepDrc1.ClkSrc = 5;
+            else
+            {
+                CCU_ERR("set clock source failed! set AW_MOD_CLK_IEPDRC1 to %d!\n", parent);
+                return -1;
+            }
+            return 0;
+        }
+        case AW_MOD_CLK_IEPDEU0:
+        {
+            if(parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->IepDeu0.ClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->IepDeu0.ClkSrc = 1;
+            else if(parent == AW_SYS_CLK_PLL8)
+                aw_ccu_reg->IepDeu0.ClkSrc = 3;
+            else if(parent == AW_SYS_CLK_PLL9)
+                aw_ccu_reg->IepDeu0.ClkSrc = 4;
+            else if(parent == AW_SYS_CLK_PLL10)
+                aw_ccu_reg->IepDeu0.ClkSrc = 5;
+            else
+            {
+                CCU_ERR("set clock source failed! set AW_MOD_CLK_IEPDEU0 to %d!\n", parent);
+                return -1;
+            }
+            return 0;
+        }
+        case AW_MOD_CLK_IEPDEU1:
+        {
+            if(parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->IepDeu1.ClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->IepDeu1.ClkSrc = 1;
+            else if(parent == AW_SYS_CLK_PLL8)
+                aw_ccu_reg->IepDeu1.ClkSrc = 3;
+            else if(parent == AW_SYS_CLK_PLL9)
+                aw_ccu_reg->IepDeu1.ClkSrc = 4;
+            else if(parent == AW_SYS_CLK_PLL10)
+                aw_ccu_reg->IepDeu1.ClkSrc = 5;
+            else
+            {
+                CCU_ERR("set clock source failed! set AW_MOD_CLK_IEPDEU1 to %d!\n", parent);
+                return -1;
+            }
+            return 0;
+        }
+        case AW_MOD_CLK_GPUCORE:
+        {
+            if(parent == AW_SYS_CLK_PLL8)
+                aw_ccu_reg->GpuCore.ClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->GpuCore.ClkSrc = 2;
+            else if(parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->GpuCore.ClkSrc = 3;
+            else if(parent == AW_SYS_CLK_PLL9)
+                aw_ccu_reg->GpuCore.ClkSrc = 4;
+            else if(parent == AW_SYS_CLK_PLL10)
+                aw_ccu_reg->GpuCore.ClkSrc = 5;
+            else
+            {
+                CCU_ERR("set clock source failed! set AW_MOD_CLK_GPUCORE to %d!\n", parent);
+                return -1;
+            }
+            return 0;
+        }
+        case AW_MOD_CLK_GPUMEM:
+        {
+            if(parent == AW_SYS_CLK_PLL8)
+                aw_ccu_reg->GpuMem.ClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->GpuMem.ClkSrc = 2;
+            else if(parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->GpuMem.ClkSrc = 3;
+            else if(parent == AW_SYS_CLK_PLL9)
+                aw_ccu_reg->GpuMem.ClkSrc = 4;
+            else if(parent == AW_SYS_CLK_PLL10)
+                aw_ccu_reg->GpuMem.ClkSrc = 5;
+            else
+            {
+                CCU_ERR("set clock source failed! set AW_MOD_CLK_GPUMEM to %d!\n", parent);
+                return -1;
+            }
+            return 0;
+        }
+        case AW_MOD_CLK_GPUHYD:
+        {
+            if(parent == AW_SYS_CLK_PLL8)
+                aw_ccu_reg->GpuHyd.ClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->GpuHyd.ClkSrc = 2;
+            else if(parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->GpuHyd.ClkSrc = 3;
+            else if(parent == AW_SYS_CLK_PLL9)
+                aw_ccu_reg->GpuHyd.ClkSrc = 4;
+            else if(parent == AW_SYS_CLK_PLL10)
+                aw_ccu_reg->GpuHyd.ClkSrc = 5;
+            else
+            {
+                CCU_ERR("set clock source failed! set AW_MOD_CLK_GPUHYD to %d!\n", parent);
+                return -1;
+            }
+            return 0;
+        }
+        case AW_MOD_CLK_HDMI:
+            if(parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->Hdmi.ClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->Hdmi.ClkSrc = 1;
+            else if(parent == AW_SYS_CLK_PLL3X2)
+                aw_ccu_reg->Hdmi.ClkSrc = 2;
+            else if(parent == AW_SYS_CLK_PLL7X2)
+                aw_ccu_reg->Hdmi.ClkSrc = 3;
+            else
+                return -1;
+            return 0;
+        case AW_MOD_CLK_CSI0S:
+            if(parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->Csi0.SClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->Csi0.SClkSrc = 1;
+            else if(parent == AW_SYS_CLK_PLL3X2)
+                aw_ccu_reg->Csi0.SClkSrc = 2;
+            else if(parent == AW_SYS_CLK_PLL7X2)
+                aw_ccu_reg->Csi0.SClkSrc = 3;
+            else if(parent == AW_SYS_CLK_MIPIPLL)
+                aw_ccu_reg->Csi0.SClkSrc = 4;
+            else if(parent == AW_SYS_CLK_PLL4)
+                aw_ccu_reg->Csi0.SClkSrc = 5;
+            else
+                return -1;
+            return 0;
+        case AW_MOD_CLK_CSI0M:
+            if(parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->Csi0.MClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->Csi0.MClkSrc = 1;
+            else if(parent == AW_SYS_CLK_HOSC)
+                aw_ccu_reg->Csi0.MClkSrc = 5;
+            else
+                return -1;
+            return 0;
+        case AW_MOD_CLK_CSI1S:
+            if(parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->Csi1.SClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->Csi1.SClkSrc = 1;
+            else if(parent == AW_SYS_CLK_PLL3X2)
+                aw_ccu_reg->Csi1.SClkSrc = 2;
+            else if(parent == AW_SYS_CLK_PLL7X2)
+                aw_ccu_reg->Csi1.SClkSrc = 3;
+            else if(parent == AW_SYS_CLK_MIPIPLL)
+                aw_ccu_reg->Csi1.SClkSrc = 4;
+            else if(parent == AW_SYS_CLK_PLL4)
+                aw_ccu_reg->Csi1.SClkSrc = 5;
+            else
+                return -1;
+            return 0;
+        case AW_MOD_CLK_CSI1M:
+            if(parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->Csi1.MClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->Csi1.MClkSrc = 1;
+            else if(parent == AW_SYS_CLK_HOSC)
+                aw_ccu_reg->Csi1.MClkSrc = 5;
+            else
+                return -1;
+            return 0;
+        case AW_MOD_CLK_MIPIDSIS:
+            if(parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->MipiDsi.SClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->MipiDsi.SClkSrc = 1;
+            else if(parent == AW_SYS_CLK_PLL3X2)
+                aw_ccu_reg->MipiDsi.SClkSrc = 2;
+            else if(parent == AW_SYS_CLK_PLL7X2)
+                aw_ccu_reg->MipiDsi.SClkSrc = 3;
+            else
+                return -1;
+            return 0;
+        case AW_MOD_CLK_MIPIDSIP:
+            if(parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->MipiDsi.PClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->MipiDsi.PClkSrc = 1;
+            else if(parent == AW_SYS_CLK_PLL3X2)
+                aw_ccu_reg->MipiDsi.PClkSrc = 2;
+            else if(parent == AW_SYS_CLK_PLL7X2)
+                aw_ccu_reg->MipiDsi.PClkSrc = 3;
+            else
+                return -1;
+            return 0;
+        case AW_MOD_CLK_MIPICSIS:
+            if(parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->MipiCsi.SClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->MipiCsi.SClkSrc = 1;
+            else if(parent == AW_SYS_CLK_PLL3X2)
+                aw_ccu_reg->MipiCsi.SClkSrc = 2;
+            else if(parent == AW_SYS_CLK_PLL7X2)
+                aw_ccu_reg->MipiCsi.SClkSrc = 3;
+            else
+                return -1;
+            return 0;
+        case AW_MOD_CLK_MIPICSIP:
+            if(parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->MipiCsi.PClkSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->MipiCsi.PClkSrc = 1;
+            else if(parent == AW_SYS_CLK_PLL3X2)
+                aw_ccu_reg->MipiCsi.PClkSrc = 2;
+            else if(parent == AW_SYS_CLK_PLL7X2)
+                aw_ccu_reg->MipiCsi.PClkSrc = 3;
+            else
+                return -1;
+            return 0;
+
+        case AW_MOD_CLK_R_1WIRE:
+        {
+            if(parent == AW_SYS_CLK_LOSC) {
+                aw_cpus_reg->OneWire.ClkSrc = 0;
+            } else if(parent == AW_SYS_CLK_HOSC) {
+                aw_cpus_reg->OneWire.ClkSrc = 1;
+            } else {
+                return -1;
+            }
+            return 0;
+        }
+        case AW_MOD_CLK_R_CIR:
+        {
+            if(parent == AW_SYS_CLK_LOSC) {
+                aw_cpus_reg->Cir.ClkSrc = 0;
+            } else if(parent == AW_SYS_CLK_HOSC) {
+                aw_cpus_reg->Cir.ClkSrc = 1;
+            } else {
+                return -1;
+            }
+            return 0;
+        }
+
+        case AW_MOD_CLK_R_TWI:
+        case AW_MOD_CLK_R_UART:
+        case AW_MOD_CLK_R_P2WI:
+        case AW_MOD_CLK_R_TMR:
+        case AW_MOD_CLK_R_PIO:
+        {
+            if(parent == AW_SYS_CLK_APB0){
+                return 0;
+            }
+
+            return -1;
+        }
+
+        default:
+            return 0;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_set_status
+*
+*Description: set module clock on/off status;
+*
+*Arguments  : id        module clock id;
+*             status    module clock on/off status;
+*
+*Return     : result
+*               0,  set module clock on/off status successed;
+*              !0,  set module clock on/off status failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+#define STATUS_BIT(status)  ((status == AW_CCU_CLK_ON)? 1:0)
+static __s32 mod_clk_set_status(__aw_ccu_clk_id_e id, __aw_ccu_clk_onff_e status)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NAND0:
+            aw_ccu_reg->Nand0.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_NAND1:
+            aw_ccu_reg->Nand1.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_SDC0:
+            aw_ccu_reg->Sd0.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_SDC1:
+            aw_ccu_reg->Sd1.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_SDC2:
+            aw_ccu_reg->Sd2.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_SDC3:
+            aw_ccu_reg->Sd3.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_TS:
+            aw_ccu_reg->Ts.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_SS:
+            aw_ccu_reg->Ss.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_SPI0:
+            aw_ccu_reg->Spi0.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_SPI1:
+            aw_ccu_reg->Spi1.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_SPI2:
+            aw_ccu_reg->Spi2.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_SPI3:
+            aw_ccu_reg->Spi3.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_I2S0:
+            aw_ccu_reg->I2s0.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_I2S1:
+            aw_ccu_reg->I2s1.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_SPDIF:
+            aw_ccu_reg->Spdif.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_USBPHY0:
+            aw_ccu_reg->Usb.Phy0Gate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_USBPHY1:
+            aw_ccu_reg->Usb.Phy1Gate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_USBPHY2:
+            aw_ccu_reg->Usb.Phy2Gate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_USBOHCI0:
+            aw_ccu_reg->Usb.Ohci0Gate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_USBOHCI1:
+            aw_ccu_reg->Usb.Ohci1Gate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_USBOHCI2:
+            aw_ccu_reg->Usb.Ohci2Gate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_MDFS:
+            aw_ccu_reg->Mdfs.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_DEBE0:
+            aw_ccu_reg->Be0.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_DEBE1:
+            aw_ccu_reg->Be1.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_DEFE0:
+            aw_ccu_reg->Fe0.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_DEFE1:
+            aw_ccu_reg->Fe1.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_DEMIX:
+            aw_ccu_reg->Mp.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_LCD0CH0:
+            aw_ccu_reg->Lcd0Ch0.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_LCD0CH1:
+            aw_ccu_reg->Lcd0Ch1.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_LCD1CH0:
+            aw_ccu_reg->Lcd1Ch0.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_LCD1CH1:
+            aw_ccu_reg->Lcd1Ch1.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_CSI0S:
+            aw_ccu_reg->Csi0.SClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_CSI0M:
+            aw_ccu_reg->Csi0.MClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_CSI1S:
+            aw_ccu_reg->Csi1.SClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_CSI1M:
+            aw_ccu_reg->Csi1.MClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_VE:
+            aw_ccu_reg->Ve.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_ADDA:
+            aw_ccu_reg->Adda.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_AVS:
+            aw_ccu_reg->Avs.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_DMIC:
+            aw_ccu_reg->Dmic.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_HDMI:
+            aw_ccu_reg->Hdmi.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_HDMI_DDC:
+            return aw_ccu_reg->Hdmi.DDCGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_PS:
+            aw_ccu_reg->Ps.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_MTCACC:
+            aw_ccu_reg->MtcAcc.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_MBUS0:
+            aw_ccu_reg->MBus0.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_MBUS1:
+            aw_ccu_reg->MBus1.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_MIPIDSIS:
+            aw_ccu_reg->MipiDsi.SClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_MIPIDSIP:
+            aw_ccu_reg->MipiDsi.PClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_MIPICSIS:
+            aw_ccu_reg->MipiCsi.SClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_MIPICSIP:
+            aw_ccu_reg->MipiCsi.PClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_IEPDRC0:
+            aw_ccu_reg->IepDrc0.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_IEPDRC1:
+            aw_ccu_reg->IepDrc1.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_IEPDEU0:
+            aw_ccu_reg->IepDeu0.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_IEPDEU1:
+            aw_ccu_reg->IepDeu1.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_GPUCORE:
+            aw_ccu_reg->GpuCore.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_GPUMEM:
+            aw_ccu_reg->GpuMem.ClkGate = STATUS_BIT(status); break;
+        case AW_MOD_CLK_GPUHYD:
+            aw_ccu_reg->GpuHyd.ClkGate = STATUS_BIT(status); break;
+        case AW_AXI_CLK_DRAM:
+            aw_ccu_reg->AxiGate.Sdram = STATUS_BIT(status); break;
+        case AW_AHB_CLK_MIPICSI:
+            aw_ccu_reg->AhbGate0.MipiCsi = STATUS_BIT(status); break;
+        case AW_AHB_CLK_MIPIDSI:
+            aw_ccu_reg->AhbGate0.MipiDsi = STATUS_BIT(status); break;
+        case AW_AHB_CLK_SS:
+            aw_ccu_reg->AhbGate0.Ss = STATUS_BIT(status); break;
+        case AW_AHB_CLK_DMA:
+            aw_ccu_reg->AhbGate0.Dma = STATUS_BIT(status); break;
+        case AW_AHB_CLK_SDMMC0:
+            aw_ccu_reg->AhbGate0.Sd0 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_SDMMC1:
+            aw_ccu_reg->AhbGate0.Sd1 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_SDMMC2:
+            aw_ccu_reg->AhbGate0.Sd2 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_SDMMC3:
+            aw_ccu_reg->AhbGate0.Sd3 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_NAND1:
+            aw_ccu_reg->AhbGate0.Nand1 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_NAND0:
+            aw_ccu_reg->AhbGate0.Nand0 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_SDRAM:
+            aw_ccu_reg->AhbGate0.Dram = STATUS_BIT(status); break;
+        case AW_AHB_CLK_GMAC:
+            aw_ccu_reg->AhbGate0.Gmac = STATUS_BIT(status); break;
+        case AW_AHB_CLK_TS:
+            aw_ccu_reg->AhbGate0.Ts = STATUS_BIT(status); break;
+        case AW_AHB_CLK_HSTMR:
+            aw_ccu_reg->AhbGate0.HsTmr = STATUS_BIT(status); break;
+        case AW_AHB_CLK_SPI0:
+            aw_ccu_reg->AhbGate0.Spi0 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_SPI1:
+            aw_ccu_reg->AhbGate0.Spi1 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_SPI2:
+            aw_ccu_reg->AhbGate0.Spi2 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_SPI3:
+            aw_ccu_reg->AhbGate0.Spi3 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_OTG:
+            aw_ccu_reg->AhbGate0.Otg = STATUS_BIT(status); break;
+        case AW_AHB_CLK_EHCI0:
+            aw_ccu_reg->AhbGate0.Ehci0 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_EHCI1:
+            aw_ccu_reg->AhbGate0.Ehci1 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_OHCI0:
+            aw_ccu_reg->AhbGate0.Ohci0 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_OHCI1:
+            aw_ccu_reg->AhbGate0.Ohci1 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_OHCI2:
+            aw_ccu_reg->AhbGate0.Ohci2 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_VE:
+            aw_ccu_reg->AhbGate1.Ve = STATUS_BIT(status); break;
+        case AW_AHB_CLK_LCD0:
+            aw_ccu_reg->AhbGate1.Lcd0 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_LCD1:
+            aw_ccu_reg->AhbGate1.Lcd1 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_CSI0:
+            aw_ccu_reg->AhbGate1.Csi0 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_CSI1:
+            aw_ccu_reg->AhbGate1.Csi1 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_HDMI:
+            aw_ccu_reg->AhbGate1.Hdmi = STATUS_BIT(status); break;
+        case AW_AHB_CLK_DEBE0:
+            aw_ccu_reg->AhbGate1.Be0 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_DEBE1:
+            aw_ccu_reg->AhbGate1.Be1 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_DEFE0:
+            aw_ccu_reg->AhbGate1.Fe0 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_DEFE1:
+            aw_ccu_reg->AhbGate1.Fe1 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_MP:
+            aw_ccu_reg->AhbGate1.Mp = STATUS_BIT(status); break;
+        case AW_AHB_CLK_GPU:
+            aw_ccu_reg->AhbGate1.Gpu = STATUS_BIT(status); break;
+        case AW_AHB_CLK_MSGBOX:
+            aw_ccu_reg->AhbGate1.MsgBox = STATUS_BIT(status); break;
+        case AW_AHB_CLK_SPINLOCK:
+            aw_ccu_reg->AhbGate1.SpinLock = STATUS_BIT(status); break;
+        case AW_AHB_CLK_DEU0:
+            aw_ccu_reg->AhbGate1.Deu0 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_DEU1:
+            aw_ccu_reg->AhbGate1.Deu1 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_DRC0:
+            aw_ccu_reg->AhbGate1.Drc0 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_DRC1:
+            aw_ccu_reg->AhbGate1.Drc1 = STATUS_BIT(status); break;
+        case AW_AHB_CLK_MTCACC:
+            aw_ccu_reg->AhbGate1.MtcAcc = STATUS_BIT(status); break;
+        case AW_APB_CLK_ADDA:
+            aw_ccu_reg->Apb1Gate.Adda = STATUS_BIT(status); break;
+        case AW_APB_CLK_SPDIF:
+            aw_ccu_reg->Apb1Gate.Spdif = STATUS_BIT(status); break;
+        case AW_APB_CLK_PIO:
+            aw_ccu_reg->Apb1Gate.Pio = STATUS_BIT(status); break;
+        case AW_APB_CLK_I2S0:
+            aw_ccu_reg->Apb1Gate.I2s0 = STATUS_BIT(status); break;
+        case AW_APB_CLK_I2S1:
+            aw_ccu_reg->Apb1Gate.I2s1 = STATUS_BIT(status); break;
+        case AW_APB_CLK_TWI0:
+            aw_ccu_reg->Apb2Gate.Twi0 = STATUS_BIT(status); break;
+        case AW_APB_CLK_TWI1:
+            aw_ccu_reg->Apb2Gate.Twi1 = STATUS_BIT(status); break;
+        case AW_APB_CLK_TWI2:
+            aw_ccu_reg->Apb2Gate.Twi2 = STATUS_BIT(status); break;
+        case AW_APB_CLK_TWI3:
+            aw_ccu_reg->Apb2Gate.Twi3 = STATUS_BIT(status); break;
+        case AW_APB_CLK_UART0:
+            aw_ccu_reg->Apb2Gate.Uart0 = STATUS_BIT(status); break;
+        case AW_APB_CLK_UART1:
+            aw_ccu_reg->Apb2Gate.Uart1 = STATUS_BIT(status); break;
+        case AW_APB_CLK_UART2:
+            aw_ccu_reg->Apb2Gate.Uart2 = STATUS_BIT(status); break;
+        case AW_APB_CLK_UART3:
+            aw_ccu_reg->Apb2Gate.Uart3 = STATUS_BIT(status); break;
+        case AW_APB_CLK_UART4:
+            aw_ccu_reg->Apb2Gate.Uart4 = STATUS_BIT(status); break;
+        case AW_APB_CLK_UART5:
+            aw_ccu_reg->Apb2Gate.Uart5 = STATUS_BIT(status); break;
+        case AW_DRAM_CLK_VE:
+            aw_ccu_reg->DramGate.Ve = STATUS_BIT(status); break;
+        case AW_DRAM_CLK_CSI_ISP:
+            aw_ccu_reg->DramGate.CsiIsp = STATUS_BIT(status); break;
+        case AW_DRAM_CLK_TS:
+            aw_ccu_reg->DramGate.Ts = STATUS_BIT(status); break;
+        case AW_DRAM_CLK_DRC0:
+            aw_ccu_reg->DramGate.Drc0 = STATUS_BIT(status); break;
+        case AW_DRAM_CLK_DRC1:
+            aw_ccu_reg->DramGate.Drc1 = STATUS_BIT(status); break;
+        case AW_DRAM_CLK_DEU0:
+            aw_ccu_reg->DramGate.Deu0 = STATUS_BIT(status); break;
+        case AW_DRAM_CLK_DEU1:
+            aw_ccu_reg->DramGate.Deu1 = STATUS_BIT(status); break;
+        case AW_DRAM_CLK_DEFE0:
+            aw_ccu_reg->DramGate.Fe0 = STATUS_BIT(status); break;
+        case AW_DRAM_CLK_DEFE1:
+            aw_ccu_reg->DramGate.Fe1 = STATUS_BIT(status); break;
+        case AW_DRAM_CLK_DEBE0:
+            aw_ccu_reg->DramGate.Be0 = STATUS_BIT(status); break;
+        case AW_DRAM_CLK_DEBE1:
+            aw_ccu_reg->DramGate.Be1 = STATUS_BIT(status); break;
+        case AW_DRAM_CLK_MP:
+            aw_ccu_reg->DramGate.Mp = STATUS_BIT(status); break;
+
+        case AW_MOD_CLK_R_1WIRE:
+        {
+            aw_cpus_reg->Apb0Gate.OneWire = STATUS_BIT(status);
+            aw_cpus_reg->OneWire.ClkGate = STATUS_BIT(status);
+            break;
+        }
+        case AW_MOD_CLK_R_CIR:
+        {
+            aw_cpus_reg->Apb0Gate.Cir = STATUS_BIT(status);
+            aw_cpus_reg->Cir.ClkGate = STATUS_BIT(status);
+            break;
+        }
+        case AW_MOD_CLK_R_TWI:
+            aw_cpus_reg->Apb0Gate.Twi = STATUS_BIT(status); break;
+        case AW_MOD_CLK_R_UART:
+            aw_cpus_reg->Apb0Gate.Uart = STATUS_BIT(status); break;
+        case AW_MOD_CLK_R_P2WI:
+            aw_cpus_reg->Apb0Gate.P2wi = STATUS_BIT(status); break;
+        case AW_MOD_CLK_R_TMR:
+            aw_cpus_reg->Apb0Gate.Tmr = STATUS_BIT(status); break;
+        case AW_MOD_CLK_R_PIO:
+            aw_cpus_reg->Apb0Gate.Pio = STATUS_BIT(status); break;
+
+        default:
+            break;
+    }
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_set_rate
+*
+*Description: set module clock division;
+*
+*Arguments  : id    module clock id;
+*             rate  module clock division;
+*
+*Return     : result
+*               0,  set module clock rate successed;
+*              !0,  set module clock rate failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 mod_clk_set_rate(__aw_ccu_clk_id_e id, __s64 rate)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NAND0:
+            return _set_module0_clk_rate(&aw_ccu_reg->Nand0, rate);
+        case AW_MOD_CLK_NAND1:
+            return _set_module0_clk_rate(&aw_ccu_reg->Nand1, rate);
+        case AW_MOD_CLK_SDC0:
+            return _set_mmc_clk_rate(&aw_ccu_reg->Sd0, rate);
+        case AW_MOD_CLK_SDC1:
+            return _set_mmc_clk_rate(&aw_ccu_reg->Sd1, rate);
+        case AW_MOD_CLK_SDC2:
+            return _set_mmc_clk_rate(&aw_ccu_reg->Sd2, rate);
+        case AW_MOD_CLK_SDC3:
+            return _set_mmc_clk_rate(&aw_ccu_reg->Sd3, rate);
+        case AW_MOD_CLK_TS:
+            return _set_module0_clk_rate(&aw_ccu_reg->Ts, rate);
+        case AW_MOD_CLK_SS:
+            return _set_module0_clk_rate(&aw_ccu_reg->Ss, rate);
+        case AW_MOD_CLK_SPI0:
+            return _set_module0_clk_rate(&aw_ccu_reg->Spi0, rate);
+        case AW_MOD_CLK_SPI1:
+            return _set_module0_clk_rate(&aw_ccu_reg->Spi1, rate);
+        case AW_MOD_CLK_SPI2:
+            return _set_module0_clk_rate(&aw_ccu_reg->Spi2, rate);
+        case AW_MOD_CLK_SPI3:
+            return _set_module0_clk_rate(&aw_ccu_reg->Spi3, rate);
+        case AW_MOD_CLK_MDFS:
+            return _set_module0_clk_rate(&aw_ccu_reg->Mdfs, rate);
+        case AW_MOD_CLK_DEBE0:
+            aw_ccu_reg->Be0.DivM = rate-1;  break;
+        case AW_MOD_CLK_DEBE1:
+            aw_ccu_reg->Be1.DivM = rate-1;  break;
+        case AW_MOD_CLK_DEFE0:
+            aw_ccu_reg->Fe0.DivM = rate-1;  break;
+        case AW_MOD_CLK_DEFE1:
+            aw_ccu_reg->Fe1.DivM = rate-1;  break;
+        case AW_MOD_CLK_DEMIX:
+            aw_ccu_reg->Mp.DivM = rate-1;   break;
+        case AW_MOD_CLK_LCD0CH0:
+            aw_ccu_reg->Lcd0Ch0.DivM = rate-1;  break;
+        case AW_MOD_CLK_LCD0CH1:
+            aw_ccu_reg->Lcd0Ch1.DivM = rate-1;  break;
+        case AW_MOD_CLK_HDMI:
+            aw_ccu_reg->Hdmi.ClkDiv  = rate-1;  break;
+        case AW_MOD_CLK_LCD1CH0:
+            aw_ccu_reg->Lcd1Ch0.DivM = rate-1;  break;
+        case AW_MOD_CLK_LCD1CH1:
+            aw_ccu_reg->Lcd1Ch1.DivM = rate-1;  break;
+        case AW_MOD_CLK_CSI0S:
+            aw_ccu_reg->Csi0.SClkDiv = rate-1;  break;
+        case AW_MOD_CLK_CSI0M:
+            aw_ccu_reg->Csi0.MClkDiv = rate-1;  break;
+        case AW_MOD_CLK_CSI1S:
+            aw_ccu_reg->Csi1.SClkDiv = rate-1;  break;
+        case AW_MOD_CLK_CSI1M:
+            aw_ccu_reg->Csi1.MClkDiv = rate-1;  break;
+        case AW_MOD_CLK_VE:
+            aw_ccu_reg->Ve.ClkDiv = rate-1;  break;
+        case AW_MOD_CLK_MTCACC:
+            return _set_module0_clk_rate(&aw_ccu_reg->MtcAcc, rate);
+        case AW_MOD_CLK_MBUS0:
+            return _set_module0_clk_rate(&aw_ccu_reg->MBus0, rate);
+        case AW_MOD_CLK_MBUS1:
+            return _set_module0_clk_rate(&aw_ccu_reg->MBus1, rate);
+        case AW_MOD_CLK_MIPIDSIS:
+            aw_ccu_reg->MipiDsi.SClkDiv = rate-1;  break;
+        case AW_MOD_CLK_MIPIDSIP:
+            aw_ccu_reg->MipiDsi.PClkDiv = rate-1;  break;
+        case AW_MOD_CLK_MIPICSIS:
+            aw_ccu_reg->MipiCsi.SClkDiv = rate-1;  break;
+        case AW_MOD_CLK_MIPICSIP:
+            aw_ccu_reg->MipiCsi.PClkDiv = rate-1;  break;
+        case AW_MOD_CLK_IEPDRC0:
+            return _set_module0_clk_rate(&aw_ccu_reg->IepDrc0, rate);
+        case AW_MOD_CLK_IEPDRC1:
+            return _set_module0_clk_rate(&aw_ccu_reg->IepDrc1, rate);
+        case AW_MOD_CLK_IEPDEU0:
+            return _set_module0_clk_rate(&aw_ccu_reg->IepDeu0, rate);
+        case AW_MOD_CLK_IEPDEU1:
+            return _set_module0_clk_rate(&aw_ccu_reg->IepDeu1, rate);
+        case AW_MOD_CLK_GPUCORE:
+            return _set_module0_clk_rate(&aw_ccu_reg->GpuCore, rate);
+        case AW_MOD_CLK_GPUMEM:
+            return _set_module0_clk_rate(&aw_ccu_reg->GpuMem, rate);
+        case AW_MOD_CLK_GPUHYD:
+            return _set_module0_clk_rate(&aw_ccu_reg->GpuHyd, rate);
+
+        case AW_MOD_CLK_R_1WIRE:
+            return _set_onewire_clk_rate(&aw_cpus_reg->OneWire, rate);
+        case AW_MOD_CLK_R_CIR:
+            return _set_module0_clk_rate(&aw_cpus_reg->Cir, rate);
+
+        default:
+            return 0;
+    }
+    return 0;
+}
+
+
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_get_rate_hz
+*
+*Description: get module clock rate based on hz;
+*
+*Arguments  : id    module clock id;
+*
+*Return     : module clock division;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __u64 mod_clk_get_rate_hz(__aw_ccu_clk_id_e id)
+{
+    __u64   parent_rate = sys_clk_ops.get_rate(mod_clk_get_parent(id));
+    __u64   div = mod_clk_get_rate(id);
+
+    if(!div) {
+        div = 1;
+    }
+
+    do_div(parent_rate, div);
+    return parent_rate;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_set_rate_hz
+*
+*Description: set module clock rate based on hz;
+*
+*Arguments  : id    module clock id;
+*             rate  module clock division;
+*
+*Return     : result
+*               0,  set module clock rate successed;
+*              !0,  set module clock rate failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static int mod_clk_set_rate_hz(__aw_ccu_clk_id_e id, __u64 rate)
+{
+    __u64   parent_rate = sys_clk_ops.get_rate(mod_clk_get_parent(id));
+
+    if(!rate) {
+        return -1;
+    }
+
+    parent_rate += rate - 1;
+    do_div(parent_rate, rate);
+    return mod_clk_set_rate(id, parent_rate);
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_get_reset
+*
+*Description: get module clock reset status;
+*
+*Arguments  : id    module clock id;
+*
+*Return     : result,
+*               AW_CCU_CLK_RESET,   module clock reset valid;
+*               AW_CCU_CLK_NRESET,  module clock reset invalid;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+#define GET_RESET(reg)  ((reg == 1)? AW_CCU_CLK_NRESET : AW_CCU_CLK_RESET)
+static __aw_ccu_clk_reset_e mod_clk_get_reset(__aw_ccu_clk_id_e id)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NAND0:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Nand0);
+        case AW_MOD_CLK_NAND1:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Nand1);
+        case AW_MOD_CLK_SDC0:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Sd0);
+        case AW_MOD_CLK_SDC1:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Sd1);
+        case AW_MOD_CLK_SDC2:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Sd2);
+        case AW_MOD_CLK_SDC3:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Sd3);
+        case AW_MOD_CLK_TS:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Ts);
+        case AW_MOD_CLK_SS:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Ss);
+        case AW_MOD_CLK_SPI0:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Spi0);
+        case AW_MOD_CLK_SPI1:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Spi1);
+        case AW_MOD_CLK_SPI2:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Spi2);
+        case AW_MOD_CLK_SPI3:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Spi3);
+        case AW_MOD_CLK_I2S0:
+            return GET_RESET(aw_ccu_reg->Apb1Reset.I2s0);
+        case AW_MOD_CLK_I2S1:
+            return GET_RESET(aw_ccu_reg->Apb1Reset.I2s1);
+        case AW_MOD_CLK_SPDIF:
+            return GET_RESET(aw_ccu_reg->Apb1Reset.Spdif);
+        case AW_MOD_CLK_USBPHY0:
+            return GET_RESET(aw_ccu_reg->Usb.UsbPhy0Rst);
+        case AW_MOD_CLK_USBPHY1:
+            return GET_RESET(aw_ccu_reg->Usb.UsbPhy1Rst);
+        case AW_MOD_CLK_USBPHY2:
+            return GET_RESET(aw_ccu_reg->Usb.UsbPhy2Rst);
+        case AW_MOD_CLK_USBEHCI0:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Ehci0);
+        case AW_MOD_CLK_USBEHCI1:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Ehci1);
+        case AW_MOD_CLK_USBOHCI0:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Ohci0);
+        case AW_MOD_CLK_USBOHCI1:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Ohci1);
+        case AW_MOD_CLK_USBOHCI2:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Ohci2);
+        case AW_MOD_CLK_DEBE0:
+            return GET_RESET(aw_ccu_reg->AhbReset1.Be0);
+        case AW_MOD_CLK_DEBE1:
+            return GET_RESET(aw_ccu_reg->AhbReset1.Be1);
+        case AW_MOD_CLK_DEFE0:
+            return GET_RESET(aw_ccu_reg->AhbReset1.Fe0);
+        case AW_MOD_CLK_DEFE1:
+            return GET_RESET(aw_ccu_reg->AhbReset1.Fe1);
+        case AW_MOD_CLK_DEMIX:
+            return GET_RESET(aw_ccu_reg->AhbReset1.Mp);
+        case AW_MOD_CLK_LCD0CH0:
+        case AW_MOD_CLK_LCD0CH1:
+            return GET_RESET(aw_ccu_reg->AhbReset1.Lcd0);
+        case AW_MOD_CLK_LCD1CH0:
+        case AW_MOD_CLK_LCD1CH1:
+            return GET_RESET(aw_ccu_reg->AhbReset1.Lcd1);
+        case AW_MOD_CLK_CSI0S:
+        case AW_MOD_CLK_CSI0M:
+            return GET_RESET(aw_ccu_reg->AhbReset1.Csi0);
+        case AW_MOD_CLK_CSI1S:
+        case AW_MOD_CLK_CSI1M:
+            return GET_RESET(aw_ccu_reg->AhbReset1.Csi1);
+        case AW_MOD_CLK_VE:
+            return GET_RESET(aw_ccu_reg->AhbReset1.Ve);
+        case AW_MOD_CLK_ADDA:
+            return GET_RESET(aw_ccu_reg->Apb1Reset.Adda);
+        case AW_MOD_CLK_HDMI:
+            return GET_RESET(aw_ccu_reg->AhbReset1.Hdmi);
+        case AW_MOD_CLK_MTCACC:
+            return GET_RESET(aw_ccu_reg->AhbReset1.MtcAcc);
+        case AW_MOD_CLK_MIPIDSIS:
+        case AW_MOD_CLK_MIPIDSIP:
+            return GET_RESET(aw_ccu_reg->AhbReset0.MipiDsi);
+        case AW_MOD_CLK_MIPICSIS:
+        case AW_MOD_CLK_MIPICSIP:
+            return AW_CCU_CLK_NRESET;
+        case AW_MOD_CLK_IEPDRC0:
+            return GET_RESET(aw_ccu_reg->AhbReset1.Drc0);
+        case AW_MOD_CLK_IEPDRC1:
+            return GET_RESET(aw_ccu_reg->AhbReset1.Drc1);
+        case AW_MOD_CLK_IEPDEU0:
+            return GET_RESET(aw_ccu_reg->AhbReset1.Deu0);
+        case AW_MOD_CLK_IEPDEU1:
+            return GET_RESET(aw_ccu_reg->AhbReset1.Deu1);
+        case AW_MOD_CLK_GPUCORE:
+        case AW_MOD_CLK_GPUMEM:
+        case AW_MOD_CLK_GPUHYD:
+            return GET_RESET(aw_ccu_reg->AhbReset1.Gpu);
+        case AW_MOD_CLK_TWI0:
+            return GET_RESET(aw_ccu_reg->Apb2Reset.Twi0);
+        case AW_MOD_CLK_TWI1:
+            return GET_RESET(aw_ccu_reg->Apb2Reset.Twi1);
+        case AW_MOD_CLK_TWI2:
+            return GET_RESET(aw_ccu_reg->Apb2Reset.Twi2);
+        case AW_MOD_CLK_TWI3:
+            return GET_RESET(aw_ccu_reg->Apb2Reset.Twi3);
+        case AW_MOD_CLK_UART0:
+            return GET_RESET(aw_ccu_reg->Apb2Reset.Uart0);
+        case AW_MOD_CLK_UART1:
+            return GET_RESET(aw_ccu_reg->Apb2Reset.Uart1);
+        case AW_MOD_CLK_UART2:
+            return GET_RESET(aw_ccu_reg->Apb2Reset.Uart2);
+        case AW_MOD_CLK_UART3:
+            return GET_RESET(aw_ccu_reg->Apb2Reset.Uart3);
+        case AW_MOD_CLK_UART4:
+            return GET_RESET(aw_ccu_reg->Apb2Reset.Uart4);
+        case AW_MOD_CLK_UART5:
+            return GET_RESET(aw_ccu_reg->Apb2Reset.Uart5);
+        case AW_MOD_CLK_GMAC:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Gmac);
+        case AW_MOD_CLK_DRAM:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Sdram);
+        case AW_MOD_CLK_USBOTG:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Otg);
+        case AW_MOD_CLK_DMA:
+            return GET_RESET(aw_ccu_reg->AhbReset0.Dma);
+        case AW_MOD_CLK_HSTMR:
+            return GET_RESET(aw_ccu_reg->AhbReset0.HsTmr);
+        case AW_MOD_CLK_MSGBOX:
+            return GET_RESET(aw_ccu_reg->AhbReset1.MsgBox);
+        case AW_MOD_CLK_SPINLOCK:
+            return GET_RESET(aw_ccu_reg->AhbReset1.SpinLock);
+        case AW_MOD_CLK_LVDS:
+            return GET_RESET(aw_ccu_reg->AhbReset2.Lvds);
+
+        case AW_MOD_CLK_R_1WIRE:
+            return GET_RESET(aw_cpus_reg->ModReset.OneWire);
+        case AW_MOD_CLK_R_CIR:
+            return GET_RESET(aw_cpus_reg->ModReset.Cir);
+        case AW_MOD_CLK_R_TWI:
+            return GET_RESET(aw_cpus_reg->ModReset.Twi);
+        case AW_MOD_CLK_R_UART:
+            return GET_RESET(aw_cpus_reg->ModReset.Uart);
+        case AW_MOD_CLK_R_P2WI:
+            return GET_RESET(aw_cpus_reg->ModReset.P2wi);
+        case AW_MOD_CLK_R_TMR:
+            return GET_RESET(aw_cpus_reg->ModReset.Tmr);
+
+        default:
+            return AW_CCU_CLK_NRESET;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_set_reset
+*
+*Description: set module clock reset status
+*
+*Arguments  : id    module clock id;
+*             reset module clock reset status;
+*
+*Return     : result;
+*               0,  set module clock reset status successed;
+*              !0,  set module clock reset status failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+#define SET_RESET(reg, reset)  {reg = (reset==AW_CCU_CLK_NRESET)? 1:0;}
+static __s32 mod_clk_set_reset(__aw_ccu_clk_id_e id, __aw_ccu_clk_reset_e reset)
+{
+    switch(id)
+    {
+        case AW_MOD_CLK_NAND0:
+            SET_RESET(aw_ccu_reg->AhbReset0.Nand0, reset);  break;
+        case AW_MOD_CLK_NAND1:
+            SET_RESET(aw_ccu_reg->AhbReset0.Nand1, reset);  break;
+        case AW_MOD_CLK_SDC0:
+            SET_RESET(aw_ccu_reg->AhbReset0.Sd0, reset);    break;
+        case AW_MOD_CLK_SDC1:
+            SET_RESET(aw_ccu_reg->AhbReset0.Sd1, reset);    break;
+        case AW_MOD_CLK_SDC2:
+            SET_RESET(aw_ccu_reg->AhbReset0.Sd2, reset);    break;
+        case AW_MOD_CLK_SDC3:
+            SET_RESET(aw_ccu_reg->AhbReset0.Sd3, reset);    break;
+        case AW_MOD_CLK_TS:
+            SET_RESET(aw_ccu_reg->AhbReset0.Ts, reset);     break;
+        case AW_MOD_CLK_SS:
+            SET_RESET(aw_ccu_reg->AhbReset0.Ss, reset);     break;
+        case AW_MOD_CLK_SPI0:
+            SET_RESET(aw_ccu_reg->AhbReset0.Spi0, reset);   break;
+        case AW_MOD_CLK_SPI1:
+            SET_RESET(aw_ccu_reg->AhbReset0.Spi1, reset);   break;
+        case AW_MOD_CLK_SPI2:
+            SET_RESET(aw_ccu_reg->AhbReset0.Spi2, reset);   break;
+        case AW_MOD_CLK_SPI3:
+            SET_RESET(aw_ccu_reg->AhbReset0.Spi3, reset);   break;
+        case AW_MOD_CLK_I2S0:
+            SET_RESET(aw_ccu_reg->Apb1Reset.I2s0, reset);   break;
+        case AW_MOD_CLK_I2S1:
+            SET_RESET(aw_ccu_reg->Apb1Reset.I2s1, reset);   break;
+        case AW_MOD_CLK_SPDIF:
+            SET_RESET(aw_ccu_reg->Apb1Reset.Spdif, reset);  break;
+        case AW_MOD_CLK_USBPHY0:
+            SET_RESET(aw_ccu_reg->Usb.UsbPhy0Rst, reset);   break;
+        case AW_MOD_CLK_USBPHY1:
+            SET_RESET(aw_ccu_reg->Usb.UsbPhy1Rst, reset);   break;
+        case AW_MOD_CLK_USBPHY2:
+            SET_RESET(aw_ccu_reg->Usb.UsbPhy2Rst, reset);   break;
+        case AW_MOD_CLK_USBEHCI0:
+            SET_RESET(aw_ccu_reg->AhbReset0.Ehci0, reset);  break;
+        case AW_MOD_CLK_USBEHCI1:
+            SET_RESET(aw_ccu_reg->AhbReset0.Ehci1, reset);  break;
+        case AW_MOD_CLK_USBOHCI0:
+            SET_RESET(aw_ccu_reg->AhbReset0.Ohci0, reset);  break;
+        case AW_MOD_CLK_USBOHCI1:
+            SET_RESET(aw_ccu_reg->AhbReset0.Ohci1, reset);  break;
+        case AW_MOD_CLK_USBOHCI2:
+            SET_RESET(aw_ccu_reg->AhbReset0.Ohci2, reset);  break;
+        case AW_MOD_CLK_DEBE0:
+            SET_RESET(aw_ccu_reg->AhbReset1.Be0, reset);    break;
+        case AW_MOD_CLK_DEBE1:
+            SET_RESET(aw_ccu_reg->AhbReset1.Be1, reset);    break;
+        case AW_MOD_CLK_DEFE0:
+            SET_RESET(aw_ccu_reg->AhbReset1.Fe0, reset);    break;
+        case AW_MOD_CLK_DEFE1:
+            SET_RESET(aw_ccu_reg->AhbReset1.Fe1, reset);    break;
+        case AW_MOD_CLK_DEMIX:
+            SET_RESET(aw_ccu_reg->AhbReset1.Mp, reset);     break;
+        case AW_MOD_CLK_LCD0CH0:
+        case AW_MOD_CLK_LCD0CH1:
+            SET_RESET(aw_ccu_reg->AhbReset1.Lcd0, reset);   break;
+        case AW_MOD_CLK_LCD1CH0:
+        case AW_MOD_CLK_LCD1CH1:
+            SET_RESET(aw_ccu_reg->AhbReset1.Lcd1, reset);   break;
+        case AW_MOD_CLK_CSI0S:
+        case AW_MOD_CLK_CSI0M:
+            SET_RESET(aw_ccu_reg->AhbReset1.Csi0, reset);   break;
+        case AW_MOD_CLK_CSI1S:
+        case AW_MOD_CLK_CSI1M:
+            SET_RESET(aw_ccu_reg->AhbReset1.Csi1, reset);   break;
+        case AW_MOD_CLK_VE:
+            SET_RESET(aw_ccu_reg->AhbReset1.Ve, reset);     break;
+        case AW_MOD_CLK_ADDA:
+            SET_RESET(aw_ccu_reg->Apb1Reset.Adda, reset);   break;
+        case AW_MOD_CLK_HDMI:
+            SET_RESET(aw_ccu_reg->AhbReset1.Hdmi, reset);   break;
+        case AW_MOD_CLK_MTCACC:
+            SET_RESET(aw_ccu_reg->AhbReset1.MtcAcc, reset); break;
+        case AW_MOD_CLK_MIPIDSIS:
+        case AW_MOD_CLK_MIPIDSIP:
+            SET_RESET(aw_ccu_reg->AhbReset0.MipiDsi, reset);break;
+        case AW_MOD_CLK_MIPICSIS:
+        case AW_MOD_CLK_MIPICSIP:
+            break;
+        case AW_MOD_CLK_IEPDRC0:
+            SET_RESET(aw_ccu_reg->AhbReset1.Drc0, reset);   break;
+        case AW_MOD_CLK_IEPDRC1:
+            SET_RESET(aw_ccu_reg->AhbReset1.Drc1, reset);   break;
+        case AW_MOD_CLK_IEPDEU0:
+            SET_RESET(aw_ccu_reg->AhbReset1.Deu0, reset);   break;
+        case AW_MOD_CLK_IEPDEU1:
+            SET_RESET(aw_ccu_reg->AhbReset1.Deu1, reset);   break;
+        case AW_MOD_CLK_GPUCORE:
+        case AW_MOD_CLK_GPUMEM:
+        case AW_MOD_CLK_GPUHYD:
+            SET_RESET(aw_ccu_reg->AhbReset1.Gpu, reset);    break;
+        case AW_MOD_CLK_TWI0:
+            SET_RESET(aw_ccu_reg->Apb2Reset.Twi0, reset);   break;
+        case AW_MOD_CLK_TWI1:
+            SET_RESET(aw_ccu_reg->Apb2Reset.Twi1, reset);   break;
+        case AW_MOD_CLK_TWI2:
+            SET_RESET(aw_ccu_reg->Apb2Reset.Twi2, reset);   break;
+        case AW_MOD_CLK_TWI3:
+            SET_RESET(aw_ccu_reg->Apb2Reset.Twi3, reset);   break;
+        case AW_MOD_CLK_UART0:
+            SET_RESET(aw_ccu_reg->Apb2Reset.Uart0, reset);  break;
+        case AW_MOD_CLK_UART1:
+            SET_RESET(aw_ccu_reg->Apb2Reset.Uart1, reset);  break;
+        case AW_MOD_CLK_UART2:
+            SET_RESET(aw_ccu_reg->Apb2Reset.Uart2, reset);  break;
+        case AW_MOD_CLK_UART3:
+            SET_RESET(aw_ccu_reg->Apb2Reset.Uart3, reset);  break;
+        case AW_MOD_CLK_UART4:
+            SET_RESET(aw_ccu_reg->Apb2Reset.Uart4, reset);  break;
+        case AW_MOD_CLK_UART5:
+            SET_RESET(aw_ccu_reg->Apb2Reset.Uart5, reset);  break;
+        case AW_MOD_CLK_GMAC:
+            SET_RESET(aw_ccu_reg->AhbReset0.Gmac, reset);   break;
+        case AW_MOD_CLK_DRAM:
+            SET_RESET(aw_ccu_reg->AhbReset0.Sdram, reset);  break;
+        case AW_MOD_CLK_USBOTG:
+            SET_RESET(aw_ccu_reg->AhbReset0.Otg, reset);    break;
+        case AW_MOD_CLK_DMA:
+            SET_RESET(aw_ccu_reg->AhbReset0.Dma, reset);    break;
+        case AW_MOD_CLK_HSTMR:
+            SET_RESET(aw_ccu_reg->AhbReset0.HsTmr, reset);  break;
+        case AW_MOD_CLK_MSGBOX:
+            SET_RESET(aw_ccu_reg->AhbReset1.MsgBox, reset); break;
+        case AW_MOD_CLK_SPINLOCK:
+            SET_RESET(aw_ccu_reg->AhbReset1.SpinLock,reset);break;
+        case AW_MOD_CLK_LVDS:
+            SET_RESET(aw_ccu_reg->AhbReset2.Lvds, reset);   break;
+
+        case AW_MOD_CLK_R_1WIRE:
+            SET_RESET(aw_cpus_reg->ModReset.OneWire, reset);    break;
+        case AW_MOD_CLK_R_CIR:
+            SET_RESET(aw_cpus_reg->ModReset.Cir, reset);    break;
+        case AW_MOD_CLK_R_TWI:
+            SET_RESET(aw_cpus_reg->ModReset.Twi, reset);    break;
+        case AW_MOD_CLK_R_UART:
+            SET_RESET(aw_cpus_reg->ModReset.Uart, reset);    break;
+        case AW_MOD_CLK_R_P2WI:
+            SET_RESET(aw_cpus_reg->ModReset.P2wi, reset);    break;
+        case AW_MOD_CLK_R_TMR:
+            SET_RESET(aw_cpus_reg->ModReset.Tmr, reset);    break;
+
+        default:
+            break;
+    }
+    return 0;
+}
+
+
+
+/*
+*********************************************************************************************************
+*                           mod_clk_round_rate
+*
+*Description: round a rate of the given clock to a valid value;
+*
+*Arguments  : id    system clock id;
+*             rate  clock rate for system clock;
+*
+*Return     : result
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __u64 mod_clk_round_rate(__aw_ccu_clk_id_e id, __u64 rate)
+{
+    if(!rate) {
+        rate = 1;
+    }
+
+    switch(id)
+    {
+        case AW_MOD_CLK_NAND0:
+        case AW_MOD_CLK_NAND1:
+        case AW_MOD_CLK_SDC0:
+        case AW_MOD_CLK_SDC1:
+        case AW_MOD_CLK_SDC2:
+        case AW_MOD_CLK_SDC3:
+        case AW_MOD_CLK_TS:
+        case AW_MOD_CLK_SS:
+        case AW_MOD_CLK_SPI0:
+        case AW_MOD_CLK_SPI1:
+        case AW_MOD_CLK_SPI2:
+        case AW_MOD_CLK_SPI3:
+        case AW_MOD_CLK_MDFS:
+        case AW_MOD_CLK_MTCACC:
+        case AW_MOD_CLK_MBUS0:
+        case AW_MOD_CLK_MBUS1:
+        case AW_MOD_CLK_IEPDRC0:
+        case AW_MOD_CLK_IEPDRC1:
+        case AW_MOD_CLK_IEPDEU0:
+        case AW_MOD_CLK_IEPDEU1:
+        case AW_MOD_CLK_GPUCORE:
+        case AW_MOD_CLK_GPUMEM:
+        case AW_MOD_CLK_GPUHYD:
+        {
+            int     low, high;
+            __u64   parent_rate = sys_clk_ops.get_rate(mod_clk_get_parent(id));
+            __u64   tmp_rate;
+
+            tmp_rate = parent_rate + rate-1;
+            do_div(tmp_rate, rate);
+
+            low = 0;
+            high = sizeof(module0_clk_div_tbl)/sizeof(struct module0_div_tbl) - 1;
+
+            while(low<=high){
+                if(module0_clk_div_tbl[(low+high)/2].Div < tmp_rate)
+                {
+                    low = (low+high)/2+1;
+                } else if(module0_clk_div_tbl[(low+high)/2].Div > tmp_rate){
+                    high = (low+high)/2-1;
+                }
+                else
+                    break;
+            }
+
+            tmp_rate = (1<<module0_clk_div_tbl[(low+high)/2].FactorN) * (module0_clk_div_tbl[(low+high)/2].FactorM + 1);
+            do_div(parent_rate, tmp_rate);
+            return parent_rate;
+        }
+
+        case AW_MOD_CLK_DEBE0:
+        case AW_MOD_CLK_DEBE1:
+        case AW_MOD_CLK_DEFE0:
+        case AW_MOD_CLK_DEFE1:
+        case AW_MOD_CLK_DEMIX:
+        case AW_MOD_CLK_LCD0CH0:
+        case AW_MOD_CLK_LCD0CH1:
+        case AW_MOD_CLK_LCD1CH0:
+        case AW_MOD_CLK_LCD1CH1:
+        case AW_MOD_CLK_HDMI:
+        case AW_MOD_CLK_CSI0S:
+        case AW_MOD_CLK_CSI0M:
+        case AW_MOD_CLK_CSI1S:
+        case AW_MOD_CLK_CSI1M:
+        case AW_MOD_CLK_VE:
+        case AW_MOD_CLK_MIPIDSIS:
+        case AW_MOD_CLK_MIPIDSIP:
+        case AW_MOD_CLK_MIPICSIS:
+        case AW_MOD_CLK_MIPICSIP:
+        {
+            __u64   parent_rate = sys_clk_ops.get_rate(mod_clk_get_parent(id));
+            __u64   tmp_rate = parent_rate+rate-1;
+
+            do_div(tmp_rate, rate);
+
+            if( tmp_rate > 16) {
+                do_div(parent_rate, 16);
+                return parent_rate;
+            }
+            else {
+                tmp_rate = parent_rate+rate-1;
+                do_div(tmp_rate, rate);
+                do_div(parent_rate, tmp_rate);
+                return parent_rate;
+            }
+        }
+
+        default:
+            return rate;
+    }
+
+    return rate;
+}
+
+
+__clk_ops_t mod_clk_ops = {
+    .set_status = mod_clk_set_status,
+    .get_status = mod_clk_get_status,
+    .set_parent = mod_clk_set_parent,
+    .get_parent = mod_clk_get_parent,
+    .get_rate = mod_clk_get_rate_hz,
+    .set_rate = mod_clk_set_rate_hz,
+    .round_rate = mod_clk_round_rate,
+    .get_reset = mod_clk_get_reset,
+    .set_reset = mod_clk_set_reset,
+};
diff --git a/arch/arm/mach-sun6i/clock/pll_cfg.c b/arch/arm/mach-sun6i/clock/pll_cfg.c
new file mode 100644
index 0000000..3899de2
--- /dev/null
+++ b/arch/arm/mach-sun6i/clock/pll_cfg.c
@@ -0,0 +1,556 @@
+/*
+ *  arch/arm/mach-sun6i/clock/ccmu/pll_cfg_tbl.c
+ *
+ * Copyright 2012 (c) Allwinner.
+ * kevin.z.m (kevin@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include "ccm_i.h"
+
+struct pll_freq_cfg_tbl{
+    __u8    FactorN;
+    __u8    FactorK;
+    __u8    FactorM;
+    __u8    FactorP;
+    __u32   Pll;
+};
+
+/* core pll parameter table */
+static struct pll_freq_cfg_tbl    Pll1Tbl[] = {
+
+    {8 , 0, 3, 0, 54000000  }, /* freq = (6M * 0  ), index = 0  */
+    {8 , 0, 3, 0, 54000000  }, /* freq = (6M * 1  ), index = 1  */
+    {8 , 0, 3, 0, 54000000  }, /* freq = (6M * 2  ), index = 2  */
+    {8 , 0, 3, 0, 54000000  }, /* freq = (6M * 3  ), index = 3  */
+    {8 , 0, 3, 0, 54000000  }, /* freq = (6M * 4  ), index = 4  */
+    {8 , 0, 3, 0, 54000000  }, /* freq = (6M * 5  ), index = 5  */
+    {8 , 0, 3, 0, 54000000  }, /* freq = (6M * 6  ), index = 6  */
+    {8 , 0, 3, 0, 54000000  }, /* freq = (6M * 7  ), index = 7  */
+    {8 , 0, 3, 0, 54000000  }, /* freq = (6M * 8  ), index = 8  */
+    {8 , 0, 3, 0, 54000000  }, /* freq = (6M * 9  ), index = 9  */
+    {9 , 0, 3, 0, 60000000  }, /* freq = (6M * 10 ), index = 10 */
+    {10, 0, 3, 0, 66000000  }, /* freq = (6M * 11 ), index = 11 */
+    {8 , 0, 2, 0, 72000000  }, /* freq = (6M * 12 ), index = 12 */
+    {12, 0, 3, 0, 78000000  }, /* freq = (6M * 13 ), index = 13 */
+    {13, 0, 3, 0, 84000000  }, /* freq = (6M * 14 ), index = 14 */
+    {14, 0, 3, 0, 90000000  }, /* freq = (6M * 15 ), index = 15 */
+    {11, 0, 2, 0, 96000000  }, /* freq = (6M * 16 ), index = 16 */
+    {16, 0, 3, 0, 102000000 }, /* freq = (6M * 17 ), index = 17 */
+    {8 , 0, 1, 0, 108000000 }, /* freq = (6M * 18 ), index = 18 */
+    {18, 0, 3, 0, 114000000 }, /* freq = (6M * 19 ), index = 19 */
+    {9 , 0, 1, 0, 120000000 }, /* freq = (6M * 20 ), index = 20 */
+    {20, 0, 3, 0, 126000000 }, /* freq = (6M * 21 ), index = 21 */
+    {10, 0, 1, 0, 132000000 }, /* freq = (6M * 22 ), index = 22 */
+    {22, 0, 3, 0, 138000000 }, /* freq = (6M * 23 ), index = 23 */
+    {11, 0, 1, 0, 144000000 }, /* freq = (6M * 24 ), index = 24 */
+    {24, 0, 3, 0, 150000000 }, /* freq = (6M * 25 ), index = 25 */
+    {12, 0, 1, 0, 156000000 }, /* freq = (6M * 26 ), index = 26 */
+    {26, 0, 3, 0, 162000000 }, /* freq = (6M * 27 ), index = 27 */
+    {13, 0, 1, 0, 168000000 }, /* freq = (6M * 28 ), index = 28 */
+    {28, 0, 3, 0, 174000000 }, /* freq = (6M * 29 ), index = 29 */
+    {14, 0, 1, 0, 180000000 }, /* freq = (6M * 30 ), index = 30 */
+    {30, 0, 3, 0, 186000000 }, /* freq = (6M * 31 ), index = 31 */
+    {15, 0, 1, 0, 192000000 }, /* freq = (6M * 32 ), index = 32 */
+    {10, 2, 3, 0, 198000000 }, /* freq = (6M * 33 ), index = 33 */
+    {16, 0, 1, 0, 204000000 }, /* freq = (6M * 34 ), index = 34 */
+    {25, 0, 2, 0, 208000000 }, /* freq = (6M * 35 ), index = 35 */
+    {8 , 0, 0, 0, 216000000 }, /* freq = (6M * 36 ), index = 36 */
+    {27, 0, 2, 0, 224000000 }, /* freq = (6M * 37 ), index = 37 */
+    {18, 0, 1, 0, 228000000 }, /* freq = (6M * 38 ), index = 38 */
+    {12, 2, 3, 0, 234000000 }, /* freq = (6M * 39 ), index = 39 */
+    {9 , 0, 0, 0, 240000000 }, /* freq = (6M * 40 ), index = 40 */
+    {30, 0, 2, 0, 248000000 }, /* freq = (6M * 41 ), index = 41 */
+    {20, 0, 1, 0, 252000000 }, /* freq = (6M * 42 ), index = 42 */
+    {31, 0, 2, 0, 256000000 }, /* freq = (6M * 43 ), index = 43 */
+    {10, 0, 0, 0, 264000000 }, /* freq = (6M * 44 ), index = 44 */
+    {14, 2, 3, 0, 270000000 }, /* freq = (6M * 45 ), index = 45 */
+    {22, 0, 1, 0, 276000000 }, /* freq = (6M * 46 ), index = 46 */
+    {22, 1, 3, 0, 276000000 }, /* freq = (6M * 47 ), index = 47 */
+    {11, 0, 0, 0, 288000000 }, /* freq = (6M * 48 ), index = 48 */
+    {5 , 1, 0, 0, 288000000 }, /* freq = (6M * 49 ), index = 49 */
+    {24, 0, 1, 0, 300000000 }, /* freq = (6M * 50 ), index = 50 */
+    {16, 2, 3, 0, 306000000 }, /* freq = (6M * 51 ), index = 51 */
+    {12, 0, 0, 0, 312000000 }, /* freq = (6M * 52 ), index = 52 */
+    {19, 1, 2, 0, 320000000 }, /* freq = (6M * 53 ), index = 53 */
+    {26, 0, 1, 0, 324000000 }, /* freq = (6M * 54 ), index = 54 */
+    {8 , 2, 1, 0, 324000000 }, /* freq = (6M * 55 ), index = 55 */
+    {13, 0, 0, 0, 336000000 }, /* freq = (6M * 56 ), index = 56 */
+    {18, 2, 3, 0, 342000000 }, /* freq = (6M * 57 ), index = 57 */
+    {28, 0, 1, 0, 348000000 }, /* freq = (6M * 58 ), index = 58 */
+    {21, 1, 2, 0, 352000000 }, /* freq = (6M * 59 ), index = 59 */
+    {14, 0, 0, 0, 360000000 }, /* freq = (6M * 60 ), index = 60 */
+    {22, 1, 2, 0, 368000000 }, /* freq = (6M * 61 ), index = 61 */
+    {30, 0, 1, 0, 372000000 }, /* freq = (6M * 62 ), index = 62 */
+    {20, 2, 3, 0, 378000000 }, /* freq = (6M * 63 ), index = 63 */
+    {15, 0, 0, 0, 384000000 }, /* freq = (6M * 64 ), index = 64 */
+    {7 , 1, 0, 0, 384000000 }, /* freq = (6M * 65 ), index = 65 */
+    {10, 2, 1, 0, 396000000 }, /* freq = (6M * 66 ), index = 66 */
+    {24, 1, 2, 0, 400000000 }, /* freq = (6M * 67 ), index = 67 */
+    {16, 0, 0, 0, 408000000 }, /* freq = (6M * 68 ), index = 68 */
+    {22, 2, 3, 0, 414000000 }, /* freq = (6M * 69 ), index = 69 */
+    {25, 1, 2, 0, 416000000 }, /* freq = (6M * 70 ), index = 70 */
+    {12, 3, 2, 0, 416000000 }, /* freq = (6M * 71 ), index = 71 */
+    {17, 0, 0, 0, 432000000 }, /* freq = (6M * 72 ), index = 72 */
+    {8 , 1, 0, 0, 432000000 }, /* freq = (6M * 73 ), index = 73 */
+    {27, 1, 2, 0, 448000000 }, /* freq = (6M * 74 ), index = 74 */
+    {24, 2, 3, 0, 450000000 }, /* freq = (6M * 75 ), index = 75 */
+    {18, 0, 0, 0, 456000000 }, /* freq = (6M * 76 ), index = 76 */
+    {28, 1, 2, 0, 464000000 }, /* freq = (6M * 77 ), index = 77 */
+    {12, 2, 1, 0, 468000000 }, /* freq = (6M * 78 ), index = 78 */
+    {25, 2, 3, 0, 468000000 }, /* freq = (6M * 79 ), index = 79 */
+    {19, 0, 0, 0, 480000000 }, /* freq = (6M * 80 ), index = 80 */
+    {19, 2, 2, 0, 480000000 }, /* freq = (6M * 81 ), index = 81 */
+    {14, 3, 2, 0, 480000000 }, /* freq = (6M * 82 ), index = 82 */
+    {30, 1, 2, 0, 496000000 }, /* freq = (6M * 83 ), index = 83 */
+    {20, 0, 0, 0, 504000000 }, /* freq = (6M * 84 ), index = 84 */
+    {31, 1, 2, 0, 512000000 }, /* freq = (6M * 85 ), index = 85 */
+    {15, 3, 2, 0, 512000000 }, /* freq = (6M * 86 ), index = 86 */
+    {15, 3, 2, 0, 512000000 }, /* freq = (6M * 87 ), index = 87 */
+    {21, 0, 0, 0, 528000000 }, /* freq = (6M * 88 ), index = 88 */
+    {10, 1, 0, 0, 528000000 }, /* freq = (6M * 89 ), index = 89 */
+    {14, 2, 1, 0, 540000000 }, /* freq = (6M * 90 ), index = 90 */
+    {16, 3, 2, 0, 544000000 }, /* freq = (6M * 91 ), index = 91 */
+    {22, 0, 0, 0, 552000000 }, /* freq = (6M * 92 ), index = 92 */
+    {22, 1, 1, 0, 552000000 }, /* freq = (6M * 93 ), index = 93 */
+    {23, 0, 0, 0, 576000000 }, /* freq = (6M * 94 ), index = 94 */
+    {11, 1, 0, 0, 576000000 }, /* freq = (6M * 95 ), index = 95 */
+    {7 , 2, 0, 0, 576000000 }, /* freq = (6M * 96 ), index = 96 */
+    {5 , 3, 0, 0, 576000000 }, /* freq = (6M * 97 ), index = 97 */
+    {23, 1, 1, 0, 576000000 }, /* freq = (6M * 98 ), index = 98 */
+    {15, 2, 1, 0, 576000000 }, /* freq = (6M * 99 ), index = 99 */
+    {24, 0, 0, 0, 600000000 }, /* freq = (6M * 100), index = 100*/
+    {18, 3, 2, 0, 608000000 }, /* freq = (6M * 101), index = 101*/
+    {16, 2, 1, 0, 612000000 }, /* freq = (6M * 102), index = 102*/
+    {25, 0, 0, 0, 624000000 }, /* freq = (6M * 103), index = 103*/
+    {12, 1, 0, 0, 624000000 }, /* freq = (6M * 104), index = 104*/
+    {25, 1, 1, 0, 624000000 }, /* freq = (6M * 105), index = 105*/
+    {12, 3, 1, 0, 624000000 }, /* freq = (6M * 106), index = 106*/
+    {12, 1, 1, 0, 624000000 }, /* freq = (6M * 107), index = 107*/
+    {26, 0, 0, 0, 648000000 }, /* freq = (6M * 108), index = 108*/
+    {8 , 2, 0, 0, 648000000 }, /* freq = (6M * 109), index = 109*/
+    {26, 1, 1, 0, 648000000 }, /* freq = (6M * 110), index = 110*/
+    {17, 2, 1, 0, 648000000 }, /* freq = (6M * 111), index = 111*/
+    {27, 0, 0, 0, 672000000 }, /* freq = (6M * 112), index = 112*/
+    {13, 1, 0, 0, 672000000 }, /* freq = (6M * 113), index = 113*/
+    {18, 2, 1, 0, 684000000 }, /* freq = (6M * 114), index = 114*/
+    {28, 0, 0, 0, 696000000 }, /* freq = (6M * 115), index = 115*/
+    {28, 1, 1, 0, 696000000 }, /* freq = (6M * 116), index = 116*/
+    {28, 1, 1, 0, 696000000 }, /* freq = (6M * 117), index = 117*/
+    {28, 1, 1, 0, 696000000 }, /* freq = (6M * 118), index = 118*/
+    {29, 0, 0, 0, 720000000 }, /* freq = (6M * 119), index = 119*/
+    {14, 1, 0, 0, 720000000 }, /* freq = (6M * 120), index = 120*/
+    {9 , 2, 0, 0, 720000000 }, /* freq = (6M * 121), index = 121*/
+    {29, 1, 1, 0, 720000000 }, /* freq = (6M * 122), index = 122*/
+    {19, 2, 1, 0, 720000000 }, /* freq = (6M * 123), index = 123*/
+    {30, 0, 0, 0, 744000000 }, /* freq = (6M * 124), index = 124*/
+    {30, 1, 1, 0, 744000000 }, /* freq = (6M * 125), index = 125*/
+    {20, 2, 1, 0, 756000000 }, /* freq = (6M * 126), index = 126*/
+    {31, 0, 0, 0, 768000000 }, /* freq = (6M * 127), index = 127*/
+    {15, 1, 0, 0, 768000000 }, /* freq = (6M * 128), index = 128*/
+    {7 , 3, 0, 0, 768000000 }, /* freq = (6M * 129), index = 129*/
+    {31, 1, 1, 0, 768000000 }, /* freq = (6M * 130), index = 130*/
+    {15, 3, 1, 0, 768000000 }, /* freq = (6M * 131), index = 131*/
+    {10, 2, 0, 0, 792000000 }, /* freq = (6M * 132), index = 132*/
+    {21, 2, 1, 0, 792000000 }, /* freq = (6M * 133), index = 133*/
+    {21, 2, 1, 0, 792000000 }, /* freq = (6M * 134), index = 134*/
+    {16, 1, 0, 0, 816000000 }, /* freq = (6M * 135), index = 135*/
+    {16, 3, 1, 0, 816000000 }, /* freq = (6M * 136), index = 136*/
+    {16, 3, 1, 0, 816000000 }, /* freq = (6M * 137), index = 137*/
+    {22, 2, 1, 0, 828000000 }, /* freq = (6M * 138), index = 138*/
+    {22, 2, 1, 0, 828000000 }, /* freq = (6M * 139), index = 139*/
+    {17, 1, 0, 0, 864000000 }, /* freq = (6M * 140), index = 140*/
+    {11, 2, 0, 0, 864000000 }, /* freq = (6M * 141), index = 141*/
+    {8 , 3, 0, 0, 864000000 }, /* freq = (6M * 142), index = 142*/
+    {23, 2, 1, 0, 864000000 }, /* freq = (6M * 143), index = 143*/
+    {17, 3, 1, 0, 864000000 }, /* freq = (6M * 144), index = 144*/
+    {23, 2, 1, 0, 864000000 }, /* freq = (6M * 145), index = 145*/
+    {23, 2, 1, 0, 864000000 }, /* freq = (6M * 146), index = 146*/
+    {23, 2, 1, 0, 864000000 }, /* freq = (6M * 147), index = 147*/
+    {23, 2, 1, 0, 864000000 }, /* freq = (6M * 148), index = 148*/
+    {23, 2, 1, 0, 864000000 }, /* freq = (6M * 149), index = 149*/
+    {24, 2, 1, 0, 900000000 }, /* freq = (6M * 150), index = 150*/
+    {24, 2, 1, 0, 900000000 }, /* freq = (6M * 151), index = 151*/
+    {18, 1, 0, 0, 912000000 }, /* freq = (6M * 152), index = 152*/
+    {18, 3, 1, 0, 912000000 }, /* freq = (6M * 153), index = 153*/
+    {18, 3, 1, 0, 912000000 }, /* freq = (6M * 154), index = 154*/
+    {18, 3, 1, 0, 912000000 }, /* freq = (6M * 155), index = 155*/
+    {12, 2, 1, 0, 936000000 }, /* freq = (6M * 156), index = 156*/
+    {25, 2, 1, 0, 936000000 }, /* freq = (6M * 157), index = 157*/
+    {25, 2, 1, 0, 936000000 }, /* freq = (6M * 158), index = 158*/
+    {25, 2, 1, 0, 936000000 }, /* freq = (6M * 159), index = 159*/
+    {19, 1, 0, 0, 960000000 }, /* freq = (6M * 160), index = 160*/
+    {9 , 3, 0, 0, 960000000 }, /* freq = (6M * 161), index = 161*/
+    {9 , 3, 0, 0, 960000000 }, /* freq = (6M * 162), index = 162*/
+    {19, 1, 0, 0, 960000000 }, /* freq = (6M * 163), index = 163*/
+    {9 , 3, 0, 0, 960000000 }, /* freq = (6M * 164), index = 164*/
+    {9 , 3, 0, 0, 960000000 }, /* freq = (6M * 165), index = 165*/
+    {19, 1, 0, 0, 960000000 }, /* freq = (6M * 166), index = 166*/
+    {9 , 3, 0, 0, 960000000 }, /* freq = (6M * 167), index = 167*/
+    {20, 1, 0, 0, 1008000000}, /* freq = (6M * 168), index = 168*/
+    {13, 2, 0, 0, 1008000000}, /* freq = (6M * 169), index = 169*/
+    {20, 1, 0, 0, 1008000000}, /* freq = (6M * 170), index = 170*/
+    {13, 2, 0, 0, 1008000000}, /* freq = (6M * 171), index = 171*/
+    {20, 1, 0, 0, 1008000000}, /* freq = (6M * 172), index = 172*/
+    {13, 2, 0, 0, 1008000000}, /* freq = (6M * 173), index = 173*/
+    {13, 2, 0, 0, 1008000000}, /* freq = (6M * 174), index = 174*/
+    {21, 1, 0, 0, 1056000000}, /* freq = (6M * 175), index = 175*/
+    {10, 3, 0, 0, 1056000000}, /* freq = (6M * 176), index = 176*/
+    {21, 1, 0, 0, 1056000000}, /* freq = (6M * 177), index = 177*/
+    {10, 3, 0, 0, 1056000000}, /* freq = (6M * 178), index = 178*/
+    {21, 1, 0, 0, 1056000000}, /* freq = (6M * 179), index = 179*/
+    {14, 2, 0, 0, 1080000000}, /* freq = (6M * 180), index = 180*/
+    {14, 2, 0, 0, 1080000000}, /* freq = (6M * 181), index = 181*/
+    {14, 2, 0, 0, 1080000000}, /* freq = (6M * 182), index = 182*/
+    {14, 2, 0, 0, 1080000000}, /* freq = (6M * 183), index = 183*/
+    {22, 1, 0, 0, 1104000000}, /* freq = (6M * 184), index = 184*/
+    {22, 1, 0, 0, 1104000000}, /* freq = (6M * 185), index = 185*/
+    {22, 1, 0, 0, 1104000000}, /* freq = (6M * 186), index = 186*/
+    {22, 1, 0, 0, 1104000000}, /* freq = (6M * 187), index = 187*/
+    {22, 1, 0, 0, 1104000000}, /* freq = (6M * 188), index = 188*/
+    {22, 1, 0, 0, 1104000000}, /* freq = (6M * 189), index = 189*/
+    {22, 1, 0, 0, 1104000000}, /* freq = (6M * 190), index = 190*/
+    {22, 1, 0, 0, 1104000000}, /* freq = (6M * 191), index = 191*/
+    {23, 1, 0, 0, 1152000000}, /* freq = (6M * 192), index = 192*/
+    {15, 2, 0, 0, 1152000000}, /* freq = (6M * 193), index = 193*/
+    {11, 3, 0, 0, 1152000000}, /* freq = (6M * 194), index = 194*/
+    {23, 1, 0, 0, 1152000000}, /* freq = (6M * 195), index = 195*/
+    {15, 2, 0, 0, 1152000000}, /* freq = (6M * 196), index = 196*/
+    {11, 3, 0, 0, 1152000000}, /* freq = (6M * 197), index = 197*/
+    {23, 1, 0, 0, 1152000000}, /* freq = (6M * 198), index = 198*/
+    {15, 2, 0, 0, 1152000000}, /* freq = (6M * 199), index = 199*/
+    {24, 1, 0, 0, 1200000000}, /* freq = (6M * 200), index = 200*/
+    {24, 1, 0, 0, 1200000000}, /* freq = (6M * 201), index = 201*/
+    {24, 1, 0, 0, 1200000000}, /* freq = (6M * 202), index = 202*/
+    {24, 1, 0, 0, 1200000000}, /* freq = (6M * 203), index = 203*/
+    {16, 2, 0, 0, 1224000000}, /* freq = (6M * 204), index = 204*/
+    {16, 2, 0, 0, 1224000000}, /* freq = (6M * 205), index = 205*/
+    {16, 2, 0, 0, 1224000000}, /* freq = (6M * 206), index = 206*/
+    {16, 2, 0, 0, 1224000000}, /* freq = (6M * 207), index = 207*/
+    {25, 1, 0, 0, 1248000000}, /* freq = (6M * 208), index = 208*/
+    {12, 3, 0, 0, 1248000000}, /* freq = (6M * 209), index = 209*/
+    {25, 1, 0, 0, 1248000000}, /* freq = (6M * 210), index = 210*/
+    {12, 3, 0, 0, 1248000000}, /* freq = (6M * 211), index = 211*/
+    {25, 1, 0, 0, 1248000000}, /* freq = (6M * 212), index = 212*/
+    {12, 3, 0, 0, 1248000000}, /* freq = (6M * 213), index = 213*/
+    {25, 1, 0, 0, 1248000000}, /* freq = (6M * 214), index = 214*/
+    {12, 3, 0, 0, 1248000000}, /* freq = (6M * 215), index = 215*/
+    {26, 1, 0, 0, 1296000000}, /* freq = (6M * 216), index = 216*/
+    {17, 2, 0, 0, 1296000000}, /* freq = (6M * 217), index = 217*/
+    {26, 1, 0, 0, 1296000000}, /* freq = (6M * 218), index = 218*/
+    {17, 2, 0, 0, 1296000000}, /* freq = (6M * 219), index = 219*/
+    {26, 1, 0, 0, 1296000000}, /* freq = (6M * 220), index = 220*/
+    {17, 2, 0, 0, 1296000000}, /* freq = (6M * 221), index = 221*/
+    {26, 1, 0, 0, 1296000000}, /* freq = (6M * 222), index = 222*/
+    {17, 2, 0, 0, 1296000000}, /* freq = (6M * 223), index = 223*/
+    {27, 1, 0, 0, 1344000000}, /* freq = (6M * 224), index = 224*/
+    {13, 3, 0, 0, 1344000000}, /* freq = (6M * 225), index = 225*/
+    {13, 3, 0, 0, 1344000000}, /* freq = (6M * 226), index = 226*/
+    {13, 3, 0, 0, 1344000000}, /* freq = (6M * 227), index = 227*/
+    {18, 2, 0, 0, 1368000000}, /* freq = (6M * 228), index = 228*/
+    {18, 2, 0, 0, 1368000000}, /* freq = (6M * 229), index = 229*/
+    {18, 2, 0, 0, 1368000000}, /* freq = (6M * 230), index = 230*/
+    {18, 2, 0, 0, 1368000000}, /* freq = (6M * 231), index = 231*/
+    {28, 1, 0, 0, 1392000000}, /* freq = (6M * 232), index = 232*/
+    {28, 1, 0, 0, 1392000000}, /* freq = (6M * 233), index = 233*/
+    {28, 1, 0, 0, 1392000000}, /* freq = (6M * 234), index = 234*/
+    {28, 1, 0, 0, 1392000000}, /* freq = (6M * 235), index = 235*/
+    {28, 1, 0, 0, 1392000000}, /* freq = (6M * 236), index = 236*/
+    {28, 1, 0, 0, 1392000000}, /* freq = (6M * 237), index = 237*/
+    {28, 1, 0, 0, 1392000000}, /* freq = (6M * 238), index = 238*/
+    {28, 1, 0, 0, 1392000000}, /* freq = (6M * 239), index = 239*/
+    {29, 1, 0, 0, 1440000000}, /* freq = (6M * 240), index = 240*/
+};
+int ccm_get_pll1_para(__ccmu_pll1_reg0000_t *factor, __u64 rate)
+{
+    if(!factor)
+    {
+        return -1;
+    }
+
+    rate = rate>1440000000? 1440000000:rate;
+    do_div(rate, 6000000);
+
+    factor->FactorN = Pll1Tbl[rate].FactorN;
+    factor->FactorK = Pll1Tbl[rate].FactorK;
+    factor->FactorM = Pll1Tbl[rate].FactorM;
+
+    /* software config not valid, controlled by hw */
+    return 0;
+}
+
+
+/* normal pll(3/4/7/8/9/10) parameter table, frequency = 24*N/M */
+static struct pll_freq_cfg_tbl    PllxTbl[] = {
+    {0 , 0, 3, 0, 6000000  }, /* freq = (3M * 0  ), index = 0  */
+    {0 , 0, 3, 0, 6000000  }, /* freq = (3M * 1  ), index = 1  */
+    {0 , 0, 3, 0, 6000000  }, /* freq = (3M * 2  ), index = 2  */
+    {0 , 0, 2, 0, 8000000  }, /* freq = (3M * 3  ), index = 3  */
+    {1 , 0, 3, 0, 12000000 }, /* freq = (3M * 4  ), index = 4  */
+    {1 , 0, 2, 0, 16000000 }, /* freq = (3M * 5  ), index = 5  */
+    {2 , 0, 3, 0, 18000000 }, /* freq = (3M * 6  ), index = 6  */
+    {2 , 0, 3, 0, 18000000 }, /* freq = (3M * 7  ), index = 7  */
+    {0 , 0, 0, 0, 24000000 }, /* freq = (3M * 8  ), index = 8  */
+    {2 , 0, 2, 0, 24000000 }, /* freq = (3M * 9  ), index = 9  */
+    {4 , 0, 3, 0, 30000000 }, /* freq = (3M * 10 ), index = 10 */
+    {3 , 0, 2, 0, 32000000 }, /* freq = (3M * 11 ), index = 11 */
+    {5 , 0, 3, 0, 36000000 }, /* freq = (3M * 12 ), index = 12 */
+    {4 , 0, 2, 0, 40000000 }, /* freq = (3M * 13 ), index = 13 */
+    {6 , 0, 3, 0, 42000000 }, /* freq = (3M * 14 ), index = 14 */
+    {6 , 0, 3, 0, 42000000 }, /* freq = (3M * 15 ), index = 15 */
+    {1 , 0, 0, 0, 48000000 }, /* freq = (3M * 16 ), index = 16 */
+    {1 , 0, 0, 0, 48000000 }, /* freq = (3M * 17 ), index = 17 */
+    {8 , 0, 3, 0, 54000000 }, /* freq = (3M * 18 ), index = 18 */
+    {6 , 0, 2, 0, 56000000 }, /* freq = (3M * 19 ), index = 19 */
+    {4 , 0, 1, 0, 60000000 }, /* freq = (3M * 20 ), index = 20 */
+    {8 , 0, 2, 0, 64000000 }, /* freq = (3M * 21 ), index = 21 */
+    {10, 0, 3, 0, 66000000 }, /* freq = (3M * 22 ), index = 22 */
+    {10, 0, 3, 0, 66000000 }, /* freq = (3M * 23 ), index = 23 */
+    {2 , 0, 0, 0, 72000000 }, /* freq = (3M * 24 ), index = 24 */
+    {2 , 0, 0, 0, 72000000 }, /* freq = (3M * 25 ), index = 25 */
+    {12, 0, 3, 0, 78000000 }, /* freq = (3M * 26 ), index = 26 */
+    {12, 0, 3, 0, 78000000 }, /* freq = (3M * 27 ), index = 27 */
+    {6 , 0, 1, 0, 84000000 }, /* freq = (3M * 28 ), index = 28 */
+    {14, 0, 3, 0, 90000000 }, /* freq = (3M * 29 ), index = 29 */
+    {14, 0, 3, 0, 90000000 }, /* freq = (3M * 30 ), index = 30 */
+    {14, 0, 3, 0, 90000000 }, /* freq = (3M * 31 ), index = 31 */
+    {3 , 0, 0, 0, 96000000 }, /* freq = (3M * 32 ), index = 32 */
+    {3 , 0, 0, 0, 96000000 }, /* freq = (3M * 33 ), index = 33 */
+    {16, 0, 3, 0, 102000000}, /* freq = (3M * 34 ), index = 34 */
+    {16, 0, 3, 0, 102000000}, /* freq = (3M * 35 ), index = 35 */
+    {8 , 0, 1, 0, 108000000}, /* freq = (3M * 36 ), index = 36 */
+    {8 , 0, 1, 0, 108000000}, /* freq = (3M * 37 ), index = 37 */
+    {18, 0, 3, 0, 114000000}, /* freq = (3M * 38 ), index = 38 */
+    {4 , 0, 0, 0, 120000000}, /* freq = (3M * 39 ), index = 39 */
+    {4 , 0, 0, 0, 120000000}, /* freq = (3M * 40 ), index = 40 */
+    {4 , 0, 0, 0, 120000000}, /* freq = (3M * 41 ), index = 41 */
+    {20, 0, 3, 0, 126000000}, /* freq = (3M * 42 ), index = 42 */
+    {20, 0, 3, 0, 126000000}, /* freq = (3M * 43 ), index = 43 */
+    {10, 0, 1, 0, 132000000}, /* freq = (3M * 44 ), index = 44 */
+    {10, 0, 1, 0, 132000000}, /* freq = (3M * 45 ), index = 45 */
+    {22, 0, 3, 0, 138000000}, /* freq = (3M * 46 ), index = 46 */
+    {22, 0, 3, 0, 138000000}, /* freq = (3M * 47 ), index = 47 */
+    {5 , 0, 0, 0, 144000000}, /* freq = (3M * 48 ), index = 48 */
+    {5 , 0, 0, 0, 144000000}, /* freq = (3M * 49 ), index = 49 */
+    {24, 0, 3, 0, 150000000}, /* freq = (3M * 50 ), index = 50 */
+    {24, 0, 3, 0, 150000000}, /* freq = (3M * 51 ), index = 51 */
+    {12, 0, 1, 0, 156000000}, /* freq = (3M * 52 ), index = 52 */
+    {12, 0, 1, 0, 156000000}, /* freq = (3M * 53 ), index = 53 */
+    {12, 0, 1, 0, 156000000}, /* freq = (3M * 54 ), index = 54 */
+    {6 , 0, 0, 0, 168000000}, /* freq = (3M * 55 ), index = 55 */
+    {6 , 0, 0, 0, 168000000}, /* freq = (3M * 56 ), index = 56 */
+    {6 , 0, 0, 0, 168000000}, /* freq = (3M * 57 ), index = 57 */
+    {6 , 0, 0, 0, 168000000}, /* freq = (3M * 58 ), index = 58 */
+    {14, 0, 1, 0, 180000000}, /* freq = (3M * 59 ), index = 59 */
+    {14, 0, 1, 0, 180000000}, /* freq = (3M * 60 ), index = 60 */
+    {14, 0, 1, 0, 180000000}, /* freq = (3M * 61 ), index = 61 */
+    {14, 0, 1, 0, 180000000}, /* freq = (3M * 62 ), index = 62 */
+    {7 , 0, 0, 0, 192000000}, /* freq = (3M * 63 ), index = 63 */
+    {7 , 0, 0, 0, 192000000}, /* freq = (3M * 64 ), index = 64 */
+    {7 , 0, 0, 0, 192000000}, /* freq = (3M * 65 ), index = 65 */
+    {24, 0, 2, 0, 200000000}, /* freq = (3M * 66 ), index = 66 */
+    {24, 0, 2, 0, 200000000}, /* freq = (3M * 67 ), index = 67 */
+    {16, 0, 1, 0, 204000000}, /* freq = (3M * 68 ), index = 68 */
+    {16, 0, 1, 0, 204000000}, /* freq = (3M * 69 ), index = 69 */
+    {16, 0, 1, 0, 204000000}, /* freq = (3M * 70 ), index = 70 */
+    {8 , 0, 0, 0, 216000000}, /* freq = (3M * 71 ), index = 71 */
+    {8 , 0, 0, 0, 216000000}, /* freq = (3M * 72 ), index = 72 */
+    {8 , 0, 0, 0, 216000000}, /* freq = (3M * 73 ), index = 73 */
+    {8 , 0, 0, 0, 216000000}, /* freq = (3M * 74 ), index = 74 */
+    {18, 0, 1, 0, 228000000}, /* freq = (3M * 75 ), index = 75 */
+    {18, 0, 1, 0, 228000000}, /* freq = (3M * 76 ), index = 76 */
+    {18, 0, 1, 0, 228000000}, /* freq = (3M * 77 ), index = 77 */
+    {18, 0, 1, 0, 228000000}, /* freq = (3M * 78 ), index = 78 */
+    {9 , 0, 0, 0, 240000000}, /* freq = (3M * 79 ), index = 79 */
+    {9 , 0, 0, 0, 240000000}, /* freq = (3M * 80 ), index = 80 */
+    {9 , 0, 0, 0, 240000000}, /* freq = (3M * 81 ), index = 81 */
+    {9 , 0, 0, 0, 240000000}, /* freq = (3M * 82 ), index = 82 */
+    {20, 0, 1, 0, 252000000}, /* freq = (3M * 83 ), index = 83 */
+    {20, 0, 1, 0, 252000000}, /* freq = (3M * 84 ), index = 84 */
+    {20, 0, 1, 0, 252000000}, /* freq = (3M * 85 ), index = 85 */
+    {20, 0, 1, 0, 252000000}, /* freq = (3M * 86 ), index = 86 */
+    {10, 0, 0, 0, 264000000}, /* freq = (3M * 87 ), index = 87 */
+    {10, 0, 0, 0, 264000000}, /* freq = (3M * 88 ), index = 88 */
+    {22, 0, 1, 0, 276000000}, /* freq = (3M * 89 ), index = 89 */
+    {10, 0, 0, 0, 270000000}, /* freq = (3M * 90 ), index = 90 */
+    {22, 0, 1, 0, 276000000}, /* freq = (3M * 91 ), index = 91 */
+    {22, 0, 1, 0, 276000000}, /* freq = (3M * 92 ), index = 92 */
+    {11, 0, 0, 0, 288000000}, /* freq = (3M * 93 ), index = 93 */
+    {11, 0, 0, 0, 288000000}, /* freq = (3M * 94 ), index = 94 */
+    {11, 0, 0, 0, 288000000}, /* freq = (3M * 95 ), index = 95 */
+    {11, 0, 0, 0, 288000000}, /* freq = (3M * 96 ), index = 96 */
+    {11, 0, 0, 0, 288000000}, /* freq = (3M * 97 ), index = 97 */
+    {11, 0, 0, 0, 288000000}, /* freq = (3M * 98 ), index = 98 */
+    {11, 0, 0, 0, 297000000}, /* freq = (3M * 99 ), index = 99 */
+    {24, 0, 1, 0, 300000000}, /* freq = (3M * 100), index = 100*/
+    {24, 0, 1, 0, 300000000}, /* freq = (3M * 101), index = 101*/
+    {24, 0, 1, 0, 300000000}, /* freq = (3M * 102), index = 102*/
+    {12, 0, 0, 0, 312000000}, /* freq = (3M * 103), index = 103*/
+    {12, 0, 0, 0, 312000000}, /* freq = (3M * 104), index = 104*/
+    {12, 0, 0, 0, 312000000}, /* freq = (3M * 105), index = 105*/
+    {12, 0, 0, 0, 312000000}, /* freq = (3M * 106), index = 106*/
+    {12, 0, 0, 0, 312000000}, /* freq = (3M * 107), index = 107*/
+    {12, 0, 0, 0, 312000000}, /* freq = (3M * 108), index = 108*/
+    {12, 0, 0, 0, 312000000}, /* freq = (3M * 109), index = 109*/
+    {13, 0, 0, 0, 336000000}, /* freq = (3M * 110), index = 110*/
+    {13, 0, 0, 0, 336000000}, /* freq = (3M * 111), index = 111*/
+    {13, 0, 0, 0, 336000000}, /* freq = (3M * 112), index = 112*/
+    {13, 0, 0, 0, 336000000}, /* freq = (3M * 113), index = 113*/
+    {13, 0, 0, 0, 336000000}, /* freq = (3M * 114), index = 114*/
+    {13, 0, 0, 0, 336000000}, /* freq = (3M * 115), index = 115*/
+    {13, 0, 0, 0, 336000000}, /* freq = (3M * 116), index = 116*/
+    {13, 0, 0, 0, 336000000}, /* freq = (3M * 117), index = 117*/
+    {14, 0, 0, 0, 360000000}, /* freq = (3M * 118), index = 118*/
+    {14, 0, 0, 0, 360000000}, /* freq = (3M * 119), index = 119*/
+    {14, 0, 0, 0, 360000000}, /* freq = (3M * 120), index = 120*/
+    {14, 0, 0, 0, 360000000}, /* freq = (3M * 121), index = 121*/
+    {14, 0, 0, 0, 360000000}, /* freq = (3M * 122), index = 122*/
+    {14, 0, 0, 0, 360000000}, /* freq = (3M * 123), index = 123*/
+    {14, 0, 0, 0, 360000000}, /* freq = (3M * 124), index = 124*/
+    {14, 0, 0, 0, 360000000}, /* freq = (3M * 125), index = 125*/
+    {15, 0, 0, 0, 384000000}, /* freq = (3M * 126), index = 126*/
+    {15, 0, 0, 0, 384000000}, /* freq = (3M * 127), index = 127*/
+    {15, 0, 0, 0, 384000000}, /* freq = (3M * 128), index = 128*/
+    {15, 0, 0, 0, 384000000}, /* freq = (3M * 129), index = 129*/
+    {15, 0, 0, 0, 384000000}, /* freq = (3M * 130), index = 130*/
+    {15, 0, 0, 0, 384000000}, /* freq = (3M * 131), index = 131*/
+    {15, 0, 0, 0, 384000000}, /* freq = (3M * 132), index = 132*/
+    {16, 0, 0, 0, 408000000}, /* freq = (3M * 133), index = 133*/
+    {16, 0, 0, 0, 408000000}, /* freq = (3M * 134), index = 134*/
+    {16, 0, 0, 0, 408000000}, /* freq = (3M * 135), index = 135*/
+    {16, 0, 0, 0, 408000000}, /* freq = (3M * 136), index = 136*/
+    {16, 0, 0, 0, 408000000}, /* freq = (3M * 137), index = 137*/
+    {16, 0, 0, 0, 408000000}, /* freq = (3M * 138), index = 138*/
+    {16, 0, 0, 0, 408000000}, /* freq = (3M * 139), index = 139*/
+    {16, 0, 0, 0, 408000000}, /* freq = (3M * 140), index = 140*/
+    {16, 0, 0, 0, 408000000}, /* freq = (3M * 141), index = 141*/
+    {17, 0, 0, 0, 432000000}, /* freq = (3M * 142), index = 142*/
+    {17, 0, 0, 0, 432000000}, /* freq = (3M * 143), index = 143*/
+    {17, 0, 0, 0, 432000000}, /* freq = (3M * 144), index = 144*/
+    {17, 0, 0, 0, 432000000}, /* freq = (3M * 145), index = 145*/
+    {17, 0, 0, 0, 432000000}, /* freq = (3M * 146), index = 146*/
+    {17, 0, 0, 0, 432000000}, /* freq = (3M * 147), index = 147*/
+    {17, 0, 0, 0, 432000000}, /* freq = (3M * 148), index = 148*/
+    {17, 0, 0, 0, 432000000}, /* freq = (3M * 149), index = 149*/
+    {18, 0, 0, 0, 456000000}, /* freq = (3M * 150), index = 150*/
+    {18, 0, 0, 0, 456000000}, /* freq = (3M * 151), index = 151*/
+    {18, 0, 0, 0, 456000000}, /* freq = (3M * 152), index = 152*/
+    {18, 0, 0, 0, 456000000}, /* freq = (3M * 153), index = 153*/
+    {18, 0, 0, 0, 456000000}, /* freq = (3M * 154), index = 154*/
+    {18, 0, 0, 0, 456000000}, /* freq = (3M * 155), index = 155*/
+    {18, 0, 0, 0, 456000000}, /* freq = (3M * 156), index = 156*/
+    {19, 0, 0, 0, 480000000}, /* freq = (3M * 157), index = 157*/
+    {19, 0, 0, 0, 480000000}, /* freq = (3M * 158), index = 158*/
+    {19, 0, 0, 0, 480000000}, /* freq = (3M * 159), index = 159*/
+    {19, 0, 0, 0, 480000000}, /* freq = (3M * 160), index = 160*/
+    {19, 0, 0, 0, 480000000}, /* freq = (3M * 161), index = 161*/
+    {19, 0, 0, 0, 480000000}, /* freq = (3M * 162), index = 162*/
+    {19, 0, 0, 0, 480000000}, /* freq = (3M * 163), index = 163*/
+    {20, 0, 0, 0, 504000000}, /* freq = (3M * 164), index = 164*/
+    {20, 0, 0, 0, 504000000}, /* freq = (3M * 165), index = 165*/
+    {20, 0, 0, 0, 504000000}, /* freq = (3M * 166), index = 166*/
+    {20, 0, 0, 0, 504000000}, /* freq = (3M * 167), index = 167*/
+    {20, 0, 0, 0, 504000000}, /* freq = (3M * 168), index = 168*/
+    {20, 0, 0, 0, 504000000}, /* freq = (3M * 169), index = 169*/
+    {20, 0, 0, 0, 504000000}, /* freq = (3M * 170), index = 170*/
+    {20, 0, 0, 0, 504000000}, /* freq = (3M * 171), index = 171*/
+    {20, 0, 0, 0, 504000000}, /* freq = (3M * 172), index = 172*/
+    {20, 0, 0, 0, 504000000}, /* freq = (3M * 173), index = 173*/
+    {21, 0, 0, 0, 528000000}, /* freq = (3M * 174), index = 174*/
+    {21, 0, 0, 0, 528000000}, /* freq = (3M * 175), index = 175*/
+    {21, 0, 0, 0, 528000000}, /* freq = (3M * 176), index = 176*/
+    {21, 0, 0, 0, 528000000}, /* freq = (3M * 177), index = 177*/
+    {21, 0, 0, 0, 528000000}, /* freq = (3M * 178), index = 178*/
+    {21, 0, 0, 0, 528000000}, /* freq = (3M * 179), index = 179*/
+    {22, 0, 0, 0, 552000000}, /* freq = (3M * 180), index = 180*/
+    {22, 0, 0, 0, 552000000}, /* freq = (3M * 181), index = 181*/
+    {22, 0, 0, 0, 552000000}, /* freq = (3M * 182), index = 182*/
+    {22, 0, 0, 0, 552000000}, /* freq = (3M * 183), index = 183*/
+    {22, 0, 0, 0, 552000000}, /* freq = (3M * 184), index = 184*/
+    {22, 0, 0, 0, 552000000}, /* freq = (3M * 185), index = 185*/
+    {22, 0, 0, 0, 552000000}, /* freq = (3M * 186), index = 186*/
+    {22, 0, 0, 0, 552000000}, /* freq = (3M * 187), index = 187*/
+    {22, 0, 0, 0, 552000000}, /* freq = (3M * 188), index = 188*/
+    {22, 0, 0, 0, 552000000}, /* freq = (3M * 189), index = 189*/
+    {23, 0, 0, 0, 576000000}, /* freq = (3M * 190), index = 190*/
+    {23, 0, 0, 0, 576000000}, /* freq = (3M * 191), index = 191*/
+    {23, 0, 0, 0, 576000000}, /* freq = (3M * 192), index = 192*/
+    {23, 0, 0, 0, 576000000}, /* freq = (3M * 193), index = 193*/
+    {23, 0, 0, 0, 576000000}, /* freq = (3M * 194), index = 194*/
+    {23, 0, 0, 0, 576000000}, /* freq = (3M * 195), index = 195*/
+    {23, 0, 0, 0, 576000000}, /* freq = (3M * 196), index = 196*/
+    {24, 0, 0, 0, 600000000}, /* freq = (3M * 197), index = 197*/
+    {24, 0, 0, 0, 600000000}, /* freq = (3M * 198), index = 198*/
+    {24, 0, 0, 0, 600000000}, /* freq = (3M * 199), index = 199*/
+    {99 , 0, 3, 0, 600000000}, /* freq = (3M * 201), index = 200*/
+    {99 , 0, 3, 0, 600000000}, /* freq = (3M * 201), index = 201*/
+    {100, 0, 3, 0, 606000000}, /* freq = (3M * 202), index = 202*/
+    {100, 0, 3, 0, 606000000}, /* freq = (3M * 203), index = 203*/
+    {101, 0, 3, 0, 612000000}, /* freq = (3M * 204), index = 204*/
+    {101, 0, 3, 0, 612000000}, /* freq = (3M * 205), index = 205*/
+    {102, 0, 3, 0, 618000000}, /* freq = (3M * 206), index = 206*/
+    {102, 0, 3, 0, 618000000}, /* freq = (3M * 207), index = 207*/
+    {103, 0, 3, 0, 624000000}, /* freq = (3M * 208), index = 208*/
+    {103, 0, 3, 0, 624000000}, /* freq = (3M * 209), index = 209*/
+    {104, 0, 3, 0, 630000000}, /* freq = (3M * 210), index = 210*/
+    {104, 0, 3, 0, 630000000}, /* freq = (3M * 211), index = 211*/
+    {105, 0, 3, 0, 636000000}, /* freq = (3M * 212), index = 212*/
+    {105, 0, 3, 0, 636000000}, /* freq = (3M * 213), index = 213*/
+    {106, 0, 3, 0, 642000000}, /* freq = (3M * 214), index = 214*/
+    {106, 0, 3, 0, 642000000}, /* freq = (3M * 215), index = 215*/
+    {107, 0, 3, 0, 648000000}, /* freq = (3M * 216), index = 216*/
+    {107, 0, 3, 0, 648000000}, /* freq = (3M * 217), index = 217*/
+    {108, 0, 3, 0, 654000000}, /* freq = (3M * 218), index = 218*/
+    {108, 0, 3, 0, 654000000}, /* freq = (3M * 219), index = 219*/
+    {109, 0, 3, 0, 660000000}, /* freq = (3M * 220), index = 220*/
+    {109, 0, 3, 0, 660000000}, /* freq = (3M * 221), index = 221*/
+    {110, 0, 3, 0, 666000000}, /* freq = (3M * 222), index = 222*/
+    {110, 0, 3, 0, 666000000}, /* freq = (3M * 223), index = 223*/
+    {111, 0, 3, 0, 672000000}, /* freq = (3M * 224), index = 224*/
+    {111, 0, 3, 0, 672000000}, /* freq = (3M * 225), index = 225*/
+    {112, 0, 3, 0, 678000000}, /* freq = (3M * 226), index = 226*/
+    {112, 0, 3, 0, 678000000}, /* freq = (3M * 227), index = 227*/
+    {113, 0, 3, 0, 684000000}, /* freq = (3M * 228), index = 228*/
+    {113, 0, 3, 0, 684000000}, /* freq = (3M * 229), index = 229*/
+    {114, 0, 3, 0, 690000000}, /* freq = (3M * 230), index = 230*/
+    {114, 0, 3, 0, 690000000}, /* freq = (3M * 231), index = 231*/
+    {115, 0, 3, 0, 696000000}, /* freq = (3M * 232), index = 232*/
+    {115, 0, 3, 0, 696000000}, /* freq = (3M * 233), index = 233*/
+    {116, 0, 3, 0, 702000000}, /* freq = (3M * 224), index = 234*/
+    {116, 0, 3, 0, 702000000}, /* freq = (3M * 225), index = 235*/
+    {117, 0, 3, 0, 708000000}, /* freq = (3M * 226), index = 236*/
+    {117, 0, 3, 0, 708000000}, /* freq = (3M * 227), index = 237*/
+    {118, 0, 3, 0, 714000000}, /* freq = (3M * 226), index = 238*/
+    {118, 0, 3, 0, 714000000}, /* freq = (3M * 227), index = 239*/
+    {119, 0, 3, 0, 720000000}, /* freq = (3M * 226), index = 240*/
+};
+
+int ccm_get_pllx_para(__ccmu_media_pll_t *factor, __u64 rate)
+{
+    if(!factor) {
+        /* parameter is invalid */
+        return -1;
+    }
+
+    if(rate > 720000000) {
+        rate = 720000000;
+    }
+
+    /* find the clock configuration */
+    do_div(rate, 3000000);
+    factor->FactorN = PllxTbl[rate].FactorN;
+    factor->FactorM = PllxTbl[rate].FactorM;
+    return 0;
+}
diff --git a/arch/arm/mach-sun6i/clock/sys_clk.c b/arch/arm/mach-sun6i/clock/sys_clk.c
new file mode 100644
index 0000000..ebb0972
--- /dev/null
+++ b/arch/arm/mach-sun6i/clock/sys_clk.c
@@ -0,0 +1,1178 @@
+/*
+ *  arch/arm/mach-sun6i/clock/ccmu/ccm_sys_clk.c
+ *
+ * Copyright (c) Allwinner.  All rights reserved.
+ * kevin.z.m (kevin@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <mach/clock.h>
+#include <asm/delay.h>
+#include "ccm_i.h"
+
+
+
+/*
+*********************************************************************************************************
+*                           sys_clk_get_parent
+*
+*Description: get parent clock for system clock;
+*
+*Arguments  : id    system clock id;
+*
+*Return     : parent id;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __aw_ccu_clk_id_e sys_clk_get_parent(__aw_ccu_clk_id_e id)
+{
+    switch(id)
+    {
+        case AW_SYS_CLK_PLL2X8:
+            return AW_SYS_CLK_PLL2;
+        case AW_SYS_CLK_PLL6x2:
+            return AW_SYS_CLK_PLL6;
+        case AW_SYS_CLK_PLL3X2:
+            return AW_SYS_CLK_PLL3;
+        case AW_SYS_CLK_PLL7X2:
+            return AW_SYS_CLK_PLL7;
+        case AW_SYS_CLK_MIPIPLL:
+            return aw_ccu_reg->MipiPllCtl.PllSrc? AW_SYS_CLK_PLL7:AW_SYS_CLK_PLL3;
+        case AW_SYS_CLK_AC327:
+            switch(aw_ccu_reg->SysClkDiv.CpuClkSrc)
+            {
+                case AC327_CLKSRC_LOSC:
+                    return AW_SYS_CLK_LOSC;
+                case AC327_CLKSRC_HOSC:
+                    return AW_SYS_CLK_HOSC;
+                default:
+                    return AW_SYS_CLK_PLL1;
+            }
+        case AW_SYS_CLK_AR100:
+            switch(aw_cpus_reg->CpusCfg.ClkSrc)
+            {
+                case AR100_CLKSRC_LOSC:
+                    return AW_SYS_CLK_LOSC;
+                case AR100_CLKSRC_HOSC:
+                    return AW_SYS_CLK_HOSC;
+                default:
+                    return AW_SYS_CLK_PLL6;
+            }
+        case AW_SYS_CLK_AXI:
+            return AW_SYS_CLK_AC327;
+        case AW_SYS_CLK_AHB0:
+            return AW_SYS_CLK_AR100;
+        case AW_SYS_CLK_AHB1:
+            switch(aw_ccu_reg->Ahb1Div.Ahb1ClkSrc)
+            {
+                case AHB1_CLKSRC_LOSC:
+                    return AW_SYS_CLK_LOSC;
+                case AHB1_CLKSRC_HOSC:
+                    return AW_SYS_CLK_HOSC;
+                case AHB1_CLKSRC_AXI:
+                    return AW_SYS_CLK_AXI;
+                case AHB1_CLKSRC_PLL6:
+                    return AW_SYS_CLK_PLL6;
+            }
+        case AW_SYS_CLK_APB0:
+            return AW_SYS_CLK_AHB0;
+        case AW_SYS_CLK_APB1:
+            return AW_SYS_CLK_AHB1;
+        case AW_SYS_CLK_APB2:
+            switch(aw_ccu_reg->Apb2Div.ClkSrc)
+            {
+                case APB2_CLKSRC_LOSC:
+                    return AW_SYS_CLK_LOSC;
+                case APB2_CLKSRC_HOSC:
+                    return AW_SYS_CLK_HOSC;
+                default:
+                    return AW_SYS_CLK_PLL6;
+            }
+        default:
+            return AW_SYS_CLK_NONE;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           sys_clk_get_status
+*
+*Description: get system clock on/off status.
+*
+*Arguments  : id    system clock id;
+*
+*Return     : system clock status;
+*               0, clock is off;
+*              !0, clock is on;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __aw_ccu_clk_onff_e sys_clk_get_status(__aw_ccu_clk_id_e id)
+{
+    switch(id)
+    {
+        case AW_SYS_CLK_LOSC:
+            return AW_CCU_CLK_ON;
+        case AW_SYS_CLK_HOSC:
+            return AW_CCU_CLK_ON;
+        case AW_SYS_CLK_PLL1:
+            return PLL1_ENBLE? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL2:
+        case AW_SYS_CLK_PLL2X8:
+            return PLL2_ENBLE? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL3:
+        case AW_SYS_CLK_PLL3X2:
+            return PLL3_ENBLE? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL4:
+            return PLL4_ENBLE? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL5:
+            return PLL5_ENBLE? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL6:
+        case AW_SYS_CLK_PLL6x2:
+            return PLL6_ENBLE? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL7:
+        case AW_SYS_CLK_PLL7X2:
+            return PLL7_ENBLE? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL8:
+            return PLL8_ENBLE? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL9:
+            return PLL9_ENBLE? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_PLL10:
+            return PLL10_ENBLE? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_MIPIPLL:
+            return aw_ccu_reg->MipiPllCtl.PLLEn? AW_CCU_CLK_ON : AW_CCU_CLK_OFF;
+        case AW_SYS_CLK_AC327:
+        case AW_SYS_CLK_AR100:
+        case AW_SYS_CLK_AXI:
+        case AW_SYS_CLK_AHB0:
+        case AW_SYS_CLK_AHB1:
+        case AW_SYS_CLK_APB0:
+        case AW_SYS_CLK_APB1:
+        case AW_SYS_CLK_APB2:
+        default:
+            return AW_CCU_CLK_ON;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           sys_clk_get_rate
+*
+*Description: get clock rate for system clock;
+*
+*Arguments  : id    system clock id;
+*
+*Return     : clock rate;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __u64 sys_clk_get_rate(__aw_ccu_clk_id_e id)
+{
+    __u64   tmp_rate;
+
+    switch(id)
+    {
+        case AW_SYS_CLK_NONE:
+            return 1;
+        case AW_SYS_CLK_LOSC:
+            return 32768;
+        case AW_SYS_CLK_HOSC:
+            return 24000000;
+        case AW_SYS_CLK_PLL1:
+            tmp_rate = (__u64)24000000*PLL1_FACTOR_N*PLL1_FACTOR_K;
+            do_div(tmp_rate, PLL1_FACTOR_M);
+            return tmp_rate;
+        case AW_SYS_CLK_PLL2:
+            if((aw_ccu_reg->Pll2Ctl.FactorM == 20)
+               && (aw_ccu_reg->Pll2Ctl.FactorN == 85)
+               && (aw_ccu_reg->Pll2Ctl.FactorP == 3))
+            {
+                /* 24000000 * 86 / (21 * 4) = 24571000 */
+                return 24576000;
+            }
+            else if((aw_ccu_reg->Pll2Ctl.FactorM == 20)
+               && (aw_ccu_reg->Pll2Ctl.FactorN == 78)
+               && (aw_ccu_reg->Pll2Ctl.FactorP == 3))
+            {
+                /* 24000000 * 79 / (21 * 4) = 22571000 */
+                return 22579200;
+            }
+            else
+            {
+                aw_ccu_reg->Pll2Ctl.FactorM = 20;
+                aw_ccu_reg->Pll2Ctl.FactorN = 78;
+                aw_ccu_reg->Pll2Ctl.FactorP = 3;
+                return 22579200;
+            }
+        case AW_SYS_CLK_PLL3:
+        case AW_SYS_CLK_PLL4:
+        case AW_SYS_CLK_PLL7:
+        case AW_SYS_CLK_PLL8:
+        case AW_SYS_CLK_PLL9:
+        case AW_SYS_CLK_PLL10:
+        {
+            volatile __ccmu_media_pll_t  *tmp_reg;
+	    __ccmu_media_pll_t  tmp_pll;
+
+            if(id == AW_SYS_CLK_PLL3)
+                tmp_reg = &aw_ccu_reg->Pll3Ctl;
+            else if(id == AW_SYS_CLK_PLL4)
+                tmp_reg = &aw_ccu_reg->Pll4Ctl;
+            else if(id == AW_SYS_CLK_PLL7)
+                tmp_reg = &aw_ccu_reg->Pll7Ctl;
+            else if(id == AW_SYS_CLK_PLL8)
+                tmp_reg = &aw_ccu_reg->Pll8Ctl;
+            else if(id == AW_SYS_CLK_PLL9)
+                tmp_reg = &aw_ccu_reg->Pll9Ctl;
+            else
+                tmp_reg = &aw_ccu_reg->Pll10Ctl;
+
+            if(!tmp_reg->ModeSel)
+            {
+		tmp_rate = tmp_reg->FracMod ? 297000000 : 270000000;
+		ccm_get_pllx_para(&tmp_pll, tmp_rate);
+		tmp_reg->FactorM = tmp_pll.FactorM;
+		tmp_reg->FactorN = tmp_pll.FactorN;
+		return tmp_rate;
+            }
+            else
+            {
+                tmp_rate = (__u64)24000000*(tmp_reg->FactorN+1);
+                do_div(tmp_rate, tmp_reg->FactorM+1);
+		if(tmp_rate == 297000000 || tmp_rate == 270000000) {
+		    /* set pll to frac mode */
+		    tmp_reg->ModeSel = 0;
+		    tmp_reg->FracMod = (tmp_rate == 297000000) ? 1 : 0;
+		    ccm_get_pllx_para(&tmp_pll, tmp_rate);
+		    tmp_reg->FactorM = tmp_pll.FactorM;
+		    tmp_reg->FactorN = tmp_pll.FactorN;
+		}
+                return tmp_rate;
+            }
+        }
+
+        case AW_SYS_CLK_PLL5:
+            tmp_rate = (__u64)24000000*PLL5_FACTOR_N*PLL5_FACTOR_K;
+            do_div(tmp_rate, PLL5_FACTOR_M);
+            return tmp_rate;
+        case AW_SYS_CLK_PLL6:
+            tmp_rate = (__u64)24000000*PLL6_FACTOR_N*PLL6_FACTOR_K;
+            return tmp_rate/2;
+        case AW_SYS_CLK_PLL2X8:
+            return sys_clk_get_rate(AW_SYS_CLK_PLL2) * 8;
+        case AW_SYS_CLK_PLL3X2:
+            return sys_clk_get_rate(AW_SYS_CLK_PLL3) * 2;
+        case AW_SYS_CLK_PLL6x2:
+            return sys_clk_get_rate(AW_SYS_CLK_PLL6) * 2;
+        case AW_SYS_CLK_PLL7X2:
+            return sys_clk_get_rate(AW_SYS_CLK_PLL7) * 2;
+        case AW_SYS_CLK_MIPIPLL:
+            tmp_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            if(aw_ccu_reg->MipiPllCtl.VfbSel == 0) {
+                tmp_rate *= (aw_ccu_reg->MipiPllCtl.FactorN+1) * (aw_ccu_reg->MipiPllCtl.FactorK+1);
+                do_div(tmp_rate, aw_ccu_reg->MipiPllCtl.FactorM+1);
+            } else {
+                tmp_rate *= aw_ccu_reg->MipiPllCtl.SDiv2+1;
+                if(aw_ccu_reg->MipiPllCtl.FracMode == 0) {
+                    tmp_rate *= aw_ccu_reg->MipiPllCtl.FeedBackDiv? 7:5;
+                    do_div(tmp_rate, aw_ccu_reg->MipiPllCtl.FactorM + 1);
+                } else {
+                    tmp_rate *= aw_ccu_reg->MipiPllCtl.Sel625Or750? 750:625;
+                    do_div(tmp_rate, ((aw_ccu_reg->MipiPllCtl.FactorM+1)*100));
+                }
+            }
+            return tmp_rate;
+
+        case AW_SYS_CLK_AC327:
+            tmp_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            do_div(tmp_rate, AC327_CLK_DIV);
+            return tmp_rate;
+        case AW_SYS_CLK_AR100:
+            tmp_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            do_div(tmp_rate, AR100_CLK_DIV);
+            return tmp_rate;
+        case AW_SYS_CLK_AXI:
+            tmp_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            do_div(tmp_rate, AXI_CLK_DIV);
+            return tmp_rate;
+        case AW_SYS_CLK_AHB0:
+            tmp_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            do_div(tmp_rate, AHB0_CLK_DIV);
+            return tmp_rate;
+        case AW_SYS_CLK_AHB1:
+            tmp_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            do_div(tmp_rate, AHB1_CLK_DIV);
+            return tmp_rate;
+        case AW_SYS_CLK_APB0:
+            tmp_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            do_div(tmp_rate, APB0_CLK_DIV);
+            return tmp_rate;
+        case AW_SYS_CLK_APB1:
+            tmp_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            do_div(tmp_rate, APB1_CLK_DIV);
+            return tmp_rate;
+        case AW_SYS_CLK_APB2:
+            tmp_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            do_div(tmp_rate, APB2_CLK_DIV);
+            return tmp_rate;
+        default:
+            CCU_DBG("system clock id is:%d\n", id);
+            return 0;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           sys_clk_set_parent
+*
+*Description: set parent clock id for system clock;
+*
+*Arguments  : id        system clock id whose parent need be set;
+*             parent    parent id to be set;
+*
+*Return     : result,
+*               0,  set parent successed;
+*              !0,  set parent failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 sys_clk_set_parent(__aw_ccu_clk_id_e id, __aw_ccu_clk_id_e parent)
+{
+    switch(id)
+    {
+        case AW_SYS_CLK_PLL2X8:
+            return (parent == AW_SYS_CLK_PLL2)? 0:-1;
+        case AW_SYS_CLK_PLL3X2:
+            return (parent == AW_SYS_CLK_PLL3)? 0:-1;
+        case AW_SYS_CLK_PLL6x2:
+            return (parent == AW_SYS_CLK_PLL6)? 0:-1;
+        case AW_SYS_CLK_PLL7X2:
+            return (parent == AW_SYS_CLK_PLL7)? 0:-1;
+        case AW_SYS_CLK_MIPIPLL:
+            if(parent == AW_SYS_CLK_PLL3)
+                aw_ccu_reg->MipiPllCtl.PllSrc = 0;
+            else if(parent == AW_SYS_CLK_PLL7)
+                aw_ccu_reg->MipiPllCtl.PllSrc = 1;
+            else
+                return -1;
+            return 0;
+        case AW_SYS_CLK_AC327:
+            switch(parent)
+            {
+                case AW_SYS_CLK_LOSC:
+                    aw_ccu_reg->SysClkDiv.CpuClkSrc = AC327_CLKSRC_LOSC;
+                    return 0;
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->SysClkDiv.CpuClkSrc = AC327_CLKSRC_HOSC;
+                    return 0;
+                case AW_SYS_CLK_PLL1:
+                    aw_ccu_reg->SysClkDiv.CpuClkSrc = AC327_CLKSRC_PLL1;
+                    return 0;
+                default:
+                    CCU_ERR("ac327 clock source is ivalid!\n");
+                    return -1;
+            }
+        case AW_SYS_CLK_AR100:
+            switch(parent)
+            {
+                case AW_SYS_CLK_LOSC:
+                    aw_cpus_reg->CpusCfg.ClkSrc = AR100_CLKSRC_LOSC;
+                    return 0;
+                case AW_SYS_CLK_HOSC:
+                    aw_cpus_reg->CpusCfg.ClkSrc = AR100_CLKSRC_HOSC;
+                    return 0;
+                case AW_SYS_CLK_PLL1:
+                    aw_cpus_reg->CpusCfg.ClkSrc = AR100_CLKSRC_PLL6;
+                    return 0;
+                default:
+                    CCU_ERR("ar100 clock source is ivalid!\n");
+                    return -1;
+            }
+        case AW_SYS_CLK_AXI:
+            return (parent == AW_SYS_CLK_AC327)? 0:-1;
+        case AW_SYS_CLK_AHB0:
+            return (parent == AW_SYS_CLK_AR100)? 0:-1;
+        case AW_SYS_CLK_AHB1:
+            switch(parent)
+            {
+                case AW_SYS_CLK_LOSC:
+                    aw_ccu_reg->Ahb1Div.Ahb1ClkSrc = AHB1_CLKSRC_LOSC;
+                    return 0;
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->Ahb1Div.Ahb1ClkSrc = AW_SYS_CLK_HOSC;
+                    return 0;
+                case AW_SYS_CLK_AXI:
+                    aw_ccu_reg->Ahb1Div.Ahb1ClkSrc = AHB1_CLKSRC_AXI;
+                    return 0;
+                case AW_SYS_CLK_PLL6:
+                    aw_ccu_reg->Ahb1Div.Ahb1ClkSrc = AHB1_CLKSRC_PLL6;
+                    return 0;
+                default:
+                    CCU_ERR("axi clock source is ivalid!\n");
+                    return -1;
+            }
+        case AW_SYS_CLK_APB0:
+            return (parent == AW_SYS_CLK_AHB0)? 0:-1;
+        case AW_SYS_CLK_APB1:
+            return (parent == AW_SYS_CLK_AHB1)? 0:-1;
+        case AW_SYS_CLK_APB2:
+            switch(parent)
+            {
+                case AW_SYS_CLK_LOSC:
+                    aw_ccu_reg->Apb2Div.ClkSrc = APB2_CLKSRC_LOSC;
+                    return 0;
+                case AW_SYS_CLK_HOSC:
+                    aw_ccu_reg->Apb2Div.ClkSrc = APB2_CLKSRC_HOSC;
+                    return 0;
+                case AW_SYS_CLK_PLL6:
+                    aw_ccu_reg->Apb2Div.ClkSrc = APB2_CLKSRC_PLL6;
+                    return 0;
+                default:
+                    CCU_ERR("apb2 clock source is ivalid!\n");
+                    return -1;
+            }
+
+        case AW_SYS_CLK_LOSC:
+        case AW_SYS_CLK_HOSC:
+        case AW_SYS_CLK_PLL1:
+        case AW_SYS_CLK_PLL2:
+        case AW_SYS_CLK_PLL3:
+        case AW_SYS_CLK_PLL4:
+        case AW_SYS_CLK_PLL5:
+        case AW_SYS_CLK_PLL6:
+        case AW_SYS_CLK_PLL7:
+        case AW_SYS_CLK_PLL8:
+        case AW_SYS_CLK_PLL9:
+        case AW_SYS_CLK_PLL10:
+        default:
+            return (parent == AW_SYS_CLK_NONE)? 0:-1;
+    }
+}
+
+
+/*
+*********************************************************************************************************
+*                           sys_clk_set_status
+*
+*Description: set on/off status for system clock;
+*
+*Arguments  : id        system clock id;
+*             status    on/off status;
+*                           AW_CCU_CLK_OFF - off
+*                           AW_CCU_CLK_ON - on
+*
+*Return     : result;
+*               0,  set status successed;
+*              !0,  set status failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 sys_clk_set_status(__aw_ccu_clk_id_e id, __aw_ccu_clk_onff_e status)
+{
+    switch(id)
+    {
+        case AW_SYS_CLK_LOSC:
+            return 0;
+        case AW_SYS_CLK_HOSC:
+            return 0;
+        case AW_SYS_CLK_PLL1:
+            PLL1_ENBLE = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL2:
+            PLL2_ENBLE = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL3:
+            PLL3_ENBLE = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL4:
+            PLL4_ENBLE = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL5:
+            PLL5_ENBLE = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL6:
+            PLL6_ENBLE = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL7:
+            PLL7_ENBLE = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL8:
+            PLL8_ENBLE = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL9:
+            PLL9_ENBLE = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_PLL10:
+            PLL10_ENBLE = (status == AW_CCU_CLK_ON)? 1 : 0;
+            return 0;
+        case AW_SYS_CLK_MIPIPLL:
+            aw_ccu_reg->MipiPllCtl.PLLEn = (status == AW_CCU_CLK_ON)? 1:0;
+            return 0;
+        case AW_SYS_CLK_PLL2X8:
+            return (sys_clk_get_status(AW_SYS_CLK_PLL2) == status)? 0 : -1;
+        case AW_SYS_CLK_PLL3X2:
+            return (sys_clk_get_status(AW_SYS_CLK_PLL3) == status)? 0 : -1;
+        case AW_SYS_CLK_PLL6x2:
+            return (sys_clk_get_status(AW_SYS_CLK_PLL6) == status)? 0 : -1;
+        case AW_SYS_CLK_PLL7X2:
+            return (sys_clk_get_status(AW_SYS_CLK_PLL7) == status)? 0 : -1;
+
+        default:
+            return 0;
+    }
+}
+
+
+/* ahb1 clock division table */
+/* bit0~bit7:div(1<<n), bit8~bit15:pre-div(n+1), bit16~bit23: ahb div*/
+static __u32 ahb1_div_tbl[10] = {
+    (1<<16) |(0<<8)|(0<<0),
+    (2<<16) |(0<<8)|(1<<0),
+    (3<<16) |(2<<8)|(0<<0),
+    (4<<16) |(3<<8)|(0<<0),
+    (6<<16) |(2<<8)|(1<<0),
+    (8<<16) |(3<<8)|(1<<0),
+    (12<<16)|(2<<8)|(2<<0),
+    (16<16) |(3<<8)|(2<<0),
+    (24<<16)|(2<<8)|(3<<0),
+    (32<<16)|(3<<8)|(3<<0),
+};
+
+/*
+*********************************************************************************************************
+*                           sys_clk_set_rate
+*
+*Description: set clock rate for system clock;
+*
+*Arguments  : id    system clock id;
+*             rate  clock rate for system clock;
+*
+*Return     : result,
+*               0,  set system clock rate successed;
+*              !0,  set system clock rate failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __s32 sys_clk_set_rate(__aw_ccu_clk_id_e id, __u64 rate)
+{
+    CCU_INF("try to switch %s rate to %llu\n", aw_ccu_clk_tbl[id].name, rate);
+
+    switch(id)
+    {
+        case AW_SYS_CLK_LOSC:
+            return (rate == 32768)? 0 : -1;
+        case AW_SYS_CLK_HOSC:
+            return (rate == 24000000)? 0 : -1;
+        case AW_SYS_CLK_PLL1:
+        {
+            __ccmu_pll1_reg0000_t       tmp_pll;
+
+            tmp_pll = aw_ccu_reg->Pll1Ctl;
+            if(ccm_get_pll1_para(&tmp_pll, rate))
+            {
+                CCU_ERR("(%s:%d)try to get pll1 rate(%llu) config failed!\n", __FILE__, __LINE__, rate);
+                return -1;
+            }
+            aw_ccu_reg->Pll1Ctl = tmp_pll;
+
+            #ifdef CONFIG_AW_ASIC_EVB_PLATFORM
+            if(aw_ccu_reg->Pll1Ctl.PLLEn) {
+                while(!aw_ccu_reg->Pll1Ctl.Lock);
+            }
+            #endif
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL2:
+        {
+            if(rate == 22579200)
+            {
+                aw_ccu_reg->Pll2Ctl.FactorN = 78;
+                aw_ccu_reg->Pll2Ctl.FactorM = 20;
+                aw_ccu_reg->Pll2Ctl.FactorP = 3;
+            }
+            else if(rate == 24576000)
+            {
+                aw_ccu_reg->Pll2Ctl.FactorN = 85;
+                aw_ccu_reg->Pll2Ctl.FactorM = 20;
+                aw_ccu_reg->Pll2Ctl.FactorP = 3;
+            }
+            else
+            {
+                return -1;
+            }
+
+            #ifdef CONFIG_AW_ASIC_EVB_PLATFORM
+            if(aw_ccu_reg->Pll2Ctl.PLLEn) {
+                while(!aw_ccu_reg->Pll2Ctl.Lock);
+            }
+            #endif
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL3:
+        case AW_SYS_CLK_PLL4:
+        case AW_SYS_CLK_PLL7:
+        case AW_SYS_CLK_PLL8:
+        case AW_SYS_CLK_PLL9:
+        case AW_SYS_CLK_PLL10:
+        {
+            volatile __ccmu_media_pll_t  *tmp_reg;
+            __ccmu_media_pll_t  tmp_pll;
+
+            if(id == AW_SYS_CLK_PLL3)
+                tmp_reg = &aw_ccu_reg->Pll3Ctl;
+            else if(id == AW_SYS_CLK_PLL4)
+                tmp_reg = &aw_ccu_reg->Pll4Ctl;
+            else if(id == AW_SYS_CLK_PLL7)
+                tmp_reg = &aw_ccu_reg->Pll7Ctl;
+            else if(id == AW_SYS_CLK_PLL8)
+                tmp_reg = &aw_ccu_reg->Pll8Ctl;
+            else if(id == AW_SYS_CLK_PLL9)
+                tmp_reg = &aw_ccu_reg->Pll9Ctl;
+            else
+                tmp_reg = &aw_ccu_reg->Pll10Ctl;
+
+            if(rate == 1000000000)
+            {
+                /* special frquency, control by de */
+                tmp_reg->CtlMode = 1;
+                return 0;
+            }
+
+            tmp_reg->CtlMode = 0;
+            if((rate == 270000000) || (rate == 297000000))
+            {
+                tmp_reg->ModeSel = 0;
+                tmp_reg->FracMod = (rate == 270000000)?0:1;
+                ccm_get_pllx_para(&tmp_pll, rate);
+                tmp_reg->FactorM = tmp_pll.FactorM;
+                tmp_reg->FactorN = tmp_pll.FactorN;
+                return 0;
+            }
+            else
+            {
+                __ccmu_media_pll_t  tmp_cfg;
+
+                if(ccm_get_pllx_para(&tmp_cfg, rate)) {
+                    CCU_ERR("(%s:%d)try to get pll (%d, %llu) configuration failed!\n", __FILE__, __LINE__, id, rate);
+                    return -1;
+                }
+
+                /* write register */
+                tmp_reg->ModeSel = 1;
+                if(tmp_reg->FactorM < tmp_cfg.FactorM) {
+                    tmp_reg->FactorM = tmp_cfg.FactorM;
+                    tmp_reg->FactorN = tmp_cfg.FactorN;
+                } else {
+                    tmp_reg->FactorN = tmp_cfg.FactorN;
+                    tmp_reg->FactorM = tmp_cfg.FactorM;
+                }
+
+                #ifdef CONFIG_AW_ASIC_EVB_PLATFORM
+                if(tmp_reg->PLLEn) {
+                    while(!tmp_reg->Lock);
+                }
+                #endif
+
+                return 0;
+            }
+        }
+        case AW_SYS_CLK_PLL5:
+        {
+            __ccmu_pll5_reg0020_t       tmp_pll;
+
+            tmp_pll = aw_ccu_reg->Pll5Ctl;
+            if(ccm_get_pll1_para((__ccmu_pll1_reg0000_t *)&tmp_pll, rate))
+            {
+                CCU_ERR("(%s:%d)try to get pll5 rate(%llu) config failed!\n", __FILE__, __LINE__, rate);
+                return -1;
+            }
+            aw_ccu_reg->Pll5Ctl = tmp_pll;
+
+            #ifdef CONFIG_AW_ASIC_EVB_PLATFORM
+            if(aw_ccu_reg->Pll5Ctl.PLLEn) {
+                while(!aw_ccu_reg->Pll5Ctl.Lock);
+            }
+            #endif
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL6:
+        {
+            do_div(rate, 12000000);
+            if(rate > 32*4)
+            {
+                CCU_ERR("Rate(%lld) is invalid when set pll6 rate!\n", rate);
+                return -1;
+            }
+            else if(rate > 32*3)
+            {
+                aw_ccu_reg->Pll6Ctl.FactorK = 3;
+                do_div(rate, 4);
+                aw_ccu_reg->Pll6Ctl.FactorN = rate-1;
+
+            }
+            else if(rate > 32*2)
+            {
+                aw_ccu_reg->Pll6Ctl.FactorK = 2;
+                do_div(rate, 3);
+                aw_ccu_reg->Pll6Ctl.FactorN = rate-1;
+            }
+            else if(rate > 32)
+            {
+                aw_ccu_reg->Pll6Ctl.FactorK = 1;
+                do_div(rate, 2);
+                aw_ccu_reg->Pll6Ctl.FactorN = rate-1;
+            }
+            else
+            {
+                aw_ccu_reg->Pll6Ctl.FactorK = 0;
+                aw_ccu_reg->Pll6Ctl.FactorN = rate-1;
+            }
+
+            #ifdef CONFIG_AW_ASIC_EVB_PLATFORM
+            if(aw_ccu_reg->Pll6Ctl.PLLEn) {
+                while(!aw_ccu_reg->Pll6Ctl.Lock);
+            }
+            #endif
+
+            return 0;
+        }
+        case AW_SYS_CLK_PLL2X8:
+        case AW_SYS_CLK_PLL3X2:
+        case AW_SYS_CLK_PLL6x2:
+        case AW_SYS_CLK_PLL7X2:
+            return 0;
+        case AW_SYS_CLK_MIPIPLL:
+            //#error 'how to set mipi pll?'
+            return -1;
+        case AW_SYS_CLK_AC327:
+            return rate == sys_clk_get_rate(sys_clk_get_parent(id))? 0 : -1;
+        case AW_SYS_CLK_AXI:
+        {
+            __u64   tmp_rate;
+            tmp_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            do_div(tmp_rate, rate);
+            aw_ccu_reg->SysClkDiv.AXIClkDiv = tmp_rate;
+            return 0;
+        }
+
+        case AW_SYS_CLK_AR100:
+        {
+            __u64   tmp_rate;
+
+            tmp_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            do_div(tmp_rate, rate);
+            if(tmp_rate > 32*8) {
+                return -1;
+            } else if(tmp_rate > 32*4) {
+                aw_cpus_reg->CpusCfg.Div = 3;
+                aw_cpus_reg->CpusCfg.PostDiv = do_div(tmp_rate, 8)-1;
+            } else if(tmp_rate > 32*2) {
+                aw_cpus_reg->CpusCfg.Div = 2;
+                aw_cpus_reg->CpusCfg.PostDiv = do_div(tmp_rate, 4)-1;
+            } else if(tmp_rate > 32*1) {
+                aw_cpus_reg->CpusCfg.Div = 1;
+                aw_cpus_reg->CpusCfg.PostDiv = do_div(tmp_rate, 2)-1;
+            } else {
+                aw_cpus_reg->CpusCfg.Div = 0;
+                aw_cpus_reg->CpusCfg.PostDiv = tmp_rate-1;
+            }
+            return 0;
+        }
+        case AW_SYS_CLK_AHB0:
+            return rate == sys_clk_get_rate(sys_clk_get_parent(id))? 0 : -1;
+        case AW_SYS_CLK_APB0:
+        {
+            __u64   tmp_rate;
+
+            tmp_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            do_div(tmp_rate, rate);
+
+            if(tmp_rate > 8) {
+                return -1;
+            } else if(tmp_rate > 4) {
+                aw_cpus_reg->Apb0Div.Div = 3;
+            } else if(tmp_rate > 2) {
+                aw_cpus_reg->Apb0Div.Div = 2;
+            } else {
+                aw_cpus_reg->Apb0Div.Div = 0;
+            }
+
+            return 0;
+        }
+
+        case AW_SYS_CLK_AHB1:
+        {
+            __u64   tmp_rate;
+            __aw_ccu_clk_id_e   parent;
+
+            parent = sys_clk_get_parent(id);
+            tmp_rate = sys_clk_get_rate(parent);
+            do_div(tmp_rate, rate);
+
+            if(parent == AW_SYS_CLK_PLL6) {
+                int     i;
+                for(i=0; i<10; i++) {
+                    if(tmp_rate <= ((ahb1_div_tbl[i]>>16) & 0xff)) {
+                        aw_ccu_reg->Ahb1Div.Ahb1PreDiv = (ahb1_div_tbl[i]>>8) & 0xff;
+                        aw_ccu_reg->Ahb1Div.Ahb1Div = (ahb1_div_tbl[i]>>0) & 0xff;
+                        return 0;
+                    }
+                }
+                return -1;
+            } else {
+                if(tmp_rate > 8) {
+                    return -1;
+                } else if (tmp_rate > 4) {
+                    aw_ccu_reg->Ahb1Div.Ahb1Div = 3;
+                } else if (tmp_rate > 2) {
+                    aw_ccu_reg->Ahb1Div.Ahb1Div = 2;
+                } else if (tmp_rate > 1) {
+                    aw_ccu_reg->Ahb1Div.Ahb1Div = 1;
+                } else {
+                    aw_ccu_reg->Ahb1Div.Ahb1Div = 0;
+                }
+            }
+        }
+
+        case AW_SYS_CLK_APB1:
+        {
+            __u64   tmp_rate;
+
+            tmp_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            do_div(tmp_rate, rate);
+
+            if(tmp_rate > 8) {
+                return -1;
+            } else if(tmp_rate > 4) {
+                aw_ccu_reg->Ahb1Div.Apb1Div = 3;
+            } else if(tmp_rate > 2) {
+                aw_ccu_reg->Ahb1Div.Apb1Div = 2;
+            } else {
+                aw_ccu_reg->Ahb1Div.Apb1Div = 0;
+            }
+
+            return 0;
+        }
+        case AW_SYS_CLK_APB2:
+        {
+            __u64   tmp_rate;
+
+            tmp_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            do_div(tmp_rate, rate);
+            if(tmp_rate < 32) {
+                aw_ccu_reg->Apb2Div.DivN = 0;
+                aw_ccu_reg->Apb2Div.DivM = tmp_rate-1;
+           } else if(tmp_rate < 32*2) {
+                aw_ccu_reg->Apb2Div.DivN = 1;
+                aw_ccu_reg->Apb2Div.DivM = (tmp_rate>>1)-1;
+            } else if(tmp_rate < 32*4) {
+                aw_ccu_reg->Apb2Div.DivN = 2;
+                aw_ccu_reg->Apb2Div.DivM = (tmp_rate>>2)-1;
+            } else if(tmp_rate < 32*8) {
+                aw_ccu_reg->Apb2Div.DivN = 3;
+                aw_ccu_reg->Apb2Div.DivM = (tmp_rate>>3)-1;
+            } else {
+                return -1;
+            }
+
+            return 0;
+        }
+
+        default:
+        {
+            CCU_ERR("clock id(%d) is invaid when set rate!\n", (__s32)id);
+            return -1;
+        }
+    }
+}
+
+/*
+*********************************************************************************************************
+*                           sys_clk_round_rate
+*
+*Description: round a rate of the given clock to a valid value;
+*
+*Arguments  : id    system clock id;
+*             rate  clock rate for system clock;
+*
+*Return     : result
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static __u64 sys_clk_round_rate(__aw_ccu_clk_id_e id, __u64 rate)
+{
+    switch(id)
+    {
+        case AW_SYS_CLK_LOSC:
+            return 32768;
+        case AW_SYS_CLK_HOSC:
+            return 24000000;
+        case AW_SYS_CLK_PLL1:
+        {
+            __ccmu_pll1_reg0000_t       tmp_pll;
+
+            if(ccm_get_pll1_para(&tmp_pll, rate))
+            {
+                return rate;
+            }
+
+            return (24000000 * (tmp_pll.FactorN+1) * (tmp_pll.FactorK+1)) / (tmp_pll.FactorM+1);
+        }
+
+        case AW_SYS_CLK_PLL2:
+        {
+            if(rate < 23000000)
+            {
+                return 22579200;
+            }
+            else
+            {
+                return 24576000;
+            }
+        }
+        case AW_SYS_CLK_PLL3:
+        case AW_SYS_CLK_PLL4:
+        case AW_SYS_CLK_PLL7:
+        case AW_SYS_CLK_PLL8:
+        case AW_SYS_CLK_PLL9:
+        case AW_SYS_CLK_PLL10:
+        {
+            __ccmu_media_pll_t  tmp_pll;
+
+            if((rate == 270000000) || (rate == 297000000))
+            {
+                return rate;
+            }
+
+            if(ccm_get_pllx_para(&tmp_pll, rate)) {
+                return rate;
+            }
+
+            return 24000000 * (tmp_pll.FactorN + 1) / (tmp_pll.FactorM + 1);
+        }
+
+        case AW_SYS_CLK_PLL5:
+        {
+            __ccmu_pll5_reg0020_t       tmp_pll;
+
+            if(ccm_get_pll1_para((__ccmu_pll1_reg0000_t *)&tmp_pll, rate))
+            {
+                return rate;
+            }
+            return (24000000 * (tmp_pll.FactorN+1) * (tmp_pll.FactorK+1));
+        }
+        case AW_SYS_CLK_PLL6:
+        {
+            if(rate > 32*4*12000000) {
+                return 32*4*12000000;
+            }
+            else if(rate > 32*3*12000000) {
+                do_div(rate, 12000000*3);
+                return 12000000*3*rate;
+            }
+            else if(rate > 32*2*12000000) {
+                do_div(rate, 12000000*2);
+                return 12000000*2*rate;
+            }
+            else if(rate > 32*1*12000000) {
+                do_div(rate, 12000000*1);
+                return 12000000*1*rate;
+            }
+            else {
+                do_div(rate, 12000000*1);
+                return rate*12000000;
+            }
+        }
+        case AW_SYS_CLK_PLL2X8:
+            return sys_clk_get_rate(AW_SYS_CLK_PLL2) * 8;
+        case AW_SYS_CLK_PLL3X2:
+            return sys_clk_get_rate(AW_SYS_CLK_PLL3) * 2;
+        case AW_SYS_CLK_PLL6x2:
+            return sys_clk_get_rate(AW_SYS_CLK_PLL6) * 2;
+        case AW_SYS_CLK_PLL7X2:
+            return sys_clk_get_rate(AW_SYS_CLK_PLL7) * 2;
+        case AW_SYS_CLK_MIPIPLL:
+            return rate;
+        case AW_SYS_CLK_AC327:
+            return sys_clk_get_rate(AW_SYS_CLK_PLL1);
+        case AW_SYS_CLK_AR100:
+        {
+            __u64   src_rate, tmp_rate;
+
+            src_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            tmp_rate = src_rate;
+            tmp_rate += rate-1;
+            do_div(tmp_rate, rate);
+            if(tmp_rate > 32*8) {
+                do_div(src_rate, (32*8));
+            } else if(tmp_rate > 32*4) {
+                do_div(tmp_rate, 8);
+                tmp_rate *= 8;
+                do_div(src_rate, tmp_rate);
+            } else if(tmp_rate > 32*2) {
+                do_div(tmp_rate, 4);
+                tmp_rate *= 4;
+                do_div(src_rate, tmp_rate);
+            } else if(tmp_rate > 32*1) {
+                do_div(tmp_rate, 2);
+                tmp_rate *= 2;
+                do_div(src_rate, tmp_rate);
+            } else {
+                do_div(src_rate, tmp_rate);
+            }
+
+            return src_rate;
+        }
+        case AW_SYS_CLK_AXI:
+        {
+            __u64   src_rate, tmp_rate;
+
+            src_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            tmp_rate = src_rate;
+            tmp_rate += rate -1;
+            do_div(tmp_rate, rate);
+            if(tmp_rate > 4) {
+                tmp_rate = 4;
+            }
+
+            do_div(src_rate, tmp_rate);
+            return src_rate;
+        }
+        case AW_SYS_CLK_AHB0:
+            return sys_clk_get_rate(sys_clk_get_parent(id));
+        case AW_SYS_CLK_AHB1:
+        {
+            __u64   src_rate, tmp_rate;
+            __aw_ccu_clk_id_e   parent;
+
+            parent = sys_clk_get_parent(id);
+            src_rate = sys_clk_get_rate(parent);
+            tmp_rate = src_rate + rate - 1;
+            do_div(tmp_rate, rate);
+
+            if(parent == AW_SYS_CLK_PLL6) {
+                int     i;
+                for(i=0; i<10; i++) {
+                    if(tmp_rate <= ((ahb1_div_tbl[i]>>16) & 0xff)) {
+                        tmp_rate = (1 << ((ahb1_div_tbl[i]>>0)&0xff)) * (((ahb1_div_tbl[i]>>8)&0xff) + 1);
+                        do_div(src_rate, tmp_rate);
+                        return src_rate;
+                    }
+                }
+                do_div(src_rate, 32);
+                return src_rate;
+            } else {
+                if(tmp_rate > 4) {
+                    tmp_rate = 8;
+                } else if(tmp_rate > 2) {
+                    tmp_rate = 4;
+                } else if (tmp_rate > 1) {
+                    tmp_rate = 2;
+                } else {
+                    tmp_rate = 1;
+                }
+                do_div(src_rate, tmp_rate);
+                return src_rate;
+            }
+        }
+        case AW_SYS_CLK_APB0:
+        case AW_SYS_CLK_APB1:
+        {
+            __u64   src_rate, tmp_rate;
+
+            src_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            tmp_rate = src_rate + rate -1;
+            do_div(tmp_rate, rate);
+
+            if(tmp_rate > 4) {
+                tmp_rate = 8;
+            } else if(tmp_rate > 2) {
+                tmp_rate = 4;
+            } else if(tmp_rate > 1) {
+                tmp_rate = 2;
+            } else {
+                tmp_rate = 1;
+            }
+            do_div(src_rate, tmp_rate);
+            return src_rate;
+        }
+
+        case AW_SYS_CLK_APB2:
+        {
+            __u64   src_rate, tmp_rate;
+
+            src_rate = sys_clk_get_rate(sys_clk_get_parent(id));
+            tmp_rate = src_rate + rate - 1;
+            do_div(tmp_rate, rate);
+
+            if(tmp_rate > 32*8) {
+                tmp_rate = 32 * 8;
+            }else if(tmp_rate > 32*4) {
+                do_div(tmp_rate, 8);
+                tmp_rate *= 8;
+            }else if(tmp_rate > 32*2) {
+                do_div(tmp_rate, 4);
+                tmp_rate *= 4;
+            }else if(tmp_rate > 32) {
+                do_div(tmp_rate, 2);
+                tmp_rate *= 2;
+            }
+            do_div(src_rate, tmp_rate);
+            return src_rate;
+        }
+
+        default:
+            return rate;
+    }
+}
+
+
+__clk_ops_t sys_clk_ops = {
+    .set_status = sys_clk_set_status,
+    .get_status = sys_clk_get_status,
+    .set_parent = sys_clk_set_parent,
+    .get_parent = sys_clk_get_parent,
+    .get_rate = sys_clk_get_rate,
+    .set_rate = sys_clk_set_rate,
+    .round_rate = sys_clk_round_rate,
+    .set_reset  = 0,
+    .get_reset  = 0,
+};
diff --git a/arch/arm/mach-sun6i/core.c b/arch/arm/mach-sun6i/core.c
new file mode 100644
index 0000000..a0346ee
--- /dev/null
+++ b/arch/arm/mach-sun6i/core.c
@@ -0,0 +1,202 @@
+/*
+ *  arch/arm/mach-sun6i/core.c
+ *
+ *  Copyright (C) 2012 - 2016 Allwinner Limited
+ *  Benn Huang (benn@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/device.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/pl061.h>
+#include <linux/amba/mmci.h>
+#include <linux/memblock.h>
+#include <linux/amba/pl022.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+#include <asm/pmu.h>
+#include <asm/smp_twd.h>
+#include <asm/pgtable.h>
+#include <asm/hardware/gic.h>
+#include <linux/clockchips.h>
+#include <asm/hardware/cache-l2x0.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/platform.h>
+#include <mach/io.h>
+#include <mach/timer.h>
+
+#include "core.h"
+
+static struct map_desc sun6i_io_desc[] __initdata = {
+	{IO_ADDRESS(AW_SRAM_A1_BASE), __phys_to_pfn(AW_SRAM_A1_BASE),  AW_SRAM_A1_SIZE, MT_MEMORY_ITCM},
+	{IO_ADDRESS(AW_SRAM_A2_BASE), __phys_to_pfn(AW_SRAM_A2_BASE),  AW_SRAM_A2_SIZE, MT_DEVICE_NONSHARED},
+	{IO_ADDRESS(AW_IO_PHYS_BASE), __phys_to_pfn(AW_IO_PHYS_BASE),  AW_IO_SIZE, MT_DEVICE_NONSHARED},
+	{IO_ADDRESS(AW_BROM_BASE),    __phys_to_pfn(AW_BROM_BASE),     AW_BROM_SIZE, MT_DEVICE_NONSHARED},
+};
+
+#if defined(CONFIG_ION) || defined(CONFIG_ION_MODULE)
+static struct tag_mem32 ion_mem __initdata = {
+	.start	= ION_CARVEOUT_MEM_BASE,
+	.size	= ION_CARVEOUT_MEM_SIZE,
+};
+#endif
+
+static void __init sun6i_map_io(void)
+{
+	iotable_init(sun6i_io_desc, ARRAY_SIZE(sun6i_io_desc));
+}
+
+
+static void __init gic_init_irq(void)
+{
+	gic_init(0, 29, (void *)IO_ADDRESS(AW_GIC_DIST_BASE), (void *)IO_ADDRESS(AW_GIC_CPU_BASE));
+}
+
+
+void __init sun6i_clkevt_init(void);
+int __init sun6i_clksrc_init(void);
+int __init arch_timer_sched_clock_init(void);
+int arch_timer_common_register(void);
+
+static void __init sun6i_timer_init(void)
+{
+	sun6i_clkevt_init();
+	sun6i_clksrc_init();
+	arch_timer_common_register();
+}
+
+
+static struct sys_timer sun6i_timer = {
+	.init		= sun6i_timer_init,
+};
+
+static void __init sun6i_fixup(struct tag *tags, char **from,
+			       struct meminfo *meminfo)
+{
+	struct tag *t;
+
+	for (t = tags; t->hdr.size; t = tag_next(t)) {
+		if (t->hdr.tag == ATAG_MEM && t->u.mem.size) {
+			pr_debug("[%s]: From boot, get meminfo:\n"
+					"\tStart:\t0x%08x\n"
+					"\tSize:\t%dMB\n",
+					__func__,
+					t->u.mem.start,
+					t->u.mem.size >> 20);
+			return;
+		}
+	}
+	pr_debug("[%s] enter\n", __func__);
+
+	meminfo->bank[0].start = PLAT_PHYS_OFFSET;
+	meminfo->bank[0].size = PLAT_MEM_SIZE;
+	meminfo->nr_banks = 1;
+
+	pr_debug("nr_banks: %d, bank.start: 0x%08x, bank.size: 0x%08lx\n",
+			meminfo->nr_banks, meminfo->bank[0].start,
+			meminfo->bank[0].size);
+}
+
+void __init sun6i_reserve(void)
+{
+	/* reserve for sys_config */
+	memblock_reserve(SYS_CONFIG_MEMBASE, SYS_CONFIG_MEMSIZE);
+
+	/*
+	 * reserve for DE and VE
+	 * Here, we must use memblock_remove, because it be allocated using genalloc.
+	 */
+	memblock_remove(HW_RESERVED_MEM_BASE, HW_RESERVED_MEM_SIZE);
+
+	/* reserve for standby */
+	memblock_reserve(SUPER_STANDBY_MEM_BASE, SUPER_STANDBY_MEM_SIZE);
+
+#if defined(CONFIG_ION) || defined(CONFIG_ION_MODULE)
+	/* reserve for ION */
+	memblock_reserve(ion_mem.start, ion_mem.size);
+#endif
+}
+
+#if defined(CONFIG_ION) || defined(CONFIG_ION_MODULE)
+/*
+ * Pick out the ion memory size.  We look for ion_reserve=size@start,
+ * where start and size are "size[KkMm]"
+ */
+static int __init early_ion_reserve(char *p)
+{
+	char *endp;
+
+	ion_mem.start= ION_CARVEOUT_MEM_BASE;
+	ion_mem.size  = memparse(p, &endp);
+	if (*endp == '@')
+		ion_mem.start = memparse(endp + 1, NULL);
+
+	pr_debug("[%s]: ION memory reserve: [0x%016x - 0x%016x]\n",
+			__func__, ion_mem.start, ion_mem.size);
+
+	return 0;
+}
+early_param("ion_reserve", early_ion_reserve);
+#endif
+
+static void sun6i_restart(char mode, const char *cmd)
+{
+	pr_debug("[%s] enter\n", __func__);
+	writel(0, (AW_VIR_R_WDOG_BASE + AW_WDOG0_IRQ_EN_REG));
+	writel(1, (AW_VIR_R_WDOG_BASE + AW_WDOG0_CFG_REG));
+	writel(1, (AW_VIR_R_WDOG_BASE + AW_WDOG0_MODE_REG)); /* interval is 0.5 sec */
+	while(1); /* never return */
+}
+
+extern void sw_pdev_init(void);
+static void __init sun6i_init(void)
+{
+	pr_debug("[%s] enter\n", __func__);
+	sw_pdev_init();
+	/* Register platform devices here!! */
+}
+
+void __init sun6i_init_early(void)
+{
+	pr_debug("[%s] enter\n", __func__);
+}
+
+MACHINE_START(SUN6I, "sun6i")
+	.atag_offset	= 0x100,
+	.reserve	= sun6i_reserve,
+	.fixup		= sun6i_fixup,
+	.map_io		= sun6i_map_io,
+	.init_early	= sun6i_init_early,
+	.init_irq	= gic_init_irq,
+	.timer		= &sun6i_timer,
+	.handle_irq	= gic_handle_irq,
+	.init_machine	= sun6i_init,
+#ifdef CONFIG_ZONE_DMA
+	.dma_zone_size	= SZ_256M,
+#endif
+	.restart	= sun6i_restart,
+MACHINE_END
diff --git a/arch/arm/mach-sun6i/core.h b/arch/arm/mach-sun6i/core.h
new file mode 100644
index 0000000..55d8930
--- /dev/null
+++ b/arch/arm/mach-sun6i/core.h
@@ -0,0 +1,32 @@
+/*
+ *  linux/arch/arm/mach-sun6i/core.h
+ *
+ *  Copyright (C) 2012 - 2016 Allwinner Limited
+ *  Benn Huang (benn@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_SUN6I_H
+#define __ASM_ARCH_SUN6I_H
+
+#include <linux/amba/bus.h>
+#include <linux/io.h>
+
+#include <asm/setup.h>
+
+extern struct platform_device sun6i_uart_debug_port;
+
+#endif
diff --git a/arch/arm/mach-sun6i/cpu-freq/Makefile b/arch/arm/mach-sun6i/cpu-freq/Makefile
new file mode 100644
index 0000000..ef9df35
--- /dev/null
+++ b/arch/arm/mach-sun6i/cpu-freq/Makefile
@@ -0,0 +1,2 @@
+
+obj-y  += cpu-freq.o cpu-freq-table.o
diff --git a/arch/arm/mach-sun6i/cpu-freq/cpu-freq-table.c b/arch/arm/mach-sun6i/cpu-freq/cpu-freq-table.c
new file mode 100644
index 0000000..c9d9c5a
--- /dev/null
+++ b/arch/arm/mach-sun6i/cpu-freq/cpu-freq-table.c
@@ -0,0 +1,75 @@
+/*
+ *  arch/arm/mach-sun6i/cpu-freq/cpu-freq-table.c
+ *
+ * Copyright (c) 2012 Softwinner.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include "cpu-freq.h"
+
+struct cpufreq_frequency_table sunxi_freq_tbl[] = {
+	{ .frequency = 120000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 144000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 168000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 192000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 216000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 240000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 264000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 288000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 312000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 336000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 360000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 384000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 408000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 432000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 456000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 480000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 504000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 528000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 552000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 576000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 600000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 624000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 648000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 672000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 696000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 720000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 744000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 768000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 792000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 828000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 864000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 900000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 936000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 972000 ,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 1008000,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 1044000,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 1080000,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 1116000,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 1152000,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 1200000,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 1248000,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 1296000,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 1344000,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 1392000,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+	{ .frequency = 1440000,	.index = SUNXI_CLK_DIV(0, 0, 0, 0), },
+
+    /* table end */
+    { .frequency = CPUFREQ_TABLE_END,  .index = 0,              },
+};
diff --git a/arch/arm/mach-sun6i/cpu-freq/cpu-freq.c b/arch/arm/mach-sun6i/cpu-freq/cpu-freq.c
new file mode 100644
index 0000000..51387c2
--- /dev/null
+++ b/arch/arm/mach-sun6i/cpu-freq/cpu-freq.c
@@ -0,0 +1,483 @@
+/*
+ *  arch/arm/mach-sun6i/cpu-freq/cpu-freq.c
+ *
+ * Copyright (c) 2012 softwinner.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/cpufreq.h>
+#include <linux/cpu.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <mach/sys_config.h>
+#include <linux/cpu.h>
+#include <asm/cpu.h>
+
+#include "cpu-freq.h"
+#include <linux/pm.h>
+#include <mach/ar100.h>
+#include <mach/clock.h>
+
+static struct sunxi_cpu_freq_t  cpu_cur;    /* current cpu frequency configuration  */
+static unsigned int last_target = ~0;       /* backup last target frequency         */
+
+static struct clk *clk_pll; /* pll clock handler */
+static struct clk *clk_cpu; /* cpu clock handler */
+static struct clk *clk_axi; /* axi clock handler */
+static DEFINE_MUTEX(sunxi_cpu_lock);
+
+static unsigned int cpu_freq_max = SUNXI_CPUFREQ_MAX / 1000;
+static unsigned int cpu_freq_min = SUNXI_CPUFREQ_MIN / 1000;
+
+#ifdef CONFIG_SMP
+static struct cpumask sunxi_cpumask;
+static int cpus_initialized;
+#endif
+
+#ifdef CONFIG_CPU_FREQ_SETFREQ_DEBUG
+int setgetfreq_debug = 0;
+unsigned long long setfreq_time_usecs = 0;
+unsigned long long getfreq_time_usecs = 0;
+#endif
+
+/*
+ *check if the cpu frequency policy is valid;
+ */
+static int sunxi_cpufreq_verify(struct cpufreq_policy *policy)
+{
+    return 0;
+}
+
+
+/*
+ *show cpu frequency information;
+ */
+static void sunxi_cpufreq_show(const char *pfx, struct sunxi_cpu_freq_t *cfg)
+{
+    CPUFREQ_DBG("%s: pll=%u, cpudiv=%u, axidiv=%u\n", pfx, cfg->pll, cfg->div.cpu_div, cfg->div.axi_div);
+}
+
+
+/*
+ * adjust the frequency that cpu is currently running;
+ * policy:  cpu frequency policy;
+ * freq:    target frequency to be set, based on khz;
+ * relation:    method for selecting the target requency;
+ * return:  result, return 0 if set target frequency successed, else, return -EINVAL;
+ * notes:   this function is called by the cpufreq core;
+ */
+static int sunxi_cpufreq_target(struct cpufreq_policy *policy, __u32 freq, __u32 relation)
+{
+    int                     i, ret = 0;
+    unsigned int            index;
+    struct sunxi_cpu_freq_t freq_cfg;
+    struct cpufreq_freqs    freqs;
+#ifdef CONFIG_CPU_FREQ_SETFREQ_DEBUG
+	ktime_t calltime = ktime_set(0, 0), delta, rettime;
+
+	if (unlikely(setgetfreq_debug)) {
+		calltime = ktime_get();
+	}
+#endif
+
+    mutex_lock(&sunxi_cpu_lock);
+
+#ifdef CONFIG_SMP
+    /* Wait untill all CPU's are initialized */
+    if (unlikely(cpus_initialized < num_online_cpus())) {
+        ret = -EINVAL;
+        goto out;
+    }
+#endif
+
+    /* avoid repeated calls which cause a needless amout of duplicated
+     * logging output (and CPU time as the calculation process is
+     * done) */
+    if (freq == last_target)
+        goto out;
+
+    /* try to look for a valid frequency value from cpu frequency table */
+    if (cpufreq_frequency_table_target(policy, sunxi_freq_tbl, freq, relation, &index)) {
+        CPUFREQ_ERR("try to look for a valid frequency for %u failed!\n", freq);
+        ret = -EINVAL;
+        goto out;
+    }
+
+    /* frequency is same as the value last set, need not adjust */
+    if (sunxi_freq_tbl[index].frequency == last_target)
+        goto out;
+
+    freq = sunxi_freq_tbl[index].frequency;
+
+    /* update the target frequency */
+    freq_cfg.pll = sunxi_freq_tbl[index].frequency * 1000;
+    freq_cfg.div = *(struct sunxi_clk_div_t *)&sunxi_freq_tbl[index].index;
+    printk(KERN_ERR "target frequency find is %u, entry %u\n", freq_cfg.pll, index);
+
+    /* notify that cpu clock will be adjust if needed */
+    if (policy) {
+        freqs.cpu = policy->cpu;
+        freqs.old = last_target;
+        freqs.new = freq;
+
+#ifdef CONFIG_SMP
+        /* notifiers */
+        for_each_cpu(i, policy->cpus) {
+            freqs.cpu = i;
+            cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+        }
+#else
+        cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+#endif
+    }
+
+    /* try to set cpu frequency */
+    if (ar100_dvfs_set_cpufreq(freq, AR100_DVFS_SYN, NULL, NULL)) {
+        CPUFREQ_ERR("set cpu frequency to %uMHz failed!\n", freq / 1000);
+        /* set cpu frequency failed */
+        if (policy) {
+            freqs.cpu = policy->cpu;
+            freqs.old = freqs.new;
+            freqs.new = last_target;
+
+#ifdef CONFIG_SMP
+            /* notifiers */
+            for_each_cpu(i, policy->cpus) {
+                freqs.cpu = i;
+                cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+            }
+#else
+            cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+#endif
+        }
+
+        ret = -EINVAL;
+        goto out;
+    }
+
+    /* notify that cpu clock will be adjust if needed */
+    if (policy) {
+#ifdef CONFIG_SMP
+        /*
+         * Note that loops_per_jiffy is not updated on SMP systems in
+         * cpufreq driver. So, update the per-CPU loops_per_jiffy value
+         * on frequency transition. We need to update all dependent cpus
+         */
+        for_each_cpu(i, policy->cpus) {
+            per_cpu(cpu_data, i).loops_per_jiffy =
+                 cpufreq_scale(per_cpu(cpu_data, i).loops_per_jiffy, freqs.old, freqs.new);
+            freqs.cpu = i;
+            cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+        }
+#else
+        cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+#endif
+    }
+
+    last_target = freq;
+    printk(KERN_ERR "set cpu frequency to %uMHz ok\n", freq / 1000);
+
+out:
+#ifdef CONFIG_CPU_FREQ_SETFREQ_DEBUG
+	if (unlikely(setgetfreq_debug)) {
+		rettime = ktime_get();
+		delta = ktime_sub(rettime, calltime);
+		setfreq_time_usecs = ktime_to_ns(delta) >> 10;
+		printk("[setfreq]: %Ld usecs\n", setfreq_time_usecs);
+	}
+#endif
+    mutex_unlock(&sunxi_cpu_lock);
+
+    return ret;
+}
+
+
+/*
+ * get the frequency that cpu currently is running;
+ * cpu:    cpu number, all cpus use the same clock;
+ * return: cpu frequency, based on khz;
+ */
+static unsigned int sunxi_cpufreq_get(unsigned int cpu)
+{
+	unsigned int current_freq = 0;
+#ifdef CONFIG_CPU_FREQ_SETFREQ_DEBUG
+	ktime_t calltime = ktime_set(0, 0), delta, rettime;
+
+	if (unlikely(setgetfreq_debug)) {
+		calltime = ktime_get();
+	}
+#endif
+
+	current_freq = clk_get_rate(clk_cpu) / 1000;
+
+#ifdef CONFIG_CPU_FREQ_SETFREQ_DEBUG
+	if (unlikely(setgetfreq_debug)) {
+		rettime = ktime_get();
+		delta = ktime_sub(rettime, calltime);
+		getfreq_time_usecs = ktime_to_ns(delta) >> 10;
+		printk("[getfreq]: %Ld usecs\n", getfreq_time_usecs);
+	}
+#endif
+
+	return current_freq;
+}
+
+
+/*
+ * get the frequency that cpu average is running;
+ * cpu:    cpu number, all cpus use the same clock;
+ * return: cpu frequency, based on khz;
+ */
+static unsigned int sunxi_cpufreq_getavg(struct cpufreq_policy *policy, unsigned int cpu)
+{
+    return clk_get_rate(clk_cpu) / 1000;
+}
+
+
+/*
+ * get a valid frequency from cpu frequency table;
+ * target_freq:	target frequency to be judge, based on KHz;
+ * return: cpu frequency, based on khz;
+ */
+static unsigned int __get_valid_freq(unsigned int target_freq)
+{
+    struct cpufreq_frequency_table *tmp = &sunxi_freq_tbl[0];
+
+    while(tmp->frequency != CPUFREQ_TABLE_END){
+        if((tmp+1)->frequency <= target_freq)
+            tmp++;
+        else
+            break;
+    }
+
+    return tmp->frequency;
+}
+
+
+/*
+ * init cpu max/min frequency from sysconfig;
+ * return: 0 - init cpu max/min successed, !0 - init cpu max/min failed;
+ */
+static int __init_freq_syscfg(void)
+{
+    int ret = 0;
+    script_item_u max, min;
+    script_item_value_type_e type;
+
+    type = script_get_item("dvfs_table", "max_freq", &max);
+    if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
+        CPUFREQ_ERR("get cpu max frequency from sysconfig failed\n");
+        ret = -1;
+        goto fail;
+    }
+    cpu_freq_max = max.val;
+
+    type = script_get_item("dvfs_table", "min_freq", &min);
+    if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
+        CPUFREQ_ERR("get cpu min frequency from sysconfig failed\n");
+        ret = -1;
+        goto fail;
+    }
+    cpu_freq_min = min.val;
+
+    if(cpu_freq_max > SUNXI_CPUFREQ_MAX || cpu_freq_max < SUNXI_CPUFREQ_MIN
+        || cpu_freq_min < SUNXI_CPUFREQ_MIN || cpu_freq_min > SUNXI_CPUFREQ_MAX){
+        CPUFREQ_ERR("cpu max or min frequency from sysconfig is more than range\n");
+        ret = -1;
+        goto fail;
+    }
+
+    if(cpu_freq_min > cpu_freq_max){
+        CPUFREQ_ERR("cpu min frequency can not be more than cpu max frequency\n");
+        ret = -1;
+        goto fail;
+    }
+
+    /* get valid max/min frequency from cpu frequency table */
+    cpu_freq_max = __get_valid_freq(cpu_freq_max / 1000);
+    cpu_freq_min = __get_valid_freq(cpu_freq_min / 1000);
+
+    return 0;
+
+fail:
+    /* use default cpu max/min frequency */
+    cpu_freq_max = SUNXI_CPUFREQ_MAX / 1000;
+    cpu_freq_min = SUNXI_CPUFREQ_MIN / 1000;
+
+    return ret;
+}
+
+
+/*
+ * cpu frequency initialise a policy;
+ * policy:  cpu frequency policy;
+ * result:  return 0 if init ok, else, return -EINVAL;
+ */
+static int sunxi_cpufreq_init(struct cpufreq_policy *policy)
+{
+    policy->cur = sunxi_cpufreq_get(0);
+    policy->min = policy->cpuinfo.min_freq = cpu_freq_min;
+    policy->max = policy->cpuinfo.max_freq = cpu_freq_max;
+    policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+
+    /* feed the latency information from the cpu driver */
+    policy->cpuinfo.transition_latency = SUNXI_FREQTRANS_LATENCY;
+    cpufreq_frequency_table_get_attr(sunxi_freq_tbl, policy->cpu);
+
+#ifdef CONFIG_SMP
+    /*
+     * both processors share the same voltage and the same clock,
+     * but have dedicated power domains. So both cores needs to be
+     * scaled together and hence needs software co-ordination.
+     * Use cpufreq affected_cpus interface to handle this scenario.
+     */
+    policy->shared_type = CPUFREQ_SHARED_TYPE_ANY;
+    cpumask_or(&sunxi_cpumask, cpumask_of(policy->cpu), &sunxi_cpumask);
+    cpumask_copy(policy->cpus, &sunxi_cpumask);
+    cpus_initialized++;
+#endif
+
+    return 0;
+}
+
+
+/*
+ * get current cpu frequency configuration;
+ * cfg:     cpu frequency cofniguration;
+ * return:  result;
+ */
+static int sunxi_cpufreq_getcur(struct sunxi_cpu_freq_t *cfg)
+{
+    unsigned int    freq, freq0;
+
+    if(!cfg) {
+        return -EINVAL;
+    }
+
+    cfg->pll = clk_get_rate(clk_pll);
+    freq = clk_get_rate(clk_cpu);
+    cfg->div.cpu_div = cfg->pll / freq;
+    freq0 = clk_get_rate(clk_axi);
+    cfg->div.axi_div = freq / freq0;
+
+    return 0;
+}
+
+
+#ifdef CONFIG_PM
+
+/*
+ * cpu frequency configuration suspend;
+ */
+static int sunxi_cpufreq_suspend(struct cpufreq_policy *policy)
+{
+    CPUFREQ_DBG("%s\n", __func__);
+    return 0;
+}
+
+/*
+ * cpu frequency configuration resume;
+ */
+static int sunxi_cpufreq_resume(struct cpufreq_policy *policy)
+{
+    /* invalidate last_target setting */
+    last_target = ~0;
+    CPUFREQ_DBG("%s\n", __func__);
+    return 0;
+}
+
+
+#else   /* #ifdef CONFIG_PM */
+
+#define sunxi_cpufreq_suspend   NULL
+#define sunxi_cpufreq_resume    NULL
+
+#endif  /* #ifdef CONFIG_PM */
+
+
+static struct cpufreq_driver sunxi_cpufreq_driver = {
+    .name       = "sunxi",
+    .flags      = CPUFREQ_STICKY,
+    .init       = sunxi_cpufreq_init,
+    .verify     = sunxi_cpufreq_verify,
+    .target     = sunxi_cpufreq_target,
+    .get        = sunxi_cpufreq_get,
+    .getavg     = sunxi_cpufreq_getavg,
+    .suspend    = sunxi_cpufreq_suspend,
+    .resume     = sunxi_cpufreq_resume,
+};
+
+
+/*
+ * cpu frequency driver init
+ */
+static int __init sunxi_cpufreq_initcall(void)
+{
+    int ret = 0;
+
+    cpumask_clear(&sunxi_cpumask);
+
+    clk_pll = clk_get(NULL, CLK_SYS_AC327);
+    clk_cpu = clk_get(NULL, CLK_SYS_PLL1);
+    clk_axi = clk_get(NULL, CLK_SYS_AXI);
+
+    if (IS_ERR(clk_pll) || IS_ERR(clk_cpu) || IS_ERR(clk_axi)) {
+        CPUFREQ_ERR("%s: could not get clock(s)\n", __func__);
+        return -ENOENT;
+    }
+
+    CPUFREQ_INF("%s: clocks pll=%lu,cpu=%lu,axi=%lu\n", __func__,
+           clk_get_rate(clk_pll), clk_get_rate(clk_cpu), clk_get_rate(clk_axi));
+
+    /* initialise current frequency configuration */
+    sunxi_cpufreq_getcur(&cpu_cur);
+    sunxi_cpufreq_show("cur", &cpu_cur);
+
+    /* init cpu frequency from sysconfig */
+    if(__init_freq_syscfg()) {
+        CPUFREQ_ERR("%s, use default cpu max/min frequency, max freq: %uMHz, min freq: %uMHz\n",
+                    __func__, cpu_freq_max/1000, cpu_freq_min/1000);
+    }else{
+        CPUFREQ_INF("%s, get cpu frequency from sysconfig, max freq: %uMHz, min freq: %uMHz\n",
+                    __func__, cpu_freq_max/1000, cpu_freq_min/1000);
+    }
+
+    /* register cpu frequency driver */
+    ret = cpufreq_register_driver(&sunxi_cpufreq_driver);
+
+    return ret;
+}
+
+
+/*
+ * cpu frequency driver exit
+ */
+static void __exit sunxi_cpufreq_exitcall(void)
+{
+    clk_put(clk_pll);
+    clk_put(clk_cpu);
+    clk_put(clk_axi);
+    cpufreq_unregister_driver(&sunxi_cpufreq_driver);
+}
+
+
+MODULE_DESCRIPTION("cpufreq driver for sunxi SOCs");
+MODULE_LICENSE("GPL");
+module_init(sunxi_cpufreq_initcall);
+module_exit(sunxi_cpufreq_exitcall);
diff --git a/arch/arm/mach-sun6i/cpu-freq/cpu-freq.h b/arch/arm/mach-sun6i/cpu-freq/cpu-freq.h
new file mode 100644
index 0000000..748ebdd
--- /dev/null
+++ b/arch/arm/mach-sun6i/cpu-freq/cpu-freq.h
@@ -0,0 +1,64 @@
+/*
+ *  arch/arm/mach-sun6i/cpu-freq/cpu-freq.h
+ *
+ * Copyright (c) 2012 Softwinner.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __sunxi_CPU_FREQ_H__
+#define __sunxi_CPU_FREQ_H__
+
+#include <linux/types.h>
+#include <linux/cpufreq.h>
+
+#undef CPUFREQ_DBG
+#undef CPUFREQ_ERR
+#if (0)
+    #define CPUFREQ_DBG(format,args...)   printk("[cpu_freq] DBG:"format,##args)
+    #define CPUFREQ_INF(format,args...)   printk("[cpu_freq] INF:"format,##args)
+#else
+    #define CPUFREQ_DBG(format,args...)   do{}while(0)
+    #define CPUFREQ_INF(format,args...)   do{}while(0)
+#endif
+
+#define CPUFREQ_ERR(format,args...)   printk(KERN_ERR "[cpu_freq] ERR:"format,##args)
+
+
+#define SUNXI_CPUFREQ_MAX       (1008000000)    /* config the maximum frequency of sunxi core */
+#define SUNXI_CPUFREQ_MIN       (96000000)      /* config the minimum frequency of sunxi core */
+#define SUNXI_FREQTRANS_LATENCY (2000000)       /* config the transition latency, based on ns */
+
+struct sunxi_clk_div_t {
+    __u32   cpu_div:4;      /* division of cpu clock, divide core_pll */
+    __u32   axi_div:4;      /* division of axi clock, divide cpu clock*/
+    __u32   ahb_div:4;      /* division of ahb clock, divide axi clock*/
+    __u32   apb_div:4;      /* division of apb clock, divide ahb clock*/
+    __u32   reserved:16;
+};
+
+
+struct sunxi_cpu_freq_t {
+    __u32                   pll;    /* core pll frequency value */
+    struct sunxi_clk_div_t  div;    /* division configuration   */
+};
+
+
+#define SUNXI_CLK_DIV(cpu_div, axi_div, ahb_div, apb_div)       \
+                ((cpu_div<<0)|(axi_div<<4)|(ahb_div<<8)|(apb_div<<12))
+
+extern struct cpufreq_frequency_table sunxi_freq_tbl[];
+
+#endif  /* #ifndef __sunxi_CPU_FREQ_H__ */
diff --git a/arch/arm/mach-sun6i/delay.c b/arch/arm/mach-sun6i/delay.c
new file mode 100644
index 0000000..b150116
--- /dev/null
+++ b/arch/arm/mach-sun6i/delay.c
@@ -0,0 +1,73 @@
+#include <asm/delay.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <mach/hardware.h>
+#include <mach/platform.h>
+#include <mach/timer.h>
+#include <linux/export.h>
+#include <linux/jiffies.h>
+#include <linux/notifier.h>
+#include <linux/suspend.h>
+
+/*
+ * Since we calibrate only once at boot, this
+ * function should be set once at boot and not changed
+ */
+#define TIME_NUM	1
+#define MAX_COUNTER 0xffffffff
+#define CYCLE_NSEC	42
+#define TIMER_INTERVAL(x) (0x14 + (x) * 0x10)
+#define TIMER_CURRENTVAL(x) (0x18 + (x) * 0x10)
+#define TIMER_CTL(x)	(0x10 + (x) * 0x10)
+
+static void aw_delay(unsigned long);
+static unsigned long read_cur_counter(void);
+
+void (*delay_fn)(unsigned long n) = __udelay;
+EXPORT_SYMBOL(delay_fn);
+
+/*
+ * Read the timer counter.
+ */
+static inline unsigned long read_cur_counter(void)
+{
+	return readl(IO_ADDRESS(AW_TIMER_BASE) + TIMER_CURRENTVAL(TIME_NUM));
+}
+
+static void aw_delay(unsigned long usec)
+{
+	unsigned long old, new, cur = 0;
+	unsigned long loops_nsec = 1000 * usec;
+
+	/*
+	 * Time currentval is down-counter.
+	 */
+	old = read_cur_counter();
+	for (;;) {
+		new = read_cur_counter();
+		if (new > old){
+			cur += (MAX_COUNTER - new + old);
+		} else {
+			cur += (old - new);
+		}
+		old = new;
+		if ((cur * CYCLE_NSEC) >= loops_nsec)
+			break;
+	}
+}
+
+void use_time_delay(void)
+{
+#if (TIME_NUM != 0)
+	unsigned long irq_reg;
+
+	irq_reg = readl(IO_ADDRESS(AW_TIMER_BASE) + 0x00);
+	writel(irq_reg & (~0x02), IO_ADDRESS(AW_TIMER_BASE) + 0x00);
+
+	writel(MAX_COUNTER, IO_ADDRESS(AW_TIMER_BASE) + TIMER_INTERVAL(TIME_NUM));
+	writel(0x07, IO_ADDRESS(AW_TIMER_BASE) + TIMER_CTL(TIME_NUM));
+#endif
+
+	delay_fn = aw_delay;
+	printk("[aw_delay]: It is use use_time_delay function!\n");
+}
diff --git a/arch/arm/mach-sun6i/devices.c b/arch/arm/mach-sun6i/devices.c
new file mode 100644
index 0000000..8fe1f68
--- /dev/null
+++ b/arch/arm/mach-sun6i/devices.c
@@ -0,0 +1,131 @@
+/*
+ *  arch/arm/mach-$chip/devices.c
+ *
+ *  Copyright (C) 2012 AllWinner Limited
+ *  Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/serial_8250.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/pda_power.h>
+#include <linux/io.h>
+#include <linux/i2c.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/setup.h>
+#include <mach/hardware.h>
+#include <mach/system.h>
+#include <mach/platform.h>
+#include <mach/irqs.h>
+#if(CONFIG_CPU_HAS_PMU)
+#include <asm/pmu.h>
+#endif
+
+
+/* uart */
+static struct plat_serial8250_port debug_uart_platform_data[] = {
+	{
+		.membase        = (void __iomem *)(IO_ADDRESS(AW_UART0_BASE)),
+		.mapbase        = (resource_size_t)AW_UART0_BASE,
+		.irq            = AW_IRQ_UART0,
+		.flags          = UPF_BOOT_AUTOCONF|UPF_IOREMAP,
+		.iotype         = UPIO_MEM32,
+		.regshift       = 2,
+		.uartclk        = 24000000,
+	}, {
+		.flags          = 0,
+	}
+ };
+
+static struct platform_device debug_uart = {
+	.name = "serial8250",
+	.id = PLAT8250_DEV_PLATFORM,
+	.dev = {
+		.platform_data = &debug_uart_platform_data[0],
+	}
+};
+
+/* dma */
+static u64 sw_dmac_dmamask = DMA_BIT_MASK(32);
+
+static struct resource sw_dmac_resources[] = {
+	[0] = {
+		.start 	= AW_DMA_BASE,
+		.end 	= AW_DMA_BASE + 0x1000, /* lead to boot_secondary->enable_aw_cpu halt? no */
+		.flags 	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start 	= AW_IRQ_DMA,
+		.end 	= AW_IRQ_DMA,
+		.flags 	= IORESOURCE_IRQ,
+	}
+};
+
+static struct platform_device sw_dmac_device = {
+	.name 		= "sw_dmac",	/* must be same as sw_dmac_driver's name */
+	.id 		= 0, 		/* there is only one device for sw_dmac dirver, so id is 0 */
+	.num_resources 	= ARRAY_SIZE(sw_dmac_resources),
+	.resource 	= sw_dmac_resources,
+	.dev 		= {
+				.dma_mask = &sw_dmac_dmamask,
+				.coherent_dma_mask = DMA_BIT_MASK(32),	/* validate dma_pool_alloc */
+				// .platform_data = (void *) &sw_dmac_pdata,
+	}
+};
+
+struct platform_device sw_pdev_nand =
+{
+	.name = "sw_nand",
+	.id = -1,
+};
+
+#if(CONFIG_CPU_HAS_PMU)
+/* cpu performance support */
+static struct resource sun6i_pmu_resource = {
+    .start  = AW_IRQ_PMU0,
+    .end    = AW_IRQ_PMU3,
+    .flags  = IORESOURCE_IRQ,
+};
+
+static struct platform_device sun6i_pmu_device = {
+    .name   = "arm-pmu",
+    .id     = ARM_PMU_DEVICE_CPU,
+    .num_resources = 1,
+    .resource = &sun6i_pmu_resource,
+};
+#endif
+
+static struct platform_device *sw_pdevs[] __initdata = {
+	&debug_uart,
+	&sw_dmac_device,
+	&sw_pdev_nand,
+    #if(CONFIG_CPU_HAS_PMU)
+    &sun6i_pmu_device,
+    #endif
+};
+
+void sw_pdev_init(void)
+{
+	platform_add_devices(sw_pdevs, ARRAY_SIZE(sw_pdevs));
+}
+
diff --git a/arch/arm/mach-sun6i/dma/Makefile b/arch/arm/mach-sun6i/dma/Makefile
new file mode 100644
index 0000000..c753c49
--- /dev/null
+++ b/arch/arm/mach-sun6i/dma/Makefile
@@ -0,0 +1,2 @@
+
+obj-y += dma.o dma_interface.o dma_csp.o dma_single.o dma_chain.o
diff --git a/arch/arm/mach-sun6i/dma/dma.c b/arch/arm/mach-sun6i/dma/dma.c
new file mode 100644
index 0000000..a43a898
--- /dev/null
+++ b/arch/arm/mach-sun6i/dma/dma.c
@@ -0,0 +1,252 @@
+/*
+ * arch/arm/mach-sun6i/dma/dma.c
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i dma driver interface
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include "dma_include.h"
+
+/**
+ * __dma_irq_hdl - dma irq process function
+ * @irq:	dma physical irq num
+ * @dev:	para passed in request_irq function
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ *
+ * we cannot lock __dma_irq_hdl through,
+ * because sw_dma_enqueue maybe called in cb,
+ * which will result in deadlock
+ */
+irqreturn_t __dma_irq_hdl(int irq, void *dev)
+{
+	u32 		i = 0;
+	u32 		upend_bits = 0;
+	struct dma_channel_t *pchan = NULL;
+	struct dma_mgr_t *pdma_mgr = NULL;
+
+	DMA_DBG("%s, line %d, dma en0 0x%08x, en1 0x%08x, pd0 0x%08x, pd1 0x%08x\n", __func__, __LINE__, \
+		DMA_READ_REG(DMA_IRQ_EN_REG0), DMA_READ_REG(DMA_IRQ_EN_REG1), \
+		DMA_READ_REG(DMA_IRQ_PEND_REG0), DMA_READ_REG(DMA_IRQ_PEND_REG1));
+
+	pdma_mgr = (struct dma_mgr_t *)dev;
+	for(i = 0; i < DMA_CHAN_TOTAL; i++) {
+		pchan = &pdma_mgr->chnl[i];
+		/* get channel irq pend bits */
+		upend_bits = csp_dma_chan_get_irqpend(pchan);
+		if(0 == upend_bits)
+			continue;
+
+		if(DMA_WORK_MODE_SINGLE == pchan->work_mode)
+			dma_irq_hdl_single(pchan, upend_bits);
+		else if(DMA_WORK_MODE_CHAIN == pchan->work_mode)
+			dma_irq_hdl_chain(pchan, upend_bits);
+	}
+	return IRQ_HANDLED;
+}
+
+/**
+ * __dma_init - initial the dma manager, request irq
+ * @device:	platform device pointer
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+int __dma_init(struct platform_device *device)
+{
+	int 		ret = 0;
+	int 		i = 0;
+	struct dma_channel_t *pchan = NULL;
+
+	/* init dma controller */
+	csp_dma_init();
+
+	/* initial the dma manager */
+	memset(&g_dma_mgr, 0, sizeof(g_dma_mgr));
+	for(i = 0; i < DMA_CHAN_TOTAL; i++) {
+		pchan 		= &g_dma_mgr.chnl[i];
+		pchan->used 	= 0;
+		pchan->id 	= i;
+		pchan->reg_base = (u32)DMA_EN_REG(i);
+		pchan->irq_spt 	= CHAN_IRQ_NO;
+		pchan->bconti_mode = false;
+		pchan->work_mode = DMA_WORK_MODE_INVALID;
+		DMA_CHAN_LOCK_INIT(&pchan->lock);
+		//pchan->state = DMA_CHAN_STA_IDLE; /* initial when request */
+
+		/* these has cleared in memset-g_dma_mgr-0 */
+		/*memset(pchan->owner, 0, sizeof(pchan->owner));
+		memset(&pchan->hd_cb, 0, sizeof(struct dma_cb_t));
+		memset(&pchan->fd_cb, 0, sizeof(struct dma_cb_t));
+		memset(&pchan->qd_cb, 0, sizeof(struct dma_cb_t));
+		memset(&pchan->op_cb, 0, sizeof(struct dma_op_cb_t));
+		memset(&pchan->des_info_save, 0, sizeof(pchan->des_info_save));
+		pchan->pdes_mgr = NULL;*/
+	}
+
+	/* alloc dma pool for des list */
+	g_des_pool = dmam_pool_create("dma_des_pool", &device->dev, sizeof(des_item), 4, 0);
+	if(NULL == g_des_pool) {
+		ret = __LINE__;
+		goto end;
+	}
+	DMA_INF("%s(%d): g_des_pool 0x%08x\n", __func__, __LINE__, (u32)g_des_pool);
+
+	/* register dma interrupt */
+	ret = request_irq(AW_IRQ_DMA, __dma_irq_hdl, IRQF_DISABLED, "dma_irq", (void *)&g_dma_mgr);
+	if(ret) {
+		DMA_ERR("%s err: request_irq return %d\n", __func__, ret);
+		ret = __LINE__;
+		goto end;
+	}
+	DMA_INF("%s, line %d\n", __func__, __LINE__);
+
+end:
+	if(0 != ret) {
+		DMA_ERR("%s err, line %d\n", __func__, ret);
+		if (NULL != g_des_pool) {
+			dma_pool_destroy(g_des_pool);
+			g_des_pool = NULL;
+		}
+		for(i = 0; i < DMA_CHAN_TOTAL; i++)
+			DMA_CHAN_LOCK_DEINIT(&g_dma_mgr.chnl[i].lock);
+	}
+	return ret;
+}
+
+/**
+ * __dma_deinit - deinit the dma manager, free irq
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+int __dma_deinit(void)
+{
+	u32 	i = 0;
+
+	DMA_INF("%s, line %d\n", __func__, __LINE__);
+	/* free dma irq */
+	free_irq(AW_IRQ_DMA, (void *)&g_dma_mgr);
+
+	if (NULL != g_des_pool) {
+		dma_pool_destroy(g_des_pool);
+		g_des_pool = NULL;
+	}
+	for(i = 0; i < DMA_CHAN_TOTAL; i++)
+		DMA_CHAN_LOCK_DEINIT(&g_dma_mgr.chnl[i].lock);
+	/* clear dma manager */
+	memset(&g_dma_mgr, 0, sizeof(g_dma_mgr));
+	return 0;
+}
+
+/**
+ * dma_drv_probe - dma driver inital function.
+ * @dev:	platform device pointer
+ *
+ * Returns 0 if success, otherwise return the err line number.
+ */
+static int __devinit dma_drv_probe(struct platform_device *dev)
+{
+	return __dma_init(dev);
+}
+
+/**
+ * dma_drv_remove - dma driver deinital function.
+ * @dev:	platform device pointer
+ *
+ * Returns 0 if success, otherwise means err.
+ */
+static int __devexit dma_drv_remove(struct platform_device *dev)
+{
+	return __dma_deinit();
+}
+
+/**
+ * dma_drv_suspend - dma driver suspend function.
+ * @dev:	platform device pointer
+ * @state:	power state
+ *
+ * Returns 0 if success, otherwise means err.
+ */
+int dma_drv_suspend(struct device *dev)
+{
+	if(NORMAL_STANDBY == standby_type) { /* process for normal standby */
+		DMA_INF("%s: normal standby, line %d\n", __func__, __LINE__);
+		/* close dma mode clock */
+		if(NULL != g_dma_mod_clk && !IS_ERR(g_dma_mod_clk)) {
+			if(0 != clk_reset(g_dma_mod_clk, AW_CCU_CLK_RESET))
+				printk("%s err: clk_reset failed\n", __func__);
+			clk_disable(g_dma_mod_clk);
+			clk_put(g_dma_mod_clk);
+			g_dma_mod_clk = NULL;
+			DMA_INF("%s: close dma mod clock success\n", __func__);
+		}
+	} else if(SUPER_STANDBY == standby_type) { /* process for super standby */
+		DMA_INF("%s: super standby, line %d\n", __func__, __LINE__);
+		/* close dma clock */
+		if(0 != dma_clk_deinit())
+			DMA_ERR("%s err, dma_clk_deinit failed\n", __func__);
+	}
+	return 0;
+}
+
+/**
+ * dma_drv_resume - dma driver resume function.
+ * @dev:	platform device pointer
+ *
+ * Returns 0 if success, otherwise means err.
+ */
+int dma_drv_resume(struct device *dev)
+{
+	if(NORMAL_STANDBY == standby_type) { /* process for normal standby */
+		DMA_INF("%s: normal standby, line %d\n", __func__, __LINE__);
+		/* enable dma mode clock */
+		g_dma_mod_clk = clk_get(NULL, CLK_MOD_DMA);
+		if(NULL == g_dma_mod_clk || IS_ERR(g_dma_mod_clk)) {
+			printk("%s err: clk_get %s failed\n", __func__, CLK_MOD_DMA);
+			return -EPERM;
+		}
+		WARN_ON(0 != clk_enable(g_dma_mod_clk));
+		WARN_ON(0 != clk_reset(g_dma_mod_clk, AW_CCU_CLK_NRESET));
+		DMA_INF("%s: open dma mod clock success\n", __func__);
+	} else if(SUPER_STANDBY == standby_type) { /* process for super standby */
+		DMA_INF("%s: super standby, line %d\n", __func__, __LINE__);
+		/* enable dma clock */
+		if(0 != dma_clk_init())
+			DMA_ERR("%s err, dma_clk_init failed\n", __func__);
+	}
+	return 0;
+}
+
+static const struct dev_pm_ops sw_dmac_pm = {
+	.suspend	= dma_drv_suspend,
+	.resume		= dma_drv_resume,
+};
+static struct platform_driver sw_dmac_driver = {
+	.probe          = dma_drv_probe,
+	.remove         = __devexit_p(dma_drv_remove),
+	.driver         = {
+		.name   = "sw_dmac",
+		.owner  = THIS_MODULE,
+		.pm 	= &sw_dmac_pm,
+		},
+};
+
+/**
+ * drv_dma_init - dma driver register function
+ *
+ * Returns 0 if success, otherwise means err.
+ */
+static int __init drv_dma_init(void)
+{
+	if(platform_driver_register(&sw_dmac_driver))
+		printk("%s(%d) err: platform_driver_register failed\n", __func__, __LINE__);
+	return 0;
+}
+arch_initcall(drv_dma_init);
diff --git a/arch/arm/mach-sun6i/dma/dma_chain.c b/arch/arm/mach-sun6i/dma/dma_chain.c
new file mode 100644
index 0000000..cd45131
--- /dev/null
+++ b/arch/arm/mach-sun6i/dma/dma_chain.c
@@ -0,0 +1,491 @@
+/*
+ * arch/arm/mach-sun6i/dma/dma_chain_new.c
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i dma driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include "dma_include.h"
+
+void __free_dest_list(struct list_head *plist)
+{
+	des_item *pcur = NULL, *n = NULL;
+
+	/* free all buf on the list */
+	list_for_each_entry_safe(pcur, n, plist, list) {
+		//printk(KERN_DEBUG "%s: free buf 0x%08x(phys: 0x%08x)\n", __func__, (u32)pcur, (u32)pcur->paddr);
+		dma_pool_free(g_des_pool, pcur, pcur->paddr);
+	}
+	/* init list */
+	INIT_LIST_HEAD(plist);
+}
+
+/* before start: cur_list is not empty, next_list is empty */
+void __dma_start_chain(dm_hdl_t dma_hdl)
+{
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+	des_item *pitem = NULL;
+
+	BUG_ON(list_empty(&pchan->cur_list) || !list_empty(&pchan->next_list));
+
+	/* get the first item from cur_list */
+	pitem = list_first_entry(&pchan->cur_list, des_item, list);
+
+	/* write the item's paddr to start reg; start dma */
+	csp_dma_chan_set_startaddr(pchan, pitem->paddr);
+	csp_dma_chan_start(pchan);
+	STATE_CHAIN(pchan) = SINGLE_STA_RUNING;
+}
+
+void __dma_stop_chain(dm_hdl_t dma_hdl)
+{
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	//dma_dump_chain(dma_hdl);
+
+	/* stop dma channle and clear irq pending */
+	csp_dma_chan_stop(pchan);
+	csp_dma_chan_clear_irqpend(pchan, CHAN_IRQ_HD | CHAN_IRQ_FD | CHAN_IRQ_QD);
+
+	/* free all buffer */
+	__free_dest_list(&pchan->cur_list);
+	__free_dest_list(&pchan->next_list);
+
+	/* change channel state to idle */
+	STATE_CHAIN(pchan) = DMA_CHAN_STA_IDLE;
+}
+
+void __dma_pause_chain(dm_hdl_t dma_hdl)
+{
+	csp_dma_chan_pause((struct dma_channel_t *)dma_hdl);
+}
+
+void __dma_resume_chain(dm_hdl_t dma_hdl)
+{
+	csp_dma_chan_resume((struct dma_channel_t *)dma_hdl);
+}
+
+u32 __dma_set_op_cb_chain(dm_hdl_t dma_hdl, struct dma_op_cb_t *pcb)
+{
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	WARN_ON(DMA_CHAN_STA_IDLE != STATE_CHAIN(pchan));
+	pchan->op_cb.func = pcb->func;
+	pchan->op_cb.parg = pcb->parg;
+	return 0;
+}
+
+u32 __dma_set_hd_cb_chain(dm_hdl_t dma_hdl, struct dma_cb_t *pcb)
+{
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	WARN_ON(DMA_CHAN_STA_IDLE != STATE_CHAIN(pchan));
+	pchan->hd_cb.func = pcb->func;
+	pchan->hd_cb.parg = pcb->parg;
+	return 0;
+}
+
+u32 __dma_set_fd_cb_chain(dm_hdl_t dma_hdl, struct dma_cb_t *pcb)
+{
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	WARN_ON(DMA_CHAN_STA_IDLE != STATE_CHAIN(pchan));
+	pchan->fd_cb.func = pcb->func;
+	pchan->fd_cb.parg = pcb->parg;
+	return 0;
+}
+
+u32 __dma_set_qd_cb_chain(dm_hdl_t dma_hdl, struct dma_cb_t *pcb)
+{
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	WARN_ON(DMA_CHAN_STA_IDLE != STATE_CHAIN(pchan));
+	pchan->qd_cb.func = pcb->func;
+	pchan->qd_cb.parg = pcb->parg;
+	return 0;
+}
+
+u32 __dma_chain_enqueue(struct dma_channel_t *pchain, struct cofig_des_t *pdes)
+{
+	u32 paddr = 0, uret = 0;
+	des_item *pdes_temp = NULL, *pdes_last = NULL;
+
+	/* cannot enqueue more than one buffer in continue mode */
+	if(pchain->des_info_save.bconti_mode && (!list_empty(&pchain->cur_list) || !list_empty(&pchain->next_list))) {
+		uret = __LINE__;
+		goto end;
+	}
+
+	/* create new des */
+	pdes_temp = (des_item *)dma_pool_alloc(g_des_pool, GFP_ATOMIC, &paddr);
+	if(NULL == pdes_temp) {
+		uret = __LINE__;
+		goto end;
+	}
+	pdes_temp->des = *pdes;
+	pdes_temp->paddr = paddr;
+	/* if continue mode, des link to itself */
+	if(pchain->des_info_save.bconti_mode)
+		pdes_temp->des.pnext = (struct cofig_des_t *)paddr;
+
+	switch(STATE_CHAIN(pchain)) {
+	case DMA_CHAN_STA_IDLE:
+		/* change last->link to cur */
+		if(!list_empty(&pchain->cur_list)) {
+			pdes_last = (des_item *)list_entry(pchain->cur_list.prev, des_item, list);
+			pdes_last->des.pnext = (struct cofig_des_t *)paddr;
+		}
+		/* add to cur list end */
+		list_add_tail(&pdes_temp->list, &pchain->cur_list);
+		break;
+	case DMA_CHAN_STA_RUNING:
+		/* assert cur list not empty */
+		WARN_ON(list_empty(&pchain->cur_list));
+		/* change next.last->link to cur */
+		if(!list_empty(&pchain->next_list)) {
+			pdes_last = list_entry(pchain->next_list.prev, des_item, list);
+			pdes_last->des.pnext = (struct cofig_des_t *)paddr;
+		}
+		/* add to next list end */
+		list_add_tail(&pdes_temp->list, &pchain->next_list);
+		break;
+	case DMA_CHAN_STA_DONE:
+		/* assert cur/next list empty */
+		WARN_ON(!list_empty(&pchain->cur_list) || !list_empty(&pchain->next_list));
+		/* add to cur list */
+		list_add_tail(&pdes_temp->list, &pchain->cur_list);
+		/* start cur list */
+		__dma_start_chain(pchain);
+		break;
+	default:
+		uret = __LINE__;
+		break;
+	}
+end:
+	if(0 != uret) {
+		DMA_ERR("%s(%d) err, pchain 0x%08x, pdes 0x%08x\n", __func__, uret, (u32)pchain, (u32)pdes);
+		if(NULL != pdes_temp)
+			dma_pool_free(g_des_pool, pdes_temp, paddr);
+	}
+	return uret;
+}
+
+void dma_dump_chain(struct dma_channel_t *pchan)
+{
+	des_item *pitem = NULL;
+
+	if(NULL == pchan) {
+		DMA_ERR("%s(%d) err, para is NULL\n", __func__, __LINE__);
+		return;
+	}
+
+	printk("+++++++++++%s+++++++++++\n", __func__);
+	printk("  channel id:        %d\n", pchan->id);
+	printk("  channel used:      %d\n", pchan->used);
+	printk("  channel owner:     %s\n", pchan->owner);
+	printk("  bconti_mode:       %d\n", pchan->bconti_mode);
+	printk("  channel irq_spt:   0x%08x\n", pchan->irq_spt);
+	printk("  channel reg_base:  0x%08x\n", pchan->reg_base);
+	printk("          EN REG:             0x%08x\n", DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_EN));
+	printk("          PAUSE REG:          0x%08x\n", DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_PAUSE));
+	printk("          START REG:          0x%08x\n", DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_START));
+	printk("          CONFIG REG:         0x%08x\n", DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_CFG));
+	printk("          CUR SRC REG:        0x%08x\n", DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_CUR_SRC));
+	printk("          CUR DST REG:        0x%08x\n", DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_CUR_DST));
+	printk("          BYTE CNT LEFT REG:  0x%08x\n", DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_BCNT_LEFT));
+	printk("          PARA REG:           0x%08x\n", DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_PARA));
+	printk("  channel hd_cb:     (func: 0x%08x, parg: 0x%08x)\n", (u32)pchan->hd_cb.func, (u32)pchan->hd_cb.parg);
+	printk("  channel fd_cb:     (func: 0x%08x, parg: 0x%08x)\n", (u32)pchan->fd_cb.func, (u32)pchan->fd_cb.parg);
+	printk("  channel qd_cb:     (func: 0x%08x, parg: 0x%08x)\n", (u32)pchan->qd_cb.func, (u32)pchan->qd_cb.parg);
+	printk("  channel op_cb:     (func: 0x%08x, parg: 0x%08x)\n", (u32)pchan->op_cb.func, (u32)pchan->op_cb.parg);
+	printk("  channel des_info_save:  (cofig: 0x%08x, param: 0x%08x, bconti_mode %d)\n", pchan->des_info_save.cofig,
+		pchan->des_info_save.param, pchan->des_info_save.bconti_mode);
+	if(DMA_WORK_MODE_CHAIN == pchan->work_mode) { /* chain mode */
+		/* dump cur des chain */
+		printk("  channel cur des buf chain:\n");
+		list_for_each_entry(pitem, &pchan->cur_list, list) {
+			printk("   pitem: 0x%08x, &pitem->list 0x%08x, &pchan->cur_list 0x%08x\n", (u32)pitem, (u32)&pitem->list, (u32)&pchan->cur_list);
+			printk("   paddr:        0x%08x\n", (u32)pitem->paddr);
+			printk("   cofig/saddr/daddr/bcnt/param/pnext: 0x%08x/0x%08x/0x%08x/0x%08x/0x%08x/0x%08x/\n",
+				pitem->des.cofig, pitem->des.saddr, pitem->des.daddr, pitem->des.bcnt, pitem->des.param, (u32)pitem->des.pnext);
+		}
+		/* dump next des chain */
+		printk("  channel next des buf chain:\n");
+		list_for_each_entry(pitem, &pchan->next_list, list) {
+			printk("   pitem: 0x%08x, &pitem->list 0x%08x, &pchan->next_list 0x%08x\n", (u32)pitem, (u32)&pitem->list, (u32)&pchan->next_list);
+			printk("   paddr:        0x%08x\n", (u32)pitem->paddr);
+			printk("   cofig/saddr/daddr/bcnt/param/pnext: 0x%08x/0x%08x/0x%08x/0x%08x/0x%08x/0x%08x/\n",
+				pitem->des.cofig, pitem->des.saddr, pitem->des.daddr, pitem->des.bcnt, pitem->des.param, (u32)pitem->des.pnext);
+		}
+		printk("  channel state:     0x%08x\n", (u32)STATE_CHAIN(pchan));
+	} else { /* single mode */
+		list_for_each_entry(pitem, &pchan->buf_list_head, list) {
+			printk("   pitem: 0x%08x, &pitem->list 0x%08x, &pchan->cur_list 0x%08x\n", (u32)pitem, (u32)&pitem->list, (u32)&pchan->cur_list);
+			printk("   paddr:        0x%08x\n", (u32)pitem->paddr);
+			printk("   cofig/saddr/daddr/bcnt/param/pnext: 0x%08x/0x%08x/0x%08x/0x%08x/0x%08x/0x%08x/\n",
+				pitem->des.cofig, pitem->des.saddr, pitem->des.daddr, pitem->des.bcnt, pitem->des.param, (u32)pitem->des.pnext);
+		}
+		printk("  channel state:     0x%08x\n", (u32)STATE_SGL(pchan));
+	}
+	printk("-----------%s-----------\n", __func__);
+}
+
+u32 dma_enqueue_chain(dm_hdl_t dma_hdl, u32 src_addr, u32 dst_addr, u32 byte_cnt)
+{
+	u32 uret = 0;
+	unsigned long flags = 0;
+	struct cofig_des_t des;
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	memset(&des, 0, sizeof(des));
+	des.saddr 	= src_addr;
+	des.daddr 	= dst_addr;
+	des.bcnt 	= byte_cnt;
+	des.cofig 	= pchan->des_info_save.cofig;
+	des.param 	= pchan->des_info_save.param;
+	des.pnext	= (struct cofig_des_t *)DMA_END_DES_LINK;
+
+	DMA_CHAN_LOCK(&pchan->lock, flags);
+	if(0 != __dma_chain_enqueue(dma_hdl, &des)) {
+		uret = __LINE__;
+		goto end;
+	}
+
+end:
+	DMA_CHAN_UNLOCK(&pchan->lock, flags);
+	if(0 != uret)
+		DMA_ERR("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+
+u32 dma_config_chain(dm_hdl_t dma_hdl, struct dma_config_t *pcfg)
+{
+	u32 		uret = 0;
+	u32		uConfig = 0;
+	unsigned long	flags = 0;
+	struct cofig_des_t	des;
+	struct dma_channel_t	*pchan = (struct dma_channel_t *)dma_hdl;
+
+	/* get dma config val */
+	uConfig |= xfer_arr[pcfg->xfer_type]; /* src/dst burst length and data width */
+	uConfig |= addrtype_arr[pcfg->address_type]; /* src/dst address mode */
+	uConfig |= (pcfg->src_drq_type << DMA_OFF_BITS_SDRQ)
+			| (pcfg->dst_drq_type << DMA_OFF_BITS_DDRQ); /* src/dst drq type */
+	/* fill cofig_des_t struct */
+	memset(&des, 0, sizeof(des));
+	des.cofig = uConfig;
+	des.saddr = pcfg->src_addr;
+	des.daddr = pcfg->dst_addr;
+	des.bcnt  = pcfg->byte_cnt;
+	des.param = pcfg->para;
+	des.pnext = (struct cofig_des_t *)DMA_END_DES_LINK;
+	/* get continue mode flag */
+	pchan->bconti_mode = pcfg->bconti_mode;
+	/* get irq surport type for channel handle */
+	pchan->irq_spt = pcfg->irq_spt;
+	/* bkup config/param */
+	pchan->des_info_save.cofig = uConfig;
+	pchan->des_info_save.param = pcfg->para;
+	pchan->des_info_save.bconti_mode = pcfg->bconti_mode;
+
+	DMA_CHAN_LOCK(&pchan->lock, flags);
+
+	/* irq enable */
+	csp_dma_chan_irq_enable(pchan, pcfg->irq_spt);
+	/* des enqueue */
+	if(0 != __dma_chain_enqueue(dma_hdl, &des)) {
+		uret = __LINE__;
+		goto end;
+	}
+end:
+	DMA_CHAN_UNLOCK(&pchan->lock, flags);
+	if(0 != uret)
+		DMA_ERR("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+
+u32 dma_ctrl_chain(dm_hdl_t dma_hdl, enum dma_op_type_e op, void *parg)
+{
+	u32		uret = 0;
+	unsigned long	flags = 0;
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	/* only in start/stop/pause/resume case can parg be NULL  */
+	if((NULL == parg) && (DMA_OP_START != op) && (DMA_OP_PAUSE != op) && (DMA_OP_RESUME != op) && (DMA_OP_STOP != op)) {
+		WARN_ON(1);
+		return __LINE__;
+	}
+
+	DMA_CHAN_LOCK(&pchan->lock, flags);
+
+	/* let the caller to do some operation before op */
+	if((DMA_OP_SET_OP_CB != op) && (NULL != pchan->op_cb.func))
+		if(0 != pchan->op_cb.func(dma_hdl, pchan->op_cb.parg, op))
+			DMA_ERR("%s err, line %d\n", __func__, __LINE__);
+
+	switch(op) {
+	/* dma hw control */
+	case DMA_OP_START:
+		__dma_start_chain(dma_hdl);
+		break;
+	case DMA_OP_PAUSE:
+		__dma_pause_chain(dma_hdl);
+		break;
+	case DMA_OP_RESUME:
+		__dma_resume_chain(dma_hdl);
+		break;
+	case DMA_OP_STOP:
+		__dma_stop_chain(dma_hdl);
+		break;
+	case DMA_OP_GET_STATUS:
+		*(u32 *)parg = csp_dma_chan_get_status(pchan);
+		break;
+	case DMA_OP_GET_CUR_SRC_ADDR:
+		*(u32 *)parg = csp_dma_chan_get_cur_srcaddr(pchan);
+		break;
+	case DMA_OP_GET_CUR_DST_ADDR:
+		*(u32 *)parg = csp_dma_chan_get_cur_dstaddr(pchan);
+		break;
+	case DMA_OP_GET_BYTECNT_LEFT:
+		*(u32 *)parg = csp_dma_chan_get_left_bytecnt(pchan);
+		break;
+	/* set callback */
+	case DMA_OP_SET_OP_CB:
+		uret = __dma_set_op_cb_chain(dma_hdl, (struct dma_op_cb_t *)parg);
+		break;
+	case DMA_OP_SET_HD_CB:
+		uret = __dma_set_hd_cb_chain(dma_hdl, (struct dma_cb_t *)parg);
+		break;
+	case DMA_OP_SET_FD_CB:
+		uret = __dma_set_fd_cb_chain(dma_hdl, (struct dma_cb_t *)parg);
+		break;
+	case DMA_OP_SET_QD_CB:
+		uret = __dma_set_qd_cb_chain(dma_hdl, (struct dma_cb_t *)parg);
+		break;
+	default:
+		uret = __LINE__;
+		goto end;
+	}
+
+end:
+	DMA_CHAN_UNLOCK(&pchan->lock, flags);
+	if(0 != uret)
+		DMA_ERR("%s err, line %d, dma_hdl 0x%08x\n", __func__, uret, (u32)dma_hdl);
+	return uret;
+}
+
+u32 dma_release_chain(dm_hdl_t dma_hdl)
+{
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+	unsigned long	flags = 0;
+
+	DMA_CHAN_LOCK(&pchan->lock, flags);
+
+	/* if not idle, call stop */
+	if(DMA_CHAN_STA_IDLE != STATE_CHAIN(pchan))
+		__dma_stop_chain(dma_hdl);
+
+	/* assert all buf freed */
+	WARN_ON(!list_empty(&pchan->cur_list) || !list_empty(&pchan->next_list));
+
+	//memset(pchan, 0, sizeof(*pchan)); /* donot do that, because id...shouldnot be cleared */
+	pchan->used = 0;
+	pchan->irq_spt = CHAN_IRQ_NO;
+	pchan->bconti_mode = false;
+	memset(pchan->owner, 0, sizeof(pchan->owner));
+	memset(&pchan->des_info_save, 0, sizeof(pchan->des_info_save));
+	memset(&pchan->op_cb, 0, sizeof(pchan->op_cb));
+	memset(&pchan->hd_cb, 0, sizeof(pchan->hd_cb));
+	memset(&pchan->fd_cb, 0, sizeof(pchan->fd_cb));
+	memset(&pchan->qd_cb, 0, sizeof(pchan->qd_cb));
+
+	DMA_CHAN_UNLOCK(&pchan->lock, flags);
+	return 0;
+}
+
+u32 dma_request_init_chain(struct dma_channel_t *pchan)
+{
+	INIT_LIST_HEAD(&pchan->cur_list);
+	INIT_LIST_HEAD(&pchan->next_list);
+	STATE_CHAIN(pchan) = DMA_CHAN_STA_IDLE;
+
+	/* init for single mode, incase err access by someone */
+	INIT_LIST_HEAD(&pchan->buf_list_head);
+	return 0;
+}
+
+void __handle_qd_chain(struct dma_channel_t *pchan)
+{
+	unsigned long	flags = 0;
+
+	/* cannot lock fd_cb function, in case sw_dma_enqueue called and locked agin */
+	if(NULL != pchan->qd_cb.func)
+		pchan->qd_cb.func((dm_hdl_t)pchan, pchan->qd_cb.parg, DMA_CB_OK);
+
+	DMA_CHAN_LOCK(&pchan->lock, flags);
+
+	switch(STATE_CHAIN(pchan)) {
+	case DMA_CHAN_STA_IDLE:
+		/* stopped in cb before? or normal stopped */
+		WARN_ON(!list_empty(&pchan->cur_list) || !list_empty(&pchan->next_list));
+		break;
+	case DMA_CHAN_STA_RUNING:
+		if(likely(false == pchan->des_info_save.bconti_mode)) {
+			//dma_dump_chain(pchan);
+			/* free cur buf list */
+			__free_dest_list(&pchan->cur_list);
+			if(!list_empty(&pchan->next_list)) {
+				/* change list head */
+				list_replace_init(&pchan->next_list, &pchan->cur_list);
+				/* start cur list */
+				__dma_start_chain(pchan);
+			} else
+				STATE_CHAIN(pchan) = DMA_CHAN_STA_DONE;
+		}
+		break;
+	case DMA_CHAN_STA_DONE:
+		/* never here */
+		BUG_ON(1);
+		break;
+	default:
+		BUG_ON(1);
+		break;
+	}
+
+	DMA_CHAN_UNLOCK(&pchan->lock, flags);
+}
+
+void dma_irq_hdl_chain(struct dma_channel_t *pchan, u32 upend_bits)
+{
+	u32	uirq_spt = 0;
+
+	WARN(0 == upend_bits, "%s err, line %d!\n", __func__, __LINE__);
+	uirq_spt = pchan->irq_spt;
+
+	/* deal half done */
+	if(upend_bits & CHAN_IRQ_HD) {
+		csp_dma_chan_clear_irqpend(pchan, CHAN_IRQ_HD);
+		if((uirq_spt & CHAN_IRQ_HD) && NULL != pchan->hd_cb.func)
+			pchan->hd_cb.func((dm_hdl_t)pchan, pchan->hd_cb.parg, DMA_CB_OK);
+	}
+	/* deal full done */
+	if(upend_bits & CHAN_IRQ_FD) {
+		csp_dma_chan_clear_irqpend(pchan, CHAN_IRQ_FD);
+		if((uirq_spt & CHAN_IRQ_FD) && NULL != pchan->fd_cb.func)
+				pchan->fd_cb.func((dm_hdl_t)pchan, pchan->fd_cb.parg, DMA_CB_OK);
+	}
+	/* deal queue done */
+	if(upend_bits & CHAN_IRQ_QD) {
+		csp_dma_chan_clear_irqpend(pchan, CHAN_IRQ_QD);
+		if(uirq_spt & CHAN_IRQ_QD)
+			__handle_qd_chain(pchan);
+	}
+}
diff --git a/arch/arm/mach-sun6i/dma/dma_chain.h b/arch/arm/mach-sun6i/dma/dma_chain.h
new file mode 100644
index 0000000..2fe1e49
--- /dev/null
+++ b/arch/arm/mach-sun6i/dma/dma_chain.h
@@ -0,0 +1,27 @@
+/*
+ * arch/arm/mach-sun6i/dma/dma_chain_new.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i dma header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __DMA_CHAIN_NEW_H
+#define __DMA_CHAIN_NEW_H
+
+void dma_irq_hdl_chain(struct dma_channel_t *pchan, u32 upend_bits);
+u32 dma_request_init_chain(struct dma_channel_t *pchan);
+void dma_dump_chain(struct dma_channel_t *pchan);
+u32 dma_enqueue_chain(dm_hdl_t dma_hdl, u32 src_addr, u32 dst_addr, u32 byte_cnt);
+u32 dma_config_chain(dm_hdl_t dma_hdl, struct dma_config_t *pcfg);
+u32 dma_ctrl_chain(dm_hdl_t dma_hdl, enum dma_op_type_e op, void *parg);
+u32 dma_release_chain(dm_hdl_t dma_hdl);
+
+#endif  /* __DMA_CHAIN_NEW_H */
diff --git a/arch/arm/mach-sun6i/dma/dma_common.h b/arch/arm/mach-sun6i/dma/dma_common.h
new file mode 100644
index 0000000..8aae35e
--- /dev/null
+++ b/arch/arm/mach-sun6i/dma/dma_common.h
@@ -0,0 +1,136 @@
+/*
+ * arch/arm/mach-sun6i/dma/dma_common.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i dma common header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __DMA_COMMON_H
+#define __DMA_COMMON_H
+
+#include <linux/spinlock.h>
+
+/* dma print macro */
+#define DMA_DBG_LEVEL		3
+
+#if (DMA_DBG_LEVEL == 1)
+	#define DMA_DBG(format,args...)   printk("[dma-dbg] "format,##args)
+	#define DMA_INF(format,args...)   printk("[dma-inf] "format,##args)
+	#define DMA_ERR(format,args...)   printk("[dma-err] "format,##args)
+#elif (DMA_DBG_LEVEL == 2)
+	#define DMA_DBG(format,args...)   do{}while(0)
+	#define DMA_INF(format,args...)   printk("[dma-inf] "format,##args)
+	#define DMA_ERR(format,args...)   printk("[dma-err] "format,##args)
+#elif (DMA_DBG_LEVEL == 3)
+	#define DMA_DBG(format,args...)   do{}while(0)
+	#define DMA_INF(format,args...)   do{}while(0)
+	#define DMA_ERR(format,args...)   printk("[dma-err] "format,##args)
+#endif
+
+/* dma channel total */
+#define DMA_CHAN_TOTAL		(16)
+
+/* dma channel owner name max len */
+#define MAX_OWNER_NAME_LEN	32
+
+/* dma end des link */
+#define DMA_END_DES_LINK	0xFFFFF800
+
+/* dam channel state, software state */
+enum st_md_chain_e {
+	DMA_CHAN_STA_IDLE,  	/* maybe before start or after stop */
+	DMA_CHAN_STA_RUNING,	/* transferring */
+	DMA_CHAN_STA_DONE	/* all buffer has transfer done, hw idle, des queue is empty */
+};
+
+/* dam channel state for single mode */
+enum st_md_single_e {
+	SINGLE_STA_IDLE,  	/* maybe before start or after stop */
+	SINGLE_STA_RUNING,	/* transferring */
+	SINGLE_STA_LAST_DONE	/* the last buffer has done,
+				 * in this state, any enqueueing will start dma
+				 */
+};
+
+/* define dma config descriptor struct for hardware */
+struct cofig_des_t {
+	u32		cofig;		/* dma configuration reg */
+	u32		saddr;		/* dma src addr reg */
+	u32		daddr;		/* dma dst addr reg */
+	u32		bcnt;		/* dma byte cnt reg */
+	u32		param;		/* dma param reg */
+	struct cofig_des_t *pnext;	/* next descriptor address */
+};
+
+/* descriptor item define */
+typedef struct __des_item {
+	struct cofig_des_t	des;		/* descriptor that will be set to hw */
+	u32			paddr;		/* physical addr of this __des_item struct */
+	struct list_head 	list;		/* list node */
+}des_item;
+
+/* define dma config/param info, for dma_channel_t.des_info_save */
+struct des_save_info_t {
+	u32		cofig;     	/* dma configuration reg */
+	u32		param;     	/* dma param reg */
+	u32		bconti_mode;    /* if dma transfer in continue mode */
+};
+
+/* dma channle state */
+union dma_chan_sta_u {
+	enum st_md_chain_e 	st_md_ch;	/* channel state for chain mode */
+	enum st_md_single_e 	st_md_sg;	/* channel state for single mode */
+};
+
+/* define dma channel struct */
+struct dma_channel_t {
+	u32		used;     	/* 1 used, 0 unuse */
+	u32		id;     	/* channel id, 0~15 */
+	char 		owner[MAX_OWNER_NAME_LEN];	/* dma chnnnel owner name */
+	u32		reg_base;	/* regs base addr */
+	u32		bconti_mode;	/* cotinue mode */
+	u32 		irq_spt;	/* channel irq supprot type, used for irq handler only enabled then can call irq callback */
+	struct dma_cb_t		hd_cb;		/* half done call back func */
+	struct dma_cb_t		fd_cb;		/* full done call back func */
+	struct dma_cb_t		qd_cb;		/* queue done call back func */
+	struct dma_op_cb_t	op_cb;		/* dma operation call back func */
+	struct des_save_info_t	des_info_save;	/* save the prev buf para, used by sw_dma_enqueue */
+	enum dma_work_mode_e	work_mode;
+	union dma_chan_sta_u	state;		/* channel state for chain/single mode */
+	spinlock_t 		lock;		/* dma channel lock */
+	/*
+	 * for chain mode only
+	 */
+	struct list_head 	cur_list;	/* buf list which is being tranferring */
+	struct list_head 	next_list;	/* buf list bkup for next tranfer */
+	/*
+	 * for single mode only
+	 */
+	des_item		*pcur_des;	/* cur buffer which is transferring */
+	struct list_head 	buf_list_head;
+};
+
+#define STATE_CHAIN(dma_hdl)	(((struct dma_channel_t *)(dma_hdl))->state.st_md_ch)
+#define STATE_SGL(dma_hdl)	(((struct dma_channel_t *)(dma_hdl))->state.st_md_sg)
+
+/* dma manager struct */
+struct dma_mgr_t {
+	struct dma_channel_t chnl[DMA_CHAN_TOTAL];
+};
+extern struct dma_mgr_t g_dma_mgr;
+
+/* dma channel lock */
+#define DMA_CHAN_LOCK_INIT(lock)	spin_lock_init((lock))
+#define DMA_CHAN_LOCK_DEINIT(lock)	do{}while(0)
+#define DMA_CHAN_LOCK(lock, flag)	spin_lock_irqsave((lock), (flag))
+#define DMA_CHAN_UNLOCK(lock, flag)	spin_unlock_irqrestore((lock), (flag))
+
+#endif  /* __DMA_COMMON_H */
diff --git a/arch/arm/mach-sun6i/dma/dma_csp.c b/arch/arm/mach-sun6i/dma/dma_csp.c
new file mode 100644
index 0000000..cf9bdb4
--- /dev/null
+++ b/arch/arm/mach-sun6i/dma/dma_csp.c
@@ -0,0 +1,307 @@
+/*
+ * arch/arm/mach-sun6i/dma/dma_csp.c
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i dma csp functions
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include "dma_include.h"
+
+struct clk 	*g_dma_ahb_clk = NULL;
+struct clk 	*g_dma_mod_clk = NULL;
+
+u32 dma_clk_init(void)
+{
+	if(NULL != g_dma_mod_clk || NULL != g_dma_ahb_clk) {
+		DMA_INF("%s maybe err: g_dma_mod_clk(0x%08x)/g_dma_ahb_clk(0x%08x) not NULL, line %d\n",
+			__func__, (u32)g_dma_mod_clk, (u32)g_dma_ahb_clk, __LINE__);
+	}
+
+	/* config dma module clock */
+	g_dma_mod_clk = clk_get(NULL, CLK_MOD_DMA);
+	DMA_DBG("%s: get g_dma_mod_clk 0x%08x\n", __func__, (u32)g_dma_mod_clk);
+	if(NULL == g_dma_mod_clk || IS_ERR(g_dma_mod_clk)) {
+		DMA_ERR("%s err: clk_get %s failed\n", __func__, CLK_MOD_DMA);
+		return -EPERM;
+	} else {
+		if(0 != clk_enable(g_dma_mod_clk)) {
+			DMA_ERR("%s err: clk_enable failed, line %d\n", __func__, __LINE__);
+			return -EPERM;
+		}
+		DMA_DBG("%s: clk_enable g_dma_mod_clk success\n", __func__);
+
+		if(0 != clk_reset(g_dma_mod_clk, AW_CCU_CLK_NRESET)) {
+			DMA_ERR("%s err: clk_reset failed, line %d\n", __func__, __LINE__);
+			return -EPERM;
+		}
+		DMA_DBG("%s: clk_reset g_dma_mod_clk-AW_CCU_CLK_NRESET success\n", __func__);
+	}
+
+	/* config dma ahb clock */
+	g_dma_ahb_clk = clk_get(NULL, CLK_AHB_DMA);
+	DMA_DBG("%s: get g_dma_ahb_clk 0x%08x\n", __func__, (u32)g_dma_ahb_clk);
+	if(NULL == g_dma_ahb_clk || IS_ERR(g_dma_ahb_clk)) {
+		printk("%s err: clk_get %s failed\n", __func__, CLK_AHB_DMA);
+		return -EPERM;
+	} else {
+		if(0 != clk_enable(g_dma_ahb_clk)) {
+			DMA_ERR("%s err: clk_enable failed, line %d\n", __func__, __LINE__);
+			return -EPERM;
+		}
+		DMA_DBG("%s: clk_enable g_dma_ahb_clk success\n", __func__);
+	}
+
+	DMA_DBG("%s success\n", __func__);
+	return 0;
+}
+
+u32 dma_clk_deinit(void)
+{
+	DMA_DBG("%s: g_dma_mod_clk 0x%08x, g_dma_ahb_clk 0x%08x\n",
+		__func__, (u32)g_dma_mod_clk, (u32)g_dma_ahb_clk);
+
+	/* release dma mode clock */
+	if(NULL == g_dma_mod_clk || IS_ERR(g_dma_mod_clk)) {
+		DMA_INF("%s: g_dma_mod_clk 0x%08x invalid, just return\n", __func__, (u32)g_dma_mod_clk);
+		return 0;
+	} else {
+		if(0 != clk_reset(g_dma_mod_clk, AW_CCU_CLK_RESET)) {
+			DMA_ERR("%s err: clk_reset failed\n", __func__);
+		}
+		DMA_DBG("%s: clk_reset g_dma_mod_clk-AW_CCU_CLK_RESET success\n", __func__);
+		clk_disable(g_dma_mod_clk);
+		clk_put(g_dma_mod_clk);
+		g_dma_mod_clk = NULL;
+	}
+
+	/* release dma ahb clock */
+	if(NULL == g_dma_ahb_clk || IS_ERR(g_dma_ahb_clk)) {
+		DMA_INF("%s: g_dma_ahb_clk 0x%08x invalid, just return\n", __func__, (u32)g_dma_ahb_clk);
+		return 0;
+	} else {
+		clk_disable(g_dma_ahb_clk);
+		clk_put(g_dma_ahb_clk);
+		g_dma_ahb_clk = NULL;
+	}
+
+	DMA_DBG("%s success\n", __func__);
+	return 0;
+}
+
+/**
+ * csp_dma_init - init dmac
+ */
+void csp_dma_init(void)
+{
+	u32 	i = 0;
+
+	/* init dma clock */
+	if(0 != dma_clk_init())
+		DMA_ERR("%s err, dma_clk_init failed, line %d\n", __func__, __LINE__);
+
+	/* Disable & clear all interrupts */
+	DMA_WRITE_REG(0, DMA_IRQ_EN_REG0);
+	DMA_WRITE_REG(0, DMA_IRQ_EN_REG1);
+	DMA_WRITE_REG(0xffffffff, DMA_IRQ_PEND_REG0);
+	DMA_WRITE_REG(0xffffffff, DMA_IRQ_PEND_REG1);
+
+	/* init enable reg */
+	for(i = 0; i < DMA_CHAN_TOTAL; i++)
+		DMA_WRITE_REG(0, DMA_EN_REG(i));
+}
+
+/**
+ * csp_dma_chan_set_startaddr - set the des's start phys addr to start reg, then we can start the dma
+ * @pchan:	dma channel handle
+ * @ustart_addr: dma channel start physcal address to set
+ */
+void csp_dma_chan_set_startaddr(struct dma_channel_t * pchan, u32 ustart_addr)
+{
+	DMA_WRITE_REG(ustart_addr, pchan->reg_base + DMA_OFF_REG_START);
+}
+
+/**
+ * csp_dma_chan_start - start the dma channel
+ * @pchan:	dma channel handle
+ */
+void csp_dma_chan_start(struct dma_channel_t * pchan)
+{
+	DMA_WRITE_REG(1, pchan->reg_base + DMA_OFF_REG_EN);
+}
+
+/**
+ * csp_dma_chan_pause - pause the dma channel
+ * @pchan:	dma channel handle
+ */
+void csp_dma_chan_pause(struct dma_channel_t * pchan)
+{
+	DMA_WRITE_REG(1, pchan->reg_base + DMA_OFF_REG_PAUSE);
+}
+
+/**
+ * csp_dma_chan_resume - resume the dma channel
+ * @pchan:	dma channel handle
+ */
+void csp_dma_chan_resume(struct dma_channel_t * pchan)
+{
+	DMA_WRITE_REG(0, pchan->reg_base + DMA_OFF_REG_PAUSE);
+}
+
+/**
+ * csp_dma_chan_stop - stop the dma channel
+ * @pchan:	dma channel handle
+ */
+void csp_dma_chan_stop(struct dma_channel_t * pchan)
+{
+	DMA_WRITE_REG(0, pchan->reg_base + DMA_OFF_REG_EN);
+}
+
+/**
+ * csp_dma_chan_get_status - get dma channel status
+ * @pchan:	dma channel handle
+ *
+ * Returns 1 indicate channel is busy, 0 idle
+ */
+u32 csp_dma_chan_get_status(struct dma_channel_t * pchan)
+{
+	return ((DMA_READ_REG(DMA_STATE_REG) >> pchan->id) & 1);
+}
+
+/**
+ * csp_dma_chan_get_cur_srcaddr - get dma channel's cur src addr reg value
+ *
+ * Returns the channel's cur src addr reg value
+ */
+u32 csp_dma_chan_get_cur_srcaddr(struct dma_channel_t * pchan)
+{
+	return DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_CUR_SRC);
+}
+
+/**
+ * csp_dma_chan_get_cur_dstaddr - get dma channel's cur dst addr reg value
+ * @pchan:	dma channel handle
+ *
+ * Returns the channel's cur dst addr reg value
+ */
+u32 csp_dma_chan_get_cur_dstaddr(struct dma_channel_t * pchan)
+{
+	return DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_CUR_DST);
+}
+
+/**
+ * csp_dma_chan_get_left_bytecnt - get dma channel's left byte cnt
+ * @pchan:	dma channel handle
+ *
+ * Returns the channel's left byte cnt
+ */
+u32 csp_dma_chan_get_left_bytecnt(struct dma_channel_t * pchan)
+{
+	return DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_BCNT_LEFT);
+}
+
+/**
+ * csp_dma_chan_get_startaddr - get dma channel's start address reg value
+ * @pchan:	dma channel handle
+ *
+ * Returns the dma channel's start address reg value
+ */
+u32 csp_dma_chan_get_startaddr(struct dma_channel_t *pchan)
+{
+	return DMA_READ_REG(pchan->reg_base + DMA_OFF_REG_START);
+}
+
+/**
+ * csp_dma_chan_irq_enable - enable dma channel irq
+ * @pchan:	dma channel handle
+ * @irq_type:	irq type that will be enabled
+ */
+void csp_dma_chan_irq_enable(struct dma_channel_t * pchan, u32 irq_type)
+{
+	u32 	uTemp = 0;
+
+	if(pchan->id < 8) {
+		uTemp = DMA_READ_REG(DMA_IRQ_EN_REG0);
+		uTemp &= (~(0xf << (pchan->id << 2)));
+		uTemp |= (irq_type << (pchan->id << 2));
+		DMA_WRITE_REG(uTemp, DMA_IRQ_EN_REG0);
+	} else {
+		uTemp = DMA_READ_REG(DMA_IRQ_EN_REG1);
+		uTemp &= (~(0xf << ((pchan->id - 8) << 2)));
+		uTemp |= (irq_type << ((pchan->id - 8) << 2));
+		DMA_WRITE_REG(uTemp, DMA_IRQ_EN_REG1);
+	}
+}
+
+/**
+ * csp_dma_chan_get_status - get dma channel irq pending val
+ * @pchan:	dma channel handle
+ *
+ * Returns the irq pend value, eg: 0b101
+ */
+u32 csp_dma_chan_get_irqpend(struct dma_channel_t * pchan)
+{
+	u32 	uret = 0;
+	u32 	utemp = 0;
+
+	if(pchan->id < 8) {
+		utemp = DMA_READ_REG(DMA_IRQ_PEND_REG0);
+		uret = (utemp >> (pchan->id << 2)) & 0x7;
+	} else {
+		utemp = DMA_READ_REG(DMA_IRQ_PEND_REG1);
+		uret = (utemp >> ((pchan->id - 8) << 2)) & 0x7;
+	}
+	return uret;
+}
+
+/**
+ * csp_dma_chan_clear_irqpend - clear the dma channel irq pending
+ * @pchan:	dma channel handle
+ * @irq_type:	irq type that willbe cleared, eg: CHAN_IRQ_HD|CHAN_IRQ_FD
+ */
+void csp_dma_chan_clear_irqpend(struct dma_channel_t * pchan, u32 irq_type)
+{
+	u32 	uTemp = 0;
+
+	if(pchan->id < 8) {
+		uTemp = DMA_READ_REG(DMA_IRQ_PEND_REG0);
+		uTemp &= (irq_type << (pchan->id << 2));
+		DMA_WRITE_REG(uTemp, DMA_IRQ_PEND_REG0);
+	} else {
+		uTemp = DMA_READ_REG(DMA_IRQ_PEND_REG1);
+		uTemp &= (irq_type << ((pchan->id - 8) << 2));
+		DMA_WRITE_REG(uTemp, DMA_IRQ_PEND_REG1);
+	}
+}
+
+/**
+ * csp_dma_clear_irqpend - clear dma irq pending register
+ * @index:	irq pend reg index, 0 or 1
+ *
+ * Returns the irq pend value before cleared, 0xffffffff if failed
+ */
+u32 csp_dma_clear_irqpend(u32 index)
+{
+	u32 	uret = 0;
+	u32 	ureg_addr = 0;
+
+	if(0 == index)
+		ureg_addr = (u32)DMA_IRQ_PEND_REG0;
+	else if(1 == index)
+		ureg_addr = (u32)DMA_IRQ_PEND_REG1;
+	else {
+		DMA_ERR("%s err, line %d\n", __func__, __LINE__);
+		return 0xffffffff;
+	}
+
+	uret = DMA_READ_REG(ureg_addr);
+	DMA_WRITE_REG(uret, ureg_addr);
+	return uret;
+}
diff --git a/arch/arm/mach-sun6i/dma/dma_csp.h b/arch/arm/mach-sun6i/dma/dma_csp.h
new file mode 100644
index 0000000..5723935
--- /dev/null
+++ b/arch/arm/mach-sun6i/dma/dma_csp.h
@@ -0,0 +1,42 @@
+/*
+ * arch/arm/mach-sun6i/dma/dma_csp.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i dma csp header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __DMA_CSP_H
+#define __DMA_CSP_H
+
+extern struct clk *g_dma_ahb_clk;
+extern struct clk *g_dma_mod_clk;
+
+u32 dma_clk_init(void);
+u32 dma_clk_deinit(void);
+
+void csp_dma_init(void);
+u32  csp_dma_clear_irqpend(u32 index);
+
+void csp_dma_chan_set_startaddr(struct dma_channel_t * pchan, u32 ustart_addr);
+void csp_dma_chan_start(struct dma_channel_t * pchan);
+void csp_dma_chan_pause(struct dma_channel_t * pchan);
+void csp_dma_chan_resume(struct dma_channel_t * pchan);
+void csp_dma_chan_stop(struct dma_channel_t * pchan);
+u32  csp_dma_chan_get_startaddr(struct dma_channel_t *pchan);
+u32  csp_dma_chan_get_left_bytecnt(struct dma_channel_t * pchan);
+u32  csp_dma_chan_get_cur_dstaddr(struct dma_channel_t * pchan);
+u32  csp_dma_chan_get_cur_srcaddr(struct dma_channel_t * pchan);
+u32  csp_dma_chan_get_status(struct dma_channel_t * pchan);
+void csp_dma_chan_irq_enable(struct dma_channel_t * pchan, u32 irq_type);
+void csp_dma_chan_clear_irqpend(struct dma_channel_t * pchan, u32 irq_type);
+u32  csp_dma_chan_get_irqpend(struct dma_channel_t * pchan);
+
+#endif  /* __DMA_CSP_H */
diff --git a/arch/arm/mach-sun6i/dma/dma_include.h b/arch/arm/mach-sun6i/dma/dma_include.h
new file mode 100644
index 0000000..912f356
--- /dev/null
+++ b/arch/arm/mach-sun6i/dma/dma_include.h
@@ -0,0 +1,56 @@
+/*
+ * arch/arm/mach-sun6i/dma/dma_include.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i dma header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __DMA_INCLUDE_H
+#define __DMA_INCLUDE_H
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/serial_core.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <mach/platform.h>
+
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/pm.h>
+
+//#define TEMP_FOR_XJF_20121121 	/* alloc des buf in request, temp for xujinfeng, 2012-11-21 */
+
+#include <mach/dma.h>
+#include <mach/clock.h>
+#include "dma_regs.h"
+#include "dma_common.h"
+#include "dma_csp.h"
+#include "dma_interface.h"
+#include "dma_single.h"
+#include "dma_chain.h"
+
+#ifdef TEMP_FOR_XJF_20121121
+#define TEMP_DES_CNT	20
+extern u32 index_get, index_put;
+extern u32 v_addr, p_addr;
+#endif /* TEMP_FOR_XJF_20121121 */
+
+#ifdef DBG_DMA
+#include <linux/delay.h>
+#endif /* DBG_DMA */
+
+#endif  /* __DMA_INCLUDE_H */
diff --git a/arch/arm/mach-sun6i/dma/dma_interface.c b/arch/arm/mach-sun6i/dma/dma_interface.c
new file mode 100644
index 0000000..ba0fcd4
--- /dev/null
+++ b/arch/arm/mach-sun6i/dma/dma_interface.c
@@ -0,0 +1,455 @@
+/*
+ * arch/arm/mach-sun6i/dma/dma_interface.c
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i dma driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include "dma_include.h"
+
+/* dma manager */
+struct dma_mgr_t g_dma_mgr; /* compile warning if "g_dma_mgr = {0}" */
+
+/* lock for request */
+static DEFINE_MUTEX(dma_mutex);
+
+/* dma descriptor buf pool */
+struct dma_pool	*g_des_pool = NULL;
+
+#ifdef TEMP_FOR_XJF_20121121
+u32 index_get = 0, index_put = 0;
+u32 v_addr = 0, p_addr = 0;
+#endif /* TEMP_FOR_XJF_20121121 */
+
+/* data length and burst length value in config reg */
+unsigned long xfer_arr[DMAXFER_MAX] =
+{
+	/* des:X_SIGLE  src:X_SIGLE */
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+
+	/* des:X_SIGLE   src:X_BURST */
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_WORD << 9),
+
+	/* des:X_SIGLE   src:X_TIPPL */
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_SIGLE << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+
+	/* des:X_BURST  src:X_BURST */
+	(X_BURST << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_WORD << 9),
+
+	/* des:X_BURST   src:X_SIGLE */
+	(X_BURST << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+
+	/* des:X_BURST   src:X_TIPPL */
+	(X_BURST << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_BURST << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+
+	/* des:X_TIPPL   src:X_TIPPL */
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_TIPPL <<7) | (X_WORD << 9),
+
+	/* des:X_TIPPL   src:X_SIGLE */
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_SIGLE <<7) | (X_WORD << 9),
+
+	/* des:X_TIPPL   src:X_BURST */
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_BYTE << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_HALF << 25) | (X_BURST <<7) | (X_WORD << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_BYTE << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_HALF << 9),
+	(X_TIPPL << 23) | (X_WORD << 25) | (X_BURST <<7) | (X_WORD << 9),
+};
+
+/* src/dst address type value in config reg */
+unsigned long addrtype_arr[DMAADDRT_MAX] =
+{
+	(A_LN  << 21) | (A_LN  << 5),
+	(A_LN  << 21) | (A_IO  << 5),
+	(A_IO  << 21) | (A_LN  << 5),
+	(A_IO  << 21) | (A_IO  << 5),
+};
+
+#if 0 /* remove warning: defined but not used */
+/**
+ * __dma_dump_config_para - dump dma_config_t struct
+ * @para:	dma_config_t struct to dump
+ */
+static void __dma_dump_config_para(struct dma_config_t *para)
+{
+	if(NULL == para) {
+		DMA_ERR("%s err, line %d\n", __func__, __LINE__);
+		return;
+	}
+
+	DMA_DBG("+++++++++++%s+++++++++++\n", __func__);
+	DMA_DBG("  xfer_type:         %d\n", para->xfer_type);
+	DMA_DBG("  address_type:      %d\n", para->address_type);
+	DMA_DBG("  para:              0x%08x\n", para->para);
+	DMA_DBG("  irq_spt:           %d\n", para->irq_spt);
+	DMA_DBG("  src_addr:          0x%08x\n", para->src_addr);
+	DMA_DBG("  dst_addr:          0x%08x\n", para->dst_addr);
+	DMA_DBG("  byte_cnt:          0x%08x\n", para->byte_cnt);
+	DMA_DBG("  bconti_mode:       %d\n", para->bconti_mode);
+	DMA_DBG("  src_drq_type:      %d\n", para->src_drq_type);
+	DMA_DBG("  dst_drq_type:      %d\n", para->dst_drq_type);
+	DMA_DBG("-----------%s-----------\n", __func__);
+}
+#endif
+
+/**
+ * dma_check_handle - check if dma handle is valid
+ * @dma_hdl:	dma handle
+ *
+ * return 0 if vaild, the err line number if not vaild
+ */
+u32 dma_check_handle(dm_hdl_t dma_hdl)
+{
+	u32	uret = 0;
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	if(NULL == pchan) {
+		uret = __LINE__;
+		goto end;
+	}
+	if(0 == pchan->used) { /* already released? */
+		uret = __LINE__;
+		goto end;
+	}
+	if(DMA_WORK_MODE_CHAIN != pchan->work_mode && DMA_WORK_MODE_SINGLE != pchan->work_mode) {
+		uret = __LINE__;
+		goto end;
+	}
+
+end:
+	if(0 != uret)
+		DMA_ERR("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+
+#ifdef DBG_DMA
+/**
+ * __dma_check_channel_free - check if channel is free
+ * @pchan:	dma handle
+ *
+ * return true if channel is free, false if not
+ *
+ * NOTE: can only be called in sw_dma_request recently, becase
+ * should be locked
+ */
+static u32 __dma_check_channel_free(struct dma_channel_t *pchan)
+{
+	if(0 == pchan->used
+		&& 0 == pchan->owner[0]
+		//&& CHAN_IRQ_NO == pchan->irq_spt /* maybe not use dma irq? */
+		&& NULL == pchan->hd_cb.func
+		&& NULL == pchan->fd_cb.func
+		&& NULL == pchan->qd_cb.func
+		&& NULL == pchan->op_cb.func
+		&& DMA_CHAN_STA_IDLE == STATE_CHAIN(pchan)
+		&& DMA_WORK_MODE_INVALID == pchan->work_mode
+		)
+		return true;
+	else {
+		dma_dump_chain(pchan);
+		return false;
+	}
+}
+#endif /* DBG_DMA */
+
+/**
+ * __dma_channel_already_exist - check if channel already requested by others
+ * @name:	channel name
+ *
+ * return true if channel already requested, false if not
+ */
+bool __dma_channel_already_exist(char *name)
+{
+	u32 i = 0;
+
+	if(NULL == name)
+		return false;
+	for(i = 0; i < DMA_CHAN_TOTAL; i++) {
+		if(1 == g_dma_mgr.chnl[i].used && !strcmp(g_dma_mgr.chnl[i].owner, name))
+			return true;
+	}
+	return false;
+}
+
+/**
+ * sw_dma_request - request a dma channel
+ * @name:	dma channel name
+ *
+ * Returns handle to the channel if success, NULL if failed.
+ */
+dm_hdl_t sw_dma_request(char *name, enum dma_work_mode_e work_mode)
+{
+	u32	i = 0;
+	u32	usign = 0;
+	struct dma_channel_t	*pchan = NULL;
+
+	DMA_DBG("%s: name %s, work_mode %d\n", __func__, name, (u32)work_mode);
+	if(strlen(name) >= MAX_OWNER_NAME_LEN || (work_mode != DMA_WORK_MODE_CHAIN && work_mode != DMA_WORK_MODE_SINGLE)) {
+		DMA_ERR("%s: para err, name %s, work mode %d\n", __func__, name, (u32)work_mode);
+		return NULL;
+	}
+
+	mutex_lock(&dma_mutex);
+
+	/* check if already exist */
+	if(NULL != name && __dma_channel_already_exist(name)) {
+		usign = __LINE__;
+		goto end;
+	}
+	/* get a free channel */
+	for(i = 0; i < DMA_CHAN_TOTAL; i++) {
+		pchan = &g_dma_mgr.chnl[i];
+		if(0 == pchan->used) {
+#ifdef DBG_DMA
+			if(true != __dma_check_channel_free(pchan))
+				DMA_ERR("%s(%d) err, channel is not free\n", __func__, __LINE__);
+#endif /* DBG_DMA */
+			break;
+		}
+	}
+	/* cannot get a free channel */
+	if(DMA_CHAN_TOTAL == i) {
+		usign = __LINE__;
+		goto end;
+	}
+
+	/* init channel */
+	if(DMA_WORK_MODE_CHAIN == work_mode) {
+		if(0 != dma_request_init_chain(pchan)) {
+			usign = __LINE__;
+			goto end;
+		}
+	} else if(DMA_WORK_MODE_SINGLE == work_mode) {
+		if(0 != dma_request_init_single(pchan)) {
+			usign = __LINE__;
+			goto end;
+		}
+#ifdef TEMP_FOR_XJF_20121121
+		v_addr = (u32)dma_alloc_coherent(NULL, TEMP_DES_CNT * sizeof(des_item), (dma_addr_t *)&p_addr, GFP_KERNEL);
+		if(0 == v_addr)
+			printk("%s err, dma_alloc_coherent failed, line %d\n", __func__, __LINE__);
+		else
+			printk("%s: dma_alloc_coherent return v_addr 0x%08x, p_addr 0x%08x\n", __func__, v_addr, p_addr);
+		index_get = 0;
+		index_put = 0;
+#endif /* TEMP_FOR_XJF_20121121 */
+	}
+	pchan->used = 1;
+	if(NULL != name)
+		strcpy(pchan->owner, name);
+	pchan->work_mode = work_mode;
+
+end:
+	mutex_unlock(&dma_mutex);
+	if(0 != usign) {
+		DMA_ERR("%s err, line %d\n", __func__, usign);
+		return (dm_hdl_t)NULL;
+	} else {
+		DMA_DBG("%s: success, channel id %d\n", __func__, i);
+		return (dm_hdl_t)pchan;
+	}
+}
+EXPORT_SYMBOL(sw_dma_request);
+
+/**
+ * sw_dma_release - free a dma channel
+ * @dma_hdl:	dma handle
+ *
+ * Returns 0 if sucess, other value if failed.
+ */
+u32 sw_dma_release(dm_hdl_t dma_hdl)
+{
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	BUG_ON(unlikely(NULL == pchan));
+	if(DMA_WORK_MODE_SINGLE == pchan->work_mode)
+		return dma_release_single(dma_hdl);
+	else
+		return dma_release_chain(dma_hdl);
+}
+EXPORT_SYMBOL(sw_dma_release);
+
+/**
+ * sw_dma_ctl - dma ctrl operation
+ * @dma_hdl:	dma handle
+ * @op:		dma operation type
+ * @parg:	arg for the op
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_dma_ctl(dm_hdl_t dma_hdl, enum dma_op_type_e op, void *parg)
+{
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	BUG_ON(unlikely(NULL == pchan));
+	if(DMA_WORK_MODE_SINGLE == pchan->work_mode)
+		return dma_ctrl_single(dma_hdl, op, parg);
+	else
+		return dma_ctrl_chain(dma_hdl, op, parg);
+}
+EXPORT_SYMBOL(sw_dma_ctl);
+
+/**
+ * sw_dma_config - config dma channel, enqueue the buffer
+ * @dma_hdl:	dma handle
+ * @pcfg:	dma cofig para
+ * @phase:	dma enqueue phase
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_dma_config(dm_hdl_t dma_hdl, struct dma_config_t *pcfg, enum dma_enque_phase_e phase)
+{
+	struct dma_channel_t	*pchan = (struct dma_channel_t *)dma_hdl;
+
+	BUG_ON(unlikely(NULL == pchan));
+	if(DMA_WORK_MODE_SINGLE == pchan->work_mode)
+		return dma_config_single(dma_hdl, pcfg, phase);
+	else
+		return dma_config_chain(dma_hdl, pcfg);
+}
+EXPORT_SYMBOL(sw_dma_config);
+
+/**
+ * sw_dma_enqueue - enqueue the buffer to des chain
+ * @dma_hdl:	dma handle
+ * @src_addr:	buffer src phys addr
+ * @dst_addr:	buffer dst phys addr
+ * @byte_cnt:	buffer byte cnt
+ * @phase:	enqueue phase
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_dma_enqueue(dm_hdl_t dma_hdl, u32 src_addr, u32 dst_addr, u32 byte_cnt,
+				enum dma_enque_phase_e phase)
+{
+	struct dma_channel_t 	*pchan = (struct dma_channel_t *)dma_hdl;
+
+	BUG_ON(unlikely(NULL == pchan));
+	if(DMA_WORK_MODE_SINGLE == pchan->work_mode)
+		return dma_enqueue_single(dma_hdl, src_addr, dst_addr, byte_cnt, phase);
+	else
+		return dma_enqueue_chain(dma_hdl, src_addr, dst_addr, byte_cnt);
+}
+EXPORT_SYMBOL(sw_dma_enqueue);
+
+/**
+ * sw_dma_getposition - get the src and dst address from the reg
+ * @dma_hdl:	dma handle
+ * @psrc:	pointed to src addr that will be got
+ * @pdst:	pointed to dst addr that will be got
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+int sw_dma_getposition(dm_hdl_t dma_hdl, u32 *psrc, u32 *pdst)
+{
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	if(NULL == dma_hdl || NULL == psrc || NULL == pdst) {
+		DMA_ERR("%s err, line %d\n", __func__, __LINE__);
+		return __LINE__;
+	}
+	if(0 == pchan->used) {
+		DMA_ERR("%s err, line %d\n", __func__, __LINE__);
+		return __LINE__;
+	}
+
+	*psrc = csp_dma_chan_get_cur_srcaddr(pchan);
+	*pdst = csp_dma_chan_get_cur_dstaddr(pchan);
+	DMA_DBG("%s: get *psrc 0x%08x, *pdst 0x%08x\n", __func__, *psrc, *pdst);
+	return 0;
+}
+EXPORT_SYMBOL(sw_dma_getposition);
+
+/**
+ * sw_dma_dump_chan - dump dma chain
+ * @dma_hdl:	dma handle
+ */
+void sw_dma_dump_chan(dm_hdl_t dma_hdl)
+{
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+	unsigned long	flags = 0;
+
+	BUG_ON(unlikely(NULL == pchan));
+
+	DMA_CHAN_LOCK(&pchan->lock, flags);
+	dma_dump_chain(pchan);
+	DMA_CHAN_UNLOCK(&pchan->lock, flags);
+}
+EXPORT_SYMBOL(sw_dma_dump_chan);
+
diff --git a/arch/arm/mach-sun6i/dma/dma_interface.h b/arch/arm/mach-sun6i/dma/dma_interface.h
new file mode 100644
index 0000000..cdc8ff1
--- /dev/null
+++ b/arch/arm/mach-sun6i/dma/dma_interface.h
@@ -0,0 +1,26 @@
+/*
+ * arch/arm/mach-sun6i/dma/dma_interface.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i dma header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __DMA_INTERFACE_H
+#define __DMA_INTERFACE_H
+
+extern struct dma_pool	 *g_des_pool;
+
+extern unsigned long addrtype_arr[];
+extern unsigned long xfer_arr[];
+
+extern u32 dma_check_handle(dm_hdl_t dma_hdl);
+
+#endif  /* __DMA_INTERFACE_H */
diff --git a/arch/arm/mach-sun6i/dma/dma_regs.h b/arch/arm/mach-sun6i/dma/dma_regs.h
new file mode 100644
index 0000000..6cd771c
--- /dev/null
+++ b/arch/arm/mach-sun6i/dma/dma_regs.h
@@ -0,0 +1,68 @@
+/*
+ * arch/arm/mach-sun6i/dma/dma_regs.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i dma regs defination
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __DMA_REGS_H
+#define __DMA_REGS_H
+
+/* dma reg off from DMAC_IO_BASE */
+#define DMA_IRQ_EN_REG0_OFF            		( 0x0000                        )
+#define DMA_IRQ_EN_REG1_OFF            		( 0x0004                        )
+#define DMA_IRQ_PEND_REG0_OFF            	( 0x0010                        )
+#define DMA_IRQ_PEND_REG1_OFF            	( 0x0014                        )
+#define DMA_STATE_REG_OFF            		( 0x0030                        )
+
+#define DMA_EN_REG_OFF(chan)            	( 0x100 + ((chan) << 6)        ) /* ( 0x100 + (chan) * 0x40        ) */
+#define DMA_PAUSE_REG_OFF(chan)            	( 0x100 + ((chan) << 6) + 0x4  )
+#define DMA_START_REG_OFF(chan)            	( 0x100 + ((chan) << 6) + 0x8  )
+#define DMA_CFG_REG_OFF(chan)            	( 0x100 + ((chan) << 6) + 0xC  )
+#define DMA_CUR_SRC_REG_OFF(chan)            	( 0x100 + ((chan) << 6) + 0x10 )
+#define DMA_CUR_DST_REG_OFF(chan)            	( 0x100 + ((chan) << 6) + 0x14 )
+#define DMA_BCNT_LEFT_REG_OFF(chan)            	( 0x100 + ((chan) << 6) + 0x18 )
+#define DMA_PARA_REG_OFF(chan)            	( 0x100 + ((chan) << 6) + 0x1C )
+
+/* reg offset from channel base */
+#define DMA_OFF_REG_EN            		( 0x0000                       )
+#define DMA_OFF_REG_PAUSE            		( 0x0004                       )
+#define DMA_OFF_REG_START            		( 0x0008                       )
+#define DMA_OFF_REG_CFG            		( 0x000C                       )
+#define DMA_OFF_REG_CUR_SRC            		( 0x0010                       )
+#define DMA_OFF_REG_CUR_DST            		( 0x0014                       )
+#define DMA_OFF_REG_BCNT_LEFT            	( 0x0018                       )
+#define DMA_OFF_REG_PARA            		( 0x001C                       )
+
+/* bits offset */
+#define DMA_OFF_BITS_SDRQ            		( 0                            )
+#define DMA_OFF_BITS_DDRQ            		( 16                           )
+
+/* dma reg addr */
+#define DMA_IRQ_EN_REG0            		( AW_VIR_DMA_BASE + DMA_IRQ_EN_REG0_OFF 	)
+#define DMA_IRQ_EN_REG1            		( AW_VIR_DMA_BASE + DMA_IRQ_EN_REG1_OFF 	)
+#define DMA_IRQ_PEND_REG0            		( AW_VIR_DMA_BASE + DMA_IRQ_PEND_REG0_OFF 	)
+#define DMA_IRQ_PEND_REG1            		( AW_VIR_DMA_BASE + DMA_IRQ_PEND_REG1_OFF 	)
+#define DMA_STATE_REG            		( AW_VIR_DMA_BASE + DMA_STATE_REG_OFF		)
+#define DMA_EN_REG(chan)            		( AW_VIR_DMA_BASE + DMA_EN_REG_OFF(chan)	)
+#define DMA_PAUSE_REG(chan)            		( AW_VIR_DMA_BASE + DMA_PAUSE_REG_OFF(chan)	)
+#define DMA_START_REG(chan)            		( AW_VIR_DMA_BASE + DMA_START_REG_OFF(chan)	)
+#define DMA_CFG_REG(chan)            		( AW_VIR_DMA_BASE + DMA_CFG_REG_OFF(chan)	)
+#define DMA_CUR_SRC_REG(chan)            	( AW_VIR_DMA_BASE + DMA_CUR_SRC_REG_OFF(chan)	)
+#define DMA_CUR_DST_REG(chan)            	( AW_VIR_DMA_BASE + DMA_CUR_DST_REG_OFF(chan)	)
+#define DMA_BCNT_LEFT_REG(chan)            	( AW_VIR_DMA_BASE + DMA_BCNT_LEFT_REG_OFF(chan))
+#define DMA_PARA_REG(chan)            		( AW_VIR_DMA_BASE + DMA_PARA_REG_OFF(chan)	)
+
+/* dma reg rw */
+#define DMA_READ_REG(reg)			readl(reg)
+#define DMA_WRITE_REG(val, reg)			writel(val, reg)
+
+#endif  /* __DMA_REGS_H */
diff --git a/arch/arm/mach-sun6i/dma/dma_single.c b/arch/arm/mach-sun6i/dma/dma_single.c
new file mode 100644
index 0000000..a84dd3bc
--- /dev/null
+++ b/arch/arm/mach-sun6i/dma/dma_single.c
@@ -0,0 +1,622 @@
+/*
+ * arch/arm/mach-sun6i/dma/dma_single.c
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i dma driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include "dma_include.h"
+
+/* 找到链上第一个buffer, 移出队列, start它 */
+u32 __dma_start(dm_hdl_t dma_hdl)
+{
+	u32	uret = 0;
+	des_item *pdes_item = NULL;
+	struct dma_channel_t 	*pchan = (struct dma_channel_t *)dma_hdl;
+
+	if(list_empty(&pchan->buf_list_head)) {
+		uret = __LINE__;
+		goto end;
+	}
+
+	/* remove from list */
+	pdes_item = list_entry(pchan->buf_list_head.next, des_item, list);
+	list_del(&pdes_item->list); /* 只是从链表移除, 未释放空间 */
+
+	DMA_WRITE_REG(pdes_item->paddr, pchan->reg_base + DMA_OFF_REG_START);
+	csp_dma_chan_start(pchan);
+	STATE_SGL(pchan) = SINGLE_STA_RUNING;
+	pchan->pcur_des = pdes_item;
+
+end:
+	if(0 != uret)
+		DMA_ERR("%s err, line %d, dma_hdl 0x%08x\n", __func__, uret, (u32)dma_hdl);
+	return uret;
+}
+
+void __dma_pause(dm_hdl_t dma_hdl)
+{
+	csp_dma_chan_pause((struct dma_channel_t *)dma_hdl);
+}
+
+void __dma_resume(dm_hdl_t dma_hdl)
+{
+	csp_dma_chan_resume((struct dma_channel_t *)dma_hdl);
+}
+
+/* not include cur buf */
+u32 __dma_free_buflist(struct dma_channel_t *pchan)
+{
+	u32	utemp = 0;
+	des_item *pdes_item = NULL;
+
+	while (!list_empty(&pchan->buf_list_head)) {
+		pdes_item = list_entry(pchan->buf_list_head.next, des_item, list);
+		utemp = pdes_item->paddr;
+		list_del(&pdes_item->list);
+#ifndef TEMP_FOR_XJF_20121121
+		dma_pool_free(g_des_pool, pdes_item, utemp);
+#else
+		index_put++;
+		if(index_put >= TEMP_DES_CNT)
+			index_put = 0;
+#endif /* TEMP_FOR_XJF_20121121 */
+	}
+	return 0;
+}
+
+/* include cur buf */
+u32 __dma_free_allbuf(struct dma_channel_t *pchan)
+{
+	u32	utemp = 0;
+
+	if(NULL != pchan->pcur_des) {
+		utemp = pchan->pcur_des->paddr;
+#ifndef TEMP_FOR_XJF_20121121
+		dma_pool_free(g_des_pool, pchan->pcur_des, utemp);
+#else
+		index_put++;
+		if(index_put >= TEMP_DES_CNT)
+			index_put = 0;
+		//if(index_put > index_get)
+		//	printk("%s err: index_put %d > index_get %d", __func__, index_put, index_get);
+#endif /* TEMP_FOR_XJF_20121121 */
+		pchan->pcur_des = NULL;
+	}
+
+	__dma_free_buflist(pchan);
+	return 0;
+}
+
+/* abort回调, 硬件上stop, 释放当前buffer(如果有), 释放list buffer */
+u32 __dma_stop(dm_hdl_t dma_hdl)
+{
+	u32 	uret = 0;
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	DMA_INF("%s: state %d, buf chain: \n", __func__, (u32)STATE_SGL(pchan));
+	//dma_dump_chain(pchan);
+
+	switch(STATE_SGL(pchan)) {
+	case SINGLE_STA_IDLE:
+		DMA_INF("%s: state idle, maybe before start or after stop, so stop the channel, free all buf list\n", __func__);
+		WARN(NULL != pchan->pcur_des, "%s err, line %d!\n", __func__, __LINE__);
+		break;
+	case SINGLE_STA_RUNING:
+		DMA_INF("%s: state running, so stop the channel, abort the cur buf, and free extra buf\n", __func__);
+		WARN(NULL == pchan->pcur_des, "%s err, line %d!\n", __func__, __LINE__);
+		break;
+	case SINGLE_STA_LAST_DONE:
+		DMA_INF("%s: state last done, so stop the channel, buffer already freed all, to check\n", __func__);
+		WARN(NULL != pchan->pcur_des || !list_empty(&pchan->buf_list_head),
+			"%s err, line %d!\n", __func__, __LINE__);
+		break;
+	default:
+		uret = __LINE__;
+		goto end;
+	}
+
+	/* stop dma channle and clear irq pending */
+	csp_dma_chan_stop(pchan);
+	csp_dma_chan_clear_irqpend(pchan, CHAN_IRQ_HD | CHAN_IRQ_FD | CHAN_IRQ_QD);
+
+	/* free buffer list */
+	__dma_free_allbuf(pchan);
+
+	/* change channel state to idle */
+	STATE_SGL(pchan) = SINGLE_STA_IDLE;
+
+end:
+	if(0 != uret)
+		DMA_ERR("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+
+u32 __dma_get_status(dm_hdl_t dma_hdl, u32 *pval)
+{
+	*pval = csp_dma_chan_get_status((struct dma_channel_t *)dma_hdl);
+	return 0;
+}
+
+u32 __dma_get_cur_src_addr(dm_hdl_t dma_hdl, u32 *pval)
+{
+	*pval = csp_dma_chan_get_cur_srcaddr((struct dma_channel_t *)dma_hdl);
+	return 0;
+}
+
+u32 __dma_get_cur_dst_addr(dm_hdl_t dma_hdl, u32 *pval)
+{
+	*pval = csp_dma_chan_get_cur_dstaddr((struct dma_channel_t *)dma_hdl);
+	return 0;
+}
+
+u32 __dma_get_left_bytecnt(dm_hdl_t dma_hdl, u32 *pval)
+{
+	*pval = csp_dma_chan_get_left_bytecnt((struct dma_channel_t *)dma_hdl);
+	return 0;
+}
+
+u32 __dma_set_op_cb(dm_hdl_t dma_hdl, struct dma_op_cb_t *pcb)
+{
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	if(SINGLE_STA_IDLE != STATE_SGL(pchan))
+		DMA_ERR("%s err, line %d\n", __func__, __LINE__);
+	pchan->op_cb.func = pcb->func;
+	pchan->op_cb.parg = pcb->parg;
+	return 0;
+}
+
+u32 __dma_set_hd_cb(dm_hdl_t dma_hdl, struct dma_cb_t *pcb)
+{
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	if(SINGLE_STA_IDLE != STATE_SGL(pchan))
+		DMA_ERR("%s err, line %d\n", __func__, __LINE__);
+	pchan->hd_cb.func = pcb->func;
+	pchan->hd_cb.parg = pcb->parg;
+	return 0;
+}
+
+u32 __dma_set_fd_cb(dm_hdl_t dma_hdl, struct dma_cb_t *pcb)
+{
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	if(SINGLE_STA_IDLE != STATE_SGL(pchan))
+		DMA_ERR("%s err, line %d\n", __func__, __LINE__);
+	pchan->fd_cb.func = pcb->func;
+	pchan->fd_cb.parg = pcb->parg;
+	return 0;
+}
+
+u32 __dma_set_qd_cb(dm_hdl_t dma_hdl, struct dma_cb_t *pcb)
+{
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	if(SINGLE_STA_IDLE != STATE_SGL(pchan))
+		DMA_ERR("%s err, line %d\n", __func__, __LINE__);
+	pchan->qd_cb.func = pcb->func;
+	pchan->qd_cb.parg = pcb->parg;
+	return 0;
+}
+
+u32 __dma_enqueue(dm_hdl_t dma_hdl, struct cofig_des_t *pdes, enum dma_enque_phase_e phase)
+{
+	u32 	uret = 0;
+	u32 	utemp = 0;
+	struct dma_channel_t 	*pchan = (struct dma_channel_t *)dma_hdl;
+	des_item	*pdes_itm = NULL;
+
+#ifdef TEMP_FOR_XJF_20121121
+	u32 offset = 0;
+	offset = sizeof(des_item) * index_get;
+	pdes_itm = (des_item *)(v_addr + offset);
+	utemp = p_addr + offset;
+	index_get++;
+	if(index_get >= TEMP_DES_CNT)
+		index_get = 0;
+	if(index_get == index_put)
+		printk("%s err: des buffer full, to check!", __func__);
+#else
+	pdes_itm = (des_item *)dma_pool_alloc(g_des_pool, GFP_ATOMIC, &utemp);
+	if (NULL == pdes_itm) {
+		uret = __LINE__;
+		goto end;
+	}
+#endif /* TEMP_FOR_XJF_20121121 */
+	pdes_itm->des = *pdes;
+	pdes_itm->paddr = utemp;
+
+	/* 不管状态怎样, enqueue to list */
+	list_add_tail(&pdes_itm->list, &pchan->buf_list_head);
+
+	if(SINGLE_STA_LAST_DONE == STATE_SGL(pchan)) {
+		if(ENQUE_PHASE_NORMAL != phase)
+			DMA_ERR("%s err, line %d\n", __func__, __LINE__);
+		DMA_INF("%s, line %d\n", __func__, __LINE__);
+		if(0 != __dma_start(dma_hdl)) {
+			uret = __LINE__;
+			goto end;
+		}
+	}
+end:
+	if(0 != uret)
+		DMA_ERR("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+
+u32 __handle_qd_sgmd(struct dma_channel_t *pchan)
+{
+	u32 		uret = 0;
+	u32 		utemp = 0;
+	unsigned long	flags = 0;
+	enum st_md_single_e cur_state = 0;
+
+	/* cannot lock fd_cb function, in case sw_dma_enqueue called and locked agin */
+	if(NULL != pchan->qd_cb.func) {
+		if(0 != pchan->qd_cb.func((dm_hdl_t)pchan, pchan->qd_cb.parg, DMA_CB_OK))
+			DMA_ERR("%s err, line %d\n", __func__, __LINE__);
+	}
+
+	DMA_CHAN_LOCK(&pchan->lock, flags);
+
+	cur_state = STATE_SGL(pchan);
+
+	/* stopped when hd_cb/fd_cb/qd_cb/somewhere calling? */
+	if(SINGLE_STA_IDLE == cur_state) {
+		WARN(NULL != pchan->pcur_des, "%s err, line %d!\n", __func__, __LINE__);
+		DMA_INF("%s: state idle, stopped in cb before? just return ok!\n", __func__);
+		goto end;
+	} else if(SINGLE_STA_RUNING == cur_state) {
+		/* for continue mode, just re start the cur buffer */
+		if(unlikely(true == pchan->bconti_mode)) {
+			WARN(!list_empty(&pchan->buf_list_head), "%s err, line %d!\n", __func__, __LINE__);
+			list_add_tail(&pchan->pcur_des->list, &pchan->buf_list_head);
+			uret = __dma_start((dm_hdl_t)pchan);
+			goto end;
+		}
+
+		/* for no-continue mode, free cur buf and start the next buf in chain */
+		WARN(NULL == pchan->pcur_des, "%s err, line %d!\n", __func__, __LINE__);
+		utemp = pchan->pcur_des->paddr;
+#ifndef TEMP_FOR_XJF_20121121
+		dma_pool_free(g_des_pool, pchan->pcur_des, utemp);
+#else
+		index_put++;
+		if(index_put >= TEMP_DES_CNT)
+			index_put = 0;
+#endif /* TEMP_FOR_XJF_20121121 */
+		pchan->pcur_des = NULL;
+
+		/* start next if there is, or change to last done */
+		if(!list_empty(&pchan->buf_list_head)) {
+			if(0 != __dma_start((dm_hdl_t)pchan)) {
+				uret = __LINE__;
+				goto end;
+			}
+		} else {
+			DMA_INF("%s(%d), all buf done, change state to last done\n", __func__, __LINE__);
+			STATE_CHAIN(pchan) = SINGLE_STA_LAST_DONE; /* change state to done */
+		}
+	} else { /* should never be last done */
+		uret = __LINE__;
+		goto end;
+	}
+
+end:
+	DMA_CHAN_UNLOCK(&pchan->lock, flags);
+	if(0 != uret)
+		DMA_ERR("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+
+u32 dma_request_init_single(struct dma_channel_t *pchan)
+{
+	INIT_LIST_HEAD(&pchan->buf_list_head);
+	STATE_SGL(pchan) = SINGLE_STA_IDLE;
+
+	/* init for chain mode, incase err access by someone */
+	INIT_LIST_HEAD(&pchan->cur_list);
+	INIT_LIST_HEAD(&pchan->next_list);
+	return 0;
+}
+
+/**
+ * dma_release_single - release dma channel, for single mode
+ * @dma_hdl:	dma handle
+ *
+ * return 0 if success, the err line number if not
+ */
+u32 dma_release_single(dm_hdl_t dma_hdl)
+{
+	unsigned long 	flags = 0;
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	DMA_CHAN_LOCK(&pchan->lock, flags);
+
+#ifdef DBG_DMA
+	if(0 != dma_check_handle(dma_hdl)) {
+		DMA_CHAN_UNLOCK(&pchan->lock, flags);
+		DMA_ERR("%s err, line %d\n", __func__, __LINE__);
+		return __LINE__;
+	}
+#endif /* DBG_DMA */
+
+	/* if not idle, call stop first */
+	if(SINGLE_STA_IDLE != STATE_SGL(pchan)) {
+		DMA_INF("%s maybe err: line %d, state(%d) not idle, call stop dma first!\n", \
+			__func__, __LINE__, STATE_SGL(pchan));
+		if(0 != __dma_stop(dma_hdl))
+			DMA_ERR("%s err, line %d\n", __func__, __LINE__);
+	}
+
+	//memset(pchan, 0, sizeof(*pchan)); /* donot do that, because id...shouldnot be cleared */
+	pchan->used 	= 0;
+	memset(pchan->owner, 0, sizeof(pchan->owner));
+
+	pchan->irq_spt 	= CHAN_IRQ_NO;
+	pchan->bconti_mode = false;
+	memset(&pchan->des_info_save, 0, sizeof(pchan->des_info_save));
+
+	pchan->work_mode = DMA_WORK_MODE_INVALID;
+
+	memset(&pchan->op_cb, 0, sizeof(pchan->op_cb));
+	memset(&pchan->hd_cb, 0, sizeof(pchan->hd_cb));
+	memset(&pchan->fd_cb, 0, sizeof(pchan->fd_cb));
+	memset(&pchan->qd_cb, 0, sizeof(pchan->qd_cb));
+
+	/* maybe enqueued but not started, so free buf */
+	WARN(NULL != pchan->pcur_des, "%s err, line %d!\n", __func__, __LINE__);
+	__dma_free_buflist(pchan);
+
+	DMA_CHAN_UNLOCK(&pchan->lock, flags);
+	return 0;
+}
+
+/**
+ * dma_ctrl_single - dma ctrl, for single mode
+ * @dma_hdl:	dma handle
+ * @op:		dma operation type
+ * @parg:	arg for the op
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 dma_ctrl_single(dm_hdl_t dma_hdl, enum dma_op_type_e op, void *parg)
+{
+	u32		uret = 0;
+	unsigned long	flags = 0;
+	struct dma_channel_t *pchan = (struct dma_channel_t *)dma_hdl;
+
+	/* only in start/stop/pause/resume case can parg be NULL  */
+	if((NULL == parg)
+		&& (DMA_OP_START != op)
+		&& (DMA_OP_PAUSE != op)
+		&& (DMA_OP_RESUME != op)
+		&& (DMA_OP_STOP != op)) {
+		DMA_ERR("%s err, line %d\n", __func__, __LINE__);
+		return __LINE__;
+	}
+
+	DMA_CHAN_LOCK(&pchan->lock, flags);
+
+#ifdef DBG_DMA
+	if(0 != dma_check_handle(dma_hdl)) {
+		DMA_CHAN_UNLOCK(&pchan->lock, flags);
+		DMA_ERR("%s err, line %d\n", __func__, __LINE__);
+		return __LINE__;
+	}
+#endif /* DBG_DMA */
+
+	/* let the caller to do some operation before op */
+	if((DMA_OP_SET_OP_CB != op) && (NULL != pchan->op_cb.func)) {
+		if(0 != pchan->op_cb.func(dma_hdl, pchan->op_cb.parg, op))
+			DMA_ERR("%s err, line %d\n", __func__, __LINE__);
+	}
+
+	switch(op) {
+	case DMA_OP_START:
+		uret = __dma_start(dma_hdl);
+		break;
+	case DMA_OP_PAUSE:
+		__dma_pause(dma_hdl);
+		break;
+	case DMA_OP_RESUME:
+		__dma_resume(dma_hdl);
+		break;
+	case DMA_OP_STOP:
+		uret = __dma_stop(dma_hdl);
+		break;
+	case DMA_OP_GET_STATUS:
+		*(u32 *)parg = csp_dma_chan_get_status(pchan);
+		break;
+	case DMA_OP_GET_CUR_SRC_ADDR:
+		*(u32 *)parg = csp_dma_chan_get_cur_srcaddr(pchan);
+		break;
+	case DMA_OP_GET_CUR_DST_ADDR:
+		*(u32 *)parg = csp_dma_chan_get_cur_dstaddr(pchan);
+		break;
+	case DMA_OP_GET_BYTECNT_LEFT:
+		*(u32 *)parg = csp_dma_chan_get_left_bytecnt(pchan);
+		break;
+	case DMA_OP_SET_OP_CB:
+		uret = __dma_set_op_cb(dma_hdl, (struct dma_op_cb_t *)parg);
+		break;
+	case DMA_OP_SET_HD_CB:
+		uret = __dma_set_hd_cb(dma_hdl, (struct dma_cb_t *)parg);
+		break;
+	case DMA_OP_SET_FD_CB:
+		uret = __dma_set_fd_cb(dma_hdl, (struct dma_cb_t *)parg);
+		break;
+	case DMA_OP_SET_QD_CB:
+		uret = __dma_set_qd_cb(dma_hdl, (struct dma_cb_t *)parg);
+		break;
+	default:
+		uret = __LINE__;
+		goto end;
+	}
+
+end:
+	DMA_CHAN_UNLOCK(&pchan->lock, flags);
+	if(0 != uret)
+		DMA_ERR("%s err, line %d, dma_hdl 0x%08x\n", __func__, uret, (u32)dma_hdl);
+	return uret;
+}
+
+/**
+ * dma_config_single - config dma channel, enqueue the buffer, for single mode only
+ * @dma_hdl:	dma handle
+ * @pcfg:	dma cofig para
+ * @phase:	dma enqueue phase
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 dma_config_single(dm_hdl_t dma_hdl, struct dma_config_t *pcfg, enum dma_enque_phase_e phase)
+{
+	u32 		uret = 0;
+	u32		uConfig = 0;
+	unsigned long	flags = 0;
+	struct cofig_des_t	des;
+	struct dma_channel_t	*pchan = (struct dma_channel_t *)dma_hdl;
+
+	/* get dma config val */
+	uConfig |= xfer_arr[pcfg->xfer_type]; /* src/dst burst length and data width */
+	uConfig |= addrtype_arr[pcfg->address_type]; /* src/dst address mode */
+	uConfig |= (pcfg->src_drq_type << DMA_OFF_BITS_SDRQ)
+			| (pcfg->dst_drq_type << DMA_OFF_BITS_DDRQ); /* src/dst drq type */
+
+	/* fill cofig_des_t struct */
+	memset(&des, 0, sizeof(des));
+	des.cofig = uConfig;
+	des.saddr = pcfg->src_addr;
+	des.daddr = pcfg->dst_addr;
+	des.bcnt  = pcfg->byte_cnt;
+	des.param = pcfg->para;
+	des.pnext = (struct cofig_des_t *)DMA_END_DES_LINK;
+	/* get continue mode flag */
+	pchan->bconti_mode = pcfg->bconti_mode;
+	/* get irq surport type for channel handle */
+	pchan->irq_spt = pcfg->irq_spt;
+	/* bkup config/param */
+	pchan->des_info_save.cofig = uConfig;
+	pchan->des_info_save.param = pcfg->para;
+	pchan->des_info_save.bconti_mode = pcfg->bconti_mode;
+
+	/*
+	 * when called in irq, just use spin_lock, not spin_lock_irqsave
+	 */
+	DMA_CHAN_LOCK(&pchan->lock, flags);
+
+	/* cannot enqueue more than one buffer in single_continue mode */
+	if(true == pcfg->bconti_mode
+		&& !list_empty(&pchan->buf_list_head)) {
+		uret = __LINE__;
+		goto end;
+	}
+
+	/* irq enable */
+	csp_dma_chan_irq_enable(pchan, pcfg->irq_spt);
+
+	/* des enqueue */
+	if(0 != __dma_enqueue(dma_hdl, &des, phase)) {
+		uret = __LINE__;
+		goto end;
+	}
+
+end:
+	DMA_CHAN_UNLOCK(&pchan->lock, flags);
+	if(0 != uret)
+		DMA_ERR("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+
+/**
+ * sw_dma_enqueue - enqueue the buffer, for single mode only
+ * @dma_hdl:	dma handle
+ * @src_addr:	buffer src phys addr
+ * @dst_addr:	buffer dst phys addr
+ * @byte_cnt:	buffer byte cnt
+ * @phase:	enqueue phase
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 dma_enqueue_single(dm_hdl_t dma_hdl, u32 src_addr, u32 dst_addr, u32 byte_cnt,
+				enum dma_enque_phase_e phase)
+{
+	u32 			uret = 0;
+	unsigned long		flags = 0;
+	struct cofig_des_t	des;
+	struct dma_channel_t 	*pchan = (struct dma_channel_t *)dma_hdl;
+
+	memset(&des, 0, sizeof(des));
+	des.saddr 	= src_addr;
+	des.daddr 	= dst_addr;
+	des.bcnt 	= byte_cnt;
+	des.cofig 	= pchan->des_info_save.cofig;
+	des.param 	= pchan->des_info_save.param;
+	des.pnext	= (struct cofig_des_t *)DMA_END_DES_LINK;
+
+	/*
+	 * when called in irq, just use spin_lock, not spin_lock_irqsave
+	 */
+	DMA_CHAN_LOCK(&pchan->lock, flags);
+
+	/* cannot enqueue more than one buffer in single_continue mode */
+	if(true == pchan->bconti_mode
+		&& !list_empty(&pchan->buf_list_head)) {
+		uret = __LINE__;
+		goto end;
+	}
+
+	if(0 != __dma_enqueue(dma_hdl, &des, phase)) {
+		uret = __LINE__;
+		goto end;
+	}
+
+end:
+	DMA_CHAN_UNLOCK(&pchan->lock, flags);
+
+	if(0 != uret)
+		DMA_ERR("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+
+/**
+ * dma_irq_hdl_sgmd - dma irq handle, for single mode only
+ * @pchan:	dma channel handle
+ * @upend_bits:	irq pending for the channel
+ *
+ */
+void dma_irq_hdl_single(struct dma_channel_t *pchan, u32 upend_bits)
+{
+	u32	uirq_spt = 0;
+
+	WARN(0 == upend_bits, "%s err, line %d!\n", __func__, __LINE__);
+	uirq_spt = pchan->irq_spt;
+
+	/* deal half done */
+	if(upend_bits & CHAN_IRQ_HD) {
+		csp_dma_chan_clear_irqpend(pchan, CHAN_IRQ_HD);
+		if((uirq_spt & CHAN_IRQ_HD) && NULL != pchan->hd_cb.func)
+			pchan->hd_cb.func((dm_hdl_t)pchan, pchan->hd_cb.parg, DMA_CB_OK);
+	}
+	/* deal full done */
+	if(upend_bits & CHAN_IRQ_FD) {
+		csp_dma_chan_clear_irqpend(pchan, CHAN_IRQ_FD);
+		if((uirq_spt & CHAN_IRQ_FD) && NULL != pchan->fd_cb.func)
+			pchan->fd_cb.func((dm_hdl_t)pchan, pchan->fd_cb.parg, DMA_CB_OK);
+	}
+	/* deal queue done */
+	if(upend_bits & CHAN_IRQ_QD) {
+		csp_dma_chan_clear_irqpend(pchan, CHAN_IRQ_QD);
+		if(uirq_spt & CHAN_IRQ_QD)
+			__handle_qd_sgmd(pchan);
+	}
+}
diff --git a/arch/arm/mach-sun6i/dma/dma_single.h b/arch/arm/mach-sun6i/dma/dma_single.h
new file mode 100644
index 0000000..c2b124b
--- /dev/null
+++ b/arch/arm/mach-sun6i/dma/dma_single.h
@@ -0,0 +1,27 @@
+/*
+ * arch/arm/mach-sun6i/dma/dma_single.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i dma header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __DMA_SINGLE_H
+#define __DMA_SINGLE_H
+
+void dma_irq_hdl_single(struct dma_channel_t *pchan, u32 upend_bits);
+u32 dma_enqueue_single(dm_hdl_t dma_hdl, u32 src_addr, u32 dst_addr, u32 byte_cnt,
+				enum dma_enque_phase_e phase);
+u32 dma_config_single(dm_hdl_t dma_hdl, struct dma_config_t *pcfg, enum dma_enque_phase_e phase);
+u32 dma_ctrl_single(dm_hdl_t dma_hdl, enum dma_op_type_e op, void *parg);
+u32 dma_release_single(dm_hdl_t dma_hdl);
+u32 dma_request_init_single(struct dma_channel_t *pchan);
+
+#endif  /* __DMA_SINGLE_H */
diff --git a/arch/arm/mach-sun6i/dram-freq/Makefile b/arch/arm/mach-sun6i/dram-freq/Makefile
new file mode 100644
index 0000000..1b47a55
--- /dev/null
+++ b/arch/arm/mach-sun6i/dram-freq/Makefile
@@ -0,0 +1,2 @@
+
+obj-y  += dram-freq.o mdfs.o
diff --git a/arch/arm/mach-sun6i/dram-freq/dram-freq.c b/arch/arm/mach-sun6i/dram-freq/dram-freq.c
new file mode 100644
index 0000000..c911544
--- /dev/null
+++ b/arch/arm/mach-sun6i/dram-freq/dram-freq.c
@@ -0,0 +1,454 @@
+/*
+ * arch/arm/mach-sun6i/dram-freq/dram-freq.c
+ *
+ * Copyright (C) 2012 - 2016 Reuuimlla Limited
+ * Pan Nan <pannan@reuuimllatech.com>
+ *
+ * SUN6I dram frequency dynamic scaling driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/suspend.h>
+#include <linux/devfreq.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <mach/clock.h>
+#include <mach/system.h>
+#include <mach/sys_config.h>
+#include <mach/dram-freq.h>
+
+#undef DRAMFREQ_ERR
+#undef DRAMFREQ_DBG
+#if (1)
+    #define DRAMFREQ_DBG(format,args...)   printk("[dramfreq] "format,##args)
+#else
+    #define DRAMFREQ_DBG(format,args...)   do{}while(0)
+#endif
+#define DRAMFREQ_ERR(format,args...)   printk(KERN_ERR "[dramfreq] ERR:"format,##args)
+
+extern char *mdfs_bin_start;
+extern char *mdfs_bin_end;
+
+static struct srcu_notifier_head dramfreq_transition_notifier;
+static bool init_dramfreq_transition_notifier_called;
+
+static int __init init_dramfreq_transition_notifier(void)
+{
+	srcu_init_notifier_head(&dramfreq_transition_notifier);
+	init_dramfreq_transition_notifier_called = true;
+	return 0;
+}
+pure_initcall(init_dramfreq_transition_notifier);
+
+static struct clk *clk_pll5; /* pll5 clock handler */
+static unsigned int master_bw_usage[MASTER_MAX] = {0};
+static unsigned int bw_cnt_hist[MASTER_MAX] = {0};
+struct aw_mdfs_info mdfs_info;
+static spinlock_t mdfs_spin_lock;
+struct devfreq *this_df = NULL;
+static unsigned int dram_clk_syscfg = 0;
+static unsigned int pll5_freq = 0;
+static unsigned int dram_freq_table[SUN6I_DRAMFREQ_TABLE_SIZE][2] = {{0}};
+
+struct master_info master_info_list[MASTER_INFO_SIZE] = {
+    { MASTER_CPUX, "CPUX" },
+    { MASTER_GPU0, "GPU0" },
+    { MASTER_GPU1, "GPU1" },
+    { MASTER_CPUS, "CPUS" },
+    { MASTER_ATH , "ATH"  },
+    { MASTER_GMAC, "GMAC" },
+    { MASTER_SDC0, "SDC0" },
+    { MASTER_SDC1, "SDC1" },
+    { MASTER_SDC2, "SDC2" },
+    { MASTER_SDC3, "SDC3" },
+    { MASTER_USB , "USB"  },
+    { MASTER_NFC1, "NFC1" },
+    { MASTER_DMAC, "DMAC" },
+    { MASTER_VE  , "VE"   },
+    { MASTER_MP  , "MP"   },
+    { MASTER_NFC0, "NFC0" },
+    { MASTER_DRC0, "DRC0" },
+    { MASTER_DRC1, "DRC1" },
+    { MASTER_DEU0, "DEU0" },
+    { MASTER_DEU1, "DEU1" },
+    { MASTER_BE0 , "BE0"  },
+    { MASTER_FE0 , "FE0"  },
+    { MASTER_BE1 , "BE1"  },
+    { MASTER_FE1 , "FE1"  },
+    { MASTER_CSI0, "CSI0" },
+    { MASTER_CSI1, "CSI1" },
+    { MASTER_TS  , "TS"   },
+    { MASTER_ALL , "ALL"  },
+};
+
+
+int dramfreq_register_notifier(struct notifier_block *nb)
+{
+	WARN_ON(!init_dramfreq_transition_notifier_called);
+	return srcu_notifier_chain_register(&dramfreq_transition_notifier, nb);
+}
+EXPORT_SYMBOL_GPL(dramfreq_register_notifier);
+
+int dramfreq_unregister_notifier(struct notifier_block *nb)
+{
+	return srcu_notifier_chain_unregister(&dramfreq_transition_notifier, nb);
+}
+EXPORT_SYMBOL_GPL(dramfreq_unregister_notifier);
+
+int dramfreq_notify_transition(unsigned int state, struct dramfreq_udata *data)
+{
+	switch (state) {
+	case DRAMFREQ_PRECHANGE:
+		srcu_notifier_call_chain(&dramfreq_transition_notifier, DRAMFREQ_PRECHANGE, data);
+		break;
+	case DRAMFREQ_POSTCHANGE:
+		srcu_notifier_call_chain(&dramfreq_transition_notifier, DRAMFREQ_POSTCHANGE, data);
+		break;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dramfreq_notify_transition);
+
+
+static int dramfreq_table_target(unsigned long *target_freq, unsigned int *index)
+{
+    int i = 0;
+    int j = 0;
+
+    while (((dram_freq_table[i+1][0] >= *target_freq)
+            || (dram_freq_table[i+1][0] == 0)) && (i < (SUN6I_DRAMFREQ_TABLE_SIZE - 1)))
+    {
+        if (dram_freq_table[i+1][0] != 0) {
+            j = (i + 1);
+        }
+        i++;
+    }
+    *index = j;
+
+    return 0;
+}
+
+static unsigned long __dramfreq_get(struct clk *pll5)
+{
+    unsigned long pll5_rate, dram_freq;
+    unsigned int dram_div;
+
+    pll5_rate = clk_get_rate(pll5) / 1000;
+    dram_div = 1 + ((readl(CCM_DRAMCLK_CFG_CTRL) >> 8) & 0xf);
+    dram_freq = pll5_rate / dram_div;
+
+    return dram_freq;
+}
+
+/**
+ * dramfreq_get - get the current DRAM frequency (in KHz)
+ *
+ */
+unsigned long dramfreq_get(void)
+{
+    return __dramfreq_get(clk_pll5);
+}
+EXPORT_SYMBOL_GPL(dramfreq_get);
+
+/**
+ * 	freq_div: PLL5/freq_div = current frequency
+ */
+int __dramfreq_set(unsigned int freq_div)
+{
+    int (*mdfs_main)(struct aw_mdfs_info *mdfs);
+    unsigned long flags;
+
+    if ((freq_div < 1) || (freq_div > 16)) {
+        DRAMFREQ_ERR("mdfs div=%u is invalid\n", freq_div);
+        return -1;
+    }
+
+    mdfs_main = (int (*)(struct aw_mdfs_info *mdfs))SRAM_MDFS_START;
+
+    /* move mdfs_main code to sram */
+    memcpy((void *)SRAM_MDFS_START, (void *)&mdfs_bin_start, (int)&mdfs_bin_end - (int)&mdfs_bin_start);
+    mdfs_info.div = freq_div;
+
+    spin_lock_irqsave(&mdfs_spin_lock, flags);
+    /* goto sram and run */
+    mdfs_main(&mdfs_info);
+    spin_unlock_irqrestore(&mdfs_spin_lock, flags);
+    DRAMFREQ_DBG("MDFS finish\n");
+
+	return 0;
+}
+
+static int dramfreq_target(struct device *dev, unsigned long *freq, u32 flags)
+{
+    struct platform_device *pdev = container_of(dev, struct platform_device, dev);
+    struct devfreq *df = platform_get_drvdata(pdev);
+    struct dramfreq_udata *user_data = (struct dramfreq_udata *)df->data;
+    unsigned int dram_div = 0;
+    unsigned long freq_target = 0;
+    int index = 0;
+    int ret = 0;
+
+    if (*freq == df->previous_freq) {
+        DRAMFREQ_DBG("freq_calc == df->previous_freq\n");
+        return 0;
+    }
+
+    dramfreq_table_target(freq, &index);
+    dram_div = dram_freq_table[index][1];
+
+    freq_target = pll5_freq / dram_div;
+    DRAMFREQ_DBG("dram target frequency is find: %luMHz, entry %u\n", freq_target / 1000, index);
+    if (freq_target == df->previous_freq) {
+        DRAMFREQ_DBG("freq_target == df->previous_freq\n");
+        *freq = freq_target;
+        return 0;
+    }
+
+    dramfreq_notify_transition(DRAMFREQ_PRECHANGE, user_data);
+    ret = __dramfreq_set(dram_div);
+    if (ret) {
+        DRAMFREQ_ERR("set dram frequency hw failed!\n");
+        user_data->freq_to_user = df->previous_freq;
+        dramfreq_notify_transition(DRAMFREQ_POSTCHANGE, user_data);
+        return ret;
+    }
+
+    *freq = freq_target;
+    user_data->freq_to_user = freq_target;
+    dramfreq_notify_transition(DRAMFREQ_POSTCHANGE, user_data);
+
+    DRAMFREQ_DBG("dram: %luMHz->%luMHz ok!\n", df->previous_freq / 1000, freq_target / 1000);
+
+    return 0;
+}
+
+static void __update_master_bw(void)
+{
+    int i, bw_cnt_cur, bw_usage;
+    enum master_type mt;
+
+    for (i = 0; i < ARRAY_SIZE(master_info_list); i++) {
+        mt = master_info_list[i].type;
+        writel(mt << 1 | 1, SDR_COM_MCGCR);
+        bw_cnt_cur = readl(SDR_COM_BWCR);
+        bw_usage = bw_cnt_cur - bw_cnt_hist[mt];
+        if (MASTER_GPU0 == mt) {
+            master_bw_usage[mt] = 2 * (bw_usage / 1024);
+        } else {
+            master_bw_usage[mt] = (bw_usage / 1024);
+        }
+        bw_cnt_hist[mt] = bw_cnt_cur;
+    }
+}
+
+static void master_bw_dbg(void)
+{
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(master_info_list); i++) {
+        DRAMFREQ_DBG("MASTER_%s=%u(MB)\n", master_info_list[i].name, master_bw_usage[master_info_list[i].type]);
+    }
+}
+
+static int dramfreq_get_dev_status(struct device *dev,
+				      struct devfreq_dev_status *stat)
+{
+    __update_master_bw();
+    stat->current_frequency = dramfreq_get();
+    stat->private_data = master_bw_usage;
+    master_bw_dbg();
+
+    return 0;
+}
+
+static struct devfreq_dev_profile dram_devfreq_profile = {
+    .polling_ms     = SUN6I_DRAMFREQ_POLLING_MS,
+    .target         = dramfreq_target,
+    .get_dev_status	= dramfreq_get_dev_status,
+};
+
+static void __dramfreq_init_table(struct clk *pll5)
+{
+    int i;
+    pll5_freq = clk_get_rate(pll5) / 1000;
+
+    for (i = 0; i < SUN6I_DRAMFREQ_TABLE_SIZE; i++) {
+        if (!(pll5_freq % (1000 * (i + 1)))) {
+            dram_freq_table[i][0] = pll5_freq / (i + 1);
+            dram_freq_table[i][1] = (i + 1);
+        } else {
+            dram_freq_table[i][0] = 0;
+            dram_freq_table[i][1] = 0;
+        }
+    }
+}
+
+static ssize_t dram_table_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+    int i;
+
+    for (i = 0; i < SUN6I_DRAMFREQ_TABLE_SIZE; i++) {
+        printk("freq=%-6u   div=%-5u\n", dram_freq_table[i][0], dram_freq_table[i][1]);
+    }
+
+    return 0;
+}
+
+static ssize_t mdfs_table_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+    int m, n;
+
+    for (m = 0; m < SUN6I_DRAMFREQ_TABLE_SIZE; m++) {
+        for (n = 0; n < 8; n++) {
+            DRAMFREQ_DBG("mdfs_table[%d][%d]=0x%x\n", m, n, mdfs_info.table[m][n]);
+        }
+    }
+
+    return 0;
+}
+
+static ssize_t dual_channel_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+    return sprintf(buf, "%d\n", mdfs_info.is_dual_channel);
+}
+
+static DEVICE_ATTR(dram_table, S_IRUGO, dram_table_show, NULL);
+static DEVICE_ATTR(mdfs_table, S_IRUGO, mdfs_table_show, NULL);
+static DEVICE_ATTR(dual_channel, S_IRUGO, dual_channel_show, NULL);
+
+static const struct attribute *dramfreq_arrrib[] = {
+    &dev_attr_dram_table.attr,
+    &dev_attr_mdfs_table.attr,
+    &dev_attr_dual_channel.attr,
+    NULL
+};
+
+static __devinit int sun6i_dramfreq_probe(struct platform_device *pdev)
+{
+    void *tmp_tbl = NULL;
+    int err = 0;
+    script_item_u used;
+    script_item_value_type_e type;
+
+    type = script_get_item("dram_para", "dram_clk", &used);
+    if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
+        DRAMFREQ_ERR("fetch para from sysconfig failed\n");
+        return -ENODEV;
+    }
+
+    dram_clk_syscfg = used.val * 1000;
+    DRAMFREQ_DBG("dram clk sysconfig=%uKHz\n", dram_clk_syscfg);
+
+    tmp_tbl = __va(SYS_CONFIG_MEMBASE + SYS_CONFIG_MEMSIZE - 1024);
+    memcpy(mdfs_info.table, tmp_tbl, sizeof(mdfs_info.table));
+    mdfs_info.is_dual_channel = !!(readl(SDR_COM_CR) & (0x1<<19));
+
+    clk_pll5 = clk_get(NULL, CLK_SYS_PLL5);
+    if (!clk_pll5 || IS_ERR(clk_pll5)) {
+        DRAMFREQ_ERR("try to get PLL5 failed!\n");
+        err = -ENOENT;
+        goto err_clk;
+    }
+
+    /* init dram freq table */
+    __dramfreq_init_table(clk_pll5);
+
+    dram_devfreq_profile.initial_freq = __dramfreq_get(clk_pll5);
+    this_df = devfreq_add_device(&pdev->dev, &dram_devfreq_profile, &devfreq_userspace, NULL);
+    // this_df = devfreq_add_device(&pdev->dev, &dram_devfreq_profile, &devfreq_vans, NULL);
+	if (IS_ERR(this_df)) {
+        DRAMFREQ_ERR("add devfreq device failed!\n");
+        err = PTR_ERR(this_df);
+		goto err_devfreq;
+	}
+
+    this_df->min_freq = this_df->scaling_min_freq = SUN6I_DRAMFREQ_MIN / 1000;
+    this_df->max_freq = this_df->scaling_max_freq = SUN6I_DRAMFREQ_MAX / 1000;
+    platform_set_drvdata(pdev, this_df);
+
+    err = sysfs_create_files(&pdev->dev.kobj, dramfreq_arrrib);
+    if (err) {
+        DRAMFREQ_ERR("create sysfs file failed\n");
+        err = -ENODEV;
+        goto err_create_files;
+    }
+
+    DRAMFREQ_DBG("sun6i dramfreq probe ok!\n");
+
+    return 0;
+
+err_create_files:
+    devfreq_remove_device(this_df);
+err_devfreq:
+    clk_put(clk_pll5);
+    clk_pll5 = NULL;
+err_clk:
+    return err;
+}
+
+static __devexit int sun6i_dramfreq_remove(struct platform_device *pdev)
+{
+    struct devfreq *df = platform_get_drvdata(pdev);
+
+    devfreq_remove_device(df);
+
+    if (!clk_pll5 || IS_ERR(clk_pll5)) {
+        DRAMFREQ_ERR("clk_pll5 handle is invalid, just return!\n");
+        return -EINVAL;
+    } else {
+        clk_put(clk_pll5);
+        clk_pll5 = NULL;
+    }
+
+    return 0;
+}
+
+static struct platform_driver sun6i_dramfreq_driver = {
+    .probe  = sun6i_dramfreq_probe,
+    .remove	= sun6i_dramfreq_remove,
+    .driver = {
+        .name   = "sun6i-dramfreq",
+        .owner  = THIS_MODULE,
+    },
+};
+
+struct platform_device sun6i_dramfreq_device = {
+    .name       = "sun6i-dramfreq",
+};
+
+static int __init sun6i_dramfreq_init(void)
+{
+    int ret = 0;
+
+    ret = platform_device_register(&sun6i_dramfreq_device);
+    if (ret) {
+        DRAMFREQ_ERR("dramfreq device init failed!\n");
+        goto out;
+    }
+
+    ret = platform_driver_register(&sun6i_dramfreq_driver);
+    if (ret) {
+        DRAMFREQ_ERR("dramfreq driver init failed!\n");
+        goto out;
+    }
+
+out:
+    return ret;
+}
+late_initcall(sun6i_dramfreq_init);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("SUN6I dramfreq driver with devfreq framework");
+MODULE_AUTHOR("pannan");
diff --git a/arch/arm/mach-sun6i/dram-freq/mdfs.S b/arch/arm/mach-sun6i/dram-freq/mdfs.S
new file mode 100644
index 0000000..9655fb5
--- /dev/null
+++ b/arch/arm/mach-sun6i/dram-freq/mdfs.S
@@ -0,0 +1,6 @@
+	.globl	mdfs_bin_start
+mdfs_bin_start:
+	.incbin	"arch/arm/mach-sun6i/dram-freq/mdfs/mdfs.code"
+	.globl	mdfs_bin_end
+mdfs_bin_end:
+	.align	2
diff --git a/arch/arm/mach-sun6i/dram-freq/mdfs/Makefile b/arch/arm/mach-sun6i/dram-freq/mdfs/Makefile
new file mode 100644
index 0000000..73ed8dd
--- /dev/null
+++ b/arch/arm/mach-sun6i/dram-freq/mdfs/Makefile
@@ -0,0 +1,40 @@
+#makefile for mdfs.code
+
+INCLUDE   = -I. \
+	-I$(KDIR)/include \
+	-I$(KDIR)/arch/arm/mach-sun6i/include
+
+MDFS_OBJ = mdfs_entry.o \
+           mdfs.o   \
+           mem_mmu_pc_asm.o \
+           mem_divlib.o
+
+CC = $(CROSS_COMPILE)gcc
+
+CFLAGS = -g -c -nostdlib -march=armv7-a -marm -fno-unwind-tables -fno-asynchronous-unwind-tables -mlittle-endian -O2 --min_array_alignment=4 --no_unaligned_access
+
+LD_FLAGS = -static
+#LIBS = -lgcc -L/home/pannan/fiber/lichee/buildroot/output/external-toolchain/lib/gcc/arm-linux-gnueabi/4.6.3
+
+all:
+	$(CC) $(INCLUDE) $(CFLAGS) mdfs_entry.c           		-o mdfs_entry.o
+	$(CC) $(INCLUDE) $(CFLAGS) mdfs.c           			-o mdfs.o
+	$(CC) $(INCLUDE) $(CFLAGS) mem_mmu_pc_asm.S				-o mem_mmu_pc_asm.o
+	$(CC) $(INCLUDE) $(CFLAGS) mem_divlib.S					-o mem_divlib.o
+
+	$(CROSS_COMPILE)ld -T mdfs.ld $(LD_FLAGS) $(LIBS) -EL  $(MDFS_OBJ) -o mdfs.elf  -Map mdfs.map
+	$(CROSS_COMPILE)objdump -D mdfs.elf > mdfs.lst
+	$(CROSS_COMPILE)objcopy -O binary mdfs.elf mdfs.bin
+
+	rm -rf *.o ../*.o
+
+	cp mdfs.bin mdfs.code
+
+	@echo ----------------------------------------
+	@echo         mdfs make success
+	@echo ----------------------------------------
+	@echo well done!
+
+
+clean:
+	-rm *.code *.map *.lst *.bin *.elf
diff --git a/arch/arm/mach-sun6i/dram-freq/mdfs/mdfs.c b/arch/arm/mach-sun6i/dram-freq/mdfs/mdfs.c
new file mode 100644
index 0000000..acc6a68
--- /dev/null
+++ b/arch/arm/mach-sun6i/dram-freq/mdfs/mdfs.c
@@ -0,0 +1,439 @@
+/*
+ * arch/arm/mach-sun6i/dram-freq/mdfs/mdfs.c
+ *
+ * Copyright (C) 2012 - 2016 Reuuimlla Limited
+ * Pan Nan <pannan@reuuimllatech.com>
+ *
+ * SUN6I dram frequency dynamic scaling driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <stdarg.h>
+#include "mdfs.h"
+
+static void serial_put_char(char c)
+{
+	while (!(readb(SUART_USR) & 2));
+	writeb(c, SUART_THR);
+}
+
+__s32 serial_puts(const char *string)
+{
+	while (*string != '\0') {
+		if (*string == '\n') {
+			// if current character is '\n',
+			// insert output with '\r'.
+			serial_put_char('\r');
+		}
+		serial_put_char(*string++);
+	}
+
+	return 0;
+}
+
+size_t strlen(const char *s)
+{
+	const char *sc;
+
+	for (sc = s; *sc != '\0'; ++sc)
+	{
+		/* nothing */
+		;
+	}
+	return sc - s;
+}
+
+char *strcpy(char *dest, const char *src)
+{
+	char *tmp = dest;
+
+	while ((*dest++ = *src++) != '\0')
+	{
+		/* nothing */
+		;
+	}
+	return tmp;
+}
+
+char *itoa(int value, char *string, int radix)
+{
+	char stack[16];
+	int  negative = 0;			//defualt is positive value
+	int  i;
+	int  j;
+	char digit_string[] = "0123456789ABCDEF";
+
+	if(value == 0)
+	{
+		//zero
+		string[0] = '0';
+		string[1] = '\0';
+		return string;
+	}
+
+	if(value < 0)
+	{
+		//'value' is negative, convert to postive first
+		negative = 1;
+		value = -value ;
+	}
+
+	for(i = 0; value > 0; ++i)
+	{
+		// characters in reverse order are put in 'stack'.
+		stack[i] = digit_string[value % radix];
+		value /= radix;
+	}
+
+	//restore reversed order result to user string
+    j = 0;
+	if(negative)
+	{
+		//add sign at first charset.
+		string[j++] = '-';
+	}
+	for(--i; i >= 0; --i, ++j)
+	{
+		string[j] = stack[i];
+	}
+	//must end with '\0'.
+	string[j] = '\0';
+
+	return string;
+}
+
+char *utoa(unsigned int value, char *string, int radix)
+{
+	char stack[16];
+	int  i;
+	int  j;
+	char digit_string[] = "0123456789ABCDEF";
+
+	if(value == 0)
+	{
+		//zero
+		string[0] = '0';
+		string[1] = '\0';
+		return string;
+	}
+
+	for(i = 0; value > 0; ++i)
+	{
+		// characters in reverse order are put in 'stack'.
+		stack[i] = digit_string[value % radix];
+		value /= radix;
+	}
+
+	//restore reversed order result to user string
+    for(--i, j = 0; i >= 0; --i, ++j)
+	{
+		string[j] = stack[i];
+	}
+	//must end with '\0'.
+	string[j] = '\0';
+
+	return string;
+}
+
+
+char *strncat(char *dest, const char *src, size_t count)
+{
+	char *tmp = dest;
+
+	if (count)
+	{
+		while (*dest)
+		{
+			dest++;
+		}
+		while ((*dest++ = *src++) != 0)
+		{
+			if (--count == 0)
+			{
+				*dest = '\0';
+				break;
+			}
+		}
+	}
+	return tmp;
+}
+
+__s32 print_align(char *string, __s32 len, __s32 align)
+{
+	//fill with space ' ' when align request,
+	//the max align length is 16 byte.
+	char fill_ch[] = "                ";
+	if (len < align)
+	{
+		//fill at right
+		strncat(string, fill_ch, align - len);
+		return align - len;
+	}
+	//not fill anything
+	return 0;
+}
+
+char debugger_buffer[256];
+__s32 printk(const char *format, ...)
+{
+	va_list args;
+	char 	string[16];	//align by cpu word
+	char 	*pdest;
+	char 	*psrc;
+	__s32 	align;
+	__s32		len = 0;
+
+	pdest = debugger_buffer;
+	va_start(args, format);
+	while(*format)
+	{
+		if(*format == '%')
+		{
+			++format;
+			if (('0' < (*format)) && ((*format) <= '9'))
+			{
+				//we just suport wide from 1 to 9.
+				align = *format - '0';
+				++format;
+			}
+			else
+			{
+				align = 0;
+			}
+			switch(*format)
+			{
+				case 'd':
+				{
+					//int
+					itoa(va_arg(args, int), string, 10);
+                    len = strlen(string);
+                    len += print_align(string, len, align);
+                    strcpy(pdest, string);
+                    pdest += len;
+                    break;
+				}
+				case 'x':
+				case 'p':
+				{
+					//hex
+					utoa(va_arg(args, int), string, 16);
+					len = strlen(string);
+					len += print_align(string, len, align);
+					strcpy(pdest, string);
+                    pdest += len;
+                    break;
+				}
+				case 'u':
+				{
+					//unsigned int
+					utoa(va_arg(args, int), string, 10);
+                    len = strlen(string);
+                    len += print_align(string, len, align);
+                    strcpy(pdest, string);
+					pdest += len;
+					break;
+				}
+				case 'c':
+				{
+					//charset, aligned by cpu word
+					*pdest = (char)va_arg(args, int);
+					break;
+				}
+				case 's':
+				{
+					//string
+					psrc = va_arg(args, char *);
+					strcpy(pdest, psrc);
+					pdest += strlen(psrc);
+					break;
+				}
+				default :
+				{
+					//no-conversion
+					*pdest++ = '%';
+					*pdest++ = *format;
+				}
+			}
+		}
+		else
+		{
+			*pdest++ = *format;
+		}
+		//parse next token
+		++format;
+	}
+	va_end(args);
+
+	//must end with '\0'
+	*pdest = '\0';
+	pdest++;
+	serial_puts(debugger_buffer);
+
+	return (pdest - debugger_buffer);
+}
+
+void __div0(void)
+{
+	printk("Attempting division by 0!");
+}
+
+void mdfs_memcpy(void *dest, const void *src, int n)
+{
+    char *tmp = dest;
+    const char *s = src;
+
+    if (!dest || !src)
+        return;
+
+    while (n--)
+        *tmp++ = *s++;
+
+    return;
+}
+
+void mdfs_memset(void *s, int c, int n)
+{
+    char *xs = s;
+
+    if (!s)
+        return;
+
+    while (n--)
+        *xs++ = c;
+
+    return;
+}
+
+int mdfs_start(struct aw_mdfs_info *mdfs)
+{
+    unsigned int reg_val, tmp, freq_div, dual_channel_en;
+    unsigned int *mdfs_table;
+    int i;
+
+    dual_channel_en = mdfs->is_dual_channel;
+    freq_div = mdfs->div;
+    mdfs_table = &mdfs->table[0][0];
+
+    /* wait for whether the past MDFS process has done */
+    while (readl(SDR_COM_MDFSCR)&0x1);
+
+    /* move to CFG */
+    writel(0x1, SDR_SCTL);
+    while ((readl(SDR_SSTAT) & 0x7) != 0x1);
+    if (dual_channel_en) {
+        writel(0x1, 0x1000 + SDR_SCTL);
+        while ((readl(0x1000 + SDR_SSTAT) & 0x7) != 0x1);
+    }
+
+    /* pd_idle setting */
+    reg_val = readl(SDR_MCFG);
+    reg_val &= ~(0xff<<8);
+    writel(reg_val, SDR_MCFG);
+    if (dual_channel_en) {
+        reg_val = readl(0x1000 + SDR_MCFG);
+        reg_val &= ~(0xff<<8);
+        writel(reg_val, 0x1000 + SDR_MCFG);
+    }
+
+    /* set Toggle 1us/100ns REG */
+    reg_val  = (((readl(CCM_PLL5_DDR_CTRL)>>8)&0x1f)+1)*24;
+    reg_val *= (((readl(CCM_PLL5_DDR_CTRL)>>4)&0x3) + 1);
+    tmp = ((readl(CCM_PLL5_DDR_CTRL)>>0)&0x3) + 1;
+    reg_val /= (((readl(CCM_PLL5_DDR_CTRL)>>0)&0x3) + 1);
+    reg_val /= freq_div;
+    writel(reg_val, SDR_TOGCNT1U);                  //1us
+    if (dual_channel_en) {
+        writel(reg_val, 0x1000 + SDR_TOGCNT1U);     //1us
+    }
+    reg_val /= 10;
+    writel(reg_val, SDR_TOGCNT100N);                //100ns
+    if (dual_channel_en) {
+        writel(reg_val, 0x1000 + SDR_TOGCNT100N);   //100ns
+    }
+
+    /* move to GO */
+    writel(0x2, SDR_SCTL);
+    while ((readl(SDR_SSTAT) & 0x7) != 0x3);
+    if (dual_channel_en) {
+        writel(0x2, 0x1000 + SDR_SCTL);
+        while ((readl(0x1000 + SDR_SSTAT) & 0x7) != 0x3);
+    }
+
+    /* set DRAM middle & destination clock */
+    reg_val = readl(CCM_DRAMCLK_CFG_CTRL);
+    reg_val &= ~(0x1<<16);
+    reg_val &= ~(0xf<<8);
+    reg_val |= (freq_div-1)<<8;
+    writel(reg_val, CCM_DRAMCLK_CFG_CTRL);
+
+    /* set Master enable and Ready mask */
+    reg_val = 0x3ff00001;
+    writel(reg_val, SDR_COM_MDFSMER);
+    reg_val = 0xfffffff8;
+    writel(reg_val, SDR_COM_MDFSMRMR);
+
+    /* set MDFS timing parameter */
+    reg_val = 0x258;                                //3us/5ns = 600
+    writel(reg_val, SDR_COM_MDFSTR0);
+    reg_val = 102400*freq_div;
+    tmp = (((readl(CCM_PLL5_DDR_CTRL)>>8)&0x1f)+1)*24;
+    reg_val /= tmp;
+    reg_val ++;
+    writel(reg_val, SDR_COM_MDFSTR1);               //512*200/sclk
+    reg_val = 0x80;
+    writel(reg_val, SDR_COM_MDFSTR2);               //fixed value : 128
+
+    /* set MDFS DQS Gate Configuration */
+    for (i=0;i<8;i++) {
+        writel(*(mdfs_table + (8*(freq_div-1)) + i), SDR_COM_MDFSGCR + 4*i);
+    }
+
+    /* start hardware MDFS */
+    reg_val = readl(SDR_COM_MDFSCR);
+    reg_val >>= 2;
+    reg_val &= ((0x1<<4) | (0x1<<8));
+    reg_val |= 0x5 | (0x2u<<30);
+    tmp = (((readl(CCM_PLL5_DDR_CTRL)>>8)&0x1f)+1)*24;
+    tmp *= (((readl(CCM_PLL5_DDR_CTRL)>>4)&0x3) + 1);
+    tmp /= (((readl(CCM_PLL5_DDR_CTRL)>>0)&0x3) + 1);
+    if ((tmp/freq_div) < 200)
+        reg_val |= 0x1<<10;
+    if ((tmp/freq_div) <= 120)
+        reg_val |= 0x1<<6;
+    writel(reg_val, SDR_COM_MDFSCR);
+
+	/* wait for whether the past MDFS process is done */
+	while (readl(SDR_COM_MDFSCR)&0x1);
+
+    /* move to CFG */
+    writel(0x1, SDR_SCTL);
+    while ((readl(SDR_SSTAT) & 0x7) != 0x1);
+    if (dual_channel_en) {
+        writel(0x1, 0x1000 + SDR_SCTL);
+        while ((readl(0x1000 + SDR_SSTAT) & 0x7) != 0x1);
+    }
+
+    /* pd_idle setting */
+    reg_val = readl(SDR_MCFG);
+    reg_val |= (0x10<<8);
+    writel(reg_val, SDR_MCFG);
+    if (dual_channel_en) {
+        reg_val = readl(0x1000 + SDR_MCFG);
+        reg_val |= (0x10<<8);
+        writel(reg_val, 0x1000 + SDR_MCFG);
+    }
+
+    /* move to GO */
+    writel(0x2, SDR_SCTL);
+    while ((readl(SDR_SSTAT) & 0x7) != 0x3);
+    if (dual_channel_en) {
+        writel(0x2, 0x1000 + SDR_SCTL);
+        while ((readl(0x1000 + SDR_SSTAT) & 0x7) != 0x3);
+    }
+
+	return 0;
+}
diff --git a/arch/arm/mach-sun6i/dram-freq/mdfs/mdfs.h b/arch/arm/mach-sun6i/dram-freq/mdfs/mdfs.h
new file mode 100644
index 0000000..6ffcff9
--- /dev/null
+++ b/arch/arm/mach-sun6i/dram-freq/mdfs/mdfs.h
@@ -0,0 +1,43 @@
+/*
+ * arch/arm/mach-sun6i/dram-freq/mdfs/mdfs.h
+ *
+ * Copyright (C) 2012 - 2016 Reuuimlla Limited
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __MDFS_H__
+#define __MDFS_H__
+
+#include <mach/dram-freq-common.h>
+
+#define SUART_BASE_VA   AW_VIR_UART0_BASE
+#define SUART_THR       (SUART_BASE_VA + 0x00)
+#define SUART_USR       (SUART_BASE_VA + 0x7c)
+
+#define readb(addr)		(*((volatile unsigned char  *)(addr)))
+#define readl(addr)		(*((volatile unsigned long  *)(addr)))
+#define writeb(v, addr)	(*((volatile unsigned char  *)(addr)) = (unsigned char)(v))
+#define writel(v, addr)	(*((volatile unsigned long  *)(addr)) = (unsigned long)(v))
+
+#if 1
+#define MDFS_DBG(format,args...)    printk("[mdfs] "format,##args)
+#else
+#define MDFS_DBG(format,args...)
+#endif
+
+typedef signed int          __s32;
+typedef unsigned int        __u32;
+typedef int                 u32;
+typedef unsigned int        size_t;
+
+extern void __aeabi_idiv(void);
+extern void __aeabi_idivmod(void);
+extern void __aeabi_uidiv(void);
+extern void __aeabi_uidivmod(void);
+extern __s32 printk(const char *format, ...);
+
+#endif  //__MDFS_H__
diff --git a/arch/arm/mach-sun6i/dram-freq/mdfs/mdfs.ld b/arch/arm/mach-sun6i/dram-freq/mdfs/mdfs.ld
new file mode 100644
index 0000000..49b5715
--- /dev/null
+++ b/arch/arm/mach-sun6i/dram-freq/mdfs/mdfs.ld
@@ -0,0 +1,20 @@
+
+OUTPUT_ARCH(arm)
+ENTRY(mdfs_main)
+
+SECTIONS
+{
+	__mdfs_start = . ;
+	.text 0xf0000000 :
+	{
+		mdfs_entry.o(.text.startup)
+		*(.text)
+		*(.rodata)
+	}
+
+	.data   : { *(.data) }
+	__bss_start = . ;
+	.bss : { *(.sbss) *(.scommon) *(.bss) *(COMMON) }
+	__bss_end = .;
+	__mdfs_end = . ;
+}
diff --git a/arch/arm/mach-sun6i/dram-freq/mdfs/mdfs_entry.c b/arch/arm/mach-sun6i/dram-freq/mdfs/mdfs_entry.c
new file mode 100644
index 0000000..e6e60cb
--- /dev/null
+++ b/arch/arm/mach-sun6i/dram-freq/mdfs/mdfs_entry.c
@@ -0,0 +1,43 @@
+/*
+ * arch/arm/mach-sun6i/dram-freq/mdfs/mdfs.c
+ *
+ * Copyright (C) 2012 - 2016 Reuuimlla Limited
+ * Pan Nan <pannan@reuuimllatech.com>
+ *
+ * SUN6I dram frequency dynamic scaling driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include "mdfs.h"
+
+static unsigned int sp_backup;
+struct aw_mdfs_info mdfs_info;
+
+extern char __bss_start[];
+extern char __bss_end[];
+
+extern void mdfs_memcpy(void *dest, const void *src, int n);
+extern void mdfs_memset(void *s, int c, int n);
+extern int  mdfs_start(struct aw_mdfs_info *mdfs);
+
+int mdfs_main(struct aw_mdfs_info *mdfs)
+{
+    MDFS_DBG("%s enter\n", __func__);
+    /* clear bss section */
+    mdfs_memset(__bss_start, 0, (unsigned int)(__bss_end - __bss_start));
+    /* save stack pointer registger, switch stack to sram */
+    sp_backup = save_sp();
+    /* copy mdfs info to sram space */
+    mdfs_memcpy(&mdfs_info, mdfs, sizeof(struct aw_mdfs_info));
+    /* start mdfs */
+    mdfs_start(&mdfs_info);
+    /* restore stack pointer */
+    restore_sp(sp_backup);
+    MDFS_DBG("%s done\n", __func__);
+
+    return 0;
+}
diff --git a/arch/arm/mach-sun6i/dram-freq/mdfs/mem_divlib.S b/arch/arm/mach-sun6i/dram-freq/mdfs/mem_divlib.S
new file mode 100644
index 0000000..11d8daf
--- /dev/null
+++ b/arch/arm/mach-sun6i/dram-freq/mdfs/mem_divlib.S
@@ -0,0 +1,180 @@
+/*
+ * linux/arch/arm/lib/lib1funcs.S: Optimized ARM division routines
+ *
+ * Author: Nicolas Pitre <nico@fluxnic.net>
+ *   - contributed to gcc-3.4 on Sep 30, 2003
+ *   - adapted for the Linux kernel on Oct 2, 2003
+ */
+
+
+.macro ARM_DIV_BODY dividend, divisor, result, curbit
+
+	clz	\curbit, \divisor
+	clz	\result, \dividend
+	sub	\result, \curbit, \result
+	mov	\curbit, #1
+	mov	\divisor, \divisor, lsl \result
+	mov	\curbit, \curbit, lsl \result
+	mov	\result, #0
+
+	@ Division loop
+1:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	orrhs	\result,   \result,   \curbit
+	cmp	\dividend, \divisor,  lsr #1
+	subhs	\dividend, \dividend, \divisor, lsr #1
+	orrhs	\result,   \result,   \curbit,  lsr #1
+	cmp	\dividend, \divisor,  lsr #2
+	subhs	\dividend, \dividend, \divisor, lsr #2
+	orrhs	\result,   \result,   \curbit,  lsr #2
+	cmp	\dividend, \divisor,  lsr #3
+	subhs	\dividend, \dividend, \divisor, lsr #3
+	orrhs	\result,   \result,   \curbit,  lsr #3
+	cmp	\dividend, #0			@ Early termination?
+	movnes	\curbit,   \curbit,  lsr #4	@ No, any more bits to do?
+	movne	\divisor,  \divisor, lsr #4
+	bne	1b
+
+.endm
+
+
+.macro ARM_DIV2_ORDER divisor, order
+	clz	\order, \divisor
+	rsb	\order, \order, #31
+.endm
+
+
+.macro ARM_MOD_BODY dividend, divisor, order, spare
+	clz	\order, \divisor
+	clz	\spare, \dividend
+	sub	\order, \order, \spare
+	mov	\divisor, \divisor, lsl \order
+
+	@ Perform all needed substractions to keep only the reminder.
+	@ Do comparisons in batch of 4 first.
+	subs	\order, \order, #3		@ yes, 3 is intended here
+	blt	2f
+
+1:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	cmp	\dividend, \divisor,  lsr #1
+	subhs	\dividend, \dividend, \divisor, lsr #1
+	cmp	\dividend, \divisor,  lsr #2
+	subhs	\dividend, \dividend, \divisor, lsr #2
+	cmp	\dividend, \divisor,  lsr #3
+	subhs	\dividend, \dividend, \divisor, lsr #3
+	cmp	\dividend, #1
+	mov	\divisor, \divisor, lsr #4
+	subges	\order, \order, #4
+	bge	1b
+
+	tst	\order, #3
+	teqne	\dividend, #0
+	beq	5f
+
+	@ Either 1, 2 or 3 comparison/substractions are left.
+2:	cmn	\order, #2
+	blt	4f
+	beq	3f
+	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	mov	\divisor,  \divisor,  lsr #1
+3:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	mov	\divisor,  \divisor,  lsr #1
+4:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+5:
+.endm
+
+    .text
+    .globl Ldiv0
+Ldiv0:
+	str	lr, [sp, #-8]!
+	bl	__div0
+	mov	r0, #0			@ About as wrong as it could be.
+	ldr	pc, [sp], #8
+
+    .text
+    .globl __aeabi_uidiv
+__aeabi_uidiv:
+	subs	r2, r1, #1
+	moveq	pc, lr
+	bcc	Ldiv0
+	cmp	r0, r1
+	bls	11f
+	tst	r1, r2
+	beq	12f
+
+	ARM_DIV_BODY r0, r1, r2, r3
+
+	mov	r0, r2
+	mov	pc, lr
+
+11:	moveq	r0, #1
+	movne	r0, #0
+	mov	pc, lr
+
+12:	ARM_DIV2_ORDER r1, r2
+
+	mov	r0, r0, lsr r2
+	mov	pc, lr
+
+
+    .text
+    .globl __aeabi_idiv
+__aeabi_idiv:
+	cmp	r1, #0
+	eor	ip, r0, r1			@ save the sign of the result.
+	beq	Ldiv0
+	rsbmi	r1, r1, #0			@ loops below use unsigned.
+	subs	r2, r1, #1			@ division by 1 or -1 ?
+	beq	10f
+	movs	r3, r0
+	rsbmi	r3, r0, #0			@ positive dividend value
+	cmp	r3, r1
+	bls	11f
+	tst	r1, r2				@ divisor is power of 2 ?
+	beq	12f
+
+	ARM_DIV_BODY r3, r1, r0, r2
+
+	cmp	ip, #0
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+10:	teq	ip, r0				@ same sign ?
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+11:	movlo	r0, #0
+	moveq	r0, ip, asr #31
+	orreq	r0, r0, #1
+	mov	pc, lr
+
+12:	ARM_DIV2_ORDER r1, r2
+
+	cmp	ip, #0
+	mov	r0, r3, lsr r2
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+    .text
+    .globl __aeabi_uidivmod
+__aeabi_uidivmod:
+	stmfd	sp!, {r0, r1, ip, lr}
+	bl	__aeabi_uidiv
+	ldmfd	sp!, {r1, r2, ip, lr}
+	mul	r3, r0, r2
+	sub	r1, r1, r3
+	mov	pc, lr
+
+    .text
+    .globl __aeabi_idivmod
+__aeabi_idivmod:
+	stmfd	sp!, {r0, r1, ip, lr}
+	bl	__aeabi_idiv
+	ldmfd	sp!, {r1, r2, ip, lr}
+	mul	r3, r0, r2
+	sub	r1, r1, r3
+	mov	pc, lr
\ No newline at end of file
diff --git a/arch/arm/mach-sun6i/dram-freq/mdfs/mem_mmu_pc_asm.S b/arch/arm/mach-sun6i/dram-freq/mdfs/mem_mmu_pc_asm.S
new file mode 100644
index 0000000..1dce3d5
--- /dev/null
+++ b/arch/arm/mach-sun6i/dram-freq/mdfs/mem_mmu_pc_asm.S
@@ -0,0 +1,25 @@
+
+/**-----------------------------stack point address in sram-----------------------------------------*/
+#define SP_IN_SRAM	0xf0007000 //32k
+/*save_sp*/
+/*restore_sp*/
+/*get_sp*/
+
+    .text
+    .globl save_sp
+save_sp:
+    mov r0, r13
+    ldr  r13, =SP_IN_SRAM
+    mov pc,lr
+
+    .text
+    .globl restore_sp
+restore_sp:
+    mov r13, r0
+    mov pc,lr
+
+    .text
+    .globl get_sp
+get_sp:
+    mov r0, r13
+    mov pc,lr
diff --git a/arch/arm/mach-sun6i/gpio/Makefile b/arch/arm/mach-sun6i/gpio/Makefile
new file mode 100644
index 0000000..8ebd9f2
--- /dev/null
+++ b/arch/arm/mach-sun6i/gpio/Makefile
@@ -0,0 +1,2 @@
+
+obj-y		+= gpio_init.o gpio_base.o gpio_multi_func.o gpio_eint.o
diff --git a/arch/arm/mach-sun6i/gpio/gpio_base.c b/arch/arm/mach-sun6i/gpio/gpio_base.c
new file mode 100644
index 0000000..d918921
--- /dev/null
+++ b/arch/arm/mach-sun6i/gpio/gpio_base.c
@@ -0,0 +1,190 @@
+/*
+ * arch/arm/mach-sun6i/gpio/gpio_base.c
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i gpio driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include "gpio_include.h"
+
+/**
+ * __gpio_direction_input - set pio to input
+ * NOTE: not need set pull and driver level, user care
+ * @chip:	gpio_chip
+ * @offset:	gpio offset from gpio_chip->base
+ *
+ * Returns 0 if success, the err line number otherwise.
+ */
+static int __gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	u32 	ureg_off = 0, ubits_off = 0;
+	unsigned long flags;
+	struct aw_gpio_chip *pchip = to_aw_gpiochip(chip);
+
+#if 0
+	PIO_DBG("%s: chip 0x%08x, offset %d, aw chip 0x%08x\n", __func__,
+		(u32)chip, offset, (u32)pchip);
+#endif
+	ureg_off = ((offset << 2) >> 5) << 2; 	/* ureg_off = ((offset * 4) / 32) * 4 */
+	ubits_off = (offset << 2) % 32;		/* ubits_off = (offset * 4) % 32 */
+
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+
+	PIO_DBG("%s: write cfg reg 0x%08x, bits_off %d, width %d, cfg_val %d\n", __func__,
+		ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_CFG, PIO_CFG_INPUT);
+
+	PIO_WRITE_BITS(ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_CFG, PIO_CFG_INPUT);
+
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+	return 0;
+}
+
+/**
+ * __gpio_direction_output - set the gpio as ouput, and set the val
+ * @chip:	gpio_chip
+ * @offset:	offset from gpio_chip->base
+ * @value:	the val to set
+ *
+ * Returns 0 if success, the err line number otherwise.
+ */
+static int __gpio_direction_output(struct gpio_chip *chip, unsigned offset, int value)
+{
+	u32 	ureg_off = 0, ubits_off = 0;
+	unsigned long flags;
+	struct aw_gpio_chip *pchip = to_aw_gpiochip(chip);
+
+#if 0
+	PIO_DBG("%s: chip 0x%08x, offset %d, val %d, aw chip 0x%08x\n", __func__,
+		(u32)chip, offset, value, (u32)pchip);
+#endif
+	ureg_off = ((offset << 2) >> 5) << 2; 	/* ureg_off = ((offset * 4) / 32) * 4 */
+	ubits_off = (offset << 2) % 32;		/* ubits_off = (offset * 4) % 32 */
+
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+
+	PIO_DBG("%s: write cfg reg 0x%08x, bits_off %d, width %d, cfg_val %d\n", __func__,
+		ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_CFG, PIO_CFG_OUTPUT);
+
+	PIO_WRITE_BITS(ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_CFG, PIO_CFG_OUTPUT);
+
+	PIO_DBG("%s: write data reg 0x%08x, offset %d, val %d\n", __func__, \
+		PIO_OFF_REG_DATA + (u32)pchip->vbase, offset, (0 != value ? 1 : 0));
+
+	PIO_WRITE_BITS(PIO_OFF_REG_DATA + (u32)pchip->vbase, offset, 1, (0 != value ? 1 : 0));
+
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+	return 0;
+}
+
+/**
+ * __gpio_get - get the gpio value. NOTE: the gpio is already input.
+ * @chip:	gpio_chip
+ * @offset:	offset from gpio_chip->base
+ *
+ * Return the gpio value(data).
+ */
+static int __gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	int 	iret = 0;
+	unsigned long flags;
+	struct aw_gpio_chip *pchip = to_aw_gpiochip(chip);
+
+#if 0
+	PIO_DBG("%s: chip 0x%08x, offset %d, aw chip 0x%08x\n", __func__,
+		(u32)chip, offset, (u32)pchip);
+#endif
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+
+	iret = PIO_READ_BITS(PIO_OFF_REG_DATA + (u32)pchip->vbase, offset, 1);
+
+	PIO_DBG("%s: read data reg 0x%08x - 0x%08x, offset %d, ret %d\n", __func__,
+		PIO_OFF_REG_DATA + (u32)pchip->vbase,	PIO_READ_REG(PIO_OFF_REG_DATA + pchip->vbase), offset, iret);
+
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+	return iret;
+}
+
+/**
+ * __gpio_set - set the gpio value. NOTE: the gpio is already output.
+ * @chip:	gpio_chip
+ * @offset:	offset from gpio_chip->base
+ * @value:	the val to set
+ */
+static void __gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	unsigned long flags;
+	struct aw_gpio_chip *pchip = to_aw_gpiochip(chip);
+
+#if 0
+	PIO_DBG("%s: chip 0x%08x, offset %d, value %d, aw chip 0x%08x\n", __func__,
+		(u32)chip, offset, value, (u32)pchip);
+#endif
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+
+	PIO_DBG("%s: write data reg 0x%08x, offset %d, val %d\n", __func__,
+		PIO_OFF_REG_DATA + (u32)pchip->vbase, offset, (0 != value ? 1 : 0));
+
+	PIO_WRITE_BITS(PIO_OFF_REG_DATA + (u32)pchip->vbase, offset, 1, (0 != value ? 1 : 0));
+
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+	return;
+}
+
+/**
+ * aw_gpiochip_add - init gpio_chip struct, and register the chip to gpiolib
+ * @chip:	gpio_chip
+ *
+ * Returns 0 if success, the err line number otherwise.
+ */
+int aw_gpiochip_add(struct gpio_chip *chip)
+{
+	if(NULL == chip->direction_input) {
+		chip->direction_input = __gpio_direction_input;
+	}
+	if(NULL == chip->direction_output) {
+		chip->direction_output = __gpio_direction_output;
+	}
+	if(NULL == chip->set) {
+		chip->set = __gpio_set;
+	}
+	if(NULL == chip->get) {
+		chip->get = __gpio_get;
+	}
+
+	/* register chip to gpiolib */
+	if(0 != gpiochip_add(chip)) {
+		printk("%s err, line %d\n", __func__, __LINE__);
+		return __LINE__;
+	}
+	return 0;
+}
+
+/**
+ * __pio_to_irq - find the interrupt num for the gpio
+ * @chip:	gpio_chip
+ * @offset:	gpio offset from gpio_chip->base
+ *
+ * Returns the irq number if sucess, IRQ_NUM_INVALID if failed.
+ */
+int __pio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	struct aw_gpio_chip *pchip = to_aw_gpiochip(chip);
+
+#if 0
+	PIO_DBG("%s: chip 0x%08x, offset %d, aw chip 0x%08x\n", __func__,
+		(u32)chip, offset, (u32)pchip);
+#endif
+	if(is_gpio_canbe_eint(chip->base + offset))
+		return pchip->irq_num;
+	printk("%s err: line %d\n", __func__, __LINE__);
+	return IRQ_NUM_INVALID;
+}
+
diff --git a/arch/arm/mach-sun6i/gpio/gpio_base.h b/arch/arm/mach-sun6i/gpio/gpio_base.h
new file mode 100644
index 0000000..9c1aec9
--- /dev/null
+++ b/arch/arm/mach-sun6i/gpio/gpio_base.h
@@ -0,0 +1,101 @@
+/*
+ * arch/arm/mach-sun6i/gpio/gpio_base.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i gpio header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __GPIO_BASE_H
+#define __GPIO_BASE_H
+
+/**
+ * gpiochip_match - match function to find gpio_chip
+ * @chip:	gpio_chip struct
+ * @data:	data for match
+ *
+ * Returns 1 if match, 0 if not match
+ */
+static inline int gpiochip_match(struct gpio_chip * chip, void * data)
+{
+	u32 	num = 0;
+
+	if(NULL == chip || NULL == data)
+		return 0;
+	num = *(u32 *)data;
+	if(num >= chip->base && num < chip->base + chip->ngpio)
+		return 1;
+	return 0;
+}
+
+/**
+ * to_gpiochip - get gpio_chip for the gpio index
+ * @gpio:	the global gpio index
+ *
+ * Returns gpio_chip pointer if success, NULL otherwise.
+ */
+static inline struct gpio_chip *to_gpiochip(u32 gpio)
+{
+	u32 	num = gpio;
+	struct gpio_chip *pchip = NULL;
+
+	pchip = gpiochip_find((void *)&num, gpiochip_match);
+	if(NULL == pchip) {
+		printk("%s err, line %d\n", __func__, __LINE__);
+		return NULL;
+	}
+
+	return pchip;
+}
+
+/**
+ * to_aw_gpiochip - get aw_gpio_chip from gpio_chip poniter
+ * @gpc:	the gpio_chip poniter
+ *
+ * Returns aw_gpio_chip pointer for the gpio_chip
+ */
+static inline struct aw_gpio_chip *to_aw_gpiochip(struct gpio_chip *gpc)
+{
+	return container_of(gpc, struct aw_gpio_chip, chip);
+}
+
+/**
+ * gpio_to_aw_gpiochip - get aw_gpio_chip from gpio index
+ * @gpio:	the global gpio index
+ *
+ * Returns aw_gpio_chip pointer for the gpio if success, NULL ttherwise.
+ */
+static inline struct aw_gpio_chip *gpio_to_aw_gpiochip(u32 gpio)
+{
+	struct gpio_chip *pchip = NULL;
+
+	if(GPIO_INDEX_INVALID == gpio) {
+		printk("%s err, line %d, invalid gpio index\n", __func__, __LINE__);
+		return NULL;
+	}
+#ifdef CONFIG_AW_AXP22
+	/* axp pin can only use linux stardard api */
+	if(gpio >= AXP_NR_BASE && gpio < AXP_NR_BASE + AXP_NR) {
+		printk("%s err, line %d, axp gpio cannot to aw_gpiochip\n", __func__, __LINE__);
+		return NULL;
+	}
+#endif /* CONFIG_AW_AXP22 */
+	pchip = to_gpiochip(gpio);
+	if(NULL == pchip) {
+		printk("%s err, line %d, gpio 0x%x\n", __func__, __LINE__, gpio);
+		return NULL;
+	}
+	return to_aw_gpiochip(pchip);
+}
+
+int __pio_to_irq(struct gpio_chip *chip, unsigned offset);
+int aw_gpiochip_add(struct gpio_chip *chip);
+
+#endif /* __GPIO_BASE_H */
diff --git a/arch/arm/mach-sun6i/gpio/gpio_common.h b/arch/arm/mach-sun6i/gpio/gpio_common.h
new file mode 100644
index 0000000..b44d42e
--- /dev/null
+++ b/arch/arm/mach-sun6i/gpio/gpio_common.h
@@ -0,0 +1,181 @@
+/*
+ * arch/arm/mach-sun6i/gpio/gpio_common.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i gpio header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __GPIO_COMMON_H
+#define __GPIO_COMMON_H
+
+/*
+ * gpio print macro
+ */
+#define PIO_DBG_LEVEL	3
+
+#if (PIO_DBG_LEVEL == 1)
+	#define PIO_DBG(format,args...)   printk("[gpio-dbg] "format,##args)
+	#define PIO_INF(format,args...)   printk("[gpio-inf] "format,##args)
+	#define PIO_ERR(format,args...)   printk("[gpio-err] "format,##args)
+#elif (PIO_DBG_LEVEL == 2)
+	#define PIO_DBG(format,args...)   do{}while(0)
+	#define PIO_INF(format,args...)   printk("[gpio-inf] "format,##args)
+	#define PIO_ERR(format,args...)   printk("[gpio-err] "format,##args)
+#elif (PIO_DBG_LEVEL == 3)
+	#define PIO_DBG(format,args...)   do{}while(0)
+	#define PIO_INF(format,args...)   do{}while(0)
+	#define PIO_ERR(format,args...)   printk("[gpio-err] "format,##args)
+#endif
+
+/*
+ * pull state
+ */
+enum pull_sta_e {
+	PULL_DISABLE 	= (0b00	),  	/* pull up/down disable */
+	PULL_UP 	= (0b01	),  	/* pull up */
+	PULL_DOWN 	= (0b10	),  	/* pull down */
+	PULL_RESERVE 	= (0b11	),  	/* reserve */
+};
+
+/*
+ * driver level state
+ */
+enum driver_level_e {
+	DRV_LVL_0 	= (0b00	),  	/* driver level 0 */
+	DRV_LVL_1 	= (0b01	),  	/* driver level 1 */
+	DRV_LVL_2 	= (0b10	),  	/* driver level 2 */
+	DRV_LVL_3 	= (0b11	),  	/* driver level 3 */
+};
+
+/*
+ * default pull and driver lever
+ */
+#define PIO_DEFAULT_PULL   		PULL_UP
+#define PIO_DEFAULT_DRVLVL   		DRV_LVL_1
+
+/*
+ * config value for input/output, common for every pio
+ */
+#define PIO_CFG_INPUT   		(0b000	)
+#define PIO_CFG_OUTPUT   		(0b001	)
+
+/*
+ * bits width, common for every pio
+ */
+#define PIO_BITS_WIDTH_CFG   		(3	)
+#define PIO_BITS_WIDTH_PULL   		(2	)
+#define PIO_BITS_WIDTH_DRVLVL   	(2	)
+
+/*
+ * reg offset(from cfg0 reg addr)
+ */
+#define PIO_OFF_REG_DATA   		(0x10	) /* data reg offset */
+#define PIO_OFF_REG_PULL   		(0x1C	) /* pull0 reg offset */
+#define PIO_OFF_REG_DRVLVL   		(0x14	) /* drvlevel0 reg offset */
+
+/*
+ * lock operation for gpio chip
+ */
+#define PIO_CHIP_LOCK_INIT(lock)	spin_lock_init((lock))
+#define PIO_CHIP_LOCK_DEINIT(lock)	do{}while(0)
+#define PIO_CHIP_LOCK(lock, flags)	spin_lock_irqsave((lock), (flags))
+#define PIO_CHIP_UNLOCK(lock, flags)	spin_unlock_irqrestore((lock), (flags))
+
+/*
+ * reg read write operation
+ */
+#define PIO_READ_REG(reg)		readl(reg)
+/* fix watchdog hw bug:
+ * when write 01C208D8/01C208F8/01C20918, clear wd reg 01C20CD8/01C20CF8/01C20D18
+ */
+#define PIO_WRITE_REG(reg, val)		do {						\
+						writel((val), (void *)(reg));		\
+						if(unlikely(0xF1C208D8 == reg ))	\
+							writel(0, 0xF1C20CD8);		\
+						else if(unlikely(0xF1C208F8 == reg))	\
+							writel(0, 0xF1C20CF8);		\
+						else if(unlikely(0xF1C20918 == reg))	\
+							writel(0, 0xF1C20D18);		\
+					} while(0)
+/* read/write bits value from pos of reg */
+#define PIO_READ_BITS(reg, pos, width)		((PIO_READ_REG(reg) >> (pos)) & ((1 << (width)) - 1))
+#define PIO_WRITE_BITS(reg, pos, width, val)	PIO_WRITE_REG(reg, (readl(reg) & (u32)(~(((1 << (width)) - 1) << (pos)))) \
+								| (u32)(((val) & ((1 << (width)) - 1)) << (pos)))
+/* set/clear one bit */
+#define PIO_SET_BIT(reg, offset)	PIO_WRITE_BITS(reg, offset, 1, 1)
+#define PIO_CLR_BIT(reg, offset)	PIO_WRITE_BITS(reg, offset, 1, 0)
+
+/*
+ * gpio struct define below
+ */
+struct gpio_cfg_t;
+struct gpio_pm_t;
+struct aw_gpio_chip;
+
+typedef u32 (*pset_cfg)(struct aw_gpio_chip *pchip, u32 offset, u32 val);
+typedef u32 (*pget_cfg)(struct aw_gpio_chip *pchip, u32 offset);
+typedef u32 (*pset_pull)(struct aw_gpio_chip *pchip, u32 offset, u32 val);
+typedef u32 (*pget_pull)(struct aw_gpio_chip *pchip, u32 offset);
+typedef u32 (*pset_drvlevel)(struct aw_gpio_chip *pchip, u32 offset, u32 val);
+typedef u32 (*pget_drvlevel)(struct aw_gpio_chip *pchip, u32 offset);
+
+struct gpio_cfg_t {
+	pset_cfg 	set_cfg;
+	pget_cfg 	get_cfg;
+	pset_pull 	set_pull;
+	pget_pull 	get_pull;
+	pset_drvlevel 	set_drvlevel;
+	pget_drvlevel 	get_drvlevel;
+};
+
+typedef u32 (*peint_set_trig)(struct aw_gpio_chip *pchip, u32 offset, enum gpio_eint_trigtype trig_val);
+typedef u32 (*peint_get_trig)(struct aw_gpio_chip *pchip, u32 offset, enum gpio_eint_trigtype *pval);
+typedef u32 (*peint_get_enable)(struct aw_gpio_chip *pchip, u32 offset, u32 *penable);
+typedef u32 (*peint_set_enable)(struct aw_gpio_chip *pchip, u32 offset, u32 enable);
+typedef u32 (*peint_get_irqpd_sta)(struct aw_gpio_chip *pchip, u32 offset);
+typedef u32 (*peint_clr_irqpd_sta)(struct aw_gpio_chip *pchip, u32 offset);
+typedef u32 (*peint_set_debounce)(struct aw_gpio_chip *pchip, struct gpio_eint_debounce val); /* for chip, not just port */
+typedef u32 (*peint_get_debounce)(struct aw_gpio_chip *pchip, struct gpio_eint_debounce *pval); /* for chip, not just port */
+
+struct gpio_eint_cfg_t {
+	peint_set_trig 		eint_set_trig;
+	peint_get_trig 		eint_get_trig;
+	peint_set_enable 	eint_set_enable;
+	peint_get_enable 	eint_get_enable;
+	peint_get_irqpd_sta 	eint_get_irqpd_sta;
+	peint_clr_irqpd_sta 	eint_clr_irqpd_sta;
+	peint_set_debounce 	eint_set_debounce;
+	peint_get_debounce 	eint_get_debounce;
+};
+
+typedef u32 (*psave)(struct aw_gpio_chip *pchip);
+typedef u32 (*presume)(struct aw_gpio_chip *pchip);
+
+struct gpio_pm_t {
+	psave 		save;
+	presume 	resume;
+};
+
+/*
+ * struct for aw gpio chip
+ */
+struct aw_gpio_chip {
+	struct gpio_chip 	chip;
+	struct gpio_cfg_t	*cfg;
+	struct gpio_eint_cfg_t	*cfg_eint;
+	struct gpio_pm_t 	*pm;
+	void __iomem		*vbase;
+	void __iomem		*vbase_eint;	/* gpio eint config reg base */
+	u32 			irq_num;
+	spinlock_t 		lock;
+};
+
+#endif  /* __GPIO_COMMON_H */
diff --git a/arch/arm/mach-sun6i/gpio/gpio_eint.c b/arch/arm/mach-sun6i/gpio/gpio_eint.c
new file mode 100644
index 0000000..e2c5a3a
--- /dev/null
+++ b/arch/arm/mach-sun6i/gpio/gpio_eint.c
@@ -0,0 +1,834 @@
+/*
+ * arch/arm/mach-sun6i/gpio/gpio_eint.c
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i gpio driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include "gpio_include.h"
+
+/**
+ * is_gpio_canbe_eint - check if gpio canbe configured as eint
+ * @gpio:	the global gpio index
+ *
+ * return true if the gpio canbe configured as eint, false otherwise.
+ */
+bool is_gpio_canbe_eint(u32 gpio)
+{
+	int 	i = 0;
+	u32 	gpio_eint_group[][2] = {
+		{GPIOA(0), 	GPIOA(27)},
+		{GPIOB(0), 	GPIOB(7) },
+		{GPIOE(0), 	GPIOE(16)},
+		{GPIOG(0), 	GPIOG(18)},
+		{GPIOL(5), 	GPIOL(8) }, /* NOTE: only PL5 ~ PL8 can be configured as einit */
+		{GPIOM(0), 	GPIOM(7) }
+	};
+
+	for(i = 0; i < ARRAY_SIZE(gpio_eint_group); i++)
+		if(gpio >= gpio_eint_group[i][0]
+			&& gpio <= gpio_eint_group[i][1])
+			return true;
+	return false;
+}
+
+/**
+ * __is_r_pl - check if gpio is in r_gpio_l
+ * @gpio:	the global gpio index
+ *
+ * return true if the gpio is in r_gpio_l, false otherwise.
+ */
+u32 inline __is_r_pl(u32 gpio)
+{
+	return (gpio >= PL_NR_BASE && gpio < PL_NR_BASE + PL_NR);
+}
+
+/**
+ * __is_r_pio - check if gpio is r_gpio: r_pl or r_pm
+ * @gpio:	the global gpio index
+ *
+ * return true if the gpio is in r_gpio, false otherwise.
+ */
+u32 inline __is_r_pio(u32 gpio)
+{
+	if((gpio >= PL_NR_BASE && gpio < PL_NR_BASE + PL_NR)
+		|| (gpio >= PM_NR_BASE && gpio < PM_NR_BASE + PM_NR))
+		return true;
+	return false;
+}
+
+/**
+ * gpio_eint_set_trig - set trig type of the gpio
+ * @chip:	aw_gpio_chip struct for the gpio
+ * @offset:	offset from gpio_chip->base
+ * @trig_val:	the trig type to set
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 gpio_eint_set_trig(struct aw_gpio_chip *pchip, u32 offset, enum gpio_eint_trigtype trig_val)
+{
+	u32 	reg_off, bits_off;
+
+	reg_off = ((offset << 2) >> 5) << 2; /* (offset * 4) / 32 * 4 */
+	bits_off = (offset << 2) & ((1 << 5) - 1); /* (offset * 4) % 32 */
+
+#ifdef DBG_GPIO
+	WARN_ON(trig_val >= TRIG_INALID);
+	PIO_DBG("%s: chip 0x%08x, offset %d, write reg 0x%08x, bits off %d, val %d\n", __func__,
+		(u32)pchip, offset, (u32)pchip->vbase_eint + reg_off, bits_off, (u32)trig_val);
+#endif /* DBG_GPIO */
+	PIO_WRITE_BITS((u32)pchip->vbase_eint + reg_off, bits_off, 4, (u32)trig_val);
+	return 0;
+}
+
+/**
+ * gpio_eint_get_trig - get trig type of the gpio
+ * @chip:	aw_gpio_chip struct for the gpio
+ * @offset:	offset from gpio_chip->base
+ * @pval:	the trig type got
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 gpio_eint_get_trig(struct aw_gpio_chip *pchip, u32 offset, enum gpio_eint_trigtype *pval)
+{
+	u32 	reg_off, bits_off;
+
+	reg_off = ((offset << 2) >> 5) << 2; /* (offset * 4) / 32 * 4 */
+	bits_off = (offset << 2) & ((1 << 5) - 1); /* (offset * 4) % 32 */
+
+	*pval = (enum gpio_eint_trigtype)PIO_READ_BITS((u32)pchip->vbase_eint + reg_off, bits_off, 4);
+#ifdef DBG_GPIO
+	PIO_DBG("%s: chip 0x%08x, offset %d, read reg 0x%08x - 0x%08x, bits off %d, ret val %d\n", __func__,
+		(u32)pchip, offset, (u32)pchip->vbase_eint + reg_off,
+		PIO_READ_REG((u32)pchip->vbase_eint + reg_off), bits_off, (u32)*pval);
+	WARN_ON(*pval >= TRIG_INALID);
+#endif /* DBG_GPIO */
+	return 0;
+}
+
+/**
+ * gpio_eint_set_enable - enable/disable the gpio eint
+ * @chip:	aw_gpio_chip struct for the gpio
+ * @offset:	offset from gpio_chip->base
+ * @enable:	1 - enable the eint, 0 - disable the eint.
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 gpio_eint_set_enable(struct aw_gpio_chip *pchip, u32 offset, u32 enable)
+{
+#ifdef DBG_GPIO
+	PIO_DBG("%s: chip 0x%08x, offset %d, enable %d, write reg 0x%08x\n", __func__,
+		(u32)pchip, offset, enable, (u32)pchip->vbase_eint + PIO_EINT_OFF_REG_CTRL);
+#endif /* DBG_GPIO */
+
+	if(0 != enable)
+		PIO_SET_BIT((u32)pchip->vbase_eint + PIO_EINT_OFF_REG_CTRL, offset);
+	else
+		PIO_CLR_BIT((u32)pchip->vbase_eint + PIO_EINT_OFF_REG_CTRL, offset);
+	return 0;
+}
+
+/**
+ * gpio_eint_get_enable - get the gpio eint's enable/disable satus
+ * @chip:	aw_gpio_chip struct for the gpio
+ * @offset:	offset from gpio_chip->base
+ * @penable:	status got, 1 - the eint is enabled, 0 - disabled
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 gpio_eint_get_enable(struct aw_gpio_chip *pchip, u32 offset, u32 *penable)
+{
+	WARN_ON(NULL == penable);
+	*penable = PIO_READ_BITS((u32)pchip->vbase_eint + PIO_EINT_OFF_REG_CTRL, offset, 1);
+#ifdef DBG_GPIO
+	PIO_DBG("%s: chip 0x%08x, offset %d, read reg 0x%08x - 0x%08x, penable 0x%08x, *penable %d\n", __func__,
+		(u32)pchip, offset, (u32)pchip->vbase_eint + PIO_EINT_OFF_REG_CTRL,
+		PIO_READ_REG((u32)pchip->vbase_eint + PIO_EINT_OFF_REG_CTRL), (u32)penable, *penable);
+#endif /* DBG_GPIO */
+	return 0;
+}
+
+/**
+ * gpio_eint_get_irqpd_sta - get the irqpend status of the gpio
+ * @chip:	aw_gpio_chip struct for the gpio
+ * @offset:	offset from gpio_chip->base
+ *
+ * Returns the irqpend status of the gpio. 1 - irq pend, 0 - no irq pend.
+ */
+u32 gpio_eint_get_irqpd_sta(struct aw_gpio_chip *pchip, u32 offset)
+{
+	u32	uret = 0;
+
+	uret = PIO_READ_BITS((u32)pchip->vbase_eint + PIO_EINT_OFF_REG_STATUS, offset, 1);
+#ifdef DBG_GPIO
+	PIO_DBG("%s: chip 0x%08x, offset %d, read reg 0x%08x - 0x%08x, ret %d\n", __func__,
+		(u32)pchip, offset, (u32)pchip->vbase_eint + PIO_EINT_OFF_REG_STATUS,
+		PIO_READ_REG((u32)pchip->vbase_eint + PIO_EINT_OFF_REG_STATUS), uret);
+#endif /* DBG_GPIO */
+	return uret;
+}
+
+/**
+ * gpio_eint_clr_irqpd_sta - clr the irqpend status of the gpio
+ * @chip:	aw_gpio_chip struct for the gpio
+ * @offset:	offset from gpio_chip->base
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 gpio_eint_clr_irqpd_sta(struct aw_gpio_chip *pchip, u32 offset)
+{
+	if(1 == PIO_READ_BITS((u32)pchip->vbase_eint + PIO_EINT_OFF_REG_STATUS, offset, 1))
+		/* bug: clear all pending bits, but only need clear the offset bit here */
+		//PIO_WRITE_BITS(pchip->vbase_eint + PIO_EINT_OFF_REG_STATUS, offset, 1, 1);
+		PIO_WRITE_REG((u32)pchip->vbase_eint + PIO_EINT_OFF_REG_STATUS, 1 << offset);
+	return 0;
+}
+
+/**
+ * gpio_eint_set_debounce - set the debounce of the gpio group
+ * @chip:	aw_gpio_chip struct for the gpio
+ * @val:	debounce to set.
+ *
+ * for eint group, not for single port
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 gpio_eint_set_debounce(struct aw_gpio_chip *pchip, struct gpio_eint_debounce val)
+{
+	u32 	utemp = 0;
+
+	utemp = (val.clk_sel & 1) | ((val.clk_pre_scl & 0b111) << 4);
+
+#ifdef DBG_GPIO
+	PIO_DBG("%s: clk_sel %d, clk_pre_scl %d, write 0x%08x to reg 0x%08x\n", __func__, val.clk_sel,
+		val.clk_pre_scl, utemp, (u32)pchip->vbase_eint + PIO_EINT_OFF_REG_DEBOUNCE);
+#endif /* DBG_GPIO */
+	PIO_WRITE_REG((u32)pchip->vbase_eint + PIO_EINT_OFF_REG_DEBOUNCE, utemp);
+	return 0;
+}
+
+/**
+ * gpio_eint_get_debounce - get the debounce of the gpio group
+ * @chip:	aw_gpio_chip struct for the gpio
+ * @val:	debounce got.
+ *
+ * for eint group, not for single port
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 gpio_eint_get_debounce(struct aw_gpio_chip *pchip, struct gpio_eint_debounce *pval)
+{
+	u32 	utemp = 0;
+
+	WARN_ON(NULL == pval);
+	utemp = PIO_READ_REG((u32)pchip->vbase_eint + PIO_EINT_OFF_REG_DEBOUNCE);
+	pval->clk_sel = utemp & 1;
+	pval->clk_pre_scl = (utemp >> 4) & 0b111;
+#ifdef DBG_GPIO
+	PIO_DBG("%s: read from reg 0x%08x - 0x%08x, clk_sel %d, clk_pre_scl %d\n", __func__,
+		(u32)pchip->vbase_eint + PIO_EINT_OFF_REG_DEBOUNCE,
+		utemp, pval->clk_sel, pval->clk_pre_scl);
+#endif /* DBG_GPIO */
+	return 0;
+}
+
+/**
+ * sw_gpio_eint_set_trigtype - set trig type of the gpio
+ * @gpio:	the global gpio index
+ * @trig_type:	the trig type to set
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_gpio_eint_set_trigtype(u32 gpio, enum gpio_eint_trigtype trig_type)
+{
+	u32	uret = 0;
+	u32	offset = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	PIO_DBG("%s: gpio 0x%08x, trig_type %d\n", __func__, gpio, (u32)trig_type);
+
+	if(false == is_gpio_canbe_eint(gpio) || trig_type >= TRIG_INALID) {
+		uret = __LINE__;
+		goto end;
+	}
+	pchip = gpio_to_aw_gpiochip(gpio);
+	if(!pchip || !pchip->cfg_eint || !pchip->cfg_eint->eint_set_trig) {
+		uret = __LINE__;
+		goto end;
+	}
+
+	if(unlikely(__is_r_pl(gpio)))
+		offset = gpio - pchip->chip.base - R_PL_EINT_START;
+	else
+		offset = gpio - pchip->chip.base;
+
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+	uret = pchip->cfg_eint->eint_set_trig(pchip, offset, trig_type);
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+end:
+	if(0 != uret)
+		printk("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+EXPORT_SYMBOL(sw_gpio_eint_set_trigtype);
+
+/**
+ * sw_gpio_eint_get_trigtype - get trig type of the gpio
+ * @gpio:	the global gpio index
+ * @pval:	the trig type got
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_gpio_eint_get_trigtype(u32 gpio, enum gpio_eint_trigtype *pval)
+{
+	u32	uret = 0;
+	u32	offset = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	if(false == is_gpio_canbe_eint(gpio) || NULL == pval) {
+		uret = __LINE__;
+		goto end;
+	}
+	pchip = gpio_to_aw_gpiochip(gpio);
+	if(!pchip || !pchip->cfg_eint || !pchip->cfg_eint->eint_get_trig) {
+		uret = __LINE__;
+		goto end;
+	}
+
+	if(unlikely(__is_r_pl(gpio)))
+		offset = gpio - pchip->chip.base - R_PL_EINT_START;
+	else
+		offset = gpio - pchip->chip.base;
+
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+	uret = pchip->cfg_eint->eint_get_trig(pchip, offset, pval);
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+	PIO_DBG("%s: gpio 0x%08x, trig_type ret %d\n", __func__, gpio, (u32)*pval);
+end:
+	if(0 != uret)
+		printk("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+EXPORT_SYMBOL(sw_gpio_eint_get_trigtype);
+
+/**
+ * sw_gpio_eint_set_enable - enable/disable the gpio eint
+ * @gpio:	the global gpio index
+ * @enable:	1 - enable the eint, 0 - disable the eint.
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_gpio_eint_set_enable(u32 gpio, u32 enable)
+{
+	u32	uret = 0;
+	u32	offset = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	PIO_DBG("%s: gpio 0x%08x, enable %d\n", __func__, gpio, enable);
+	if(false == is_gpio_canbe_eint(gpio)) {
+		uret = __LINE__;
+		goto end;
+	}
+	pchip = gpio_to_aw_gpiochip(gpio);
+	if(!pchip || !pchip->cfg_eint || !pchip->cfg_eint->eint_set_enable) {
+		uret = __LINE__;
+		goto end;
+	}
+
+	if(unlikely(__is_r_pl(gpio)))
+		offset = gpio - pchip->chip.base - R_PL_EINT_START;
+	else
+		offset = gpio - pchip->chip.base;
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+	uret = pchip->cfg_eint->eint_set_enable(pchip, offset, enable);
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+end:
+	if(0 != uret)
+		printk("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+EXPORT_SYMBOL(sw_gpio_eint_set_enable);
+
+/**
+ * sw_gpio_eint_get_enable - get the gpio eint's enable/disable satus
+ * @gpio:	the global gpio index
+ * @penable:	status got, 1 - the eint is enabled, 0 - disabled
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_gpio_eint_get_enable(u32 gpio, u32 *penable)
+{
+	u32	uret = 0;
+	u32	offset = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	if(false == is_gpio_canbe_eint(gpio) || NULL == penable) {
+		uret = __LINE__;
+		goto end;
+	}
+	pchip = gpio_to_aw_gpiochip(gpio);
+	if(!pchip || !pchip->cfg_eint || !pchip->cfg_eint->eint_get_enable) {
+		uret = __LINE__;
+		goto end;
+	}
+
+	if(unlikely(__is_r_pl(gpio)))
+		offset = gpio - pchip->chip.base - R_PL_EINT_START;
+	else
+		offset = gpio - pchip->chip.base;
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+	uret = pchip->cfg_eint->eint_get_enable(pchip, offset, penable);
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+	PIO_DBG("%s: gpio 0x%08x, penable ret %d\n", __func__, gpio, *penable);
+end:
+	if(0 != uret)
+		printk("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+EXPORT_SYMBOL(sw_gpio_eint_get_enable);
+
+/**
+ * sw_gpio_eint_get_irqpd_sta - get the irqpend status of the gpio
+ * @gpio:	the global gpio index
+ *
+ * Returns the irqpend status of the gpio. 1 - irq pend, 0 - no irq pend.
+ */
+u32 sw_gpio_eint_get_irqpd_sta(u32 gpio)
+{
+	u32	uret = 0;
+	u32	offset = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	if(false == is_gpio_canbe_eint(gpio)) {
+		uret = __LINE__;
+		goto err;
+	}
+	pchip = gpio_to_aw_gpiochip(gpio);
+	if(!pchip || !pchip->cfg_eint || !pchip->cfg_eint->eint_get_irqpd_sta) {
+		uret = __LINE__;
+		goto err;
+	}
+
+	if(unlikely(__is_r_pl(gpio)))
+		offset = gpio - pchip->chip.base - R_PL_EINT_START;
+	else
+		offset = gpio - pchip->chip.base;
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+	uret = pchip->cfg_eint->eint_get_irqpd_sta(pchip, offset);
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+	return uret;
+err:
+	printk("%s err, line %d\n", __func__, uret);
+	return 0; /* note here */
+}
+EXPORT_SYMBOL(sw_gpio_eint_get_irqpd_sta);
+
+/**
+ * sw_gpio_eint_clr_irqpd_sta - clr the irqpend status of the gpio
+ * @gpio:	the global gpio index
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_gpio_eint_clr_irqpd_sta(u32 gpio)
+{
+	u32	uret = 0;
+	u32	offset = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	if(false == is_gpio_canbe_eint(gpio)) {
+		uret = __LINE__;
+		goto end;
+	}
+	pchip = gpio_to_aw_gpiochip(gpio);
+	if(!pchip || !pchip->cfg_eint || !pchip->cfg_eint->eint_clr_irqpd_sta) {
+		uret = __LINE__;
+		goto end;
+	}
+
+	if(unlikely(__is_r_pl(gpio)))
+		offset = gpio - pchip->chip.base - R_PL_EINT_START;
+	else
+		offset = gpio - pchip->chip.base;
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+	uret = pchip->cfg_eint->eint_clr_irqpd_sta(pchip, offset);
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+end:
+	if(0 != uret)
+		printk("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+EXPORT_SYMBOL(sw_gpio_eint_clr_irqpd_sta);
+
+/**
+ * sw_gpio_eint_get_debounce - get the debounce of the gpio group
+ * @gpio:	the global gpio index
+ * @pdbc:	debounce got.
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_gpio_eint_get_debounce(u32 gpio, struct gpio_eint_debounce *pdbc)
+{
+	u32	uret = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	PIO_INF("%s to check: user are not allowed to get debounce, gpio %d\n", __func__, gpio);
+
+	if(false == is_gpio_canbe_eint(gpio) || NULL == pdbc) {
+		uret = __LINE__;
+		goto end;
+	}
+	pchip = gpio_to_aw_gpiochip(gpio);
+	if(!pchip || !pchip->cfg_eint || !pchip->cfg_eint->eint_get_debounce) {
+		uret = __LINE__;
+		goto end;
+	}
+
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+	uret = pchip->cfg_eint->eint_get_debounce(pchip, pdbc);
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+end:
+	if(0 != uret)
+		printk("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+EXPORT_SYMBOL(sw_gpio_eint_get_debounce);
+
+/**
+ * sw_gpio_eint_set_debounce - set the debounce of the gpio group
+ * @gpio:	the global gpio index
+ * @dbc:	debounce to set.
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_gpio_eint_set_debounce(u32 gpio, struct gpio_eint_debounce dbc)
+{
+	u32	uret = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	PIO_INF("%s to check: user are not allowed to set debounce, gpio %d\n", __func__, gpio);
+
+	if(false == is_gpio_canbe_eint(gpio)) {
+		uret = __LINE__;
+		goto end;
+	}
+	pchip = gpio_to_aw_gpiochip(gpio);
+	if(!pchip || !pchip->cfg_eint || !pchip->cfg_eint->eint_set_debounce) {
+		uret = __LINE__;
+		goto end;
+	}
+
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+	uret = pchip->cfg_eint->eint_set_debounce(pchip, dbc);
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+end:
+	if(0 != uret)
+		printk("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+EXPORT_SYMBOL(sw_gpio_eint_set_debounce);
+
+/**
+ * sw_gpio_eint_setall_range - config a range of gpio, config mul sel to eint,
+ * 	set driver level and pull, set the trig mode, and enable eint.
+ * @pcfg:	config info to set.
+ * @cfg_num:	member cnt of pcfg
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_gpio_eint_setall_range(struct gpio_config_eint_all *pcfg, u32 cfg_num)
+{
+	u32 	i = 0;
+	u32	uret = 0;
+	u32	offset = 0;
+	u32	mulsel_eint = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	if(NULL == pcfg || 0 == cfg_num)
+		return __LINE__;
+
+	for(i = 0; i < cfg_num; i++, pcfg++) {
+		/* request gpio */
+		if(false == is_gpio_canbe_eint(pcfg->gpio)) {
+			printk("%s err: line %d, gpio %d cannot configed as eint\n", __func__, __LINE__, pcfg->gpio);
+			continue;
+		}
+		if(pcfg->trig_type >= TRIG_INALID) {
+			printk("%s err: line %d, gpio %d trig type %d invalid\n", __func__, __LINE__, pcfg->gpio, pcfg->trig_type);
+			continue;
+		}
+		/* get aw_gpiochip */
+		pchip = gpio_to_aw_gpiochip(pcfg->gpio);
+		if(!pchip || !pchip->cfg->set_cfg || !pchip->cfg->set_pull || !pchip->cfg->set_drvlevel
+			 || !pchip->cfg_eint->eint_set_trig || !pchip->cfg_eint->eint_set_enable
+			 || !pchip->cfg_eint->eint_clr_irqpd_sta) {
+			printk("%s err: line %d failed, gpio %d\n", __func__, __LINE__, pcfg->gpio);
+			continue;
+		}
+		/* get mul sel */
+		offset = pcfg->gpio - pchip->chip.base;
+		if(unlikely(__is_r_pio(pcfg->gpio)))
+			mulsel_eint = R_GPIO_CFG_EINT;
+		else
+			mulsel_eint = GPIO_CFG_EINT;
+
+		PIO_DBG("%s: gpio %d, base %d, offset %d\n", __func__, pcfg->gpio, pchip->chip.base, offset);
+
+		PIO_CHIP_LOCK(&pchip->lock, flags);
+		/* set mul sel, pull and drvlvl */
+		WARN_ON(0 != pchip->cfg->set_cfg(pchip, offset, mulsel_eint));
+		if(GPIO_PULL_DEFAULT != pcfg->pull)
+			WARN_ON(0 != pchip->cfg->set_pull(pchip, offset, pcfg->pull));
+		if(GPIO_DRVLVL_DEFAULT != pcfg->drvlvl)
+			WARN_ON(0 != pchip->cfg->set_drvlevel(pchip, offset, pcfg->drvlvl));
+
+		/* redirect offset for eint op: r_pl_5 is PL_EINT0... */
+		if(unlikely(__is_r_pl(pcfg->gpio)))
+			offset -= R_PL_EINT_START;
+		/* set trig type */
+		pchip->cfg_eint->eint_set_trig(pchip, offset, pcfg->trig_type);
+		/* enable/disable eint */
+		WARN(0 != pcfg->enabled, "%s maybe err, line %d, enable gpio irq may lead to __report_bad_irq!\n", __func__, __LINE__);
+		pchip->cfg_eint->eint_set_enable(pchip, offset, pcfg->enabled);
+		/* clr the irqpd status */
+		if(0 != pcfg->irq_pd)
+			pchip->cfg_eint->eint_clr_irqpd_sta(pchip, offset);
+		PIO_CHIP_UNLOCK(&pchip->lock, flags);
+	}
+
+	return uret;
+}
+EXPORT_SYMBOL(sw_gpio_eint_setall_range);
+
+/**
+ * sw_gpio_eint_getall_range - get a range of gpio's eint info
+ * @pcfg:	config info got.
+ * @cfg_num:	member cnt of pcfg
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_gpio_eint_getall_range(struct gpio_config_eint_all *pcfg, u32 cfg_num)
+{
+	u32 	i = 0;
+	u32	uret = 0;
+	u32	offset = 0;
+	u32	mulsel_eint = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	if(NULL == pcfg || 0 == cfg_num)
+		return __LINE__;
+
+	for(i = 0; i < cfg_num; i++, pcfg++) {
+		/* check gpio invality */
+		if(false == is_gpio_canbe_eint(pcfg->gpio)) {
+			printk("%s err: line %d, gpio %d cannot configed as eint\n", __func__, __LINE__, pcfg->gpio);
+			continue;
+		}
+		pchip = gpio_to_aw_gpiochip(pcfg->gpio);
+		if(!pchip || !pchip->cfg->get_cfg || !pchip->cfg->get_pull || !pchip->cfg->get_drvlevel
+			 || !pchip->cfg_eint->eint_get_trig || !pchip->cfg_eint->eint_get_enable
+			 || !pchip->cfg_eint->eint_get_irqpd_sta) {
+			printk("%s err: line %d, gpio_to_aw_gpiochip failed, gpio %d\n", __func__, __LINE__, pcfg->gpio);
+			continue;
+		}
+
+		/* get mul sel */
+		offset = pcfg->gpio - pchip->chip.base;
+		if(unlikely(__is_r_pio(pcfg->gpio)))
+			mulsel_eint = R_GPIO_CFG_EINT;
+		else
+			mulsel_eint = GPIO_CFG_EINT;
+
+		PIO_CHIP_LOCK(&pchip->lock, flags);
+		/* verify mul sel is eint, and get pull and drvlvl */
+		WARN_ON(mulsel_eint != pchip->cfg->get_cfg(pchip, offset));
+		pcfg->pull = pchip->cfg->get_pull(pchip, offset);
+		pcfg->drvlvl = pchip->cfg->get_drvlevel(pchip, offset);
+
+		/* redirect offset for eint op: r_pl_5 is PL_EINT0... */
+		if(unlikely(__is_r_pl(pcfg->gpio)))
+			offset -= R_PL_EINT_START;
+		/* get trig type */
+		pchip->cfg_eint->eint_get_trig(pchip, offset, &pcfg->trig_type);
+		WARN_ON(pcfg->trig_type >= TRIG_INALID);
+		/* get enable/disable status */
+		pchip->cfg_eint->eint_get_enable(pchip, offset, &pcfg->enabled);
+		/* get the irqpd status */
+		pcfg->irq_pd = pchip->cfg_eint->eint_get_irqpd_sta(pchip, offset);
+		PIO_CHIP_UNLOCK(&pchip->lock, flags);
+	}
+
+	return uret;
+}
+EXPORT_SYMBOL(sw_gpio_eint_getall_range);
+
+/**
+ * sw_gpio_eint_dumpall_range - dump a range of gpio's eint config info.
+ * @pcfg:	config info to dump.
+ * @cfg_num:	member cnt of pcfg
+ *
+ */
+void sw_gpio_eint_dumpall_range(struct gpio_config_eint_all *pcfg, u32 cfg_num)
+{
+	u32 	i = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	if(NULL == pcfg || 0 == cfg_num)
+		return;
+
+	PIO_DBG("+++++++++++%s+++++++++++\n", __func__);
+	PIO_DBG("  gpio    pull    drvlevl   enabled  irq_pd   trig_type\n");
+	for(i = 0; i < cfg_num; i++, pcfg++) {
+		pchip = gpio_to_aw_gpiochip(pcfg->gpio);
+		if(NULL == pchip) {
+			printk("%s err: line %d, gpio_to_aw_gpiochip(%d) failed\n", __func__, __LINE__, pcfg->gpio);
+			continue;
+		}
+		/* dump config item */
+		PIO_CHIP_LOCK(&pchip->lock, flags);
+		PIO_DBG("  %4d    %4d    %7d   %7d  %6d   %9d\n", pcfg->gpio, pcfg->pull, pcfg->drvlvl,
+			pcfg->enabled, pcfg->irq_pd, pcfg->trig_type);
+		PIO_CHIP_UNLOCK(&pchip->lock, flags);
+	}
+	PIO_DBG("-----------%s-----------\n", __func__);
+}
+EXPORT_SYMBOL(sw_gpio_eint_dumpall_range);
+
+irqreturn_t gpio_irq_hdl(int irq, void *dev)
+{
+	struct gpio_irq_handle *pdev_id = (struct gpio_irq_handle *)dev;
+
+	if(NULL == pdev_id || false == is_gpio_canbe_eint(pdev_id->gpio))
+		return IRQ_NONE;
+	if(0 == sw_gpio_eint_get_irqpd_sta(pdev_id->gpio))
+		return IRQ_NONE;
+
+	sw_gpio_eint_clr_irqpd_sta(pdev_id->gpio);
+	if(NULL != pdev_id->handler) {
+		if(0 != pdev_id->handler(pdev_id->parg))
+			printk("%s err, line %d, handler failed\n", __func__, __LINE__);
+	}
+	return IRQ_HANDLED;
+}
+
+/**
+ * sw_gpio_irq_request - request gpio irq.
+ * @gpio:	the global gpio index
+ * @trig_type:	trig type of gpio eint
+ * @handle:	irq callback
+ * @para:	para of the handle function.
+ *
+ * Returns the handle if sucess, 0 if failed.
+ */
+u32 sw_gpio_irq_request(u32 gpio, enum gpio_eint_trigtype trig_type,
+			peint_handle handle, void *para)
+{
+	int 	irq_no = 0;
+	int 	req_ret = -1;
+	u32 	usign = 0;
+	struct gpio_config_eint_all cfg = {0};
+	struct gpio_irq_handle *pdev_id = NULL;
+
+	PIO_DBG("%s: gpio %d, trig %d, handle 0x%08x, para 0x%08x\n", __func__,
+		gpio, trig_type, (u32)handle, (u32)para);
+
+	WARN(NULL == handle, "%s err, handle is NULL!\n", __func__);
+	if(false == is_gpio_canbe_eint(gpio)) {
+		usign = __LINE__;
+		goto end;
+	}
+
+	/* config to eint, and set pull, drivel level, trig type */
+	cfg.gpio 	= gpio;
+	cfg.pull 	= GPIO_PULL_DEFAULT;
+	cfg.drvlvl 	= GPIO_DRVLVL_DEFAULT;
+	cfg.enabled	= 0;
+	cfg.trig_type	= trig_type;
+	if(0 != sw_gpio_eint_setall_range(&cfg, 1)) {
+		usign = __LINE__;
+		goto end;
+	}
+
+	/* request irq */
+	pdev_id = (struct gpio_irq_handle *)kmalloc(sizeof(struct gpio_irq_handle), GFP_KERNEL);
+	if(NULL == pdev_id) {
+		usign = __LINE__;
+		goto end;
+	}
+	pdev_id->gpio = gpio;
+	pdev_id->handler = handle;
+	pdev_id->parg = para;
+	irq_no = __gpio_to_irq(gpio);
+	PIO_DBG("%s: __gpio_to_irq return %d\n", __func__, irq_no);
+	req_ret = request_irq(irq_no, gpio_irq_hdl, IRQF_DISABLED | IRQF_SHARED, "gpio_irq", (void *)pdev_id);
+	if(req_ret) {
+		usign = __LINE__;
+		goto end;
+	}
+
+	/* enable the eint */
+	if(0 != sw_gpio_eint_set_enable(gpio, 1)) {
+		usign = __LINE__;
+		goto end;
+	}
+end:
+	if(0 != usign) {
+		printk("%s err, line %d\n", __func__, usign);
+		if(0 == req_ret && NULL != pdev_id)
+			free_irq(irq_no, (void *)pdev_id);
+		if(NULL != pdev_id)
+			kfree(pdev_id);
+		return 0;
+	}
+	return (u32)pdev_id;
+}
+EXPORT_SYMBOL(sw_gpio_irq_request);
+
+/**
+ * sw_gpio_irq_free - free gpio irq.
+ * @handle:	handle return by sw_gpio_irq_request
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+void sw_gpio_irq_free(u32 handle)
+{
+	u32 	gpio = 0;
+	int 	irq_no = 0;
+	struct gpio_irq_handle *pdev_id = (struct gpio_irq_handle *)handle;
+
+	PIO_DBG("%s: handle 0x%08x\n", __func__, (u32)handle);
+	if(NULL == pdev_id || false == is_gpio_canbe_eint(pdev_id->gpio)) {
+		printk("%s err: invalid para, line %d\n", __func__, __LINE__);
+		return;
+	}
+
+	/* clear gpio reg */
+	gpio = pdev_id->gpio;
+	sw_gpio_eint_set_enable(gpio, 0);
+	sw_gpio_eint_clr_irqpd_sta(gpio);
+	/* free irq */
+	irq_no = __gpio_to_irq(gpio);
+	PIO_DBG("%s: __gpio_to_irq(%d) ret %d\n", __func__, gpio, irq_no);
+	free_irq(irq_no, (void *)pdev_id);
+	kfree((void *)pdev_id);
+	return;
+}
+EXPORT_SYMBOL(sw_gpio_irq_free);
diff --git a/arch/arm/mach-sun6i/gpio/gpio_eint.h b/arch/arm/mach-sun6i/gpio/gpio_eint.h
new file mode 100644
index 0000000..1f7176d
--- /dev/null
+++ b/arch/arm/mach-sun6i/gpio/gpio_eint.h
@@ -0,0 +1,42 @@
+/*
+ * arch/arm/mach-sun6i/gpio/gpio_eint.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i gpio header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __GPIO_EINT_H
+#define __GPIO_EINT_H
+
+#define PIO_EINT_OFF_REG_CFG		0
+#define PIO_EINT_OFF_REG_CTRL		0x10
+#define PIO_EINT_OFF_REG_STATUS		0x14
+#define PIO_EINT_OFF_REG_DEBOUNCE	0x18
+
+#define R_PL_EINT_START			5 	/* r_pl_5 as S_PL_EINT0 */
+
+struct gpio_irq_handle {
+	u32 	gpio;
+	peint_handle handler;
+	void	*parg;
+};
+
+u32 gpio_eint_set_trig(struct aw_gpio_chip *pchip, u32 offset, enum gpio_eint_trigtype trig_val);
+u32 gpio_eint_get_trig(struct aw_gpio_chip *pchip, u32 offset, enum gpio_eint_trigtype *pval);
+u32 gpio_eint_set_enable(struct aw_gpio_chip *pchip, u32 offset, u32 enable);
+u32 gpio_eint_get_enable(struct aw_gpio_chip *pchip, u32 offset, u32 *penable);
+u32 gpio_eint_get_irqpd_sta(struct aw_gpio_chip *pchip, u32 offset);
+u32 gpio_eint_clr_irqpd_sta(struct aw_gpio_chip *pchip, u32 offset);
+u32 gpio_eint_set_debounce(struct aw_gpio_chip *pchip, struct gpio_eint_debounce val);
+u32 gpio_eint_get_debounce(struct aw_gpio_chip *pchip, struct gpio_eint_debounce *pval);
+bool is_gpio_canbe_eint(u32 gpio);
+
+#endif /* __GPIO_EINT_H */
diff --git a/arch/arm/mach-sun6i/gpio/gpio_include.h b/arch/arm/mach-sun6i/gpio/gpio_include.h
new file mode 100644
index 0000000..dc3acae
--- /dev/null
+++ b/arch/arm/mach-sun6i/gpio/gpio_include.h
@@ -0,0 +1,45 @@
+/*
+ * arch/arm/mach-sun6i/gpio/gpio_includes.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i gpio header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __GPIO_INCLUDES_H
+#define __GPIO_INCLUDES_H
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/module.h>
+#include <linux/serial_core.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/pm.h>
+#include <asm-generic/gpio.h>
+#include <linux/mfd/axp-mfd.h>
+
+#include <mach/memory.h>
+#include <mach/platform.h>
+#include <mach/gpio.h>
+#include <mach/clock.h>
+
+#include "gpio_common.h"
+#include "gpio_eint.h"
+#include "gpio_init.h"
+#include "gpio_multi_func.h"
+#include "gpio_base.h"
+
+#endif  /* __GPIO_INCLUDES_H */
diff --git a/arch/arm/mach-sun6i/gpio/gpio_init.c b/arch/arm/mach-sun6i/gpio/gpio_init.c
new file mode 100644
index 0000000..3cef7cf
--- /dev/null
+++ b/arch/arm/mach-sun6i/gpio/gpio_init.c
@@ -0,0 +1,338 @@
+/*
+ * arch/arm/mach-sun6i/gpio/gpio_init.c
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i gpio driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include "gpio_include.h"
+
+//#define GPIO_SUPPORT_STANDBY /* noramlly, gpio need not deal standby */
+
+static struct clk *g_apb_pio_clk = NULL;
+
+/**
+ * gpio_save - save somethig for the chip before enter sleep
+ * @chip:	aw_gpio_chip which will be saved
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 gpio_save(struct aw_gpio_chip *pchip)
+{
+	/* save something before suspend */
+	printk("%s: not implete yet, line %d\n", __func__, __LINE__);
+	return 0;
+}
+
+/**
+ * gpio_resume - restore somethig for the chip after wake up
+ * @chip:	aw_gpio_chip which will be saved
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 gpio_resume(struct aw_gpio_chip *pchip)
+{
+	/* restore something after wakeup */
+	printk("%s: not implete yet, line %d\n", __func__, __LINE__);
+	return 0;
+}
+
+/*
+ * gpio power api struct
+ */
+struct gpio_pm_t g_pm = {
+	gpio_save,
+	gpio_resume
+};
+
+/*
+ * gpio config api struct
+ */
+struct gpio_cfg_t g_cfg = {
+	gpio_set_cfg,
+	gpio_get_cfg,
+	gpio_set_pull,
+	gpio_get_pull,
+	gpio_set_drvlevel,
+	gpio_get_drvlevel,
+};
+
+/*
+ * gpio eint config api struct
+ */
+struct gpio_eint_cfg_t g_eint_cfg = {
+	gpio_eint_set_trig,
+	gpio_eint_get_trig,
+	gpio_eint_set_enable,
+	gpio_eint_get_enable,
+	gpio_eint_get_irqpd_sta,
+	gpio_eint_clr_irqpd_sta,
+	gpio_eint_set_debounce,
+	gpio_eint_get_debounce,
+};
+
+/*
+ * gpio chips for the platform
+ */
+struct aw_gpio_chip gpio_chips[] = {
+	{
+		.cfg	= &g_cfg,
+		.pm	= &g_pm,
+		.chip	= {
+			.base	= PA_NR_BASE,
+			.ngpio	= PA_NR,
+			.label	= "GPA",
+			.to_irq = __pio_to_irq,
+		},
+		.vbase  = (void __iomem *)PIO_VBASE(0),
+		/* cfg for eint */
+		.irq_num = AW_IRQ_EINTA,
+		.vbase_eint = (void __iomem *)PIO_VBASE_EINT_PA,
+		.cfg_eint = &g_eint_cfg,
+	}, {
+		.cfg	= &g_cfg,
+		.pm	= &g_pm,
+		.chip	= {
+			.base	= PB_NR_BASE,
+			.ngpio	= PB_NR,
+			.label	= "GPB",
+			.to_irq = __pio_to_irq,
+		},
+		.vbase  = (void __iomem *)PIO_VBASE(1),
+		/* cfg for eint */
+		.irq_num = AW_IRQ_EINTB,
+		.vbase_eint = (void __iomem *)PIO_VBASE_EINT_PB,
+		.cfg_eint = &g_eint_cfg,
+	}, {
+		.cfg	= &g_cfg,
+		.pm	= &g_pm,
+		.chip	= {
+			.base	= PC_NR_BASE,
+			.ngpio	= PC_NR,
+			.label	= "GPC",
+		},
+		.vbase  = (void __iomem *)PIO_VBASE(2),
+	}, {
+		.cfg	= &g_cfg,
+		.pm	= &g_pm,
+		.chip	= {
+			.base	= PD_NR_BASE,
+			.ngpio	= PD_NR,
+			.label	= "GPD",
+		},
+		.vbase  = (void __iomem *)PIO_VBASE(3),
+	}, {
+		.cfg	= &g_cfg,
+		.pm	= &g_pm,
+		.chip	= {
+			.base	= PE_NR_BASE,
+			.ngpio	= PE_NR,
+			.label	= "GPE",
+			.to_irq = __pio_to_irq,
+		},
+		.vbase  = (void __iomem *)PIO_VBASE(4),
+		/* cfg for eint */
+		.irq_num = AW_IRQ_EINTE,
+		.vbase_eint = (void __iomem *)PIO_VBASE_EINT_PE,
+		.cfg_eint = &g_eint_cfg,
+	}, {
+		.cfg	= &g_cfg,
+		.pm	= &g_pm,
+		.chip	= {
+			.base	= PF_NR_BASE,
+			.ngpio	= PF_NR,
+			.label	= "GPF",
+		},
+		.vbase  = (void __iomem *)PIO_VBASE(5),
+	}, {
+		.cfg	= &g_cfg,
+		.pm	= &g_pm,
+		.chip	= {
+			.base	= PG_NR_BASE,
+			.ngpio	= PG_NR,
+			.label	= "GPG",
+			.to_irq = __pio_to_irq,
+		},
+		.vbase  = (void __iomem *)PIO_VBASE(6),
+		/* cfg for eint */
+		.irq_num = AW_IRQ_EINTG,
+		.vbase_eint = (void __iomem *)PIO_VBASE_EINT_PG,
+		.cfg_eint = &g_eint_cfg,
+	}, {
+		.cfg	= &g_cfg,
+		.pm	= &g_pm,
+		.chip	= {
+			.base	= PH_NR_BASE,
+			.ngpio	= PH_NR,
+			.label	= "GPH",
+		},
+		.vbase  = (void __iomem *)PIO_VBASE(7),
+	}, {
+		.cfg	= &g_cfg,
+		.pm	= &g_pm,
+		.chip	= {
+			.base	= PL_NR_BASE,
+			.ngpio	= PL_NR,
+			.label	= "GPL",
+			.to_irq = __pio_to_irq,
+		},
+		.vbase  = (void __iomem *)RPIO_VBASE(0),
+		/* cfg for eint */
+		.irq_num = AW_IRQ_EINTL,
+		.vbase_eint = (void __iomem *)PIO_VBASE_EINT_R_PL,
+		.cfg_eint = &g_eint_cfg,
+	}, {
+		.cfg	= &g_cfg,
+		.pm	= &g_pm,
+		.chip	= {
+			.base	= PM_NR_BASE,
+			.ngpio	= PM_NR,
+			.label	= "GPM",
+			.to_irq = __pio_to_irq,
+		},
+		.vbase  = (void __iomem *)RPIO_VBASE(1),
+		/* cfg for eint */
+		.irq_num = AW_IRQ_EINTM,
+		.vbase_eint = (void __iomem *)PIO_VBASE_EINT_R_PM,
+		.cfg_eint = &g_eint_cfg,
+	}
+};
+
+u32 gpio_clk_init(void)
+{
+	PIO_INF("%s todo: cpus pio clock init, line %d\n", __func__, __LINE__);
+	//r_gpio_clk_init();
+
+	if(NULL != g_apb_pio_clk)
+		PIO_INF("%s maybe err: g_apb_pio_clk not NULL, line %d\n", __func__, __LINE__);
+
+	g_apb_pio_clk = clk_get(NULL, CLK_APB_PIO);
+	PIO_DBG("%s: get g_apb_pio_clk 0x%08x\n", __func__, (u32)g_apb_pio_clk);
+	if(NULL == g_apb_pio_clk || IS_ERR(g_apb_pio_clk)) {
+		printk("%s err: clk_get %s failed\n", __func__, CLK_APB_PIO);
+		goto err;
+	} else {
+		if(0 != clk_enable(g_apb_pio_clk)) {
+			printk("%s err: clk_enable failed\n", __func__);
+			goto err;
+		}
+		PIO_DBG("%s: clk_enable g_apb_pio_clk success\n", __func__);
+		if(0 != clk_reset(g_apb_pio_clk, AW_CCU_CLK_NRESET)) {
+			printk("%s err: clk_reset failed\n", __func__);
+			goto err;
+		}
+		PIO_DBG("%s: clk_reset g_apb_pio_clk-AW_CCU_CLK_NRESET success\n", __func__);
+	}
+	PIO_DBG("%s success\n", __func__);
+	return 0;
+err:
+	return -EPERM;
+}
+
+u32 gpio_clk_deinit(void)
+{
+	//r_gpio_clk_deinit(); /* cpus pio clock deinit here */
+	if(NULL == g_apb_pio_clk || IS_ERR(g_apb_pio_clk)) {
+		PIO_INF("%s: g_apb_pio_clk 0x%08x invalid, just return\n", __func__, (u32)g_apb_pio_clk);
+		return 0;
+	}
+
+	if(0 != clk_reset(g_apb_pio_clk, AW_CCU_CLK_RESET))
+		printk("%s err: clk_reset failed\n", __func__);
+	clk_disable(g_apb_pio_clk);
+	clk_put(g_apb_pio_clk);
+	g_apb_pio_clk = NULL;
+
+	PIO_DBG("%s success\n", __func__);
+	return 0;
+}
+
+#ifdef GPIO_SUPPORT_STANDBY
+int gpio_drv_suspend(struct device *dev)
+{
+	if(NORMAL_STANDBY == standby_type) /* process for normal standby */
+		PIO_INF("%s: normal standby, line %d\n", __func__, __LINE__);
+	else if(SUPER_STANDBY == standby_type) { /* process for super standby */
+		PIO_INF("%s: super standby, line %d\n", __func__, __LINE__);
+		if(0 != gpio_clk_deinit())
+			printk("%s err, gpio_clk_deinit failed\n", __func__);
+	}
+	return 0;
+}
+
+int gpio_drv_resume(struct device *dev)
+{
+	if(NORMAL_STANDBY == standby_type) /* process for normal standby */
+		PIO_INF("%s: normal standby, line %d\n", __func__, __LINE__);
+	else if(SUPER_STANDBY == standby_type) { /* process for super standby */
+		PIO_INF("%s: super standby, line %d\n", __func__, __LINE__);
+		if(0 != gpio_clk_init())
+			printk("%s err, gpio_clk_init failed\n", __func__);
+	}
+	return 0;
+}
+
+static const struct dev_pm_ops sw_gpio_pm = {
+	.suspend	= gpio_drv_suspend,
+	.resume		= gpio_drv_resume,
+};
+#endif /* GPIO_SUPPORT_STANDBY */
+
+static struct platform_device sw_gpio_device = {
+	.name = "sw_gpio",
+};
+static struct platform_driver sw_gpio_driver = {
+	.driver.name 	= "sw_gpio",
+	.driver.owner 	= THIS_MODULE,
+#ifdef GPIO_SUPPORT_STANDBY
+	.driver.pm 	= &sw_gpio_pm,
+#endif /* GPIO_SUPPORT_STANDBY */
+};
+
+/**
+ * aw_gpio_init - gpio driver init function
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+static __init int aw_gpio_init(void)
+{
+	u32	uret = 0;
+	u32 	i = 0;
+
+	/* init gpio clock */
+	if(0 != gpio_clk_init())
+		printk("%s err: line %d\n", __func__, __LINE__);
+	/* register gpio chips */
+	for(i = 0; i < ARRAY_SIZE(gpio_chips); i++) {
+		PIO_CHIP_LOCK_INIT(&gpio_chips[i].lock);
+		/* register gpio_chip */
+		if(0 != aw_gpiochip_add(&gpio_chips[i].chip)) {
+			uret = __LINE__;
+			goto end;
+		}
+	}
+	/* register gpio platform driver */
+	if(platform_device_register(&sw_gpio_device))
+		printk("%s(%d) err: platform_device_register failed\n", __func__, __LINE__);
+	if(platform_driver_register(&sw_gpio_driver))
+		printk("%s(%d) err: platform_driver_register failed\n", __func__, __LINE__);
+
+#if (CONFIG_ARCH_SUN6I == 1) /* pull up all pl pin, in case electricity leak, sunny */
+	for(i = PL_NR_BASE; i < PL_NR_BASE + PL_NR - 1; i++)
+		WARN_ON(sw_gpio_setpull(i, 0b01));
+#endif
+
+end:
+	if(0 != uret)
+		printk("%s err, line %d\n", __func__, uret);
+	return uret;
+}
+subsys_initcall(aw_gpio_init);
diff --git a/arch/arm/mach-sun6i/gpio/gpio_init.h b/arch/arm/mach-sun6i/gpio/gpio_init.h
new file mode 100644
index 0000000..7455a8f
--- /dev/null
+++ b/arch/arm/mach-sun6i/gpio/gpio_init.h
@@ -0,0 +1,20 @@
+/*
+ * arch/arm/mach-sun6i/gpio/gpio_init.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i gpio header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __GPIO_INIT_H
+#define __GPIO_INIT_H
+
+
+#endif /* __GPIO_INIT_H */
diff --git a/arch/arm/mach-sun6i/gpio/gpio_multi_func.c b/arch/arm/mach-sun6i/gpio/gpio_multi_func.c
new file mode 100644
index 0000000..490f7da
--- /dev/null
+++ b/arch/arm/mach-sun6i/gpio/gpio_multi_func.c
@@ -0,0 +1,510 @@
+/*
+ * arch/arm/mach-sun6i/gpio/gpio_multi_func.c
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i gpio driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include "gpio_include.h"
+
+#ifdef CONFIG_AW_AXP22
+extern int axp_gpio_set_io(int gpio, int io_state);
+extern int axp_gpio_get_io(int gpio, int *io_state);
+extern int axp_gpio_set_value(int gpio, int value);
+extern int axp_gpio_get_value(int gpio, int *value);
+#endif /* CONFIG_AW_AXP22 */
+
+/**
+ * gpio_set_cfg - set multi sel for the gpio
+ * @chip:	aw_gpio_chip struct for the gpio
+ * @offset:	offset from gpio_chip->base
+ * @val:	multi sel to set
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 gpio_set_cfg(struct aw_gpio_chip *pchip, u32 offset, u32 val)
+{
+	u32 	ureg_off = 0, ubits_off = 0;
+
+#ifdef DBG_GPIO
+	if(val & ~((1 << PIO_BITS_WIDTH_CFG) - 1)) {
+		PIO_DBG("%s maybe err: val 0x%08x\n", __func__, val);
+	}
+#endif /* DBG_GPIO */
+
+	ureg_off = ((offset << 2) >> 5) << 2; 	/* ureg_off = ((offset * 4) / 32) * 4 */
+	ubits_off = (offset << 2) % 32;		/* ubits_off = (offset * 4) % 32 */
+
+	PIO_DBG("%s: write cfg reg 0x%08x, bits_off %d, width %d, cfg_val %d\n", __func__,
+		ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_CFG, val);
+
+	PIO_WRITE_BITS(ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_CFG, val);
+	return 0;
+}
+
+/**
+ * gpio_get_cfg - get multi sel for the gpio
+ * @chip:	aw_gpio_chip struct for the gpio
+ * @offset:	offset from gpio_chip->base
+ *
+ * Returns the multi sel value for the gpio
+ */
+u32 gpio_get_cfg(struct aw_gpio_chip *pchip, u32 offset)
+{
+	u32 	ureg_off = 0, ubits_off = 0;
+
+	ureg_off = ((offset << 2) >> 5) << 2; 	/* ureg_off = ((offset * 4) / 32) * 4 */
+	ubits_off = (offset << 2) % 32;		/* ubits_off = (offset * 4) % 32 */
+
+	PIO_DBG("%s: read cfg reg 0x%08x, bits_off %d, width %d, ret %d\n", __func__,
+		ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_CFG,
+		PIO_READ_BITS(ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_CFG));
+
+	return PIO_READ_BITS(ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_CFG);
+}
+
+/**
+ * gpio_set_pull - set pull state for the gpio
+ * @chip:	aw_gpio_chip struct for the gpio
+ * @offset:	offset from gpio_chip->base
+ * @val:	pull value to set
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 gpio_set_pull(struct aw_gpio_chip *pchip, u32 offset, u32 val)
+{
+	u32 	ureg_off = 0, ubits_off = 0;
+
+#ifdef DBG_GPIO
+	if(val & ~((1 << PIO_BITS_WIDTH_PULL) - 1)) {
+		PIO_DBG("%s maybe err: val 0x%08x\n", __func__, val);
+	}
+#endif /* DBG_GPIO */
+
+	ureg_off = PIO_OFF_REG_PULL + (((offset << 1) >> 5) << 2); 	/* ureg_off = ((offset * 2) / 32) * 4 */
+	ubits_off = (offset << 1) % 32;					/* ubits_off = (offset * 2) % 32 */
+
+	PIO_DBG("%s: write pull reg 0x%08x, bits_off %d, width %d, pul_val %d\n", __func__,
+		ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_PULL, val);
+
+	PIO_WRITE_BITS(ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_PULL, val);
+	return 0;
+}
+
+/**
+ * gpio_get_pull - get pull state for the gpio
+ * @chip:	aw_gpio_chip struct for the gpio
+ * @offset:	offset from gpio_chip->base
+ *
+ * Returns the pull value for the gpio
+ */
+u32 gpio_get_pull(struct aw_gpio_chip *pchip, u32 offset)
+{
+	u32 	ureg_off = 0, ubits_off = 0;
+
+	ureg_off = PIO_OFF_REG_PULL + (((offset << 1) >> 5) << 2); 	/* ureg_off = ((offset * 2) / 32) * 4 */
+	ubits_off = (offset << 1) % 32;					/* ubits_off = (offset * 2) % 32 */
+
+	PIO_DBG("%s: read pul reg 0x%08x, bits_off %d, width %d, ret %d\n", __func__,
+		ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_PULL,
+		PIO_READ_BITS(ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_PULL));
+
+	return PIO_READ_BITS(ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_PULL);
+}
+
+/**
+ * gpio_set_drvlevel - set driver level for the gpio
+ * @chip:	aw_gpio_chip struct for the gpio
+ * @offset:	offset from gpio_chip->base
+ * @val:	driver level value to set
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 gpio_set_drvlevel(struct aw_gpio_chip *pchip, u32 offset, u32 val)
+{
+	u32 	ureg_off = 0, ubits_off = 0;
+
+#ifdef DBG_GPIO
+	if(val & ~((1 << PIO_BITS_WIDTH_DRVLVL) - 1)) {
+		PIO_DBG("%s maybe err: val 0x%08x\n", __func__, val);
+	}
+#endif /* DBG_GPIO */
+
+	ureg_off = PIO_OFF_REG_DRVLVL + (((offset << 1) >> 5) << 2); 	/* ureg_off = ((offset * 2) / 32) * 4 */
+	ubits_off = (offset << 1) % 32;					/* ubits_off = (offset * 2) % 32 */
+
+	PIO_DBG("%s: write drvlevel reg 0x%08x, bits_off %d, width %d, drvlvl_val %d\n", __func__,
+		ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_DRVLVL, val);
+
+	PIO_WRITE_BITS(ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_DRVLVL, val);
+	return 0;
+}
+
+/**
+ * gpio_get_drvlevel - get driver level for the gpio
+ * @chip:	aw_gpio_chip struct for the gpio
+ * @offset:	offset from gpio_chip->base
+ *
+ * Returns the driver level value for the gpio
+ */
+u32 gpio_get_drvlevel(struct aw_gpio_chip *pchip, u32 offset)
+{
+	u32 	ureg_off = 0, ubits_off = 0;
+
+	ureg_off = PIO_OFF_REG_DRVLVL + (((offset << 1) >> 5) << 2); 	/* ureg_off = ((offset * 2) / 32) * 4 */
+	ubits_off = (offset << 1) % 32;					/* ubits_off = (offset * 2) % 32 */
+
+	PIO_DBG("%s: read drvlevel reg 0x%08x, bits_off %d, width %d, ret %d\n", __func__,
+		ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_DRVLVL,
+		PIO_READ_BITS(ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_DRVLVL));
+
+	return PIO_READ_BITS(ureg_off + (u32)pchip->vbase, ubits_off, PIO_BITS_WIDTH_DRVLVL);
+}
+
+#ifdef DBG_GPIO
+/**
+ * is_gpio_requested - check if gpio has been requested by gpio_request
+ * @gpio:	the global gpio index
+ *
+ * Returns true if already requested, false otherwise.
+ */
+bool is_gpio_requested(u32 gpio)
+{
+	struct gpio_chip *pchip = NULL;
+
+	pchip = to_gpiochip(gpio);
+	if(NULL == pchip || NULL == gpiochip_is_requested(pchip, gpio - pchip->base))
+		return false;
+	else
+		return true;
+}
+#endif /* DBG_GPIO */
+
+/**
+ * sw_gpio_setcfg - set multi sel for the gpio
+ * @gpio:	the global gpio index
+ * @val:	multi sel to set
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_gpio_setcfg(u32 gpio, u32 val)
+{
+	u32 	offset = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	pchip = gpio_to_aw_gpiochip(gpio);
+	if(NULL == pchip || NULL == pchip->cfg || NULL == pchip->cfg->set_cfg) {
+		printk("%s err: line %d, gpio %d\n", __func__, __LINE__, gpio);
+		return __LINE__;
+	}
+
+	offset = gpio - pchip->chip.base;
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+	WARN_ON(0 != pchip->cfg->set_cfg(pchip, offset, val));
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL(sw_gpio_setcfg);
+
+/**
+ * sw_gpio_getcfg - get multi sel for the gpio
+ * @gpio:	the global gpio index
+ *
+ * Returns the multi sel value for the gpio if success, GPIO_CFG_INVALID otherwise.
+ */
+u32 sw_gpio_getcfg(u32 gpio)
+{
+	u32 	uret = 0;
+	u32 	offset = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	pchip = gpio_to_aw_gpiochip(gpio);
+	if(NULL == pchip || NULL == pchip->cfg || NULL == pchip->cfg->get_cfg) {
+		printk("%s err: line %d, gpio %d\n", __func__, __LINE__, gpio);
+		return GPIO_CFG_INVALID;
+	}
+
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+	offset = gpio - pchip->chip.base;
+	uret = pchip->cfg->get_cfg(pchip, offset);
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+	return uret;
+}
+EXPORT_SYMBOL(sw_gpio_getcfg);
+
+/**
+ * sw_gpio_setpull - set pull state for the gpio
+ * @gpio:	the global gpio index
+ * @val:	pull value to set
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_gpio_setpull(u32 gpio, u32 val)
+{
+	u32 	offset = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	if(GPIO_PULL_DEFAULT == val) {
+		PIO_INF("%s err: line %d, not need to set, gpio %d\n", __func__, __LINE__, gpio);
+		return 0;
+	}
+	pchip = gpio_to_aw_gpiochip(gpio);
+	if(NULL == pchip || NULL == pchip->cfg || NULL == pchip->cfg->set_pull) {
+		printk("%s err: line %d, gpio %d\n", __func__, __LINE__, gpio);
+		return __LINE__;
+	}
+
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+	offset = gpio - pchip->chip.base;
+	WARN_ON(0 != pchip->cfg->set_pull(pchip, offset, val));
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL(sw_gpio_setpull);
+
+/**
+ * sw_gpio_getpull - get pull state for the gpio
+ * @gpio:	the global gpio index
+ *
+ * Returns the pull value for the gpio if success, GPIO_PULL_INVALID otherwise.
+ */
+u32 sw_gpio_getpull(u32 gpio)
+{
+	u32 	uret = 0;
+	u32 	offset = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	pchip = gpio_to_aw_gpiochip(gpio);
+	if(NULL == pchip || NULL == pchip->cfg || NULL == pchip->cfg->get_pull) {
+		printk("%s err: line %d, gpio %d\n", __func__, __LINE__, gpio);
+		return GPIO_PULL_INVALID;
+	}
+
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+	offset = gpio - pchip->chip.base;
+	uret = pchip->cfg->get_pull(pchip, offset);
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+	return uret;
+}
+EXPORT_SYMBOL(sw_gpio_getpull);
+
+/**
+ * sw_gpio_setdrvlevel - set driver level for the gpio
+ * @gpio:	the global gpio index
+ * @val:	driver level to set
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_gpio_setdrvlevel(u32 gpio, u32 val)
+{
+	u32 	offset = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	if(GPIO_DRVLVL_DEFAULT == val) {
+		PIO_INF("%s err: line %d, not need to set, gpio %d\n", __func__, __LINE__, gpio);
+		return 0;
+	}
+	pchip = gpio_to_aw_gpiochip(gpio);
+	if(NULL == pchip || NULL == pchip->cfg || NULL == pchip->cfg->set_drvlevel) {
+		printk("%s err: line %d, gpio %d\n", __func__, __LINE__, gpio);
+		return __LINE__;
+	}
+
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+	offset = gpio - pchip->chip.base;
+	WARN_ON(0 != pchip->cfg->set_drvlevel(pchip, offset, val));
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL(sw_gpio_setdrvlevel);
+
+/**
+ * sw_gpio_getdrvlevel - get driver level for the gpio
+ * @gpio:	the global gpio index
+ *
+ * Returns the driver level for the gpio if success, GPIO_DRVLVL_INVALID otherwise.
+ */
+u32 sw_gpio_getdrvlevel(u32 gpio)
+{
+	u32 	uret = 0;
+	u32 	offset = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	pchip = gpio_to_aw_gpiochip(gpio);
+	if(NULL == pchip || NULL == pchip->cfg || NULL == pchip->cfg->get_drvlevel) {
+		printk("%s err: line %d, gpio %d\n", __func__, __LINE__, gpio);
+		return GPIO_DRVLVL_INVALID;
+	}
+
+	PIO_CHIP_LOCK(&pchip->lock, flags);
+	offset = gpio - pchip->chip.base;
+	uret = pchip->cfg->get_drvlevel(pchip, offset);
+	PIO_CHIP_UNLOCK(&pchip->lock, flags);
+	return uret;
+}
+EXPORT_SYMBOL(sw_gpio_getdrvlevel);
+
+/**
+ * sw_gpio_setall_range - config a group of pin, include multi sel, pull, driverlevel
+ * @pcfg:	the config value group
+ * @cfg_num:	gpio number to config, also pcfg's member number
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_gpio_setall_range(struct gpio_config *pcfg, u32 cfg_num)
+{
+	u32 	i = 0;
+	u32 	offset = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	for(i = 0; i < cfg_num; i++, pcfg++) {
+#ifdef CONFIG_AW_AXP22
+		/* axp pin can only use linux standard gpio api */
+		if(pcfg->gpio >= AXP_NR_BASE && pcfg->gpio < AXP_NR_BASE + AXP_NR) {
+			if(0 == pcfg->mul_sel) /* intput */
+				WARN(0 != gpio_direction_input(pcfg->gpio),
+					"%s err, line %d, axp pin(%d) input failed!\n", __func__, __LINE__, pcfg->gpio);
+			else if(1 == pcfg->mul_sel) /* output */
+				WARN(0 != gpio_direction_output(pcfg->gpio, (pcfg->data ? 1 : 0)),
+					"%s err, line %d, axp pin(%d) output(%d) failed!\n", __func__, __LINE__, pcfg->gpio, pcfg->data);
+			else
+				printk("%s err: line %d, axp pin(%d) but not input/output\n", __func__, __LINE__, pcfg->gpio);
+			continue;
+		}
+#endif /* CONFIG_AW_AXP22 */
+		/* get aw_gpio_chip struct */
+		pchip = gpio_to_aw_gpiochip(pcfg->gpio);
+		if(!pchip || !pchip->cfg->set_cfg || !pchip->cfg->set_pull || !pchip->cfg->set_drvlevel) {
+			printk("%s err: line %d, gpio %d\n", __func__, __LINE__, pcfg->gpio);
+			continue;
+		}
+		/* setting */
+		PIO_CHIP_LOCK(&pchip->lock, flags);
+		offset = pcfg->gpio - pchip->chip.base;
+		WARN_ON(0 != pchip->cfg->set_cfg(pchip, offset, pcfg->mul_sel));
+		if(GPIO_PULL_DEFAULT != pcfg->pull)
+			WARN_ON(0 != pchip->cfg->set_pull(pchip, offset, pcfg->pull));
+		if(GPIO_DRVLVL_DEFAULT != pcfg->drv_level)
+			WARN_ON(0 != pchip->cfg->set_drvlevel(pchip, offset, pcfg->drv_level));
+		PIO_CHIP_UNLOCK(&pchip->lock, flags);
+		if(GPIO_CFG_OUTPUT == pcfg->mul_sel && GPIO_DATA_DEFAULT != pcfg->data)
+			__gpio_set_value(pcfg->gpio, (pcfg->data ? 1 : 0));
+	}
+	return 0;
+}
+EXPORT_SYMBOL(sw_gpio_setall_range);
+
+/**
+ * sw_gpio_getall_range - get the config state for a group of pin,
+ *			include multi sel, pull, driverlevel
+ * @pcfg:	store the config information for pins
+ * @cfg_num:	number of the pins
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_gpio_getall_range(struct gpio_config *pcfg, u32 cfg_num)
+{
+	u32 	i = 0;
+	u32 	offset = 0;
+	unsigned long flags = 0;
+	struct aw_gpio_chip *pchip = NULL;
+
+	for(i = 0; i < cfg_num; i++, pcfg++) {
+#ifdef CONFIG_AW_AXP22
+		/* axp pin not treated */
+		if(pcfg->gpio >= AXP_NR_BASE && pcfg->gpio < AXP_NR_BASE + AXP_NR) {
+			int io_status = -1;
+			PIO_INF("%s maybe err: line %d, canonly get gpio_config.data item, axp pin(%d)\n",
+				__func__, __LINE__, pcfg->gpio);
+			/* get mul sel: input/output */
+			offset = pcfg->gpio - AXP_NR_BASE;
+			if(0 == axp_gpio_get_io(offset, &io_status))
+				pcfg->mul_sel = io_status;
+			else
+				printk("%s err: line %d, get axp(%d) io_status failed\n", __func__, __LINE__, offset);
+			/* get data */
+			pcfg->data = __gpio_get_value(pcfg->gpio);
+			continue;
+		}
+#endif /* CONFIG_AW_AXP22 */
+		/* get aw_gpio_chip struct */
+		pchip = gpio_to_aw_gpiochip(pcfg->gpio);
+		if(!pchip || !pchip->cfg->get_cfg || !pchip->cfg->get_pull || !pchip->cfg->get_drvlevel) {
+			printk("%s err: line %d, gpio %d\n", __func__, __LINE__, pcfg->gpio);
+			continue;
+		}
+		/* get setting */
+		PIO_CHIP_LOCK(&pchip->lock, flags);
+		offset = pcfg->gpio - pchip->chip.base;
+		pcfg->mul_sel = pchip->cfg->get_cfg(pchip, offset);
+		pcfg->pull = pchip->cfg->get_pull(pchip, offset);
+		pcfg->drv_level = pchip->cfg->get_drvlevel(pchip, offset);
+		PIO_CHIP_UNLOCK(&pchip->lock, flags);
+		if(GPIO_CFG_OUTPUT == pcfg->mul_sel || GPIO_CFG_INPUT == pcfg->mul_sel)
+			pcfg->data = __gpio_get_value(pcfg->gpio);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(sw_gpio_getall_range);
+
+/**
+ * sw_gpio_dump_config - dump config info for a group of pins
+ * @pcfg:	store the config information for pins
+ * @cfg_num:	number of the pins
+ */
+void sw_gpio_dump_config(struct gpio_config *pcfg, u32 cfg_num)
+{
+	u32 	i = 0;
+
+	if(NULL == pcfg || 0 == cfg_num)
+		return;
+
+	printk("+++++++++++%s+++++++++++\n", __func__);
+	printk("  port    mul_sel    pull    drvlevl data\n");
+	for(i = 0; i < cfg_num; i++, pcfg++) {
+		printk("  %4d    %7d    %4d    %-8d%d\n", pcfg->gpio, pcfg->mul_sel,
+			pcfg->pull, pcfg->drv_level, pcfg->data);
+	}
+	printk("-----------%s-----------\n", __func__);
+}
+EXPORT_SYMBOL(sw_gpio_dump_config);
+
+/**
+ * sw_gpio_suspend - save somethig for gpio before enter sleep
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_gpio_suspend(void)
+{
+	PIO_INF("%s: NOT implement yet, line %d\n", __func__, __LINE__);
+	return 0;
+}
+EXPORT_SYMBOL(sw_gpio_suspend);
+
+/**
+ * sw_gpio_suspend - restore somethig for gpio after wake up
+ *
+ * Returns 0 if sucess, the err line number if failed.
+ */
+u32 sw_gpio_resume(void)
+{
+	PIO_INF("%s: NOT implement yet, line %d\n", __func__, __LINE__);
+	return 0;
+}
+EXPORT_SYMBOL(sw_gpio_resume);
+
diff --git a/arch/arm/mach-sun6i/gpio/gpio_multi_func.h b/arch/arm/mach-sun6i/gpio/gpio_multi_func.h
new file mode 100644
index 0000000..b35351b
--- /dev/null
+++ b/arch/arm/mach-sun6i/gpio/gpio_multi_func.h
@@ -0,0 +1,30 @@
+/*
+ * arch/arm/mach-sun6i/gpio/gpio_multi_func.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i gpio header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __GPIO_MULTI_FUNC_H
+#define __GPIO_MULTI_FUNC_H
+
+#ifdef DBG_GPIO
+bool is_gpio_requested(u32 gpio);
+#endif /* DBG_GPIO */
+
+u32 gpio_set_cfg(struct aw_gpio_chip *pchip, u32 offset, u32 val);
+u32 gpio_get_cfg(struct aw_gpio_chip *pchip, u32 offset);
+u32 gpio_set_pull(struct aw_gpio_chip *pchip, u32 offset, u32 val);
+u32 gpio_get_pull(struct aw_gpio_chip *pchip, u32 offset);
+u32 gpio_set_drvlevel(struct aw_gpio_chip *pchip, u32 offset, u32 val);
+u32 gpio_get_drvlevel(struct aw_gpio_chip *pchip, u32 offset);
+
+#endif /* __GPIO_MULTI_FUNC_H */
diff --git a/arch/arm/mach-sun6i/headsmp.S b/arch/arm/mach-sun6i/headsmp.S
new file mode 100644
index 0000000..68c6c2a
--- /dev/null
+++ b/arch/arm/mach-sun6i/headsmp.S
@@ -0,0 +1,12 @@
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+        .section ".text.head", "ax"
+	__CPUINIT
+
+ENTRY(sun6i_secondary_startup)
+	msr	cpsr_fsxc, #0xd3
+	mov r0, #0
+	ldr r1, =0xf34
+        b       secondary_startup
+ENDPROC(sun6i_secondary_startup)
diff --git a/arch/arm/mach-sun6i/hotplug.c b/arch/arm/mach-sun6i/hotplug.c
new file mode 100644
index 0000000..2ffb777
--- /dev/null
+++ b/arch/arm/mach-sun6i/hotplug.c
@@ -0,0 +1,107 @@
+/*
+ *  linux/arch/arm/mach-sun6i/hotplug.c
+ *
+ *  Copyright (C) 2012-2016 Allwinner Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <asm/cacheflush.h>
+#include <asm/smp_plat.h>
+#include <mach/platform.h>
+#include <mach/hardware.h>
+
+
+
+static cpumask_t dead_cpus;
+
+#define IS_WFI_MODE(cpu)    (readl(IO_ADDRESS(AW_R_CPUCFG_BASE) + CPUX_STATUS(cpu)) & (1<<2))
+
+int platform_cpu_kill(unsigned int cpu)
+{
+    int k;
+    u32 pwr_reg;
+
+    int tmp_cpu = get_cpu();
+    put_cpu();
+    pr_info("[hotplug]: cpu(%d) try to kill cpu(%d)\n", tmp_cpu, cpu);
+
+    for (k = 0; k < 1000; k++) {
+        if (cpumask_test_cpu(cpu, &dead_cpus) && IS_WFI_MODE(cpu)) {
+
+            /* step8: deassert DBGPWRDUP signal */
+            pwr_reg = readl(IO_ADDRESS(AW_R_CPUCFG_BASE) + AW_CPUCFG_DBGCTL1);
+            pwr_reg &= ~(1<<cpu);
+            writel(pwr_reg, IO_ADDRESS(AW_R_CPUCFG_BASE) + AW_CPUCFG_DBGCTL1);
+
+            /* step9: set up power-off signal */
+            pwr_reg = readl(IO_ADDRESS(AW_R_PRCM_BASE) + AW_CPU_PWROFF_REG);
+            pwr_reg |= (1<<cpu);
+            writel(pwr_reg, IO_ADDRESS(AW_R_PRCM_BASE) + AW_CPU_PWROFF_REG);
+            mdelay(1);
+
+            /* step10: active the power output clamp */
+            writel(0xff, IO_ADDRESS(AW_R_PRCM_BASE) + AW_CPUX_PWR_CLAMP(cpu));
+            pr_info("[hotplug]: cpu%d is killed!\n", cpu);
+
+            return 1;
+        }
+
+        mdelay(1);
+    }
+
+    pr_err("[hotplug]: try to kill cpu:%d failed!\n", cpu);
+
+    return 0;
+}
+
+void platform_cpu_die(unsigned int cpu)
+{
+    unsigned long actlr;
+
+    /* notify platform_cpu_kill() that hardware shutdown is finished */
+    cpumask_set_cpu(cpu, &dead_cpus);
+
+    /* step1: disable cache */
+    asm("mrc    p15, 0, %0, c1, c0, 0" : "=r" (actlr) );
+    actlr &= ~(1<<2);
+    asm("mcr    p15, 0, %0, c1, c0, 0\n" : : "r" (actlr));
+
+    /* step2: clean and ivalidate L1 cache */
+    flush_cache_all();
+
+    /* step3: execute a CLREX instruction */
+    asm("clrex" : : : "memory", "cc");
+
+    /* step4: switch cpu from SMP mode to AMP mode, aim is to disable cache coherency */
+    asm("mrc    p15, 0, %0, c1, c0, 1" : "=r" (actlr) );
+    actlr &= ~(1<<6);
+    asm("mcr    p15, 0, %0, c1, c0, 1\n" : : "r" (actlr));
+
+    /* step5: execute an ISB instruction */
+    isb();
+    /* step6: execute a DSB instruction  */
+    dsb();
+
+    /* step7: execute a WFI instruction */
+    while(1) {
+        asm("wfi" : : : "memory", "cc");
+    }
+}
+
+int platform_cpu_disable(unsigned int cpu)
+{
+    cpumask_clear_cpu(cpu, &dead_cpus);
+    /*
+     * we don't allow CPU 0 to be shutdown (it is still too special
+     * e.g. clock tick interrupts)
+     */
+    return cpu == 0 ? -EPERM : 0;
+}
diff --git a/arch/arm/mach-sun6i/include/mach/ar100.h b/arch/arm/mach-sun6i/include/mach/ar100.h
new file mode 100644
index 0000000..10cebd8
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/ar100.h
@@ -0,0 +1,130 @@
+/*
+ * arch/arm/mach-sun6i/include/mach/ar100.h
+ *
+ * Copyright 2012 (c) Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef	__ASM_ARCH_A100_H
+#define	__ASM_ARCH_A100_H
+
+#include <linux/power/aw_pm.h>
+
+/* the modes of ar100 dvfs */
+#define	AR100_DVFS_SYN		(1<<0)
+
+/* axp driver interfaces */
+#define AXP_TRANS_BYTE_MAX	(8)
+
+/* ar100 call-back */
+typedef int (*ar100_cb_t)(void *arg);
+
+/**
+ * set target frequency.
+ * @freq:    target frequency to be set, based on HZ.
+ * @cb:      callback handler
+ * @cb_arg:  arguments of callback handler
+ *
+ * return: result, 0 - set frequency successed, !0 - set frequency failed;
+ */
+int ar100_dvfs_set_cpufreq(unsigned int freq, unsigned long mode, ar100_cb_t cb, void *cb_arg);
+
+/**
+ * enter super standby.
+ * @para:  parameter for enter normal standby.
+ *
+ * return: result, 0 - super standby successed, !0 - super standby failed;
+ */
+int ar100_standby_super(struct super_standby_para *para, ar100_cb_t cb, void *cb_arg);
+
+/**
+ * query super-standby wakeup source.
+ * @para:  point of buffer to store wakeup event informations.
+ *
+ * return: result, 0 - query successed, !0 - query failed;
+ */
+int ar100_query_wakeup_source(unsigned long *event);
+
+/**
+ * query super-standby dram crc result.
+ * @perror:  pointer of dram crc result.
+ * @ptotal_count: pointer of dram crc total count
+ * @perror_count: pointer of dram crc error count
+ *
+ * return: result, 0 - query successed,
+ *                !0 - query failed;
+ */
+int ar100_query_dram_crc_result(unsigned long *perror, unsigned long *ptotal_count,
+	unsigned long *perror_count);
+
+int ar100_set_dram_crc_result(unsigned long error, unsigned long total_count,
+	unsigned long error_count);
+
+/**
+ * notify ar100 cpux restored.
+ * @para:  none.
+ *
+ * return: result, 0 - notify successed, !0 - notify failed;
+ */
+int ar100_cpux_ready_notify(void);
+
+
+/**
+ * read axp register data.
+ * @addr:    point of registers address;
+ * @data:    point of registers data;
+ * @len :    number of read registers, max len:8;
+ *
+ * return: result, 0 - read register successed,
+ *                !0 - read register failed or the len more then max len;
+ */
+int ar100_axp_read_reg(unsigned char *addr, unsigned char *data, unsigned long len);
+
+/**
+ * write axp register data.
+ * addr:     point of registers address;
+ * data:     point of registers data;
+ * len :     number of write registers, max len:8;
+ *
+ * return: result, 0 - write register successed,
+ *                !0 - write register failedor the len more then max len;
+ */
+int ar100_axp_write_reg(unsigned char *addr, unsigned char *data, unsigned long len);
+
+/**
+ * register call-back function, call-back function is for ar100 notify some event to ac327,
+ * axp interrupt for ex.
+ * func:  call-back function;
+ * para:  parameter for call-back function;
+ *
+ * return: result, 0 - register call-back function successed;
+ *                !0 - register call-back function failed;
+ * NOTE: the function is like "int callback(void *para)";
+ */
+int ar100_axp_cb_register(ar100_cb_t func, void *para);
+
+
+/**
+ * unregister call-back function.
+ * @func:  call-back function which need be unregister;
+ */
+void ar100_axp_cb_unregister(ar100_cb_t func);
+
+int ar100_disable_axp_irq(void);
+int ar100_enable_axp_irq(void);
+
+int ar100_message_loopback(void);
+
+/* talk-standby interfaces */
+int ar100_standby_talk(struct super_standby_para *para, ar100_cb_t cb, void *cb_arg);
+int ar100_cpux_talkstandby_ready_notify(void);
+
+void ar100_fake_power_off(void);
+
+#endif	/* __ASM_ARCH_A100_H */
diff --git a/arch/arm/mach-sun6i/include/mach/barriers.h b/arch/arm/mach-sun6i/include/mach/barriers.h
new file mode 100644
index 0000000..723cdad
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/barriers.h
@@ -0,0 +1,3 @@
+#define mb()		dsb()
+#define rmb()		dsb()
+#define wmb()		mb()
diff --git a/arch/arm/mach-sun6i/include/mach/ccmu.h b/arch/arm/mach-sun6i/include/mach/ccmu.h
new file mode 100644
index 0000000..80ba63d
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/ccmu.h
@@ -0,0 +1,903 @@
+/*
+ *  arch/arm/mach-sun6i/include/mach/ccmu_regs.h
+ *
+ * Copyright 2012 (c) Allwinner.
+ * kevin.z.m (kevin@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __CCMU_REGS_H__
+#define __CCMU_REGS_H__
+
+
+typedef struct ___CCMU_PLL1_REG0000
+{
+    __u32   FactorM:2;          //bit0,  PLL1 Factor M
+    __u32   reserved0:2;        //bit2,  reserved
+    __u32   FactorK:2;          //bit4,  PLL1 factor K
+    __u32   reserved1:2;        //bit6,  reserved
+    __u32   FactorN:5;          //bit8,  PLL1 Factor N
+    __u32   reserved2:11;       //bit13, reserved
+    __u32   SigmaEn:1;          //bit24, sigma delta enbale
+    __u32   reserved3:3;        //bit25, reserved
+    __u32   Lock:1;             //bit28, pll is stable flag, 1-pll has stabled
+    __u32   reserved4:2;        //bit29, reserved
+    __u32   PLLEn:1;            //bit31, 0-disable, 1-enable, (24Mhz*N*K)/(M*P)
+
+} __ccmu_pll1_reg0000_t;
+
+
+typedef struct __CCMU_PLL2_REG0008
+{
+    __u32   FactorM:5;          //bit0,  PLL2 prev division M
+    __u32   reserved0:3;        //bit5,  reserved
+    __u32   FactorN:7;          //bit8,  PLL2 factor N
+    __u32   reserved1:1;        //bit15, reserved
+    __u32   FactorP:4;          //bit16, PLL2 post division
+    __u32   reserved2:4;        //bit20, reserved
+    __u32   SdmEn:1;            //bit24, pll sdm enable, factorN only low 4 bits valid when enable
+    __u32   reserved3:3;        //bit25, reserved
+    __u32   Lock:1;             //bit28, pll stable flag
+    __u32   reserved4:2;        //bit29, reserved
+    __u32   PLLEn:1;            //bit31, PLL2 enable
+} __ccmu_pll2_reg0008_t;
+
+
+typedef struct __CCMU_MEDIA_PLL
+{
+    __u32   FactorM:4;          //bit0,  PLL3 FactorM
+    __u32   reserved0:4;        //bit4,  reserved
+    __u32   FactorN:7;          //bit8,  PLL factor N
+    __u32   reserved1:5;        //bit15, reserved
+    __u32   SdmEn:1;            //bit20, sdm enable
+    __u32   reserved2:3;        //bit21, reserved
+    __u32   ModeSel:1;          //bit24, PLL mode select
+    __u32   FracMod:1;          //bit25, PLL out is 0:270Mhz, 1:297Mhz
+    __u32   reserved3:2;        //bit26, reserved
+    __u32   Lock:1;             //bit27, lock flag
+    __u32   reserved4:1;        //bit29, reserved
+    __u32   CtlMode:1;          //bit30, control mode, 0-controled by cpu, 1-control by DE
+    __u32   PLLEn:1;            //bit31, PLL3 enable
+} __ccmu_media_pll_t;
+
+
+typedef struct __CCMU_PLL5_REG0020
+{
+    __u32   FactorM:2;          //bit0,  PLL5 factor M
+    __u32   reserved0:2;        //bit2,  reserved
+    __u32   FactorK:2;          //bit4,  PLL5 factor K
+    __u32   reserved1:2;        //bit6,  reserved
+    __u32   FactorN:5;          //bit8,  PLL5 factor N
+    __u32   reserved2:7;        //bit13, reserved
+    __u32   PLLCfgUpdate:1;     //bit20, PLL configuration update
+    __u32   reserved3:3;        //bit21, reserved
+    __u32   SigmaDeltaEn:1;     //bit24, sdram sigma delta enable
+    __u32   reserved4:3;        //bit25, reserved
+    __u32   Lock:1;             //bit28, lock flag
+    __u32   reserved5:2;        //bit29, reserved
+    __u32   PLLEn:1;            //bit31, PLL5 Enable
+} __ccmu_pll5_reg0020_t;
+
+
+typedef struct __CCMU_PLL6_REG0028
+{
+    __u32   FactorM:2;          //bit0,  PLL6 factor M
+    __u32   reserved0:2;        //bit2,  reserved
+    __u32   FactorK:2;          //bit4,  PLL6 factor K
+    __u32   reserved1:2;        //bit6,  reserved
+    __u32   FactorN:5;          //bit8,  PLL6 factor N
+    __u32   reserved2:3;        //bit13, reserved
+    __u32   Pll24MPdiv:2;       //bit16, PLL 24M output clock post divider
+    __u32   Pll24MOutEn:1;      //bit18, PLL 24M output enable
+    __u32   reserved3:5;        //bit19, reserved
+    __u32   PllClkOutEn:1;      //bit24, pll clock output enable
+    __u32   PLLBypass:1;        //bit25, PLL6 output bypass enable
+    __u32   reserved4:2;        //bit26, reserved
+    __u32   Lock:1;             //bit28, lock flag
+    __u32   reserved5:2;        //bit29, reserved
+    __u32   PLLEn:1;            //bit31, PLL6 enable
+} __ccmu_pll6_reg0028_t;
+
+
+typedef struct __CCMU_MIPI_PLL_REG0040
+{
+    __u32   FactorM:4;          //bit0,  PLL FactorM
+    __u32   FactorK:2;          //bit4,  PLL FactorM
+    __u32   reserved0:2;        //bit6,  reserved
+    __u32   FactorN:4;          //bit8,  PLL factor N
+    __u32   reserved1:4;        //bit12, reserved
+    __u32   VfbSel:1;           //bit16, 0-mipi mode(n,k,m valid), 1-hdmi mode(sint_frac, sdiv2
+                                //       s6p25_7p5, pll_feedback_div valid)
+    __u32   FeedBackDiv:1;      //bit17, pll feedback division, 0:x5, 1:x7
+    __u32   reserved2:2;        //bit18, reserved
+    __u32   SdmEn:1;            //bit20, sdm enable
+    __u32   PllSrc:1;           //bit21, PLL source, 0:video pll0, 1:video pll1
+    __u32   Ldo2En:1;           //bit22, LDO2 enable
+    __u32   Ldo1En:1;           //bit23, LDO1 enable
+    __u32   reserved3:1;        //bit24, reserved
+    __u32   Sel625Or750:1;      //bit25, select pll out is input*6.25 or 7.50
+    __u32   SDiv2:1;            //bit26, PLL output seclect, 0:pll output, 1:pll output x2
+    __u32   FracMode:1;         //bit27, PLL output mode, 0:integer mode, 1:fraction mode
+    __u32   Lock:1;             //bit28, lock flag
+    __u32   reserved4:2;        //bit29, reserved
+    __u32   PLLEn:1;            //bit31, PLL enable
+} __ccmu_mipi_pll_reg0040_t;
+
+
+#define AC327_CLKSRC_LOSC   (0)
+#define AC327_CLKSRC_HOSC   (1)
+#define AC327_CLKSRC_PLL1   (2)
+typedef struct __CCMU_SYSCLK_RATIO_REG0050
+{
+    __u32   AXIClkDiv:3;        //bit0,  AXI clock divide ratio, 000-1, 001-2, 010-3, 011/1xx-4
+    __u32   reserved0:5;        //bit3,  reserved
+    __u32   AtbApbClkDiv:2;     //bit8,  ATB/APB clock div, 00-1, 01-2, 1x-4
+    __u32   reserved1:6;        //bit10, reserved
+    __u32   CpuClkSrc:2;        //bit16, CPU1/2/3/4 clock source select, 00-internal LOSC, 01-HOSC, 10/11-PLL1
+    __u32   reserved2:14;       //bit18, reserved
+} __ccmu_sysclk_ratio_reg0050_t;
+
+
+#define AHB1_CLKSRC_LOSC    (0)
+#define AHB1_CLKSRC_HOSC    (1)
+#define AHB1_CLKSRC_AXI     (2)
+#define AHB1_CLKSRC_PLL6    (3)
+typedef struct __CCMU_AHB1_RATIO_REG0054
+{
+    __u32   reserved0:4;        //bit0,  reserved
+    __u32   Ahb1Div:2;          //bit4,  ahb1 clock divide ratio,1/2/4/8
+    __u32   Ahb1PreDiv:2;       //bit6,  ahb1 clock pre-divide ratio 1/2/3/4
+    __u32   Apb1Div:2;          //bit8,  apb1 clock divide ratio 2/2/4/8, source is ahb1
+    __u32   reserved1:2;        //bit10, reserved
+    __u32   Ahb1ClkSrc:2;       //bit12, ahb1 clock source select, 00-LOSC, 01-OSC24M, 10-AXI, 11-PLL6/ahb1_pre_div
+    __u32   reserved2:18;       //bit26, reserved
+} __ccmu_ahb1_ratio_reg0054_t;
+
+
+#define APB2_CLKSRC_LOSC    (0)
+#define APB2_CLKSRC_HOSC    (1)
+#define APB2_CLKSRC_PLL6    (2)
+typedef struct __CCMU_APB2_RATIO_REG0058
+{
+    __u32   DivM:5;             //bit0,  clock divide ratio m
+    __u32   reserved:11;        //bit5,  reserved
+    __u32   DivN:2;             //bit16, clock pre-divide ratio 1/2/4/8
+    __u32   reserved1:6;        //bit18, reserved
+    __u32   ClkSrc:2;           //bit24, clock source select, 00-LOSC, 01-OSC24M, 10/11-PLL6
+    __u32   reserved2:6;        //bit26, reserved
+} __ccmu_apb2_ratio_reg0058_t;
+
+
+typedef struct __CCMU_AXI_GATE_REG005c
+{
+    __u32   Sdram:1;            //bit0,  gating AXI clock for SDRAM, 0-mask, 1-pass
+    __u32   reserved0:31;       //bit1,  reserved
+} __ccmu_axi_gate_reg005c_t;
+
+
+typedef struct __CCMU_AHB1_GATE0_REG0060
+{
+    __u32   MipiCsi:1;          //bit0,  gating AHB clock for mipi csi, 0-mask, 1-pass
+    __u32   MipiDsi:1;          //bit1,  gating AHB clock for mipi dsi, 0-mask, 1-pass
+    __u32   reserved0:3;        //bit2,  reserved
+    __u32   Ss:1;               //bit5,  gating AHB clock for SS, 0-mask, 1-pass
+    __u32   Dma:1;              //bit6,  gating AHB clock for DMA, 0-mask, 1-pass
+    __u32   reserved1:1;        //bit7,  reserved
+    __u32   Sd0:1;              //bit8,  gating AHB clock for SD/MMC0, 0-mask, 1-pass
+    __u32   Sd1:1;              //bit9,  gating AHB clock for SD/MMC1, 0-mask, 1-pass
+    __u32   Sd2:1;              //bit10, gating AHB clock for SD/MMC2, 0-mask, 1-pass
+    __u32   Sd3:1;              //bit11, gating AHB clock for SD/MMC3, 0-mask, 1-pass
+    __u32   Nand1:1;            //bit12, gating AHB clock for NAND1, 0-mask, 1-pass
+    __u32   Nand0:1;            //bit13, gating AHB clock for NAND0, 0-mask, 1-pass
+    __u32   Dram:1;             //bit14, gating AHB clock for SDRAM, 0-mask, 1-pass
+    __u32   reserved2:2;        //bit15, reserved
+    __u32   Gmac:1;             //bit17, gating AHB clock for GMAC, 0-mask, 1-pass
+    __u32   Ts:1;               //bit18, gating AHB clock for TS, 0-mask, 1-pass
+    __u32   HsTmr:1;            //bit19, gating AHB clock for High speed timer 0-mask, 1-pass
+    __u32   Spi0:1;             //bit20, gating AHB clock for SPI0, 0-mask, 1-pass
+    __u32   Spi1:1;             //bit21, gating AHB clock for SPI1, 0-mask, 1-pass
+    __u32   Spi2:1;             //bit22, gating AHB clock for SPI2, 0-mask, 1-pass
+    __u32   Spi3:1;             //bit23, gating AHB clock for SPI3, 0-mask, 1-pass
+    __u32   Otg:1;              //bit24, gating AHB clock for USB-OTG, 0-mask, 1-pass
+    __u32   reserved3:1;        //bit25, reserved
+    __u32   Ehci0:1;            //bit26, gating AHB clock for EHCI0, 0-mask, 1-pass
+    __u32   Ehci1:1;            //bit27, gating AHB clock for EHCI1, 0-mask, 1-pass
+    __u32   reserved4:1;        //bit28, reserved
+    __u32   Ohci0:1;            //bit29, gating AHB clock for OHCI0, 0-mask, 1-pass
+    __u32   Ohci1:1;            //bit30, gating AHB clock for OHCI1, 0-mask, 1-pass
+    __u32   Ohci2:1;            //bit31, gating AHB clock for OHCI2, 0-mask, 1-pass
+} __ccmu_ahb1_gate0_reg0060_t;
+
+
+typedef struct __CCMU_AHB1_GATE1_REG0064
+{
+    __u32   Ve:1;               //bit0,  gating AHB clock for VE, 0-mask, 1-pass
+    __u32   reserved0:3;        //bit1,  reserved
+    __u32   Lcd0:1;             //bit4,  gating AHB clock for LCD0, 0-mask, 1-pass
+    __u32   Lcd1:1;             //bit5,  gating AHB clock for LCD1, 0-mask, 1-pass
+    __u32   reserved1:2;        //bit6,  reserved
+    __u32   Csi0:1;             //bit8,  gating AHB clock for CSI0, 0-mask, 1-pass
+    __u32   Csi1:1;             //bit9,  gating AHB clock for CSI1, 0-mask, 1-pass
+    __u32   reserved2:1;        //bit10, reserved
+    __u32   Hdmi:1;             //bit11, gating AHB clock for HDMI, 0-mask, 1-pass
+    __u32   Be0:1;              //bit12, gating AHB clock for DE-BE0, 0-mask, 1-pass
+    __u32   Be1:1;              //bit13, gating AHB clock for DE-BE1, 0-mask, 1-pass
+    __u32   Fe0:1;              //bit14, gating AHB clock for DE-FE0, 0-mask, 1-pass
+    __u32   Fe1:1;              //bit15, gating AHB clock for DE-FE1, 0-mask, 1-pass
+    __u32   reserved3:2;        //bit16, reserved
+    __u32   Mp:1;               //bit18, gating AHB clock for MP, 0-mask, 1-pass
+    __u32   reserved4:1;        //bit19, reserved
+    __u32   Gpu:1;              //bit20, gating AHB clock for GPU, 0-mask, 1-pass
+    __u32   MsgBox:1;           //bit21, gating AHB clock for MSG-BOX, 0-mask, 1-pass
+    __u32   SpinLock:1;         //bit22, gating AHB clock for SPIN-LOCK, 0-mask, 1-pass
+    __u32   Deu0:1;             //bit23, gating AHB clock for DEU0, 0-mask, 1-pass
+    __u32   Deu1:1;             //bit24, gating AHB clock for DEU1, 0-mask, 1-pass
+    __u32   Drc0:1;             //bit25, gating AHB clock for DRC0, 0-mask, 1-pass
+    __u32   Drc1:1;             //bit26, gating AHB clock for DRC1, 0-mask, 1-pass
+    __u32   MtcAcc:1;           //bit27, gating AHB clock for MTC-ACC, 0-mask, 1-pass
+    __u32   reserved5:4;        //bit28, reserved
+} __ccmu_ahb1_gate1_reg0064_t;
+
+
+typedef struct __CCMU_APB1_GATE_REG0068
+{
+    __u32   Adda:1;             //bit0,  gating APB clock for audio codec, 0-mask, 1-pass
+    __u32   Spdif:1;            //bit1,  gating APB clock for SPDIF, 0-mask, 1-pass
+    __u32   reserved0:2;        //bit2,  reserved
+    __u32   Dmic:1;             //bit4,  gating APB clock for digital mic
+    __u32   Pio:1;              //bit5,  gating APB clock for PIO, 0-mask, 1-pass
+    __u32   reserved1:6;        //bit6,  reserved
+    __u32   I2s0:1;             //bit12, gating APB clock for I2s-0, 0-mask, 1-pass
+    __u32   I2s1:1;             //bit13, gating APB clock for I2s-1, 0-mask, 1-pass
+    __u32   reserved2:18;       //bit14, reserved
+} __ccmu_apb1_gate_reg0068_t;
+
+
+typedef struct __CCMU_APB2_GATE_REG006C
+{
+    __u32   Twi0:1;             //bit0,  gating APB clock for TWI0, 0-mask, 1-pass
+    __u32   Twi1:1;             //bit1,  gating APB clock for TWI1, 0-mask, 1-pass
+    __u32   Twi2:1;             //bit2,  gating APB clock for TWI2, 0-mask, 1-pass
+    __u32   Twi3:1;             //bit3,  gating APB clock for TWI3, 0-mask, 1-pass
+    __u32   reserved0:12;       //bit4,  reserved
+    __u32   Uart0:1;            //bit16, gating APB clock for UART0, 0-mask, 1-pass
+    __u32   Uart1:1;            //bit17, gating APB clock for UART1, 0-mask, 1-pass
+    __u32   Uart2:1;            //bit18, gating APB clock for UART2, 0-mask, 1-pass
+    __u32   Uart3:1;            //bit19, gating APB clock for UART3, 0-mask, 1-pass
+    __u32   Uart4:1;            //bit20, gating APB clock for UART4, 0-mask, 1-pass
+    __u32   Uart5:1;            //bit21, gating APB clock for UART5, 0-mask, 1-pass
+    __u32   reserved1:10;       //bit22, reserved
+} __ccmu_apb2_gate_reg006c_t;
+
+
+/* normal module clock */
+typedef struct __CCMU_MODULE0_CLK
+{
+    __u32   DivM:4;             //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0:4;        //bit4,  reserved
+    __u32   OutClkCtrl:3;       //bit8,  output clock phase control, 0~7
+    __u32   reserved1:5;        //bit11,  reserved
+    __u32   DivN:2;             //bit16, clock pre-divide ratio, predivided by 2^n , 1/2/4/8 ex.
+    __u32   reserved2:2;        //bit18, reserved
+    __u32   SampClkCtrl:3;      //bit20, sample clock phase control, 0~7
+    __u32   reserved3:1;        //bit23, reserved
+    __u32   ClkSrc:3;           //bit24, clock source select, defined with different modules
+    __u32   reserved4:4;        //bit26, reserved
+    __u32   ClkGate:1;          //bit31, Gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+} __ccmu_module0_clk_t;
+
+
+/* normal module clock */
+typedef struct __CCMU_MODULE1_CLK
+{
+    __u32   reserved0:16;       //bit0,  reserved
+    __u32   ClkSrc:2;           //bit16, clock source select, 00:PLL2X8, 01:PLL2X8/2, 10:PLLX8/4, 11:PLL2X1
+    __u32   reserved1:13;       //bit18, reserved
+    __u32   ClkGate:1;          //bit31, Gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+
+} __ccmu_module1_clk_t;
+
+
+/* normal module clock */
+typedef struct __CCMU_MODULE_CLK
+{
+    __u32   reserved0:31;       //bit0,  reserved
+    __u32   ClkGate:1;          //bit31, Gating special clock, 0-CLOCK OFF, 1-CLOCK ON
+
+} __ccmu_module_clk_t;
+
+
+typedef struct __CCMU_USB_CLK_REG00CC
+{
+    __u32   UsbPhy0Rst:1;       //bit0,  USB PHY0 reset control, 0-reset valid, 1-reset invalid
+    __u32   UsbPhy1Rst:1;       //bit1,  USB PHY1 reset control, 0-reset valid, 1-reset invalid
+    __u32   UsbPhy2Rst:1;       //bit2,  USB PHY2 reset control, 0-reset valid, 1-reset invalid
+    __u32   reserved0:5;        //bit3,  reserved
+    __u32   Phy0Gate:1;         //bit8,  gating special clock for USBPHY0, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   Phy1Gate:1;         //bit9,  gating special clock for USBPHY1, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   Phy2Gate:1;         //bit10, gating special clock for USBPHY2, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   reserved1:5;        //bit11, reserved
+    __u32   Ohci0Gate:1;        //bit16, gating special clock for OHCI0, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   Ohci1Gate:1;        //bit17, gating special clock for OHCI1, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   Ohci2Gate:1;        //bit18, gating special clock for OHCI2, 0-CLOCK OFF, 1-CLOCK ON
+    __u32   reserved2:13;       //bit19,  reserved
+} __ccmu_usb_clk_reg00cc_t;
+
+
+typedef struct __CCMU_GMAC_CLK_REG00D0
+{
+    __u32   Gtcs:2;            //bit0,  gmac transmit clock source, 00-transmit clk src for M2, 01-external transmit clk src for GM2 and RGM2,
+                               //  10-internal transmit clk src for GM2 and RGM2, 11-reserved
+    __u32   Gpit:1;            //bit2,  gmac phy interface type, 0-GM2/M2, 1-RGM2
+    __u32   Gtxie:1;           //bit3,  enable gmac transmit clock invertor, 0-disable, 1-enable
+    __u32   Grxie:1;           //bit4,  enable gmac recieve clock invertor, 0-disable, 1-enable
+    __u32   Grxdc:3;           //bit5,  config gmac recieve clock delay chain
+    __u32   reserved0:24;      //bit8,  reserved
+} __ccmu_gmac_clk_reg00d0_t;
+
+
+typedef struct __CCMU_DRAM_CFG_REG00F4
+{
+    __u32   Div1M:4;            //bit0,  sdr clock divider of configuration 1
+    __u32   ClkSrc1:1;          //bit4,  sdr clock source of configuration 1, 0:PLL5, 1:PLL6
+    __u32   reserved0:3;        //bit5,  reserved
+    __u32   Div0M:4;            //bit8,  sdr clock divider of configuration 0
+    __u32   ClkSrc0:1;          //bit12, sdr clock source of configuration 0, 0:PLL5, 1:PLL6
+    __u32   reserved1:3;        //bit13, reserved
+    __u32   SdrClkUpd:1;        //bit16, sdr clock configuration 0 update, 0:invalid, 1:valid
+    __u32   reserved2:14;       //bit14, reserved
+    __u32   CtrlerRst:1;        //bit31, sdram controller reset 0:assert, 1:de-assert
+} __ccmu_dram_cfg_reg00f4_t;
+
+
+typedef struct __CCMU_DRAM_GATE_REG0100
+{
+    __u32   Ve:1;               //bit0,  Gating dram clock for VE, 0-mask, 1-pass
+    __u32   CsiIsp:1;           //bit1,  Gating dram clock for CSI0, CSI1, MIPI_CSI0, ISP, 0-mask, 1-pass
+    __u32   reserved0:1;        //bit2,  reserved
+    __u32   Ts:1;               //bit3,  Gating dram clock for TS, 0-mask, 1-pass
+    __u32   reserved1:12;       //bit4,  reserved
+    __u32   Drc0:1;             //bit16, Gating dram clock for DRC0, 0-mask, 1-pass
+    __u32   Drc1:1;             //bit17, Gating dram clock for DRC1, 0-mask, 1-pass
+    __u32   Deu0:1;             //bit18, Gating dram clock for DEU0, 0-mask, 1-pass
+    __u32   Deu1:1;             //bit19, Gating dram clock for DEU1, 0-mask, 1-pass
+    __u32   reserved2:4;        //bit20,  reserved
+    __u32   Fe0:1;              //bit24, Gating dram clock for DE_FE0, 0-mask, 1-pass
+    __u32   Fe1:1;              //bit25, Gating dram clock for DE_FE1, 0-mask, 1-pass
+    __u32   Be0:1;              //bit26, Gating dram clock for DE_BE0, 0-mask, 1-pass
+    __u32   Be1:1;              //bit27, Gating dram clock for DE_BE1, 0-mask, 1-pass
+    __u32   Mp:1;               //bit28, Gating dram clock for MP, 0-mask, 1-pass
+    __u32   reserved3:3;        //bit29, reserved
+} __ccmu_dram_gate_reg0100_t;
+
+
+/* display module clock */
+typedef struct __CCMU_DISP_CLK
+{
+    __u32   DivM:4;             //bit0,  clock divide ratio, divied by (m+1), 1~16 ex.
+    __u32   reserved0:20;       //bit4,  reserved
+    __u32   ClkSrc:3;           //bit24, clock source select, 000-PLL3, 001-PLL7
+                                //       010-PLL6X2, 011-PLL8, 100-PLL9, 101-PLL10 110/111-reserved
+    __u32   reserved1:4;        //bit27, reserved
+    __u32   ClkGate:1;          //bit31, gating special clock, 0-clock off, 1-clock on
+} __ccmu_disp_clk_t;
+
+
+/* csi module clock source */
+typedef struct __CCMU_CSI_CLK
+{
+    __u32   MClkDiv:4;          //bit0,  master clock divide ratio, divided by (m+1), 1~16, ex.
+    __u32   reserved0:4;        //bit4,  reserved
+    __u32   MClkSrc:3;          //bit8,  clock source select, 000-PLL3(1x), 001-PLL7(1x), 010-OSC24M, 010/011/100/111-reserved, 101-PLL3(2x), 110:PLL7(2x)
+    __u32   reserved1:4;        //bit11, reserved
+    __u32   MClkGate:1;         //bit15, gating master clock
+    __u32   SClkDiv:4;          //bit16, csi clock dirvide ratio, 1~16
+    __u32   reserved2:4;        //bit20, reserved
+    __u32   SClkSrc:3;          //bit24, special clock source select, 000:PLL3(1x), 001:PLL7(1x), 010:PLL3(2x)
+                                //       011:PLL7(2x), 100:mipi pll, 101~111:reserved
+    __u32   reserved3:4;        //bit27, reserved
+    __u32   SClkGate:1;         //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_csi_clk_t;
+
+
+typedef struct __CCMU_VE_CLK_REG013C
+{
+    __u32   reserved0:16;       //bit0,  reserved
+    __u32   ClkDiv:3;           //bit16, Clock pre-divide ratio, divided by (n+1), 1~8 ex.
+    __u32   reserved1:12;       //bit19, reserved
+    __u32   ClkGate:1;          //bit31, gating special clock for VE, 0-mask, 1-pass
+}__ccmu_ve_clk_reg013c_t;
+
+
+typedef struct __CCMU_HDMI_CLK_REG0150
+{
+    __u32   ClkDiv:4;           //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0:20;       //bit4,  reserved
+    __u32   ClkSrc:2;           //bit24, clock source select, 00-PLL3(1x), 01-PLL7(1x), 10-PLL3(2x), 11-PLL7(2x)
+    __u32   reserved1:4;        //bit26, reserved
+    __u32   DDCGate:1;          //bit30, Gating ddc clock, 0-clock off, 1-clock on
+    __u32   ClkGate:1;          //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_hdmi_clk_reg0150_t;
+
+
+typedef struct __CCMU_MIPI_CLK
+{
+    __u32   PClkDiv:4;          //bit0,  clock divide ratio, divided by (m+1), 1~16 ex.
+    __u32   reserved0:4;        //bit4,  reserved
+    __u32   PClkSrc:2;          //bit8,  clock source select, 00-PLL3(1x), 01-PLL7(1x), 10-PLL3(2x), 11-PLL7(2x)
+    __u32   reserved1:5;        //bit10, reserved
+    __u32   PClkGate:1;         //bit15, gating phy clock
+    __u32   SClkDiv:4;          //bit16, Special clock divide ratio
+    __u32   reserved2:4;        //bit20, reserved
+    __u32   SClkSrc:3;          //bit24, special clock source select, 00-PLL3(1x), 01-PLL7(1x), 10-PLL3(2x), 11-PLL7(2x)
+    __u32   reserved3:4;        //bit27, reserved
+    __u32   SClkGate:1;         //bit31, Gating special clock, 0-clock off, 1-clock on
+} __ccmu_mipi_clk_t;
+
+
+typedef struct __CCMU_PLLLOCK_REG
+{
+    __u32   LockTime:16;        //bit0,  PLL lock time, based on us
+    __u32   reserved:16;        //bit16, reserved
+} __ccmu_plllock_reg_t;
+
+
+typedef struct __CCMU_MOD_RST_REG02C0
+{
+    __u32   reserved0:1;        //bit0,  reserved
+    __u32   MipiDsi:1;          //bit1,  mipi dsi reset, 0:assert, 1:de-assert
+    __u32   reserved1:3;        //bit2,  reserved
+    __u32   Ss:1;               //bit5,  ss reset, 0:assert, 1:de-assert
+    __u32   Dma:1;              //bit6,  dma reset, 0:assert, 1:de-assert
+    __u32   reserved2:1;        //bit7,  reserved
+    __u32   Sd0:1;              //bit8,  sd/mmc0 reset, 0:assert, 1:de-assert
+    __u32   Sd1:1;              //bit9,  sd/mmc1 reset, 0:assert, 1:de-assert
+    __u32   Sd2:1;              //bit10, sd/mmc2 reset, 0:assert, 1:de-assert
+    __u32   Sd3:1;              //bit11, sd/mmc3 reset, 0:assert, 1:de-assert
+    __u32   Nand1:1;            //bit12, nand1 reset, 0:assert, 1:de-assert
+    __u32   Nand0:1;            //bit13, nand0 reset, 0:assert, 1:de-assert
+    __u32   Sdram:1;            //bit14, sdram AHB reset, 0:assert, 1:de-assert
+    __u32   reserved3:2;        //bit15, reserved
+    __u32   Gmac:1;             //bit17, Gmac reset, 0:assert, 1:de-assert
+    __u32   Ts:1;               //bit18, ts reset, 0:assert, 1:de-assert
+    __u32   HsTmr:1;            //bit19, hstimer reset, 0:assert, 1:de-assert
+    __u32   Spi0:1;             //bit20, spi0 reset, 0:assert, 1:de-assert
+    __u32   Spi1:1;             //bit21, spi1 reset, 0:assert, 1:de-assert
+    __u32   Spi2:1;             //bit22, spi2 reset, 0:assert, 1:de-assert
+    __u32   Spi3:1;             //bit23, spi3 reset, 0:assert, 1:de-assert
+    __u32   Otg:1;              //bit24, usb otg reset, 0:assert, 1:de-assert
+    __u32   reserved4:1;        //bit25, reserved
+    __u32   Ehci0:1;            //bit26, usb EHCI0 reset, 0:assert, 1:de-assert
+    __u32   Ehci1:1;            //bit27, usb EHCI1 reset, 0:assert, 1:de-assert
+    __u32   reserved5:1;        //bit28, reserved
+    __u32   Ohci0:1;            //bit29, usb OHCI0 reset, 0:assert, 1:de-assert
+    __u32   Ohci1:1;            //bit30, usb OHCI1 reset, 0:assert, 1:de-assert
+    __u32   Ohci2:1;            //bit31, usb OHCI2 reset, 0:assert, 1:de-assert
+
+} __ccmu_mod_rst_reg02c0_t;
+
+
+typedef struct __CCMU_MOD_RST_REG02C4
+{
+    __u32   Ve:1;               //bit0,  ve reset, 0:assert, 1:de-assert
+    __u32   reserved0:3;        //bit1,  reserved
+    __u32   Lcd0:1;             //bit4,  lcd0 reset, 0:assert, 1:de-assert
+    __u32   Lcd1:1;             //bit5,  lcd1 reset, 0:assert, 1:de-assert
+    __u32   reserved1:2;        //bit6,  reserved
+    __u32   Csi0:1;             //bit8,  lcd0 reset, 0:assert, 1:de-assert
+    __u32   Csi1:1;             //bit9,  lcd1 reset, 0:assert, 1:de-assert
+    __u32   reserved2:1;        //bit10, reserved
+    __u32   Hdmi:1;             //bit11, hdmi reset, 0:assert, 1:de-assert
+    __u32   Be0:1;              //bit12, be0 reset, 0:assert, 1:de-assert
+    __u32   Be1:1;              //bit13, be1 reset, 0:assert, 1:de-assert
+    __u32   Fe0:1;              //bit14, fe0 reset, 0:assert, 1:de-assert
+    __u32   Fe1:1;              //bit15, fe1 reset, 0:assert, 1:de-assert
+    __u32   reserved3:2;        //bit16, reserved
+    __u32   Mp:1;               //bit18, mp reset, 0:assert, 1:de-assert
+    __u32   reserved4:1;        //bit19, reserved
+
+    __u32   Gpu:1;              //bit20, gpu reset, 0:assert, 1:de-assert
+    __u32   MsgBox:1;           //bit21, msg-box reset, 0:assert, 1:de-assert
+    __u32   SpinLock:1;         //bit22, spin-lock reset, 0:assert, 1:de-assert
+    __u32   Deu0:1;             //bit23, deu0 reset, 0:assert, 1:de-assert
+    __u32   Deu1:1;             //bit24, deu1 reset, 0:assert, 1:de-assert
+    __u32   Drc0:1;             //bit25, drc0 reset, 0:assert, 1:de-assert
+    __u32   Drc1:1;             //bit26, drc1 reset, 0:assert, 1:de-assert
+    __u32   MtcAcc:1;           //bit27, mtc-acc reset, 0:assert, 1:de-assert
+    __u32   reserved5:4;        //bit28, reserved
+
+} __ccmu_mod_rst_reg02c4_t;
+
+
+typedef struct __CCMU_MOD_RST_REG02C8
+{
+    __u32   Lvds:1;             //bit0,  lvds reset, 0:assert, 1:de-assert
+    __u32   reserved:31;        //bit1,  reserved
+
+} __ccmu_mod_rst_reg02c8_t;
+
+
+typedef struct __CCMU_MOD_RST_REG02D0
+{
+    __u32   Adda:1;             //bit0,  audio codec reset, 0:assert, 1:de-assert
+    __u32   Spdif:1;            //bit1,  spdif reset, 0:assert, 1:de-assert
+    __u32   reserved0:3;        //bit2,  reserved
+    __u32   Pio:1;              //bit5,  pio reset, 0:assert, 1:de-assert
+    __u32   reserved1:6;        //bit6,  reserved
+    __u32   I2s0:1;             //bit12, i2s-0 reset, 0:assert, 1:de-assert
+    __u32   I2s1:1;             //bit13, i2s-1 reset, 0:assert, 1:de-assert
+    __u32   reserved2:18;       //bit14, reserved
+
+} __ccmu_mod_rst_reg02d0_t;
+
+
+typedef struct __CCMU_MOD_RST_REG02D8
+{
+    __u32   Twi0:1;             //bit0,  twi0 reset, 0:assert, 1:de-assert
+    __u32   Twi1:1;             //bit1,  twi1 reset, 0:assert, 1:de-assert
+    __u32   Twi2:1;             //bit2,  twi2 reset, 0:assert, 1:de-assert
+    __u32   Twi3:1;             //bit3,  twi3 reset, 0:assert, 1:de-assert
+    __u32   reserved0:12;       //bit4,  reserved
+    __u32   Uart0:1;            //bit16, uart0 reset, 0:assert, 1:de-assert
+    __u32   Uart1:1;            //bit17, uart1 reset, 0:assert, 1:de-assert
+    __u32   Uart2:1;            //bit18, uart2 reset, 0:assert, 1:de-assert
+    __u32   Uart3:1;            //bit19, uart3 reset, 0:assert, 1:de-assert
+    __u32   Uart4:1;            //bit20, uart4 reset, 0:assert, 1:de-assert
+    __u32   Uart5:1;            //bit21, uart5 reset, 0:assert, 1:de-assert
+    __u32   reserved1:10;       //bit22, reserved
+
+} __ccmu_mod_rst_reg02d8_t;
+
+
+typedef struct __CCMU_CLK_OUT
+{
+    __u32   reserved0:8;       //bit0,  reserved
+    __u32   DivM:5;            //bit8,  clock output divide factor m
+    __u32   reserved1:7;       //bit13, reserved
+    __u32   DivN:2;            //bit20, clock output divide factor n
+    __u32   reserved2:2;       //bit22, reserved
+    __u32   ClkSrc:4;          //bit24, clock out source select
+    __u32   reserved3:3;       //bit28, reserved
+    __u32   ClkEn:1;           //bit31, clock out enable
+
+} __ccmu_clk_out_t;
+
+
+typedef struct __CCMU_REG_LIST
+{
+    volatile __ccmu_pll1_reg0000_t              Pll1Ctl;    //0x0000, PLL1 control
+    volatile __u32                              reserved0;  //0x0004, reserved
+    volatile __ccmu_pll2_reg0008_t              Pll2Ctl;    //0x0008, PLL2 control
+    volatile __u32                              reserved1;  //0x000c, reserved
+    volatile __ccmu_media_pll_t                 Pll3Ctl;    //0x0010, PLL3 control
+    volatile __u32                              reserved2;  //0x0014, reserved
+    volatile __ccmu_media_pll_t                 Pll4Ctl;    //0x0018, PLL4 control
+    volatile __u32                              reserved3;  //0x001c, reserved
+    volatile __ccmu_pll5_reg0020_t              Pll5Ctl;    //0x0020, PLL5 control
+    volatile __u32                              reserved4;  //0x0024, reserved
+    volatile __ccmu_pll6_reg0028_t              Pll6Ctl;    //0x0028, PLL6 control
+    volatile __u32                              reserved5;  //0x002c, reserved
+    volatile __ccmu_media_pll_t                 Pll7Ctl;    //0x0030, PLL7 control
+    volatile __u32                              reserved6;  //0x0034, reserved
+    volatile __ccmu_media_pll_t                 Pll8Ctl;    //0x0038, PLL8 control
+    volatile __u32                              reserved7;  //0x003c, reserved
+    volatile __ccmu_mipi_pll_reg0040_t          MipiPllCtl; //0x0040, MIPI PLL control
+    volatile __ccmu_media_pll_t                 Pll9Ctl;    //0x0044, PLL9 control
+    volatile __ccmu_media_pll_t                 Pll10Ctl;   //0x0048, PLL10 control
+    volatile __u32                              reserved8;  //0x004c, reserved
+    volatile __ccmu_sysclk_ratio_reg0050_t      SysClkDiv;  //0x0050, system clock divide ratio
+    volatile __ccmu_ahb1_ratio_reg0054_t        Ahb1Div;    //0x0054, ahb1/apb1 clock divide ratio
+    volatile __ccmu_apb2_ratio_reg0058_t        Apb2Div;    //0x0058, apb2 clock divide ratio
+    volatile __ccmu_axi_gate_reg005c_t          AxiGate;    //0x005c, axi clock gating
+    volatile __ccmu_ahb1_gate0_reg0060_t        AhbGate0;   //0x0060, ahb clock gate 0
+    volatile __ccmu_ahb1_gate1_reg0064_t        AhbGate1;   //0x0064, ahb clock gate 1
+    volatile __ccmu_apb1_gate_reg0068_t         Apb1Gate;   //0x0068, apb1 clock gate
+    volatile __ccmu_apb2_gate_reg006c_t         Apb2Gate;   //0x006c, apb2 clock gate
+    volatile __u32                              reserved9[4];   //0x0070, reserved
+    volatile __ccmu_module0_clk_t               Nand0;      //0x0080, nand controller 0 clock
+    volatile __ccmu_module0_clk_t               Nand1;      //0x0084, nand controller 1 clock
+    volatile __ccmu_module0_clk_t               Sd0;        //0x0088, sd/mmc controller 0 clock
+    volatile __ccmu_module0_clk_t               Sd1;        //0x008c, sd/mmc controller 1 clock
+    volatile __ccmu_module0_clk_t               Sd2;        //0x0090, sd/mmc controller 2 clock
+    volatile __ccmu_module0_clk_t               Sd3;        //0x0094, sd/mmc controller 3 clock
+    volatile __ccmu_module0_clk_t               Ts;         //0x0098, TS controller clock
+    volatile __ccmu_module0_clk_t               Ss;         //0x009c, SS controller clock
+    volatile __ccmu_module0_clk_t               Spi0;       //0x00a0, spi controller 0 clock
+    volatile __ccmu_module0_clk_t               Spi1;       //0x00a4, spi controller 1 clock
+    volatile __ccmu_module0_clk_t               Spi2;       //0x00a8, spi controller 2 clock
+    volatile __ccmu_module0_clk_t               Spi3;       //0x00ac, spi controller 3 clock
+    volatile __ccmu_module1_clk_t               I2s0;       //0x00b0, I2s-0 clock
+    volatile __ccmu_module1_clk_t               I2s1;       //0x00b4, I2s-1 clock
+    volatile __u32                              reserved10[2];  //0x00b8, reserved
+    volatile __ccmu_module1_clk_t               Spdif;      //0x00c0, SPDIF clock
+    volatile __u32                              reserved11[2];  //0x00c4, reserved
+    volatile __ccmu_usb_clk_reg00cc_t           Usb;        //0x00cc, usb clock
+    volatile __ccmu_gmac_clk_reg00d0_t          Gmac;       //0x00d0, gmac clock
+    volatile __u32                              reserved12[7];  //0x00d4, reserved
+    volatile __ccmu_module0_clk_t               Mdfs;       //0x00f0, mdfs clock
+    volatile __ccmu_dram_cfg_reg00f4_t          DramCfg;    //0x00f4, dram configuration clock
+    volatile __u32                              reserved13[2];  //0x00f8, reserved
+    volatile __ccmu_dram_gate_reg0100_t         DramGate;   //0x0100, dram module clock
+    volatile __ccmu_disp_clk_t                  Be0;        //0x0104, BE0 module clock
+    volatile __ccmu_disp_clk_t                  Be1;        //0x0108, BE1 module clock
+    volatile __ccmu_disp_clk_t                  Fe0;        //0x010c, FE0 module clock
+    volatile __ccmu_disp_clk_t                  Fe1;        //0x0110, FE1 module clock
+    volatile __ccmu_disp_clk_t                  Mp;         //0x0114, MP module clock
+    volatile __ccmu_disp_clk_t                  Lcd0Ch0;    //0x0118, LCD0 CH0 module clock
+    volatile __ccmu_disp_clk_t                  Lcd1Ch0;    //0x011c, LCD1 CH0 module clock
+    volatile __u32                              reserved14[3];  //0x0120, reserved
+    volatile __ccmu_disp_clk_t                  Lcd0Ch1;    //0x012c, LCD0 CH1 module clock
+    volatile __ccmu_disp_clk_t                  Lcd1Ch1;    //0x0130, LCD1 CH1 module clock
+    volatile __ccmu_csi_clk_t                   Csi0;       //0x0134, csi0 module clock
+    volatile __ccmu_csi_clk_t                   Csi1;       //0x0138, csi1 module clock
+    volatile __ccmu_ve_clk_reg013c_t            Ve;         //0x013c, ve module clock
+    volatile __ccmu_module1_clk_t               Adda;       //0x0140, adda module clock
+    volatile __ccmu_module_clk_t                Avs;        //0x0144, avs module clock
+    volatile __ccmu_module1_clk_t               Dmic;       //0x0148, digtal mic module clock
+    volatile __u32                              reserved15; //0x014c, reserved
+    volatile __ccmu_hdmi_clk_reg0150_t          Hdmi;       //0x0150, hdmi module clock
+    volatile __ccmu_module1_clk_t               Ps;         //0x0154, ps module clock
+    volatile __ccmu_module0_clk_t               MtcAcc;     //0x0158, MTC ACC clock
+    volatile __ccmu_module0_clk_t               MBus0;      //0x015C, MBUS controller 0 clock
+    volatile __ccmu_module0_clk_t               MBus1;      //0x0160, MBUS controller 1 clock
+    volatile __u32                              reserved16; //0x0164, reserved
+    volatile __ccmu_mipi_clk_t                  MipiDsi;    //0x0168, MIPI DSI clock
+    volatile __ccmu_mipi_clk_t                  MipiCsi;    //0x016C, MIPI CSI clock
+    volatile __u32                              reserved17[4];  //0x0170, reserved
+    volatile __ccmu_module0_clk_t               IepDrc0;    //0x0180, IEP DRC0 clock
+    volatile __ccmu_module0_clk_t               IepDrc1;    //0x0184, IEP DRC1 clock
+    volatile __ccmu_module0_clk_t               IepDeu0;    //0x0188, IEP DEU0 clock
+    volatile __ccmu_module0_clk_t               IepDeu1;    //0x018c, IEP DEU1 clock
+    volatile __u32                              reserved18[4];  //0x0190, reserved
+    volatile __ccmu_module0_clk_t               GpuCore;    //0x01A0, GPU Core clock
+    volatile __ccmu_module0_clk_t               GpuMem;     //0x01A4, GPU Memory clock
+    volatile __ccmu_module0_clk_t               GpuHyd;     //0x01A8, GPU hyd clock
+    volatile __u32                              reserved19[21]; //0x01AC, reserved
+    volatile __ccmu_plllock_reg_t               PllLock;    //0x0200, pll lock time
+    volatile __ccmu_plllock_reg_t               Pll1Lock;   //0x0204, pll1 lock time
+    volatile __u32                              reserved20[6]; //0x0208, reserved
+    volatile __u32                              Pll1Bias;   //0x220, pll1 bias control
+    volatile __u32                              Pll2Bias;   //0x224, pll1 bias control
+    volatile __u32                              Pll3Bias;   //0x228, pll1 bias control
+    volatile __u32                              Pll4Bias;   //0x22c, pll1 bias control
+    volatile __u32                              Pll5Bias;   //0x230, pll1 bias control
+    volatile __u32                              Pll6Bias;   //0x234, pll1 bias control
+    volatile __u32                              Pll7Bias;   //0x238, pll1 bias control
+    volatile __u32                              Pll8Bias;   //0x23c, pll1 bias control
+    volatile __u32                              MipiBias;   //0x240, pll1 bias control
+    volatile __u32                              Pll9Bias;   //0x244, pll1 bias control
+    volatile __u32                              Pll10Bias;  //0x248, pll1 bias control
+    volatile __u32                              reserved21; //0x024c, reserved
+    volatile __u32                              Pll1Tune;   //0x250, pll1 tuning control
+    volatile __u32                              reserved22[3]; //0x0254, reserved
+    volatile __u32                              Pll5Tune;  //0x260, pll1 tuning control
+    volatile __u32                              reserved23[3]; //0x0264, reserved
+    volatile __u32                              MipiTune;  //0x270, mipi pll tuning control
+    volatile __u32                              reserved24[3]; //0x0274, reserved
+    volatile __u32                              PLL1Pat;  //0x280, PLL1 pattern control
+    volatile __u32                              PLL2Pat;  //0x284, PLL2 pattern control
+    volatile __u32                              PLL3Pat;  //0x288, PLL3 pattern control
+    volatile __u32                              PLL4Pat;  //0x28c, PLL4 pattern control
+    volatile __u32                              PLL5Pat;  //0x290, PLL5 pattern control
+    volatile __u32                              reserved25; //0x0294, reserved
+    volatile __u32                              PLL7Pat;  //0x298, PLL7 pattern control
+    volatile __u32                              PLL8Pat;  //0x29c, PLL8 pattern control
+    volatile __u32                              MipiPat;  //0x2a0, mipi pll pattern control
+    volatile __u32                              PLL9Pat;  //0x2a4, PLL9 pattern control
+    volatile __u32                              PLL10Pat; //0x2a8, PLL10 pattern control
+    volatile __u32                              reserved26[5]; //0x02ac, reserved
+    volatile __ccmu_mod_rst_reg02c0_t           AhbReset0;  //0x02c0, AHB1 module reset register 0
+    volatile __ccmu_mod_rst_reg02c4_t           AhbReset1;  //0x02c4, AHB1 module reset register 1
+    volatile __ccmu_mod_rst_reg02c8_t           AhbReset2;  //0x02c8, AHB1 module reset register 2
+    volatile __u32                              reserved27; //0x02cc, reserved
+    volatile __ccmu_mod_rst_reg02d0_t           Apb1Reset;  //0x02d0, APB1 module reset register
+    volatile __u32                              reserved28; //0x02d4, reserved
+    volatile __ccmu_mod_rst_reg02d8_t           Apb2Reset;  //0x02d8, APB2 module reset register
+    volatile __u32                              reserved29[9];  //0x02dc, reserved
+    volatile __ccmu_clk_out_t                   ClkOutA;    //0x0300, pll lock time
+    volatile __ccmu_clk_out_t                   ClkOutB;    //0x0304, pll lock time
+    volatile __ccmu_clk_out_t                   ClkOutC;    //0x0308, pll lock time
+
+} __ccmu_reg_list_t;
+
+
+#define AR100_CLKSRC_LOSC       (0)
+#define AR100_CLKSRC_HOSC       (1)
+#define AR100_CLKSRC_PLL6       (2)
+typedef struct __CCMU_CPUS_CFG
+{
+    __u32   reserved0:4;        //bit0,  reserved
+    __u32   Div:2;              //bit4,  cpu0 clock divide ratio, 1/2/4/8
+    __u32   reserved1:2;        //bit6,  reserved
+    __u32   PostDiv:5;          //bit8,  cpu0 post divide, 1~32
+    __u32   reserved2:3;        //bit13, reserved
+    __u32   ClkSrc:2;           //bit16, cpu0 clock source, 00:LOSC, 01:HOSC, 10/11:PLL6/PDIV,
+    __u32   reserved:14;        //bit18, reserved
+
+} __ccmu_cpus_cfg_t;
+
+
+typedef struct __CCMU_APB0_RATIO
+{
+    __u32   Div:2;              //bit0,  apb0 clock divide ratio, 2/2/4/8
+    __u32   reserved1:30;       //bit2,  reserved
+
+} __ccmu_apb0_ratio_t;
+
+
+typedef struct __CCMU_CPUNEON_CLK
+{
+    __u32   Neon:1;             //bit0,  cpu1 neon clock enable
+    __u32   Cpu1:1;             //bit1,  cpu1 clock enable
+    __u32   reserved:30;        //bit2,  reserved
+} __ccmu_cpuneon_clk_t;
+
+
+typedef struct __CCMU_APB0_GATE
+{
+    __u32   Pio:1;              //bit0,  gating APB0 clock for pio, 0-mask, 1-pass
+    __u32   Cir:1;              //bit1,  gating APB0 clock for cir, 0-mask, 1-pass
+    __u32   Tmr:1;              //bit2,  gating APB0 clock for timer0/1, 0-mask, 1-pass
+    __u32   P2wi:1;             //bit3,  gating APB0 clock for R_P2WI, 0-mask, 1-pass
+    __u32   Uart:1;             //bit4,  gating APB0 clock for R_UART, 0-mask, 1-pass
+    __u32   OneWire:1;          //bit5,  gating APB0 clock for R_ONE_WIRE, 0-mask, 1-pass
+    __u32   Twi:1;              //bit6,  gating APB0 clock for R_TWI, 0-mask, 1-pass
+    __u32   reserved:25;        //bit7,  reserved
+} __ccmu_apb0_gate_t;
+
+typedef struct __CCMU_PLL_CTL0
+{
+    __u32   BiasEn:1;           //bit0,  Pll bias enable, 0:disable, 1:enable
+    __u32   Osc24MGain:1;       //bit1,  osc24m gain enhance
+    __u32   reserved:2;         //bit2,  reserved
+    __u32   Usb24MSrc:2;        //bit4,  usb 24Mhz clock source select
+    __u32   reserved0:6;        //bit6,  reserved
+    __u32   IntPllSel:2;        //bit12, internal pll input select
+    __u32   reserved1:6;        //bit14, reserved
+    __u32   Sel24M:2;           //bit20, 24mhz clock source select
+    __u32   reserved2:2;        //bit22, reserved
+    __u32   TestSrc:1;          //bit24, test clock select, 0:24Mhz, 1:external clock
+    __u32   reserved3:7;        //bit25, reserved
+} __ccmu_pll_ctl0_t;
+
+
+typedef struct __CCMU_PLL_CTL1
+{
+    __u32   LdoEn:1;            //bit0,  ldo enable, 0:disable, 1:enable
+    __u32   Ldo1En:1;           //bit1,  ldo1 enable, 0:disable, 1:enable
+    __u32   CrystalEn:1;        //bit2,  crystal enable, 0:disable, 1:enable
+    __u32   ClkTstEn:1;         //bit3,  clock test enable, 0:disable, 1:enable
+    __u32   reserved1:11;       //bit4,  reserved
+    __u32   PllPwr:1;           //bit15, pll input power select, 0:2.5v, 1:3.3v
+    __u32   PllVdd:3;           //bit16, pll vdd ldo output, 000~111:1.10v~1.45v, 0.05v per-step
+    __u32   reserved2:5;        //bit19, reserved
+    __u32   KeyFiled:8;         //bit24, key filed for ldo enable bit, should be 0xA7
+
+} __ccmu_pll_ctl1_t;
+
+
+typedef struct __CCMU_APB0_MOD_RST
+{
+    __u32   reserved1:1;        //bit0,  reserved
+    __u32   Cir:1;              //bit1,  cir reset, 0:assert, 1:de-assert
+    __u32   Tmr:1;              //bit2,  timer0/1 reset, 0:assert, 1:de-assert
+    __u32   P2wi:1;             //bit3,  P2WI reset, 0:assert, 1:de-assert
+    __u32   Uart;               //bit4,  uart reset, 0:assert, 1:de-assert
+    __u32   OneWire:1;          //bit5,  one wire reset, 0:assert, 1:de-assert
+    __u32   Twi:1;              //bit6,  twi reset, 0:assert, 1:de-assert
+    __u32   reserved2:25;       //bit7,  reserved
+
+} __ccmu_apb0_mod_rst_t;
+
+typedef struct __CCMU_CPU_PWROFF
+{
+    __u32   Cpu1:1;             //bit0,  gating the corresponding modules when cpu1 power-off
+    __u32   Cpu2:1;             //bit1,  gating the corresponding modules when cpu2 power-off
+    __u32   Cpu3:1;             //bit2,  gating the corresponding modules when cpu3 power-off
+    __u32   Cpu4:1;             //bit3,  gating the corresponding modules when cpu4 power-off
+    __u32   reserved:28;        //bit4,  reserved
+
+} __ccmu_cpu_pwroff_t;
+
+
+typedef struct __CCMU_VDDSYS_PWROFF
+{
+    __u32   DramCh0Hold:1;      //bit0,  hold the pad of dram channel 0
+    __u32   DramCh1Hold:1;      //bit1,  hold the pad of dram channel 1
+    __u32   AvccA:1;            //bit2,  gating modules to the avcc_a when vdd-sys power off
+    __u32   Cpu0Vdd:1;          //bit3,  gating modules to cpu0 power domain when vdd-sys power off
+    __u32   reserved:28;        //bit4,  reserved
+
+} __ccmu_vddsys_pwroff_t;
+
+
+typedef struct __CCMU_GPU_PWROFF
+{
+    __u32   Gate:1;             //bit0,  gating the corresponding modules when gpu power-off
+    __u32   reserved:31;        //bit1,  reserved
+
+} __ccmu_gpu_pwroff_t;
+
+typedef struct __CCMU_VDDSYS_RESET
+{
+    __u32   Reset:1;            //bit0,  vdd-sys power domain modules should be reset befor vdd-sys power on
+    __u32   reserved:31;        //bit1,  reserved
+
+} __ccmu_vddsys_reset_t;
+
+
+typedef struct __CCMU_CPU_PWRCLAMP
+{
+    __u32   PwrClamp:8;         //bit0,  cpu2 power clamp control
+    __u32   reserved:24;        //bit8,  reserved
+
+} __ccmu_cpu_pwrclamp_t;
+
+
+typedef struct __CCMU_ONEWIRE_CLK_REG0050
+{
+    __u32   DivM:5;            //bit0,  clock divide ratio m, the pre-divided clock is divided by (m+1)
+    __u32   reserved0:11;      //bit5,  reserved
+    __u32   DivN:2;            //bit16,  clock pre-divide ratio n, 1/2/4/8
+    __u32   reserved1:6;       //bit18,  reserved
+    __u32   ClkSrc:2;          //bit24,  clock source select, 00-losc, 01-hosc, 10/11-/
+    __u32   reserved2:5;       //bit26,  reserved
+    __u32   ClkGate:1;         //bit31,  gating special clockd(max clock=100MHz), 0-off, 1-on
+
+} __ccmu_onewire_clk_reg0050_t;
+
+
+typedef struct __CCMU_REG_CPU0_LIST
+{
+    volatile __ccmu_cpus_cfg_t               CpusCfg;       //0x0000, cpu0 clock configuration
+    volatile __u32                           reserved0[2];  //0x0004, reserved
+    volatile __ccmu_apb0_ratio_t             Apb0Div;       //0x000c, apb0 clock divide ratio
+    volatile __ccmu_cpuneon_clk_t            Cpu1En;        //0x0010, cpu1/neon clock enable
+    volatile __ccmu_cpuneon_clk_t            Cpu2En;        //0x0014, cpu2/neon clock enable
+    volatile __ccmu_cpuneon_clk_t            Cpu3En;        //0x0018, cpu3/neon clock enable
+    volatile __ccmu_cpuneon_clk_t            Cpu4En;        //0x001c, cpu4/neon clock enable
+    volatile __u32                           reserved1[2];  //0x0020, reserved
+    volatile __ccmu_apb0_gate_t              Apb0Gate;      //0x0028, apb0 clock gating register
+    volatile __u32                           reserved2[5];  //0x002c, reserved
+    volatile __ccmu_pll_ctl0_t               PllCtl0;       //0x0040, pll control register 0
+    volatile __ccmu_pll_ctl1_t               PllCtl1;       //0x0044, pll control register 1
+    volatile __u32                           reserved3[2];  //0x0048, reserved
+    volatile __ccmu_onewire_clk_reg0050_t    OneWire;       //0x0050, one wire clock
+    volatile __ccmu_module0_clk_t            Cir;           //0x0054, cir clock
+    volatile __u32                           reserved4[22]; //0x0058, reserved
+    volatile __ccmu_apb0_mod_rst_t           ModReset;      //0x00b0, apb0 module software reset register
+    volatile __u32                           reserved5[15]; //0x00b4, reserved
+    volatile __ccmu_clk_out_t                ClkOutD;       //0x00F0, rtc clock out
+    volatile __u32                           reserved6[3];  //0x00F4, reserved
+    volatile __ccmu_cpu_pwroff_t             CpuPwrOff;     //0x0100, cpu power off gating
+    volatile __u32                           reserved7[3];  //0x0104, reserved
+    volatile __ccmu_vddsys_pwroff_t          VddPwrOff;     //0x0110, vdd-sys power off gating
+    volatile __u32                           reserved8;     //0x0114, reserved
+    volatile __ccmu_gpu_pwroff_t             GpuPwrOff;     //0x0118, gpu power off gating
+    volatile __u32                           reserved9;     //0x011c, reserved
+    volatile __ccmu_vddsys_reset_t           VddPwrRst;     //0x0120, vdd-sys power domain reset
+    volatile __u32                           reserved10[8]; //0x0124, reserved
+    volatile __ccmu_cpu_pwrclamp_t           Cpu2Clamp;     //0x0144, cpu2 power clamp control
+    volatile __ccmu_cpu_pwrclamp_t           Cpu3Clamp;     //0x0148, cpu3 power clamp control
+    volatile __ccmu_cpu_pwrclamp_t           Cpu4Clamp;     //0x014c, cpu4 power clamp control
+    volatile __u32                           reserved11[12];//0x0150, reserved
+    volatile __u32                           MemPwrMod;     //0x0180, memory modules power mode control
+    volatile __u32                           reserved12[3]; //0x0184, reserved
+    volatile __u32                           MemTstMod;     //0x0190, memory modules test mode control
+
+} __ccmu_reg_cpu0_list_t;
+
+
+#endif  // #ifndef __CCMU_REGS_H__
diff --git a/arch/arm/mach-sun6i/include/mach/clkdev.h b/arch/arm/mach-sun6i/include/mach/clkdev.h
new file mode 100644
index 0000000..2d5b3f5
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/clkdev.h
@@ -0,0 +1,9 @@
+#ifndef __ASM_MACH_CLKDEV_H
+#define __ASM_MACH_CLKDEV_H
+
+#include <linux/clk.h>
+
+int __clk_get(struct clk *hclk);
+void __clk_put(struct clk *clk);
+
+#endif
diff --git a/arch/arm/mach-sun6i/include/mach/clock.h b/arch/arm/mach-sun6i/include/mach/clock.h
new file mode 100644
index 0000000..a841c16
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/clock.h
@@ -0,0 +1,269 @@
+/*
+ * arch/arm/mach-sun6i/include/mach/clock.h
+ *
+ * Copyright 2012 (c) Allwinner.
+ * kevin.z.m (kevin@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __AW_CLOCK_H__
+#define __AW_CLOCK_H__
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/spinlock.h>
+
+#define CCU_LOCK_LIUGANG_20120930 	/* add ccu lock, liugang, 2012-9-30 */
+
+#ifdef CCU_LOCK_LIUGANG_20120930
+#define CCU_LOCK_INIT(lock)	spin_lock_init(lock)
+#define CCU_LOCK_DEINIT(lock)	do{} while(0)
+#define CCU_LOCK(lock, flags)	spin_lock_irqsave((lock), (flags))
+#define CCU_UNLOCK(lock, flags)	spin_unlock_irqrestore((lock), (flags))
+#define DEFINE_FLAGS(x)		unsigned long x
+#else
+#define CCU_LOCK_INIT(lock)	do{} while(0)
+#define CCU_LOCK_DEINIT(lock)	do{} while(0)
+#define CCU_LOCK(lock, flags)	do{} while(0)
+#define CCU_UNLOCK(lock, flags)	do{} while(0)
+#define DEFINE_FLAGS(flags)	do{} while(0)
+#endif /* CCU_LOCK_LIUGANG_20120930 */
+
+/* define clock error type      */
+typedef enum __AW_CCU_ERR
+{
+    AW_CCU_ERR_NONE     =  0,
+    AW_CCU_ERR_PARA_NUL = -1,
+    AW_CCU_ERR_PARA_INV = -2,
+} __aw_ccu_err_e;
+
+
+typedef enum __AW_CCU_CLK_ONOFF
+{
+    AW_CCU_CLK_OFF          = 0,
+    AW_CCU_CLK_ON           = 1,
+} __aw_ccu_clk_onff_e;
+
+
+typedef enum __AW_CCU_CLK_RESET
+{
+    AW_CCU_CLK_RESET        = 0,
+    AW_CCU_CLK_NRESET       = 1,
+} __aw_ccu_clk_reset_e;
+
+
+/* define system clock name */
+#define CLK_SYS_LOSC        "sys_losc"
+#define CLK_SYS_HOSC        "sys_hosc"
+#define CLK_SYS_PLL1        "sys_pll1"
+#define CLK_SYS_PLL2        "sys_pll2"
+#define CLK_SYS_PLL3        "sys_pll3"
+#define CLK_SYS_PLL4        "sys_pll4"
+#define CLK_SYS_PLL5        "sys_pll5"
+#define CLK_SYS_PLL6        "sys_pll6"
+#define CLK_SYS_PLL7        "sys_pll7"
+#define CLK_SYS_PLL8        "sys_pll8"
+#define CLK_SYS_PLL9        "sys_pll9"
+#define CLK_SYS_PLL10       "sys_pll10"
+#define CLK_SYS_PLL2X8      "sys_pll2X8"
+#define CLK_SYS_PLL3X2      "sys_pll3X2"
+#define CLK_SYS_PLL6X2      "sys_pll6X2"
+#define CLK_SYS_PLL7X2      "sys_pll7X2"
+#define CLK_SYS_MIPI_PLL    "sys_mipi_pll"
+#define CLK_SYS_AC327       "sys_ac327"
+#define CLK_SYS_AR100       "sys_ar100"
+#define CLK_SYS_AXI         "sys_axi"
+#define CLK_SYS_AHB0        "sys_ahb0"
+#define CLK_SYS_AHB1        "sys_ahb1"
+#define CLK_SYS_APB0        "sys_apb0"
+#define CLK_SYS_APB1        "sys_apb1"
+#define CLK_SYS_APB2        "sys_apb2"
+
+/* define module clock name */
+#define CLK_MOD_NAND0       "mod_nand0"
+#define CLK_MOD_NAND1       "mod_nand1"
+#define CLK_MOD_SDC0        "mod_sdc0"
+#define CLK_MOD_SDC1        "mod_sdc1"
+#define CLK_MOD_SDC2        "mod_sdc2"
+#define CLK_MOD_SDC3        "mod_sdc3"
+#define CLK_MOD_TS          "mod_ts"
+#define CLK_MOD_SS          "mod_ss"
+#define CLK_MOD_SPI0        "mod_spi0"
+#define CLK_MOD_SPI1        "mod_spi1"
+#define CLK_MOD_SPI2        "mod_spi2"
+#define CLK_MOD_SPI3        "mod_spi3"
+#define CLK_MOD_I2S0        "mod_i2s0"
+#define CLK_MOD_I2S1        "mod_i2s1"
+#define CLK_MOD_SPDIF       "mod_spdif"
+#define CLK_MOD_USBPHY0     "mod_usbphy0"
+#define CLK_MOD_USBPHY1     "mod_usbphy1"
+#define CLK_MOD_USBPHY2     "mod_usbphy2"
+#define CLK_MOD_USBEHCI0    "mod_usbehci0"
+#define CLK_MOD_USBEHCI1    "mod_usbehci1"
+#define CLK_MOD_USBOHCI0    "mod_usbohci0"
+#define CLK_MOD_USBOHCI1    "mod_usbohci1"
+#define CLK_MOD_USBOHCI2    "mod_usbohci2"
+#define CLK_MOD_USBOTG      "mod_usbotg"
+#define CLK_MOD_MDFS        "mod_mdfs"
+#define CLK_MOD_DEBE0       "mod_debe0"
+#define CLK_MOD_DEBE1       "mod_debe1"
+#define CLK_MOD_DEFE0       "mod_defe0"
+#define CLK_MOD_DEFE1       "mod_defe1"
+#define CLK_MOD_DEMP        "mod_demp"
+#define CLK_MOD_LCD0CH0     "mod_lcd0ch0"
+#define CLK_MOD_LCD0CH1     "mod_lcd0ch1"
+#define CLK_MOD_LCD1CH0     "mod_lcd1ch0"
+#define CLK_MOD_LCD1CH1     "mod_lcd1ch1"
+#define CLK_MOD_CSI0S       "mod_csi0s"
+#define CLK_MOD_CSI0M       "mod_csi0m"
+#define CLK_MOD_CSI1S       "mod_csi1s"
+#define CLK_MOD_CSI1M       "mod_csi1m"
+#define CLK_MOD_VE          "mod_ve"
+#define CLK_MOD_ADDA        "mod_adda"
+#define CLK_MOD_AVS         "mod_avs"
+#define CLK_MOD_DMIC        "mod_dmic"
+#define CLK_MOD_HDMI        "mod_hdmi"
+#define CLK_MOD_HDMI_DDC    "mod_hdmi_ddc"
+#define CLK_MOD_PS          "mod_ps"
+#define CLK_MOD_MTCACC      "mod_mtcacc"
+#define CLK_MOD_MBUS0       "mod_mbus0"
+#define CLK_MOD_MBUS1       "mod_mbus1"
+#define CLK_MOD_DRAM        "mod_dram"
+#define CLK_MOD_MIPIDSIS    "mod_mipidsis"
+#define CLK_MOD_MIPIDSIP    "mod_mipidsip"
+#define CLK_MOD_MIPICSIS    "mod_mipicsis"
+#define CLK_MOD_MIPICSIP    "mod_mipicsip"
+#define CLK_MOD_IEPDRC0     "mod_iepdrc0"
+#define CLK_MOD_IEPDRC1     "mod_iepdrc1"
+#define CLK_MOD_IEPDEU0     "mod_iepdeu0"
+#define CLK_MOD_IEPDEU1     "mod_iepdeu1"
+#define CLK_MOD_GPUCORE     "mod_gpucore"
+#define CLK_MOD_GPUMEM      "mod_gpumem"
+#define CLK_MOD_GPUHYD      "mod_gpuhyd"
+#define CLK_MOD_TWI0        "mod_twi0"
+#define CLK_MOD_TWI1        "mod_twi1"
+#define CLK_MOD_TWI2        "mod_twi2"
+#define CLK_MOD_TWI3        "mod_twi3"
+#define CLK_MOD_UART0       "mod_uart0"
+#define CLK_MOD_UART1       "mod_uart1"
+#define CLK_MOD_UART2       "mod_uart2"
+#define CLK_MOD_UART3       "mod_uart3"
+#define CLK_MOD_UART4       "mod_uart4"
+#define CLK_MOD_UART5       "mod_uart5"
+#define CLK_MOD_GMAC        "mod_gmac"
+#define CLK_MOD_DMA         "mod_dma"
+#define CLK_MOD_HSTMR       "mod_hstmr"
+#define CLK_MOD_MSGBOX      "mod_msgbox"
+#define CLK_MOD_SPINLOCK    "mod_spinlock"
+#define CLK_MOD_LVDS        "mod_lvds"
+#define CLK_SMP_TWD         "smp_twd"
+#define CLK_MOD_R_TWI       "mod_r_twi"
+#define CLK_MOD_R_1WIRE     "mod_r_1wire"
+#define CLK_MOD_R_UART      "mod_r_uart"
+#define CLK_MOD_R_P2WI      "mod_r_p2wi"
+#define CLK_MOD_R_TMR       "mod_r_tmr"
+#define CLK_MOD_R_CIR       "mod_r_cir"
+#define CLK_MOD_R_PIO       "mod_r_pio"
+
+/* define ahb module gatine clock */
+#define CLK_AHB_MIPICSI     "ahb_mipicsi"
+#define CLK_AHB_MIPIDSI     "ahb_mipidsi"
+#define CLK_AHB_SS          "ahb_ss"
+#define CLK_AHB_DMA         "ahb_dma"
+#define CLK_AHB_SDMMC0      "ahb_sdmmc0"
+#define CLK_AHB_SDMMC1      "ahb_sdmmc1"
+#define CLK_AHB_SDMMC2      "ahb_sdmmc2"
+#define CLK_AHB_SDMMC3      "ahb_sdmmc3"
+#define CLK_AHB_NAND1       "ahb_nand1"
+#define CLK_AHB_NAND0       "ahb_nand0"
+#define CLK_AHB_SDRAM       "ahb_sdram"
+#define CLK_AHB_GMAC        "ahb_gmac"
+#define CLK_AHB_TS          "ahb_ts"
+#define CLK_AHB_HSTMR       "ahb_hstmr"
+#define CLK_AHB_SPI0        "ahb_spi0"
+#define CLK_AHB_SPI1        "ahb_spi1"
+#define CLK_AHB_SPI2        "ahb_spi2"
+#define CLK_AHB_SPI3        "ahb_spi3"
+#define CLK_AHB_OTG         "ahb_otg"
+#define CLK_AHB_EHCI0       "ahb_ehci0"
+#define CLK_AHB_EHCI1       "ahb_ehci1"
+#define CLK_AHB_OHCI0       "ahb_ohci0"
+#define CLK_AHB_OHCI1       "ahb_ohci1"
+#define CLK_AHB_OHCI2       "ahb_ohci2"
+#define CLK_AHB_VE          "ahb_ve"
+#define CLK_AHB_LCD0        "ahb_lcd0"
+#define CLK_AHB_LCD1        "ahb_lcd1"
+#define CLK_AHB_CSI0        "ahb_csi0"
+#define CLK_AHB_CSI1        "ahb_csi1"
+#define CLK_AHB_HDMI        "ahb_hdmid"
+#define CLK_AHB_DEBE0       "ahb_debe0"
+#define CLK_AHB_DEBE1       "ahb_debe1"
+#define CLK_AHB_DEFE0       "ahb_defe0"
+#define CLK_AHB_DEFE1       "ahb_defe1"
+#define CLK_AHB_MP          "ahb_mp"
+#define CLK_AHB_GPU         "ahb_gpu"
+#define CLK_AHB_MSGBOX      "ahb_msgbox"
+#define CLK_AHB_SPINLOCK    "ahb_spinlock"
+#define CLK_AHB_DEU0        "ahb_deu0"
+#define CLK_AHB_DEU1        "ahb_deu1"
+#define CLK_AHB_DRC0        "ahb_drc0"
+#define CLK_AHB_DRC1        "ahb_drc1"
+#define CLK_AHB_MTCACC      "ahb_mtcacc"
+
+/* define apb module gatine clock */
+#define CLK_APB_ADDA        "apb_adda"
+#define CLK_APB_SPDIF       "apb_spdif"
+#define CLK_APB_PIO         "apb_pio"
+#define CLK_APB_I2S0        "apb_i2s0"
+#define CLK_APB_I2S1        "apb_i2s1"
+#define CLK_APB_TWI0        "apb_twi0"
+#define CLK_APB_TWI1        "apb_twi1"
+#define CLK_APB_TWI2        "apb_twi2"
+#define CLK_APB_TWI3        "apb_twi3"
+#define CLK_APB_UART0       "apb_uart0"
+#define CLK_APB_UART1       "apb_uart1"
+#define CLK_APB_UART2       "apb_uart2"
+#define CLK_APB_UART3       "apb_uart3"
+#define CLK_APB_UART4       "apb_uart4"
+#define CLK_APB_UART5       "apb_uart5"
+
+/* define dram module gating clock */
+#define CLK_DRAM_VE         "dram_ve"
+#define CLK_DRAM_CSI_ISP    "dram_csi_isp"
+#define CLK_DRAM_TS         "dram_ts"
+#define CLK_DRAM_DRC0       "dram_drc0"
+#define CLK_DRAM_DRC1       "dram_drc1"
+#define CLK_DRAM_DEU0       "dram_deu0"
+#define CLK_DRAM_DEU1       "dram_deu1"
+#define CLK_DRAM_DEFE0      "dram_defe0"
+#define CLK_DRAM_DEFE1      "dram_defe1"
+#define CLK_DRAM_DEBE0      "dram_debe0"
+#define CLK_DRAM_DEBE1      "dram_debe1"
+#define CLK_DRAM_MP         "dram_mp"
+
+
+
+
+struct __AW_CCU_CLK;
+struct clk_ops;
+
+typedef struct clk
+{
+    struct __AW_CCU_CLK *aw_clk;    /* clock handle from ccu csp                            */
+    struct clk_ops      *ops;       /* clock operation handle                               */
+    int             enable;     /* enable count, when it down to 0, it will be disalbe  */
+#ifdef CCU_LOCK_LIUGANG_20120930
+    spinlock_t      lock;	/* to synchronize the clock setting */
+#endif /* CCU_LOCK_LIUGANG_20120930 */
+
+} __ccu_clk_t;
+
+
+extern int clk_reset(struct clk *clk, __aw_ccu_clk_reset_e reset);
+
+#endif  /* #ifndef __AW_CLOCK_H__ */
diff --git a/arch/arm/mach-sun6i/include/mach/debug-macro.S b/arch/arm/mach-sun6i/include/mach/debug-macro.S
new file mode 100644
index 0000000..50e2cb0
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/debug-macro.S
@@ -0,0 +1,43 @@
+/* arch/arm/mach-sun6i/include/mach/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ * Copyright (c) Allwinner.  All rights reserved.
+ * Benn Huang (benn@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <mach/platform.h>
+
+#ifdef CONFIG_DEBUG_AW_UART0
+#define UART_PADDR	AW_UART0_BASE
+#define UART_VADDR	(0xf0000000 + AW_UART0_BASE)
+
+#elif defined (CONFIG_DEBUG_AW_R_UART)
+#define UART_PADDR	AW_R_UART_BASE
+#define UART_VADDR	(0xf0000000 + AW_R_UART_BASE)
+#else
+#error "Please select a uart port"
+#endif
+
+	.macro	addruart, rp, rv, tmp
+	ldr	\rv, =UART_VADDR
+	ldr	\rp, =UART_PADDR
+	.endm
+
+
+        .macro  senduart, rd, rx
+	str	\rd, [\rx, #AW_UART_THR]
+        .endm
+
+        .macro  busyuart, rd, rx
+        .endm
+
+        .macro  waituart, rd, rx
+1002:	ldr	\rd, [\rx, #AW_UART_USR]
+	tst	\rd, #0x2
+	beq	1002b
+        .endm
diff --git a/arch/arm/mach-sun6i/include/mach/dma.h b/arch/arm/mach-sun6i/include/mach/dma.h
new file mode 100644
index 0000000..c25343f
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/dma.h
@@ -0,0 +1,330 @@
+/*
+ * arch/arm/mach-sun6i/include/mach/dma.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i dma driver header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SW_DMA_H
+#define __SW_DMA_H
+
+#include <mach/hardware.h>
+
+/* burst length */
+#define X_SIGLE   0
+#define X_BURST   1
+#define X_TIPPL	  2
+
+/* data width */
+#define X_BYTE    0
+#define X_HALF    1
+#define X_WORD    2
+
+/* address mode */
+#define A_LN      0x0
+#define A_IO      0x1
+
+/*
+ * data width and burst length combination
+ * index for xfer_arr[]
+ */
+enum xferunit_e {
+	/* des:X_SIGLE  src:X_SIGLE */
+	DMAXFER_D_SBYTE_S_SBYTE,
+	DMAXFER_D_SBYTE_S_SHALF,
+	DMAXFER_D_SBYTE_S_SWORD,
+	DMAXFER_D_SHALF_S_SBYTE,
+	DMAXFER_D_SHALF_S_SHALF,
+	DMAXFER_D_SHALF_S_SWORD,
+	DMAXFER_D_SWORD_S_SBYTE,
+	DMAXFER_D_SWORD_S_SHALF,
+	DMAXFER_D_SWORD_S_SWORD,
+
+	/* des:X_SIGLE  src:X_BURST */
+	DMAXFER_D_SBYTE_S_BBYTE,
+	DMAXFER_D_SBYTE_S_BHALF,
+	DMAXFER_D_SBYTE_S_BWORD,
+	DMAXFER_D_SHALF_S_BBYTE,
+	DMAXFER_D_SHALF_S_BHALF,
+	DMAXFER_D_SHALF_S_BWORD,
+	DMAXFER_D_SWORD_S_BBYTE,
+	DMAXFER_D_SWORD_S_BHALF,
+	DMAXFER_D_SWORD_S_BWORD,
+
+	/* des:X_SIGLE   src:X_TIPPL */
+	DMAXFER_D_SBYTE_S_TBYTE,
+	DMAXFER_D_SBYTE_S_THALF,
+	DMAXFER_D_SBYTE_S_TWORD,
+	DMAXFER_D_SHALF_S_TBYTE,
+	DMAXFER_D_SHALF_S_THALF,
+	DMAXFER_D_SHALF_S_TWORD,
+	DMAXFER_D_SWORD_S_TBYTE,
+	DMAXFER_D_SWORD_S_THALF,
+	DMAXFER_D_SWORD_S_TWORD,
+
+	/* des:X_BURST  src:X_BURST */
+	DMAXFER_D_BBYTE_S_BBYTE,
+	DMAXFER_D_BBYTE_S_BHALF,
+	DMAXFER_D_BBYTE_S_BWORD,
+	DMAXFER_D_BHALF_S_BBYTE,
+	DMAXFER_D_BHALF_S_BHALF,
+	DMAXFER_D_BHALF_S_BWORD,
+	DMAXFER_D_BWORD_S_BBYTE,
+	DMAXFER_D_BWORD_S_BHALF,
+	DMAXFER_D_BWORD_S_BWORD,
+
+	/* des:X_BURST   src:X_SIGLE */
+	DMAXFER_D_BBYTE_S_SBYTE,
+	DMAXFER_D_BBYTE_S_SHALF,
+	DMAXFER_D_BBYTE_S_SWORD,
+	DMAXFER_D_BHALF_S_SBYTE,
+	DMAXFER_D_BHALF_S_SHALF,
+	DMAXFER_D_BHALF_S_SWORD,
+	DMAXFER_D_BWORD_S_SBYTE,
+	DMAXFER_D_BWORD_S_SHALF,
+	DMAXFER_D_BWORD_S_SWORD,
+
+	/* des:X_BURST   src:X_TIPPL */
+	DMAXFER_D_BBYTE_S_TBYTE,
+	DMAXFER_D_BBYTE_S_THALF,
+	DMAXFER_D_BBYTE_S_TWORD,
+	DMAXFER_D_BHALF_S_TBYTE,
+	DMAXFER_D_BHALF_S_THALF,
+	DMAXFER_D_BHALF_S_TWORD,
+	DMAXFER_D_BWORD_S_TBYTE,
+	DMAXFER_D_BWORD_S_THALF,
+	DMAXFER_D_BWORD_S_TWORD,
+
+	/* des:X_TIPPL   src:X_TIPPL */
+	DMAXFER_D_TBYTE_S_TBYTE,
+	DMAXFER_D_TBYTE_S_THALF,
+	DMAXFER_D_TBYTE_S_TWORD,
+	DMAXFER_D_THALF_S_TBYTE,
+	DMAXFER_D_THALF_S_THALF,
+	DMAXFER_D_THALF_S_TWORD,
+	DMAXFER_D_TWORD_S_TBYTE,
+	DMAXFER_D_TWORD_S_THALF,
+	DMAXFER_D_TWORD_S_TWORD,
+
+	/* des:X_TIPPL   src:X_SIGLE */
+	DMAXFER_D_TBYTE_S_SBYTE,
+	DMAXFER_D_TBYTE_S_SHALF,
+	DMAXFER_D_TBYTE_S_SWORD,
+	DMAXFER_D_THALF_S_SBYTE,
+	DMAXFER_D_THALF_S_SHALF,
+	DMAXFER_D_THALF_S_SWORD,
+	DMAXFER_D_TWORD_S_SBYTE,
+	DMAXFER_D_TWORD_S_SHALF,
+	DMAXFER_D_TWORD_S_SWORD,
+
+	/* des:X_TIPPL   src:X_BURST */
+	DMAXFER_D_TBYTE_S_BBYTE,
+	DMAXFER_D_TBYTE_S_BHALF,
+	DMAXFER_D_TBYTE_S_BWORD,
+	DMAXFER_D_THALF_S_BBYTE,
+	DMAXFER_D_THALF_S_BHALF,
+	DMAXFER_D_THALF_S_BWORD,
+	DMAXFER_D_TWORD_S_BBYTE,
+	DMAXFER_D_TWORD_S_BHALF,
+	DMAXFER_D_TWORD_S_BWORD,
+	DMAXFER_MAX
+};
+
+/*
+ * src/dst address type
+ * index for addrtype_arr[]
+ */
+enum addrt_e {
+	DMAADDRT_D_LN_S_LN,
+	DMAADDRT_D_LN_S_IO,
+	DMAADDRT_D_IO_S_LN,
+	DMAADDRT_D_IO_S_IO,
+	DMAADDRT_MAX
+};
+
+/* dma channel irq type */
+enum dma_chan_irq_type {
+	CHAN_IRQ_NO 	= 0,			/* none */
+	CHAN_IRQ_HD	= (0b001	),	/* package half done irq */
+	CHAN_IRQ_FD	= (0b010	),	/* package full done irq */
+	CHAN_IRQ_QD	= (0b100	)	/* queue end irq */
+};
+
+/*
+ * dma config information
+ */
+struct dma_config_t {
+	/*
+	 * data length and burst length combination in DDMA and NDMA
+	 * eg: DMAXFER_D_SWORD_S_SWORD, DMAXFER_D_SBYTE_S_BBYTE
+	 */
+	enum xferunit_e	xfer_type;
+	/*
+	 * NDMA/DDMA src/dst address type
+	 * eg: DMAADDRT_D_INC_S_INC(NDMA addr type),
+	 *     DMAADDRT_D_LN_S_LN / DMAADDRT_D_LN_S_IO(DDMA addr type)
+	 */
+	enum addrt_e	address_type;
+	u32		para;		/* dma para reg */
+	u32 		irq_spt;	/* channel irq supported, eg: CHAN_IRQ_HD | CHAN_IRQ_FD */
+	u32		src_addr;	/* src phys addr */
+	u32		dst_addr;	/* dst phys addr */
+	u32		byte_cnt;	/* byte cnt for src_addr/dst_addr transfer */
+	bool		bconti_mode;	/* continue mode */
+	u8		src_drq_type;	/* src drq type */
+	u8		dst_drq_type;	/* dst drq type */
+};
+
+/* src drq type */
+enum drqsrc_type_e {
+	DRQSRC_SRAM		= 0,
+	DRQSRC_SDRAM		= 1,
+	DRQSRC_SPDIFRX		= 2,
+	DRQSRC_DAUDIO_0_RX	= 3,
+	DRQSRC_DAUDIO_1_RX	= 4,
+	DRQSRC_NAND0		= 5,
+	DRQSRC_UART0RX		= 6,
+	DRQSRC_UART1RX 		= 7,
+	DRQSRC_UART2RX		= 8,
+	DRQSRC_UART3RX		= 9,
+	DRQSRC_UART4RX		= 10,
+	DRQSRC_HDMI_DDC		= 13,
+	DRQSRC_HDMI_AUDIO	= 14,
+	DRQSRC_AUDIO_CODEC	= 15,
+	DRQSRC_SS			= 16,
+	DRQSRC_OTG_EP1		= 17,
+	DRQSRC_OTG_EP2		= 18,
+	DRQSRC_OTG_EP3		= 19,
+	DRQSRC_OTG_EP4		= 20,
+	DRQSRC_OTG_EP5		= 21,
+	DRQSRC_UART5RX		= 22,
+	DRQSRC_SPI0RX		= 23,
+	DRQSRC_SPI1RX		= 24,
+	DRQSRC_SPI2RX		= 25,
+	DRQSRC_SPI3RX		= 26,
+	DRQSRC_TP		= 27,
+	DRQSRC_NAND1		= 28,
+	DRQSRC_MTC_ACC		= 29,
+	DRQSRC_DIGITAL_MIC	= 30
+};
+
+/* dst drq type */
+enum drqdst_type_e {
+	DRQDST_SRAM		= 0,
+	DRQDST_SDRAM		= 1,
+	DRQDST_SPDIFTX		= 2,
+	DRQDST_DAUDIO_0_TX	= 3,
+	DRQDST_DAUDIO_1_TX	= 4,
+	DRQDST_NAND0		= 5,
+	DRQDST_UART0TX		= 6,
+	DRQDST_UART1TX 		= 7,
+	DRQDST_UART2TX		= 8,
+	DRQDST_UART3TX		= 9,
+	DRQDST_UART4TX		= 10,
+	DRQDST_TCON0		= 11,
+	DRQDST_TCON1		= 12,
+	DRQDST_HDMI_DDC		= 13,
+	DRQDST_HDMI_AUDIO	= 14,
+	DRQDST_AUDIO_CODEC	= 15,
+	DRQDST_SS			= 16,
+	DRQDST_OTG_EP1		= 17,
+	DRQDST_OTG_EP2		= 18,
+	DRQDST_OTG_EP3		= 19,
+	DRQDST_OTG_EP4		= 20,
+	DRQDST_OTG_EP5		= 21,
+	DRQDST_UART5TX		= 22,
+	DRQDST_SPI0TX		= 23,
+	DRQDST_SPI1TX		= 24,
+	DRQDST_SPI2TX		= 25,
+	DRQDST_SPI3TX		= 26,
+	DRQDST_NAND1		= 28,
+	DRQDST_MTC_ACC		= 29,
+	DRQDST_DIGITAL_MIC	= 30
+};
+
+/* dma operation type */
+enum dma_op_type_e {
+	DMA_OP_START,  			/* start dma */
+	DMA_OP_PAUSE,  			/* pause transferring */
+	DMA_OP_RESUME,  		/* resume transferring */
+	DMA_OP_STOP,  			/* stop dma */
+
+	DMA_OP_GET_STATUS,  		/* get channel status: idle/busy */
+	DMA_OP_GET_CUR_SRC_ADDR,  	/* get current src address */
+	DMA_OP_GET_CUR_DST_ADDR,  	/* get current dst address */
+	DMA_OP_GET_BYTECNT_LEFT,  	/* get byte cnt left */
+
+	DMA_OP_SET_OP_CB,		/* set operation callback */
+	DMA_OP_SET_HD_CB,		/* set half done callback */
+	DMA_OP_SET_FD_CB,		/* set full done callback */
+	DMA_OP_SET_QD_CB,		/* set queue done callback */
+};
+
+/* dma call back cause */
+enum dma_cb_cause_e {
+	DMA_CB_OK,		/* call back because success, eg: buf done */
+	DMA_CB_ABORT		/* call back because abort, eg: if stop the channel,
+				 * need to abort the rest buffer in buf chan
+				 */
+};
+
+/*
+ * phase for dma enqueue operation, i.e. when do we call enqueue operation
+ */
+enum dma_enque_phase_e {
+	ENQUE_PHASE_NORMAL,	/* enqueued by app(dma's caller) directly, not by callback func */
+	ENQUE_PHASE_HD,		/* enqueued by half_done callback function */
+	ENQUE_PHASE_FD,		/* enqueued by full_done callback function */
+	ENQUE_PHASE_QD		/* enqueued by queue_done callback function */
+};
+
+/* dma handle type defination */
+typedef void * dm_hdl_t;
+
+/* dma callback func */
+typedef u32 (* dma_cb)(dm_hdl_t dma_hdl, void *parg, enum dma_cb_cause_e cause);
+typedef u32 (* dma_op_cb)(dm_hdl_t dma_hdl, void *parg, enum dma_op_type_e op);
+
+/* dma callback struct */
+struct dma_cb_t {
+	dma_cb 		func;	/* dma callback fuction */
+	void 		*parg;	/* args of func */
+};
+
+/* dma operation callback struct */
+struct dma_op_cb_t {
+	dma_op_cb 	func;	/* dma operation callback fuction */
+	void 		*parg;	/* args of func */
+};
+
+/* dma channle work mode */
+enum dma_work_mode_e {
+	DMA_WORK_MODE_INVALID,	/* invalid work mode */
+	DMA_WORK_MODE_CHAIN,	/* chain mode
+				 * buffer will link in chain, hw can transfer them at one time.
+				 * in this case, irq for the middle buffer maybe lost.
+				 */
+	DMA_WORK_MODE_SINGLE	/* single mode
+				 * buffer will NOT link in chain, hw can only transfer one buffer at once.
+				 * irq for every buffer will be treated.
+				 */
+};
+
+/* dma export symbol */
+dm_hdl_t sw_dma_request(char * name, enum dma_work_mode_e work_mode);
+u32 sw_dma_release(dm_hdl_t dma_hdl);
+u32 sw_dma_enqueue(dm_hdl_t dma_hdl, u32 src_addr, u32 dst_addr, u32 byte_cnt,	enum dma_enque_phase_e phase);
+u32 sw_dma_config(dm_hdl_t dma_hdl, struct dma_config_t *pcfg, enum dma_enque_phase_e phase);
+u32 sw_dma_ctl(dm_hdl_t dma_hdl, enum dma_op_type_e op, void *parg);
+int sw_dma_getposition(dm_hdl_t dma_hdl, u32 *pSrc, u32 *pDst);
+void sw_dma_dump_chan(dm_hdl_t dma_hdl);
+
+#endif /* __SW_DMA_H */
diff --git a/arch/arm/mach-sun6i/include/mach/dram-freq-common.h b/arch/arm/mach-sun6i/include/mach/dram-freq-common.h
new file mode 100644
index 0000000..36918d2
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/dram-freq-common.h
@@ -0,0 +1,51 @@
+/*
+ * arch/arm/mach-sun6i/include/mach/dram-freq-common.h
+ *
+ * Copyright (C) 2012 - 2016 Reuuimlla Limited
+ * Pan Nan <pannan@reuuimllatech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __DRAM_FREQ_COMMON_H__
+#define __DRAM_FREQ_COMMON_H__
+
+#include <mach/platform.h>
+
+#define MDFS_TABLE_LEN  (16)
+
+#define CCM_PLL5_DDR_CTRL  		(AW_VIR_CCM_BASE      + 0x020)
+#define CCM_DRAMCLK_CFG_CTRL	(AW_VIR_CCM_BASE      + 0x0f4)
+
+#define SDR_COM_CR				(AW_VIR_DRAMCOM_BASE  +  0x00)
+#define SDR_COM_MCGCR			(AW_VIR_DRAMCOM_BASE  +  0x8c)
+#define SDR_COM_BWCR			(AW_VIR_DRAMCOM_BASE  +  0x90)
+#define SDR_COM_MDFSCR			(AW_VIR_DRAMCOM_BASE  + 0x100)
+#define SDR_COM_MDFSMER			(AW_VIR_DRAMCOM_BASE  + 0x104)
+#define SDR_COM_MDFSMRMR		(AW_VIR_DRAMCOM_BASE  + 0x108)
+#define SDR_COM_MDFSTR0			(AW_VIR_DRAMCOM_BASE  + 0x10c)
+#define SDR_COM_MDFSTR1			(AW_VIR_DRAMCOM_BASE  + 0x110)
+#define SDR_COM_MDFSTR2			(AW_VIR_DRAMCOM_BASE  + 0x114)
+#define SDR_COM_MDFSGCR			(AW_VIR_DRAMCOM_BASE  + 0x11c)
+#define SDR_PIR					(AW_VIR_DRAMPHY0_BASE +  0x04)
+#define SDR_PGSR				(AW_VIR_DRAMPHY0_BASE +  0x0c)
+#define SDR_DX0DQSTR 			(AW_VIR_DRAMPHY0_BASE + 0x1d4)
+#define SDR_DX1DQSTR 			(AW_VIR_DRAMPHY0_BASE + 0x214)
+#define SDR_DX2DQSTR 			(AW_VIR_DRAMPHY0_BASE + 0x254)
+#define SDR_DX3DQSTR 			(AW_VIR_DRAMPHY0_BASE + 0x294)
+#define SDR_SCTL				(AW_VIR_DRAMCTL0_BASE +  0x04)
+#define SDR_SSTAT				(AW_VIR_DRAMCTL0_BASE +  0x08)
+#define SDR_MCFG				(AW_VIR_DRAMCTL0_BASE +  0x80)
+#define SDR_TOGCNT1U			(AW_VIR_DRAMCTL0_BASE +  0xc0)
+#define SDR_TOGCNT100N			(AW_VIR_DRAMCTL0_BASE +  0xcc)
+
+struct aw_mdfs_info {
+    unsigned int is_dual_channel;
+    unsigned int div;
+    unsigned int table[MDFS_TABLE_LEN][8];
+};
+
+#endif /* __DRAM_FREQ_COMMON_H__ */
diff --git a/arch/arm/mach-sun6i/include/mach/dram-freq.h b/arch/arm/mach-sun6i/include/mach/dram-freq.h
new file mode 100644
index 0000000..dc9e1f7
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/dram-freq.h
@@ -0,0 +1,97 @@
+/*
+ * arch/arm/mach-sun6i/include/mach/dram-freq.h
+ *
+ * Copyright (C) 2012 - 2016 Reuuimlla Limited
+ * Pan Nan <pannan@reuuimllatech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __DRAM_FREQ_H__
+#define __DRAM_FREQ_H__
+
+#include <linux/devfreq.h>
+#include <linux/platform_device.h>
+#include <linux/notifier.h>
+#include <mach/platform.h>
+#include <mach/dram-freq-common.h>
+
+#define SRAM_MDFS_START         (0xf0000000)
+
+#define DRAMFREQ_PRECHANGE	(0)
+#define DRAMFREQ_POSTCHANGE	(1)
+
+#define SUN6I_DRAMFREQ_MAX			(312000000)	/* config the maximum frequency of sun6i dram */
+#define SUN6I_DRAMFREQ_MIN			 (39000000)	/* config the minimum frequency of sun6i dram */
+#define SUN6I_DRAMFREQ_POLLING_MS        (1000)	/* config the polling interval, based on ms   */
+#define SUN6I_DRAMFREQ_TABLE_SIZE          (16) /* mdfs table size */
+#define MASTER_INFO_SIZE                   (28) /* sum of all master */
+
+struct dramfreq_frequency_table {
+	unsigned int frequency; /* kHz */
+	unsigned int dram_div;  /* dram div factor for dram clk */
+};
+
+enum master_type {
+    MASTER_CPUX  = 0,
+    MASTER_GPU0  = 1,
+    MASTER_GPU1  = 2,
+    MASTER_CPUS  = 4,
+    MASTER_ATH   = 5,
+    MASTER_GMAC  = 6,
+    MASTER_SDC0  = 7,
+    MASTER_SDC1  = 8,
+    MASTER_SDC2  = 9,
+    MASTER_SDC3 = 10,
+    MASTER_USB  = 11,
+    MASTER_NFC1 = 15,
+    MASTER_DMAC = 16,
+    MASTER_VE   = 17,
+    MASTER_MP   = 18,
+    MASTER_NFC0 = 19,
+    MASTER_DRC0 = 20,
+    MASTER_DRC1 = 21,
+    MASTER_DEU0 = 22,
+    MASTER_DEU1 = 23,
+    MASTER_BE0  = 24,
+    MASTER_FE0  = 25,
+    MASTER_BE1  = 26,
+    MASTER_FE1  = 27,
+    MASTER_CSI0 = 28,
+    MASTER_CSI1 = 29,
+    MASTER_TS   = 30,
+    MASTER_ALL  = 32,
+    MASTER_MAX  = 33,
+};
+
+struct master_info {
+    enum master_type type;
+    char *name;
+};
+
+struct master_bw_table {
+    enum master_type type;
+    unsigned int bw_need;
+};
+
+struct dramfreq_udata {
+	enum master_type user_type;
+	unsigned long freq_to_user;	/* current dram frequency backup, used to notify user dram DVS is ok or not */
+	unsigned long freq_manual;	/* manual set dram freq, only when dramfreq_auto_scaling=0 valid */
+	unsigned long freq_to_max;	/* set dram frequency to max */
+};
+
+extern struct dramfreq_frequency_table sun6i_dramfreq_tbl[];
+extern struct platform_device sun6i_dramfreq_device;
+extern int dramfreq_user_notify_enable;
+extern int dramfreq_auto_scaling;
+extern struct master_info master_info_list[MASTER_INFO_SIZE];
+
+extern int dramfreq_register_notifier(struct notifier_block *nb);
+extern int dramfreq_unregister_notifier(struct notifier_block *nb);
+extern unsigned long dramfreq_get(void);
+
+#endif /* __DRAM_FREQ_H__ */
diff --git a/arch/arm/mach-sun6i/include/mach/entry-macro.S b/arch/arm/mach-sun6i/include/mach/entry-macro.S
new file mode 100644
index 0000000..8b97288
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/entry-macro.S
@@ -0,0 +1,16 @@
+/*
+ * arch/arm/mach-sun6i/include/mach/entry-macro.S
+ *
+ * Low-level IRQ helper macros for sun6i platforms
+ * Benn Huang (benn@allwinnertech.com)
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
diff --git a/arch/arm/mach-sun6i/include/mach/gpio.h b/arch/arm/mach-sun6i/include/mach/gpio.h
new file mode 100644
index 0000000..595ae43
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/gpio.h
@@ -0,0 +1,197 @@
+/*
+ * arch/arm/mach-sun6i/include/mach/gpio.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sun6i gpio driver header file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SW_GPIO_H
+#define __SW_GPIO_H
+
+#include <linux/types.h>
+
+/* pio/rpio base */
+#define PIO_VBASE(n) 		(0xf1c20800 + ((n) << 5) + ((n) << 2)) /* pio(PA ~ PF), 0xf1c20800 + n * 0x24 */
+#define RPIO_VBASE(n) 		(0xf1f02c00 + ((n) << 5) + ((n) << 2)) /* r-pio(PL ~ PM), 0xf1f02c00 + n * 0x24 */
+
+/* einit config reg vbase */
+#define PIO_VBASE_EINT_PA	(PIO_VBASE(0) + 0x200                 )
+#define PIO_VBASE_EINT_PB	(PIO_VBASE(0) + 0x220                 )
+#define PIO_VBASE_EINT_PE	(PIO_VBASE(0) + 0x240                 )
+#define PIO_VBASE_EINT_PG	(PIO_VBASE(0) + 0x260                 )
+#define PIO_VBASE_EINT_R_PL	(RPIO_VBASE(0) + 0x200                )
+#define PIO_VBASE_EINT_R_PM	(RPIO_VBASE(0) + 0x220                )
+
+/* port number for each pio */
+#define PA_NR			28
+#define PB_NR			8
+#define PC_NR			28
+#define PD_NR			28
+#define PE_NR			17
+#define PF_NR			6
+#define PG_NR			19
+#define PH_NR			31
+/* for R-PORT PIO */
+#define PL_NR			9
+#define PM_NR			8
+#ifdef CONFIG_AW_AXP22
+/* for axp power PIO */
+#define AXP_NR			5
+#endif /* CONFIG_AW_AXP22 */
+
+/*
+ * base index for each pio
+ */
+#define SUN6I_GPIO_SPACE	2 /* for debugging purposes so that failed if request extra gpio_nr */
+#define AW_GPIO_NEXT(gpio)	gpio##_NR_BASE + gpio##_NR + SUN6I_GPIO_SPACE
+enum sun6i_gpio_number {
+	PA_NR_BASE = 0,
+	PB_NR_BASE = AW_GPIO_NEXT(PA),
+	PC_NR_BASE = AW_GPIO_NEXT(PB),
+	PD_NR_BASE = AW_GPIO_NEXT(PC),
+	PE_NR_BASE = AW_GPIO_NEXT(PD),
+	PF_NR_BASE = AW_GPIO_NEXT(PE),
+	PG_NR_BASE = AW_GPIO_NEXT(PF),
+	PH_NR_BASE = AW_GPIO_NEXT(PG),
+
+	/* for R-PORT PIO */
+	PL_NR_BASE = AW_GPIO_NEXT(PH), /* last is PH */
+	PM_NR_BASE = AW_GPIO_NEXT(PL),
+#ifdef CONFIG_AW_AXP22
+	/* for axp power PIO */
+	AXP_NR_BASE = AW_GPIO_NEXT(PM), /* last is PM */
+	GPIO_INDEX_END = AW_GPIO_NEXT(AXP), /* last is AXP */
+#else
+	GPIO_INDEX_END = AW_GPIO_NEXT(PM), /* last is PM */
+#endif /* CONFIG_AW_AXP22 */
+};
+
+/* pio index definition */
+#define GPIOA(n)		(PA_NR_BASE + (n))
+#define GPIOB(n)		(PB_NR_BASE + (n))
+#define GPIOC(n)		(PC_NR_BASE + (n))
+#define GPIOD(n)		(PD_NR_BASE + (n))
+#define GPIOE(n)		(PE_NR_BASE + (n))
+#define GPIOF(n)		(PF_NR_BASE + (n))
+#define GPIOG(n)		(PG_NR_BASE + (n))
+#define GPIOH(n)		(PH_NR_BASE + (n))
+#define GPIOL(n)		(PL_NR_BASE + (n))
+#define GPIOM(n)		(PM_NR_BASE + (n))
+#ifdef CONFIG_AW_AXP22
+/* for axp power PIO */
+#define GPIO_AXP(n)		(AXP_NR_BASE + (n))
+#endif /* CONFIG_AW_AXP22 */
+
+/* pio default macro */
+#define GPIO_PULL_DEFAULT	((u32)-1         )
+#define GPIO_DRVLVL_DEFAULT	((u32)-1         )
+#define GPIO_DATA_DEFAULT	((u32)-1         )
+
+/* pio end, invalid macro */
+#define GPIO_INDEX_INVALID	(0xFFFFFFF0      )
+#define GPIO_CFG_INVALID	(0xEEEEEEEE      )
+#define GPIO_PULL_INVALID	(0xDDDDDDDD      )
+#define GPIO_DRVLVL_INVALID	(0xCCCCCCCC      )
+#define IRQ_NUM_INVALID		(0xFFFFFFFF      )
+#define AXP_PORT_VAL		(0x0000FFFF      ) /* port val for axp pin in sys_config.fex */
+
+/* config value for external int */
+#define GPIO_CFG_EINT   	(0b110	)	/* config value to eint for pa, pb, pe, pg */
+#define R_GPIO_CFG_EINT   	(0b010	)	/* config value to eint for r-pl, r-pm */
+#define GPIO_CFG_INPUT   	(0	)	/* mul sel value for input */
+#define GPIO_CFG_OUTPUT   	(1	)	/* mul sel value for output */
+
+/* port number for gpiolib */
+#ifdef ARCH_NR_GPIOS
+#undef ARCH_NR_GPIOS
+#endif
+#define ARCH_NR_GPIOS		(GPIO_INDEX_END)
+
+/* gpio config info */
+struct gpio_config {
+	u32	gpio;		/* gpio global index, must be unique */
+	u32 	mul_sel;	/* multi sel val: 0 - input, 1 - output... */
+	u32 	pull;		/* pull val: 0 - pull up/down disable, 1 - pull up... */
+	u32 	drv_level;	/* driver level val: 0 - level 0, 1 - level 1... */
+	u32	data;		/* data val: 0 - low, 1 - high, only vaild when mul_sel is input/output */
+};
+
+/* gpio eint trig type */
+enum gpio_eint_trigtype {
+	TRIG_EDGE_POSITIVE = 0,
+	TRIG_EDGE_NEGATIVE,
+	TRIG_LEVL_HIGH,
+	TRIG_LEVL_LOW,
+	TRIG_EDGE_DOUBLE,	/* positive/negative */
+	TRIG_INALID
+};
+
+/* gpio eint debounce para */
+struct gpio_eint_debounce {
+	u32   clk_sel;		/* pio interrupt clock select, 0-LOSC, 1-HOSC */
+	u32   clk_pre_scl;	/* debounce clk pre-scale n, the select,
+				 * clock source is pre-scale by 2^n.
+				 */
+};
+
+/* gpio external config info */
+struct gpio_config_eint_all {
+	u32	gpio;		/* the global gpio index */
+	u32	pull;		/* gpio pull val */
+	u32 	drvlvl;		/* gpio driver level */
+	u32	enabled;	/* in set function: used to enable/disable the eint, 1: enable, 0: disable
+				 * in get function: return the eint enabled status, 1: enabled, 0: disabled
+				 */
+	u32	irq_pd;		/* in set function: 1 means to clr irq pend status, 0 no use
+				 * in get function: return the actual irq pend stauts, eg, 1 means irq occur.
+				 */
+	enum gpio_eint_trigtype trig_type; /* trig type of the gpio */
+};
+
+/* gpio eint call back function */
+typedef u32 (*peint_handle)(void *para);
+
+/*
+ * exported api below
+ */
+
+/* new api */
+
+/* api for multi function */
+u32 sw_gpio_setcfg(u32 gpio, u32 val);
+u32 sw_gpio_getcfg(u32 gpio);
+u32 sw_gpio_setpull(u32 gpio, u32 val);
+u32 sw_gpio_getpull(u32 gpio);
+u32 sw_gpio_setdrvlevel(u32 gpio, u32 val);
+u32 sw_gpio_getdrvlevel(u32 gpio);
+u32 sw_gpio_setall_range(struct gpio_config *pcfg, u32 cfg_num);
+u32 sw_gpio_getall_range(struct gpio_config *pcfg, u32 cfg_num);
+void sw_gpio_dump_config(struct gpio_config *pcfg, u32 cfg_num);
+u32 sw_gpio_suspend(void);
+u32 sw_gpio_resume(void);
+
+/* api for external int */
+u32 sw_gpio_irq_request(u32 gpio, enum gpio_eint_trigtype trig_type,
+			peint_handle handle, void *para);
+void sw_gpio_irq_free(u32 handle);
+u32 sw_gpio_eint_set_trigtype(u32 gpio, enum gpio_eint_trigtype trig_type);
+u32 sw_gpio_eint_get_trigtype(u32 gpio, enum gpio_eint_trigtype *pval);
+u32 sw_gpio_eint_get_enable(u32 gpio, u32 *penable);
+u32 sw_gpio_eint_set_enable(u32 gpio, u32 enable);
+u32 sw_gpio_eint_get_irqpd_sta(u32 gpio);
+u32 sw_gpio_eint_clr_irqpd_sta(u32 gpio);
+u32 sw_gpio_eint_get_debounce(u32 gpio, struct gpio_eint_debounce *pdbc);
+u32 sw_gpio_eint_set_debounce(u32 gpio, struct gpio_eint_debounce dbc);
+u32 sw_gpio_eint_setall_range(struct gpio_config_eint_all *pcfg, u32 cfg_num);
+u32 sw_gpio_eint_getall_range(struct gpio_config_eint_all *pcfg, u32 cfg_num);
+void sw_gpio_eint_dumpall_range(struct gpio_config_eint_all *pcfg, u32 cfg_num);
+
+#endif /* __SW_GPIO_H */
diff --git a/arch/arm/mach-sun6i/include/mach/hardware.h b/arch/arm/mach-sun6i/include/mach/hardware.h
new file mode 100644
index 0000000..c47541b
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/hardware.h
@@ -0,0 +1,31 @@
+/*
+ *  arch/arm/mach-sun6i/include/mach/hardware.h
+ *
+ *  This file contains the hardware definitions of the RealView boards.
+ *
+ *  Copyright (C) 2012-2016 Allwinner Limited.
+ *  Benn Huang (benn@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+
+#define IO_ADDRESS(x)		((x) + 0xf0000000)
+#define __io_address(n)		__io(IO_ADDRESS(n))
+
+#endif
diff --git a/arch/arm/mach-sun6i/include/mach/hwmsgbox.h b/arch/arm/mach-sun6i/include/mach/hwmsgbox.h
new file mode 100644
index 0000000..b8c24f8
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/hwmsgbox.h
@@ -0,0 +1,44 @@
+/*
+ *  arch/arm/mach-sun6i/include/mach/hwmsgbox.h
+ *
+ * Copyright 2012 (c) Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__ASM_ARCH_HWMSGBOX_H
+#define	__ASM_ARCH_HWMSGBOX_H
+
+//the number of hardware message queue.
+#define AW_HWMSG_QUEUE_NUMBER	(8)
+
+//the user of hardware message queue.
+typedef enum aw_hwmsg_queue_user
+{
+	AW_HWMSG_QUEUE_USER_AR100,	//cpu0
+	AW_HWMSG_QUEUE_USER_AC327,	//cpu1
+} aw_hwmsg_queue_user_e;
+
+//hardware message-box register list
+#define	AW_MSGBOX_CTRL_REG(m)			(AW_MSGBOX_BASE + 0x0000 + (0x4 * (m>>2)))
+#define AW_MSGBOX_IRQ_EN_REG(u)			(AW_MSGBOX_BASE + 0x0040 + (0x20* u))
+#define	AW_MSGBOX_IRQ_STATUS_REG(u)		(AW_MSGBOX_BASE + 0x0050 + (0x20* u))
+#define AW_MSGBOX_FIFO_STATUS_REG(m)	(AW_MSGBOX_BASE + 0x0100 + (0x4 * m))
+#define AW_MSGBOX_MSG_STATUS_REG(m)		(AW_MSGBOX_BASE + 0x0140 + (0x4 * m))
+#define AW_MSGBOX_MSG_REG(m)			(AW_MSGBOX_BASE + 0x0180 + (0x4 * m))
+#define AW_MSGBOX_DEBUG_REG				(AW_MSGBOX_BASE + 0x01c0)
+
+#endif	//__ASM_ARCH_HWMSGBOX_H
diff --git a/arch/arm/mach-sun6i/include/mach/hwspinlock.h b/arch/arm/mach-sun6i/include/mach/hwspinlock.h
new file mode 100644
index 0000000..9e5331c
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/hwspinlock.h
@@ -0,0 +1,36 @@
+/*
+ *  arch/arm/mach-sun6i/include/mach/hwspinlock.h
+ *
+ * Copyright 2012 (c) Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__ASM_ARCH_HWSPINLOCK_H
+#define	__ASM_ARCH_HWSPINLOCK_H
+
+//the taken ot not state of spinlock
+#define	AW_SPINLOCK_NOTTAKEN	(0)
+#define	AW_SPINLOCK_TAKEN		(1)
+
+//hardware spinlock register list
+#define	AW_SPINLOCK_SYS_STATUS_REG		(AW_SPINLOCK_BASE + 0x0000)
+#define	AW_SPINLOCK_STATUS_REG			(AW_SPINLOCK_BASE + 0x0010)
+#define	AW_SPINLOCK_IRQ_EN_REG			(AW_SPINLOCK_BASE + 0x0020)
+#define AW_SPINLOCK_IRQ_PEND_REG		(AW_SPINLOCK_BASE + 0x0040)
+#define AW_SPINLOCK_LOCK_REG(id)		(AW_SPINLOCK_BASE + 0x0100 + id * 4)
+
+#endif	//__ASM_ARCH_HWSPINLOCK_H
diff --git a/arch/arm/mach-sun6i/include/mach/i2c.h b/arch/arm/mach-sun6i/include/mach/i2c.h
new file mode 100644
index 0000000..f031e7c
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/i2c.h
@@ -0,0 +1,201 @@
+/*
+ * arch/arm/mach-sun6i/include/mach/i2c.h
+ *
+ * Copyright (C) 2012 - 2016 Reuuimlla Limited
+ * Pan Nan <pannan@reuuimllatech.com>
+ *
+ * SUN6I TWI Register Definition
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+#include <mach/platform.h>
+
+#ifndef _SUN6I_I2C_H_
+#define _SUN6I_I2C_H_
+
+#define TWI_MODULE_NUM    (5)
+
+/* TWI Register Offset */
+#define TWI_ADDR_REG    	(0x00) 	/*  31:8bit reserved,7-1bit for slave addr,0 bit for GCE */
+#define TWI_XADDR_REG   	(0x04) 	/*  31:8bit reserved,7-0bit for second addr in 10bit addr */
+#define TWI_DATA_REG    	(0x08) 	/*  31:8bit reserved, 7-0bit send or receive data byte */
+#define TWI_CTL_REG     	(0x0C) 	/*  INT_EN,BUS_EN,M_STA,INT_FLAG,A_ACK */
+#define TWI_STAT_REG    	(0x10) 	/*  28 interrupt types + 0xF8 normal type = 29  */
+#define TWI_CLK_REG     	(0x14) 	/*  31:7bit reserved,6-3bit,CLK_M,2-0bit CLK_N */
+#define TWI_SRST_REG    	(0x18) 	/*  31:1bit reserved;0bit,write 1 to clear 0. */
+#define TWI_EFR_REG     	(0x1C) 	/*  31:2bit reserved,1:0 bit data byte follow read comand */
+#define TWI_LCR_REG     	(0x20) 	/*  31:6bits reserved  5:0bit for sda&scl control*/
+#define TWI_DVFS_REG        (0x24)  /*  31:3bits reserved  2:0bit for dvfs control */
+
+/* TWI address register */
+#define TWI_GCE_EN      	(0x1 <<0) /* general call address enable for slave mode */
+#define TWI_ADDR_MASK   	(0x7f<<1) /* 7:1bits */
+/* 31:8bits reserved */
+
+
+/* TWI extend address register */
+#define TWI_XADDR_MASK  (0xff) /* 7:0bits for extend slave address */
+/* 31:8bits reserved */
+
+
+/* TWI Data register default is 0x0000_0000 */
+#define TWI_DATA_MASK   (0xff) /* 7:0bits for send or received */
+
+/* TWI Control Register Bit Fields & Masks, default value: 0x0000_0000*/
+/* 1:0 bits reserved */
+#define TWI_CTL_ACK		(0x1<<2) /* set 1 to send A_ACK,then low level on SDA */
+#define TWI_CTL_INTFLG	(0x1<<3) /* INT_FLAG,interrupt status flag: set '1' when interrupt coming */
+#define TWI_CTL_STP		(0x1<<4) /* M_STP,Automatic clear 0 */
+#define TWI_CTL_STA		(0x1<<5) /* M_STA,atutomatic clear 0 */
+#define TWI_CTL_BUSEN	(0x1<<6) /* BUS_EN, master mode should be set 1.*/
+#define TWI_CTL_INTEN	(0x1<<7) /* INT_EN */
+/* 31:8 bit reserved */
+
+
+/* TWI Clock Register Bit Fields & Masks,default value:0x0000_0000 */
+/*
+Fin is APB CLOCK INPUT;
+Fsample = F0 = Fin/2^CLK_N;
+          F1 = F0/(CLK_M+1);
+
+Foscl = F1/10 = Fin/(2^CLK_N * (CLK_M+1)*10);
+Foscl is clock SCL;standard mode:100KHz or fast mode:400KHz
+*/
+#define TWI_CLK_DIV_M		(0xF<<3) /* 6:3bit  */
+#define TWI_CLK_DIV_N		(0x7<<0) /* 2:0bit */
+
+
+/* TWI Soft Reset Register Bit Fields & Masks  */
+#define TWI_SRST_SRST		(0x1<<0) /* write 1 to clear 0, when complete soft reset clear 0 */
+
+
+/* TWI Enhance Feature Register Bit Fields & Masks  */
+/* default -- 0x0 */
+#define TWI_EFR_MASK        (0x3<<0)/* 00:no,01: 1byte, 10:2 bytes, 11: 3bytes */
+#define TWI_EFR_WARC_0      (0x0<<0)
+#define TWI_EFR_WARC_1      (0x1<<0)
+#define TWI_EFR_WARC_2      (0x2<<0)
+#define TWI_EFR_WARC_3      (0x3<<0)
+
+
+/* twi line control register -default value: 0x0000_003a */
+#define TWI_LCR_SDA_EN          (0x01<<0) 	/* SDA line state control enable ,1:enable;0:disable */
+#define TWI_LCR_SDA_CTL         (0x01<<1) 	/* SDA line state control bit, 1:high level;0:low level */
+#define TWI_LCR_SCL_EN          (0x01<<2) 	/* SCL line state control enable ,1:enable;0:disable */
+#define TWI_LCR_SCL_CTL         (0x01<<3) 	/* SCL line state control bit, 1:high level;0:low level */
+#define TWI_LCR_SDA_STATE_MASK  (0x01<<4)   /* current state of SDA,readonly bit */
+#define TWI_LCR_SCL_STATE_MASK  (0x01<<5)   /* current state of SCL,readonly bit */
+/* 31:6bits reserved */
+#define TWI_LCR_IDLE_STATUS     (0x3a)
+
+
+/* TWI Status Register Bit Fields & Masks  */
+#define TWI_STAT_MASK                   (0xff)
+/* 7:0 bits use only,default is 0xF8 */
+#define TWI_STAT_BUS_ERR				(0x00) 	/* BUS ERROR */
+/* Master mode use only */
+#define TWI_STAT_TX_STA					(0x08) 	/* START condition transmitted */
+#define TWI_STAT_TX_RESTA				(0x10) 	/* Repeated START condition transmitted */
+#define TWI_STAT_TX_AW_ACK				(0x18) 	/* Address+Write bit transmitted, ACK received */
+#define TWI_STAT_TX_AW_NAK				(0x20) 	/* Address+Write bit transmitted, ACK not received */
+#define TWI_STAT_TXD_ACK				(0x28) 	/* data byte transmitted in master mode,ack received */
+#define TWI_STAT_TXD_NAK				(0x30) 	/* data byte transmitted in master mode ,ack not received */
+#define TWI_STAT_ARBLOST				(0x38) 	/* arbitration lost in address or data byte */
+#define TWI_STAT_TX_AR_ACK				(0x40) 	/* Address+Read bit transmitted, ACK received */
+#define TWI_STAT_TX_AR_NAK				(0x48) 	/* Address+Read bit transmitted, ACK not received */
+#define TWI_STAT_RXD_ACK				(0x50) 	/* data byte received in master mode ,ack transmitted */
+#define TWI_STAT_RXD_NAK				(0x58) 	/* date byte received in master mode,not ack transmitted */
+/* Slave mode use only */
+#define TWI_STAT_RXWS_ACK				(0x60) 	/* Slave address+Write bit received, ACK transmitted */
+#define TWI_STAT_ARBLOST_RXWS_ACK		(0x68)
+#define TWI_STAT_RXGCAS_ACK				(0x70) 	/* General Call address received, ACK transmitted */
+#define TWI_STAT_ARBLOST_RXGCAS_ACK		(0x78)
+#define TWI_STAT_RXDS_ACK				(0x80)
+#define TWI_STAT_RXDS_NAK				(0x88)
+#define TWI_STAT_RXDGCAS_ACK			(0x90)
+#define TWI_STAT_RXDGCAS_NAK			(0x98)
+#define TWI_STAT_RXSTPS_RXRESTAS		(0xA0)
+#define TWI_STAT_RXRS_ACK				(0xA8)
+
+#define TWI_STAT_ARBLOST_SLAR_ACK       (0xB0)
+
+/* 10bit Address, second part of address */
+#define TWI_STAT_TX_SAW_ACK             (0xD0) 	/* Second Address byte+Write bit transmitted,ACK received */
+#define TWI_STAT_TX_SAW_NAK             (0xD8) 	/* Second Address byte+Write bit transmitted,ACK not received */
+
+#define TWI_STAT_IDLE					(0xF8) 	/* No relevant status infomation,INT_FLAG = 0 */
+
+
+/* status or interrupt source */
+/*------------------------------------------------------------------------------
+* Code   Status
+* 00h    Bus error
+* 08h    START condition transmitted
+* 10h    Repeated START condition transmitted
+* 18h    Address + Write bit transmitted, ACK received
+* 20h    Address + Write bit transmitted, ACK not received
+* 28h    Data byte transmitted in master mode, ACK received
+* 30h    Data byte transmitted in master mode, ACK not received
+* 38h    Arbitration lost in address or data byte
+* 40h    Address + Read bit transmitted, ACK received
+* 48h    Address + Read bit transmitted, ACK not received
+* 50h    Data byte received in master mode, ACK transmitted
+* 58h    Data byte received in master mode, not ACK transmitted
+* 60h    Slave address + Write bit received, ACK transmitted
+* 68h    Arbitration lost in address as master, slave address + Write bit received, ACK transmitted
+* 70h    General Call address received, ACK transmitted
+* 78h    Arbitration lost in address as master, General Call address received, ACK transmitted
+* 80h    Data byte received after slave address received, ACK transmitted
+* 88h    Data byte received after slave address received, not ACK transmitted
+* 90h    Data byte received after General Call received, ACK transmitted
+* 98h    Data byte received after General Call received, not ACK transmitted
+* A0h    STOP or repeated START condition received in slave mode
+* A8h    Slave address + Read bit received, ACK transmitted
+* B0h    Arbitration lost in address as master, slave address + Read bit received, ACK transmitted
+* B8h    Data byte transmitted in slave mode, ACK received
+* C0h    Data byte transmitted in slave mode, ACK not received
+* C8h    Last byte transmitted in slave mode, ACK received
+* D0h    Second Address byte + Write bit transmitted, ACK received
+* D8h    Second Address byte + Write bit transmitted, ACK not received
+* F8h    No relevant status information or no interrupt
+*-----------------------------------------------------------------------------*/
+
+/* TWI mode select */
+#define TWI_MASTER_MODE     (1)
+#define TWI_SLAVE_MODE      (0)	/* seldom use */
+
+#define SUN6I_TWI_ADDR_SIZE		0x3FF
+
+#define TWI0_BASE_ADDR_START  (AW_TWI0_BASE)
+#define TWI0_BASE_ADDR_END    (TWI0_BASE_ADDR_START + SUN6I_TWI_ADDR_SIZE)
+#define TWI1_BASE_ADDR_START  (AW_TWI1_BASE)
+#define TWI1_BASE_ADDR_END    (TWI1_BASE_ADDR_START + SUN6I_TWI_ADDR_SIZE)
+#define TWI2_BASE_ADDR_START  (AW_TWI2_BASE)
+#define TWI2_BASE_ADDR_END    (TWI2_BASE_ADDR_START + SUN6I_TWI_ADDR_SIZE)
+#define TWI3_BASE_ADDR_START  (AW_TWI3_BASE)
+#define TWI3_BASE_ADDR_END    (TWI3_BASE_ADDR_START + SUN6I_TWI_ADDR_SIZE)
+
+#undef SUN6I_RTWI
+#ifdef SUN6I_RTWI
+#define RTWI_BASE_ADDR_START  (AW_R_TWI_BASE)
+#define RTWI_BASE_ADDR_END    (RTWI_BASE_ADDR_START + SUN6I_TWI_ADDR_SIZE)
+#endif
+
+#define TWI0_TRANSFER_SPEED     (200000)
+#define TWI1_TRANSFER_SPEED     (400000)
+#define TWI2_TRANSFER_SPEED     (200000)
+#define TWI3_TRANSFER_SPEED     (200000)
+
+#ifdef SUN6I_RTWI
+#define RTWI_TRANSFER_SPEED     (100000)
+#endif
+
+struct sun6i_i2c_platform_data {
+	int 		 bus_num;
+	unsigned int frequency;
+};
+
+#endif
diff --git a/arch/arm/mach-sun6i/include/mach/io.h b/arch/arm/mach-sun6i/include/mach/io.h
new file mode 100644
index 0000000..272efc5
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/io.h
@@ -0,0 +1,29 @@
+/*
+ *  arch/arm/mach-sun6i/include/mach/io.h
+ *
+ *  Copyright (C) 2012-2016 Allwinner Limited
+ *  Benn Huang (benn@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+#define __io(a)		__typesafe_io(a)
+#define __mem_pci(a)	(a)
+
+#endif
diff --git a/arch/arm/mach-sun6i/include/mach/irqs-sun6i.h b/arch/arm/mach-sun6i/include/mach/irqs-sun6i.h
new file mode 100644
index 0000000..6ba9851
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/irqs-sun6i.h
@@ -0,0 +1,391 @@
+/*
+ * arch/arm/mach-sun6i/include/mach/irqs-sun6i.h
+ *
+ *  Copyright (C) 2012-2016 Allwinner Limited
+ *  Benn Huang (benn@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __MACH_IRQS_AW_H
+#define __MACH_IRQS_AW_H
+
+#define AW_IRQ_GIC_START        32
+
+/*
+ * AW on-board gic irq sources
+ */
+/* the define support AW_FPGA_V4_PLATFORM AW_FPGA_V7_PLATFORM AW_ASIC_PLATFORM
+ *	you must choose one define to compile
+ * */
+#if defined (CONFIG_AW_FPGA_V4_PLATFORM) /* S4 820 */
+
+#define AW_IRQ_UART0		(AW_IRQ_GIC_START + 1)				/*	UART0		*/
+#define AW_IRQ_UART1		(AW_IRQ_GIC_START + 1)				/*	UART1		*/
+#define AW_IRQ_UART2		(AW_IRQ_GIC_START + 2 + 200)		/*	UART2		*/
+#define AW_IRQ_UART3		(AW_IRQ_GIC_START + 3 + 200)		/*	UART3		*/
+#define AW_IRQ_UART4		(AW_IRQ_GIC_START + 4 + 200)		/*	UART3		*/
+#define AW_IRQ_UART5		(AW_IRQ_GIC_START + 5 + 200)		/*	UART3		*/
+#define AW_IRQ_TWI0			(AW_IRQ_GIC_START + 2)				/*	TWI0		*/
+#define AW_IRQ_TWI1			(AW_IRQ_GIC_START + 2)				/*	TWI1		*/
+#define AW_IRQ_TWI2			(AW_IRQ_GIC_START + 8 + 200)		/*	TWI0		*/
+#define AW_IRQ_TWI3			(AW_IRQ_GIC_START + 9 + 200)		/*	TWI1		*/
+#define AW_IRQ_EINTA		(AW_IRQ_GIC_START + 2)				/*	EINTA		*/
+#define AW_IRQ_SPDIF		(AW_IRQ_GIC_START + 3)				/*	SPDIF		*/
+#define AW_IRQ_DAUDIO0		(AW_IRQ_GIC_START + 13 + 200)		/*	DAUDIO0		*/
+#define AW_IRQ_DAUDIO1      (AW_IRQ_GIC_START + 14 + 200)		/*  DAUDIO1     */
+#define AW_IRQ_EINTB        (AW_IRQ_GIC_START + 15 + 200)		/*  EINTB       */
+#define AW_IRQ_EINTE        (AW_IRQ_GIC_START + 16 + 200)		/*  EINTE       */
+#define AW_IRQ_EINTG        (AW_IRQ_GIC_START + 17 + 200)		/*  EINTG       */
+#define AW_IRQ_TIMER0		(AW_IRQ_GIC_START + 4)				/*	Timer0		*/
+#define AW_IRQ_TIMER1		(AW_IRQ_GIC_START + 5)				/*	Timer1		*/
+#define AW_IRQ_TIMER2		(AW_IRQ_GIC_START + 5)				/*	Timer2		*/
+#define AW_IRQ_TIMER3       (AW_IRQ_GIC_START + 5)     			/*  Timer3      */
+#define AW_IRQ_TIMER4       (AW_IRQ_GIC_START + 5)     			/*  Timer4      */
+#define AW_IRQ_TIMER5       (AW_IRQ_GIC_START + 5)     			/*  Timer5      */
+#define	AW_IRQ_WATCHDOG4	(AW_IRQ_GIC_START + 24 + 200)		/*	WATCHDOG4	*/
+#define	AW_IRQ_WATCHDOG1	(AW_IRQ_GIC_START + 7)				/*	WATCHDOG1	*/
+#define	AW_IRQ_WATCHDOG2	(AW_IRQ_GIC_START + 8)				/*	WATCHDOG2	*/
+#define	AW_IRQ_WATCHDOG3	(AW_IRQ_GIC_START + 27 + 200)		/*	WATCHDOG3	*/
+#define	AW_IRQ_TP			(AW_IRQ_GIC_START + 24)				/*	TOUCH PANEL	*/
+#define AW_IRQ_CODEC		(AW_IRQ_GIC_START +	24)				/*	AUDIO CEDEC	*/
+#define AW_IRQ_LRADC		(AW_IRQ_GIC_START + 24)				/*	LRADC		*/
+#define AW_IRQ_MTCACC		(AW_IRQ_GIC_START + 24)				/*	MTCACC		*/
+#define AW_IRQ_NMI			(AW_IRQ_GIC_START + 0)				/*	NMI			*/
+#define AW_IRQ_RTIMER0		(AW_IRQ_GIC_START + 9)				/*	R_TIMER 0	*/
+#define AW_IRQ_RTIMER1		(AW_IRQ_GIC_START + 9)				/*	R_TIMER 1	*/
+#define AW_IRQ_RWATCHDOG	(AW_IRQ_GIC_START + 9)				/*	R_WATCHDO	*/
+#define AW_IRQ_RCIR			(AW_IRQ_GIC_START + 16)				/*  R_CIR		*/
+#define	AW_IRQ_RUART		(AW_IRQ_GIC_START + 16)				/*	R_UART		*/
+#define AW_IRQ_RP2TWI		(AW_IRQ_GIC_START + 19)				/*	R_P2TWI		*/
+#define	AW_IRQ_RALARM0		(AW_IRQ_GIC_START + 18)				/*	R_RLARM 0	*/
+#define	AW_IRQ_RALARM1		(AW_IRQ_GIC_START + 18)				/*	R_RLARM 1	*/
+#define AW_IRQ_R_1WIRE		(AW_IRQ_GIC_START + 31)				/*	R_ONE_WIRE	*/
+#define	AW_IRQ_RTWI			(AW_IRQ_GIC_START + 19)				/*	R_TWI		*/
+#define AW_IRQ_EINTL		(AW_IRQ_GIC_START + 17)				/*	R_EINTL		*/
+#define AW_IRQ_EINTM		(AW_IRQ_GIC_START + 17)				/*	R_EINTM		*/
+#define	AW_IRQ_SPINLOCK		(AW_IRQ_GIC_START + 10)				/*	SPINLOCK	*/
+#define	AW_IRQ_MBOX			(AW_IRQ_GIC_START + 11)				/*	M-BOX		*/
+#define	AW_IRQ_DMA			(AW_IRQ_GIC_START + 6)				/*	DMA			*/
+#define AW_IRQ_HSTIMER0		(AW_IRQ_GIC_START + 12)				/*	HSTIMER0	*/
+#define AW_IRQ_HSTIMER1		(AW_IRQ_GIC_START + 52 + 200)		/*	HSTIMER1	*/
+#define AW_IRQ_HSTIMER2		(AW_IRQ_GIC_START + 53 + 200)		/*	HSTIMER2	*/
+#define AW_IRQ_HSTIMER3		(AW_IRQ_GIC_START + 54 + 200)		/*	HSTIMER3	*/
+#define	AW_IRQ_TZASC		(AW_IRQ_GIC_START + 26)				/*	TZASC		*/
+#define	AW_IRQ_VE			(AW_IRQ_GIC_START + 20)				/*	VE			*/
+#define	AW_IRQ_DIGMIC		(AW_IRQ_GIC_START + 59 + 200)		/*	DIG_MIC		*/
+#define AW_IRQ_MMC0			(AW_IRQ_GIC_START + 13)				/*	MMC0		*/
+#define AW_IRQ_MMC1			(AW_IRQ_GIC_START + 13)				/*	MMC1		*/
+#define AW_IRQ_MMC2			(AW_IRQ_GIC_START + 15)				/*	MMC2		*/
+#define AW_IRQ_MMC3			(AW_IRQ_GIC_START + 15)				/*	MMC3		*/
+#define AW_IRQ_SPI0			(AW_IRQ_GIC_START + 13)				/*	SPI0		*/
+#define AW_IRQ_SPI1			(AW_IRQ_GIC_START + 66 + 200)		/*	SPI1		*/
+#define AW_IRQ_SPI2			(AW_IRQ_GIC_START + 67 + 200)		/*	SPI2		*/
+#define AW_IRQ_SPI3			(AW_IRQ_GIC_START + 68 + 200)		/*	SPI3		*/
+#define AW_IRQ_NAND1		(AW_IRQ_GIC_START + 15)				/*	NAND1		*/
+#define AW_IRQ_NAND0		(AW_IRQ_GIC_START + 14)				/*	NAND0		*/
+#define AW_IRQ_USB_OTG		(AW_IRQ_GIC_START + 21)				/*	USB_OTG		*/
+#define AW_IRQ_USB_OHCI2	(AW_IRQ_GIC_START + 21)				/*	USB_HCI	have no define in ic spec	*/
+#define AW_IRQ_USB_EHCI0	(AW_IRQ_GIC_START + 22)				/*	USB_EHCI0	*/
+#define AW_IRQ_USB_OHCI0	(AW_IRQ_GIC_START + 23)				/*	USB_OHCI0	*/
+#define AW_IRQ_USB_EHCI1	(AW_IRQ_GIC_START + 74 + 200)		/*	USB_EHCI1	*/
+#define AW_IRQ_USB_OHCI1	(AW_IRQ_GIC_START + 75 + 200)		/*	USB_OHCI1	*/
+#define AW_IRQ_SS			(AW_IRQ_GIC_START + 24)				/*	SS			*/
+#define AW_IRQ_TS			(AW_IRQ_GIC_START + 24)				/*	TS			*/
+#define AW_IRQ_GMAC			(AW_IRQ_GIC_START + 24)				/*	GMAC		*/
+#define AW_IRQ_MP			(AW_IRQ_GIC_START + 3)				/*	MP			*/
+#define AW_IRQ_CSI0			(AW_IRQ_GIC_START + 3)				/*	CSI0		*/
+#define AW_IRQ_CSI1			(AW_IRQ_GIC_START + 3)				/*	CSI1		*/
+#define AW_IRQ_LCD0			(AW_IRQ_GIC_START + 25)				/*	LCD0		*/
+#define AW_IRQ_LCD1			(AW_IRQ_GIC_START + 87 + 200)		/*	LCD1		*/
+#define AW_IRQ_HDMI			(AW_IRQ_GIC_START + 88 + 200)		/*	HDMI		*/
+#define AW_IRQ_MIPIDSI		(AW_IRQ_GIC_START + 3)				/*	MIPI DSI	*/
+#define AW_IRQ_MIPICSI		(AW_IRQ_GIC_START + 3)				/*	MIPI CSI	*/
+#define AW_IRQ_DRC01		(AW_IRQ_GIC_START + 29)				/*	DRC 0/1		*/
+#define AW_IRQ_DEU01		(AW_IRQ_GIC_START + 30)				/*	DEU	0/1		*/
+#define AW_IRQ_DEFE0		(AW_IRQ_GIC_START + 27)				/*	DE_FE0		*/
+#define AW_IRQ_DEFE1		(AW_IRQ_GIC_START + 94 + 200)		/*	DE_FE1		*/
+#define AW_IRQ_DEBE0		(AW_IRQ_GIC_START + 28)				/*	DE_BE0		*/
+#define AW_IRQ_DEBE1		(AW_IRQ_GIC_START + 96 + 200)		/*	DE_BE1		*/
+#define	AW_IRQ_GPU			(AW_IRQ_GIC_START + 97 + 200)		/*	GPU			*/
+#define	AW_IRQ_CTI0			(AW_IRQ_GIC_START + 108 + 200)		/*	CTI0		*/
+#define	AW_IRQ_CTI1			(AW_IRQ_GIC_START + 109 + 200)		/*	CTI1		*/
+#define	AW_IRQ_CTI2			(AW_IRQ_GIC_START + 110 + 200)		/*	CTI2		*/
+#define	AW_IRQ_CTI3			(AW_IRQ_GIC_START + 111 + 200)		/*	CTI3		*/
+#define AW_IRQ_COMMTX0		(AW_IRQ_GIC_START + 112 + 200)		/*	COMMTX0		*/
+#define AW_IRQ_COMMTX1		(AW_IRQ_GIC_START + 113 + 200)		/*	COMMTX1		*/
+#define AW_IRQ_COMMTX2		(AW_IRQ_GIC_START + 114 + 200)		/*	COMMTX2		*/
+#define AW_IRQ_COMMTX3		(AW_IRQ_GIC_START + 115 + 200)		/*	COMMTX3		*/
+#define AW_IRQ_COMMRX0		(AW_IRQ_GIC_START + 116 + 200)		/*	COMMRX0		*/
+#define AW_IRQ_COMMRX1		(AW_IRQ_GIC_START + 117 + 200)		/*	COMMRX1		*/
+#define AW_IRQ_COMMRX2		(AW_IRQ_GIC_START + 118 + 200)		/*	COMMRX2		*/
+#define AW_IRQ_COMMRX3		(AW_IRQ_GIC_START + 119 + 200)		/*	COMMRX3		*/
+#define	AW_IRQ_PMU0			(AW_IRQ_GIC_START + 120 + 200)		/*	PMU0		*/
+#define	AW_IRQ_PMU1			(AW_IRQ_GIC_START + 121 + 200)		/*	PMU1		*/
+#define	AW_IRQ_PMU2			(AW_IRQ_GIC_START + 122 + 200)		/*	PMU2		*/
+#define	AW_IRQ_PMU3			(AW_IRQ_GIC_START + 123 + 200)		/*	PMU3		*/
+#define	AW_IRQ_AXI_ERROR	(AW_IRQ_GIC_START + 124 + 200)		/*	AXI_ERROR	*/
+
+#elif defined (CONFIG_AW_FPGA_V7_PLATFORM)
+
+#define AW_IRQ_UART0		(AW_IRQ_GIC_START + 1)				/*	UART0		*/
+#define AW_IRQ_UART1		(AW_IRQ_GIC_START + 1)				/*	UART1		*/
+#define AW_IRQ_UART2		(AW_IRQ_GIC_START + 2 + 200)		/*	UART2		*/
+#define AW_IRQ_UART3		(AW_IRQ_GIC_START + 3 + 200)		/*	UART3		*/
+#define AW_IRQ_UART4		(AW_IRQ_GIC_START + 4 + 200)		/*	UART3		*/
+#define AW_IRQ_UART5		(AW_IRQ_GIC_START + 5 + 200)		/*	UART3		*/
+#define AW_IRQ_TWI0			(AW_IRQ_GIC_START + 2)				/*	TWI0		*/
+#define AW_IRQ_TWI1			(AW_IRQ_GIC_START + 2)				/*	TWI1		*/
+#define AW_IRQ_TWI2			(AW_IRQ_GIC_START + 8 + 200)		/*	TWI0		*/
+#define AW_IRQ_TWI3			(AW_IRQ_GIC_START + 9 + 200)		/*	TWI1		*/
+#define AW_IRQ_EINTA		(AW_IRQ_GIC_START + 200)			/*	EINTA		*/
+#define AW_IRQ_SPDIF		(AW_IRQ_GIC_START + 3)				/*	SPDIF		*/
+#define AW_IRQ_DAUDIO0		(AW_IRQ_GIC_START + 13 + 200)		/*	DAUDIO0		*/
+#define AW_IRQ_DAUDIO1      (AW_IRQ_GIC_START + 14 + 200)		/*  DAUDIO1     */
+#define AW_IRQ_EINTB        (AW_IRQ_GIC_START + 15 + 200)		/*  EINTB       */
+#define AW_IRQ_EINTE        (AW_IRQ_GIC_START + 16 + 200)		/*  EINTE       */
+#define AW_IRQ_EINTG        (AW_IRQ_GIC_START + 17 + 200)		/*  EINTG       */
+#define AW_IRQ_TIMER0		(AW_IRQ_GIC_START + 4)				/*	Timer0		*/
+#define AW_IRQ_TIMER1		(AW_IRQ_GIC_START + 5)				/*	Timer1		*/
+#define AW_IRQ_TIMER2		(AW_IRQ_GIC_START + 200)			/*	Timer2		*/
+#define AW_IRQ_TIMER3       (AW_IRQ_GIC_START + 200)     		/*  Timer3      */
+#define AW_IRQ_TIMER4       (AW_IRQ_GIC_START + 200)     		/*  Timer4      */
+#define AW_IRQ_TIMER5       (AW_IRQ_GIC_START + 200)     		/*  Timer5      */
+#define	AW_IRQ_WATCHDOG4	(AW_IRQ_GIC_START + 24 + 200)		/*	WATCHDOG4	*/
+#define	AW_IRQ_WATCHDOG1	(AW_IRQ_GIC_START + 7)				/*	WATCHDOG1	*/
+#define	AW_IRQ_WATCHDOG2	(AW_IRQ_GIC_START + 8)				/*	WATCHDOG2	*/
+#define	AW_IRQ_WATCHDOG3	(AW_IRQ_GIC_START + 27 + 200)		/*	WATCHDOG3	*/
+#define	AW_IRQ_TP			(AW_IRQ_GIC_START + 24)				/*	TOUCH PANEL	*/
+#define AW_IRQ_CODEC		(AW_IRQ_GIC_START +	24)				/*	AUDIO CEDEC	*/
+#define AW_IRQ_LRADC		(AW_IRQ_GIC_START + 200)			/*	LRADC		*/
+#define AW_IRQ_MTCACC		(AW_IRQ_GIC_START + 200)			/*	MTCACC		*/
+#define AW_IRQ_NMI			(AW_IRQ_GIC_START + 0)				/*	NMI			*/
+#define AW_IRQ_RTIMER0		(AW_IRQ_GIC_START + 9)				/*	R_TIMER 0	*/
+#define AW_IRQ_RTIMER1		(AW_IRQ_GIC_START + 9)				/*	R_TIMER 1	*/
+#define AW_IRQ_RWATCHDOG	(AW_IRQ_GIC_START + 9)				/*	R_WATCHDO	*/
+#define AW_IRQ_RCIR			(AW_IRQ_GIC_START + 16)				/*  R_CIR		*/
+#define	AW_IRQ_RUART		(AW_IRQ_GIC_START + 16)				/*	R_UART		*/
+#define AW_IRQ_RP2TWI		(AW_IRQ_GIC_START + 19)				/*	R_P2TWI		*/
+#define	AW_IRQ_RALARM0		(AW_IRQ_GIC_START + 18)				/*	R_RLARM 0	*/
+#define	AW_IRQ_RALARM1		(AW_IRQ_GIC_START + 18)				/*	R_RLARM 1	*/
+#define AW_IRQ_R_1WIRE		(AW_IRQ_GIC_START + 31)				/*	R_ONE_WIRE	*/
+#define	AW_IRQ_RTWI			(AW_IRQ_GIC_START + 19)				/*	R_TWI		*/
+#define AW_IRQ_EINTL		(AW_IRQ_GIC_START + 17)				/*	R_EINTL		*/
+#define AW_IRQ_EINTM		(AW_IRQ_GIC_START + 200)				/*	R_EINTM		*/
+#define	AW_IRQ_SPINLOCK		(AW_IRQ_GIC_START + 10)				/*	SPINLOCK	*/
+#define	AW_IRQ_MBOX			(AW_IRQ_GIC_START + 11)				/*	M-BOX		*/
+#define	AW_IRQ_DMA			(AW_IRQ_GIC_START + 6)				/*	DMA			*/
+#define AW_IRQ_HSTIMER0		(AW_IRQ_GIC_START + 12)				/*	HSTIMER0	*/
+#define AW_IRQ_HSTIMER1		(AW_IRQ_GIC_START + 52 + 200)		/*	HSTIMER1	*/
+#define AW_IRQ_HSTIMER2		(AW_IRQ_GIC_START + 53 + 200)		/*	HSTIMER2	*/
+#define AW_IRQ_HSTIMER3		(AW_IRQ_GIC_START + 54 + 200)		/*	HSTIMER3	*/
+#define	AW_IRQ_TZASC		(AW_IRQ_GIC_START + 26)				/*	TZASC		*/
+#define	AW_IRQ_VE			(AW_IRQ_GIC_START + 20)				/*	VE			*/
+#define	AW_IRQ_DIGMIC		(AW_IRQ_GIC_START + 59 + 200)		/*	DIG_MIC		*/
+#define AW_IRQ_MMC0			(AW_IRQ_GIC_START + 13)				/*	MMC0		*/
+#define AW_IRQ_MMC1			(AW_IRQ_GIC_START + 13)				/*	MMC1		*/
+#define AW_IRQ_MMC2			(AW_IRQ_GIC_START + 13)				/*	MMC2		*/
+#define AW_IRQ_MMC3			(AW_IRQ_GIC_START + 13)				/*	MMC3		*/
+#define AW_IRQ_SPI0			(AW_IRQ_GIC_START + 13)				/*	SPI0		*/
+#define AW_IRQ_SPI1			(AW_IRQ_GIC_START + 66 + 200)		/*	SPI1		*/
+#define AW_IRQ_SPI2			(AW_IRQ_GIC_START + 67 + 200)		/*	SPI2		*/
+#define AW_IRQ_SPI3			(AW_IRQ_GIC_START + 68 + 200)		/*	SPI3		*/
+#define AW_IRQ_NAND1		(AW_IRQ_GIC_START + 15)				/*	NAND1		*/
+#define AW_IRQ_NAND0		(AW_IRQ_GIC_START + 14)				/*	NAND0		*/
+#define AW_IRQ_USB_OTG		(AW_IRQ_GIC_START + 21)				/*	USB_OTG		*/
+#define AW_IRQ_USB_OHCI2	(AW_IRQ_GIC_START + 21)				/*	USB_HCI	have no define in ic spec	*/
+#define AW_IRQ_USB_EHCI0	(AW_IRQ_GIC_START + 22)				/*	USB_EHCI0	*/
+#define AW_IRQ_USB_OHCI0	(AW_IRQ_GIC_START + 23)				/*	USB_OHCI0	*/
+#define AW_IRQ_USB_EHCI1	(AW_IRQ_GIC_START + 74 + 200)		/*	USB_EHCI1	*/
+#define AW_IRQ_USB_OHCI1	(AW_IRQ_GIC_START + 75 + 200)		/*	USB_OHCI1	*/
+#define AW_IRQ_SS			(AW_IRQ_GIC_START + 24)				/*	SS			*/
+#define AW_IRQ_TS			(AW_IRQ_GIC_START + 24)				/*	TS			*/
+#define AW_IRQ_GMAC			(AW_IRQ_GIC_START + 24)				/*	GMAC		*/
+#define AW_IRQ_MP			(AW_IRQ_GIC_START + 3)				/*	MP			*/
+#define AW_IRQ_CSI0			(AW_IRQ_GIC_START + 3)				/*	CSI0		*/
+#define AW_IRQ_CSI1			(AW_IRQ_GIC_START + 3)				/*	CSI1		*/
+#define AW_IRQ_LCD0			(AW_IRQ_GIC_START + 25)				/*	LCD0		*/
+#define AW_IRQ_LCD1			(AW_IRQ_GIC_START + 87 + 200)		/*	LCD1		*/
+#define AW_IRQ_HDMI			(AW_IRQ_GIC_START + 88 + 200)		/*	HDMI		*/
+#define AW_IRQ_MIPIDSI		(AW_IRQ_GIC_START + 3)				/*	MIPI DSI	*/
+#define AW_IRQ_MIPICSI		(AW_IRQ_GIC_START + 3)				/*	MIPI CSI	*/
+#define AW_IRQ_DRC01		(AW_IRQ_GIC_START + 29)				/*	DRC 0/1		*/
+#define AW_IRQ_DEU01		(AW_IRQ_GIC_START + 30)				/*	DEU	0/1		*/
+#define AW_IRQ_DEFE0		(AW_IRQ_GIC_START + 27)				/*	DE_FE0		*/
+#define AW_IRQ_DEFE1		(AW_IRQ_GIC_START + 94 + 200)		/*	DE_FE1		*/
+#define AW_IRQ_DEBE0		(AW_IRQ_GIC_START + 28)				/*	DE_BE0		*/
+#define AW_IRQ_DEBE1		(AW_IRQ_GIC_START + 96 + 200)		/*	DE_BE1		*/
+#define	AW_IRQ_GPU			(AW_IRQ_GIC_START + 26)				/*	GPU			*/
+#define	AW_IRQ_CTI0			(AW_IRQ_GIC_START + 108 + 200)		/*	CTI0		*/
+#define	AW_IRQ_CTI1			(AW_IRQ_GIC_START + 109 + 200)		/*	CTI1		*/
+#define	AW_IRQ_CTI2			(AW_IRQ_GIC_START + 110 + 200)		/*	CTI2		*/
+#define	AW_IRQ_CTI3			(AW_IRQ_GIC_START + 111 + 200)		/*	CTI3		*/
+#define AW_IRQ_COMMTX0		(AW_IRQ_GIC_START + 112 + 200)		/*	COMMTX0		*/
+#define AW_IRQ_COMMTX1		(AW_IRQ_GIC_START + 113 + 200)		/*	COMMTX1		*/
+#define AW_IRQ_COMMTX2		(AW_IRQ_GIC_START + 114 + 200)		/*	COMMTX2		*/
+#define AW_IRQ_COMMTX3		(AW_IRQ_GIC_START + 115 + 200)		/*	COMMTX3		*/
+#define AW_IRQ_COMMRX0		(AW_IRQ_GIC_START + 116 + 200)		/*	COMMRX0		*/
+#define AW_IRQ_COMMRX1		(AW_IRQ_GIC_START + 117 + 200)		/*	COMMRX1		*/
+#define AW_IRQ_COMMRX2		(AW_IRQ_GIC_START + 118 + 200)		/*	COMMRX2		*/
+#define AW_IRQ_COMMRX3		(AW_IRQ_GIC_START + 119 + 200)		/*	COMMRX3		*/
+#define	AW_IRQ_PMU0			(AW_IRQ_GIC_START + 120 + 200)		/*	PMU0		*/
+#define	AW_IRQ_PMU1			(AW_IRQ_GIC_START + 121 + 200)		/*	PMU1		*/
+#define	AW_IRQ_PMU2			(AW_IRQ_GIC_START + 122 + 200)		/*	PMU2		*/
+#define	AW_IRQ_PMU3			(AW_IRQ_GIC_START + 123 + 200)		/*	PMU3		*/
+#define	AW_IRQ_AXI_ERROR	(AW_IRQ_GIC_START + 124 + 200)		/*	AXI_ERROR	*/
+
+#elif defined (CONFIG_AW_ASIC_EVB_PLATFORM)
+
+#define AW_IRQ_UART_DEBUG	(AW_IRQ_GIC_START + 0)		/*	UART0		*/
+#define AW_IRQ_UART0		(AW_IRQ_GIC_START + 0)		/*	UART0		*/
+#define AW_IRQ_UART1		(AW_IRQ_GIC_START + 1)		/*	UART1		*/
+#define AW_IRQ_UART2		(AW_IRQ_GIC_START + 2)		/*	UART2		*/
+#define AW_IRQ_UART3		(AW_IRQ_GIC_START + 3)		/*	UART3		*/
+#define AW_IRQ_UART4		(AW_IRQ_GIC_START + 4)		/*	UART3		*/
+#define AW_IRQ_UART5		(AW_IRQ_GIC_START + 5)		/*	UART3		*/
+#define AW_IRQ_TWI0			(AW_IRQ_GIC_START + 6)		/*	TWI0		*/
+#define AW_IRQ_TWI1			(AW_IRQ_GIC_START + 7)		/*	TWI1		*/
+#define AW_IRQ_TWI2			(AW_IRQ_GIC_START + 8)		/*	TWI0		*/
+#define AW_IRQ_TWI3			(AW_IRQ_GIC_START + 9)		/*	TWI1		*/
+
+#define AW_IRQ_EINTA		(AW_IRQ_GIC_START + 11)		/*	EINTA		*/
+#define AW_IRQ_SPDIF		(AW_IRQ_GIC_START + 12)		/*	SPDIF		*/
+#define AW_IRQ_DAUDIO0		(AW_IRQ_GIC_START + 13)		/*	DAUDIO0		*/
+#define AW_IRQ_DAUDIO1      (AW_IRQ_GIC_START + 14)     /*  DAUDIO1     */
+#define AW_IRQ_EINTB        (AW_IRQ_GIC_START + 15)     /*  EINTB       */
+#define AW_IRQ_EINTE        (AW_IRQ_GIC_START + 16)     /*  EINTE       */
+#define AW_IRQ_EINTG        (AW_IRQ_GIC_START + 17)     /*  EINTG       */
+#define AW_IRQ_TIMER0		(AW_IRQ_GIC_START + 18)		/*	Timer0		*/
+#define AW_IRQ_TIMER1		(AW_IRQ_GIC_START + 19)		/*	Timer1		*/
+#define AW_IRQ_TIMER2		(AW_IRQ_GIC_START + 20)		/*	Timer2		*/
+#define AW_IRQ_TIMER3       (AW_IRQ_GIC_START + 21)     /*  Timer3      */
+#define AW_IRQ_TIMER4       (AW_IRQ_GIC_START + 22)     /*  Timer4      */
+#define AW_IRQ_TIMER5       (AW_IRQ_GIC_START + 23)     /*  Timer5      */
+#define	AW_IRQ_WATCHDOG4	(AW_IRQ_GIC_START + 24)		/*	WATCHDOG4	*/
+#define	AW_IRQ_WATCHDOG1	(AW_IRQ_GIC_START + 25)		/*	WATCHDOG1	*/
+#define	AW_IRQ_WATCHDOG2	(AW_IRQ_GIC_START + 26)		/*	WATCHDOG2	*/
+#define	AW_IRQ_WATCHDOG3	(AW_IRQ_GIC_START + 27)		/*	WATCHDOG3	*/
+#define	AW_IRQ_TOUCHPANEL	(AW_IRQ_GIC_START + 28)		/*	TOUCH PANEL	*/
+#define AW_IRQ_CODEC		(AW_IRQ_GIC_START +	29)		/*	AUDIO CEDEC	*/
+#define AW_IRQ_LRADC		(AW_IRQ_GIC_START + 30)		/*	LRADC		*/
+#define AW_IRQ_MTCACC		(AW_IRQ_GIC_START + 31)		/*	MTCACC		*/
+#define AW_IRQ_NMI			(AW_IRQ_GIC_START + 32)		/*	NMI			*/
+#define AW_IRQ_RTIMER0		(AW_IRQ_GIC_START + 33)		/*	R_TIMER 0	*/
+#define AW_IRQ_RTIMER1		(AW_IRQ_GIC_START + 34)		/*	R_TIMER 1	*/
+
+#define AW_IRQ_RWATCHDOG	(AW_IRQ_GIC_START + 36)     /*	R_WATCHDO	*/
+#define AW_IRQ_RCIR			(AW_IRQ_GIC_START + 37)     /*  R_CIR		*/
+#define	AW_IRQ_RUART		(AW_IRQ_GIC_START + 38)		/*	R_UART		*/
+#define AW_IRQ_RP2TWI		(AW_IRQ_GIC_START + 39)		/*	R_P2TWI		*/
+#define	AW_IRQ_RALARM0		(AW_IRQ_GIC_START + 40)		/*	R_RLARM 0	*/
+#define	AW_IRQ_RALARM1		(AW_IRQ_GIC_START + 41)		/*	R_RLARM 1	*/
+
+#define AW_IRQ_R_1WIRE		(AW_IRQ_GIC_START + 43)		/*	R_ONE_WIRE	*/
+#define	AW_IRQ_RTWI			(AW_IRQ_GIC_START + 44)		/*	R_TWI		*/
+#define AW_IRQ_EINTL		(AW_IRQ_GIC_START + 45)		/*	R_EINTL		*/
+#define AW_IRQ_EINTM		(AW_IRQ_GIC_START + 46)		/*	R_EINTM		*/
+
+#define	AW_IRQ_SPINLOCK		(AW_IRQ_GIC_START + 48)		/*	SPINLOCK	*/
+#define	AW_IRQ_MBOX			(AW_IRQ_GIC_START + 49)		/*	M-BOX		*/
+#define	AW_IRQ_DMA			(AW_IRQ_GIC_START + 50)		/*	DMA			*/
+#define AW_IRQ_HSTIMER0		(AW_IRQ_GIC_START + 51)		/*	HSTIMER0	*/
+#define AW_IRQ_HSTIMER1		(AW_IRQ_GIC_START + 52)		/*	HSTIMER1	*/
+#define AW_IRQ_HSTIMER2		(AW_IRQ_GIC_START + 53)		/*	HSTIMER2	*/
+#define AW_IRQ_HSTIMER3		(AW_IRQ_GIC_START + 54)		/*	HSTIMER3	*/
+
+#define	AW_IRQ_TZASC		(AW_IRQ_GIC_START + 56)		/*	TZASC		*/
+
+#define	AW_IRQ_VE			(AW_IRQ_GIC_START + 58)		/*	VE			*/
+#define	AW_IRQ_DIGMIC		(AW_IRQ_GIC_START + 59)		/*	DIG_MIC		*/
+#define AW_IRQ_MMC0			(AW_IRQ_GIC_START + 60)		/*	MMC0		*/
+#define AW_IRQ_MMC1			(AW_IRQ_GIC_START + 61)		/*	MMC1		*/
+#define AW_IRQ_MMC2			(AW_IRQ_GIC_START + 62)		/*	MMC2		*/
+#define AW_IRQ_MMC3			(AW_IRQ_GIC_START + 63)		/*	MMC3		*/
+
+#define AW_IRQ_SPI0			(AW_IRQ_GIC_START + 65)		/*	SPI0		*/
+#define AW_IRQ_SPI1			(AW_IRQ_GIC_START + 66)		/*	SPI1		*/
+#define AW_IRQ_SPI2			(AW_IRQ_GIC_START + 67)		/*	SPI2		*/
+#define AW_IRQ_SPI3			(AW_IRQ_GIC_START + 68)		/*	SPI3		*/
+#define AW_IRQ_NAND1		(AW_IRQ_GIC_START + 69)		/*	NAND1		*/
+#define AW_IRQ_NAND0		(AW_IRQ_GIC_START + 70)		/*	NAND0		*/
+
+#define AW_IRQ_USB_OTG		(AW_IRQ_GIC_START + 71)		/*	USB_OTG		*/
+#define AW_IRQ_USB_EHCI0	(AW_IRQ_GIC_START + 72)		/*	USB_EHCI0	*/
+#define AW_IRQ_USB_OHCI0	(AW_IRQ_GIC_START + 73)		/*	USB_OHCI0	*/
+#define AW_IRQ_USB_EHCI1	(AW_IRQ_GIC_START + 74)		/*	USB_EHCI1	*/
+#define AW_IRQ_USB_OHCI1	(AW_IRQ_GIC_START + 75)		/*	USB_OHCI1	*/
+
+#define AW_IRQ_USB_OHCI2	(AW_IRQ_GIC_START + 77)		/*	USB_OHCI2	*/
+
+
+#define AW_IRQ_SS			(AW_IRQ_GIC_START + 80)		/*	SS			*/
+#define AW_IRQ_TS			(AW_IRQ_GIC_START + 81)		/*	TS			*/
+#define AW_IRQ_GMAC			(AW_IRQ_GIC_START + 82)		/*	GMAC		*/
+#define AW_IRQ_MP			(AW_IRQ_GIC_START + 83)		/*	MP			*/
+#define AW_IRQ_CSI0			(AW_IRQ_GIC_START + 84)		/*	CSI0		*/
+#define AW_IRQ_CSI1			(AW_IRQ_GIC_START + 85)		/*	CSI1		*/
+#define AW_IRQ_LCD0			(AW_IRQ_GIC_START + 86)		/*	LCD0		*/
+#define AW_IRQ_LCD1			(AW_IRQ_GIC_START + 87)		/*	LCD1		*/
+#define AW_IRQ_HDMI			(AW_IRQ_GIC_START + 88)		/*	HDMI		*/
+#define AW_IRQ_MIPIDSI		(AW_IRQ_GIC_START + 89)		/*	MIPI DSI	*/
+#define AW_IRQ_MIPICSI		(AW_IRQ_GIC_START + 90)		/*	MIPI CSI	*/
+#define AW_IRQ_DRC01		(AW_IRQ_GIC_START + 91)		/*	DRC 0/1		*/
+#define AW_IRQ_DEU01		(AW_IRQ_GIC_START + 92)		/*	DEU	0/1		*/
+#define AW_IRQ_DEFE0		(AW_IRQ_GIC_START + 93)		/*	DE_FE0		*/
+#define AW_IRQ_DEFE1		(AW_IRQ_GIC_START + 94)		/*	DE_FE1		*/
+#define AW_IRQ_DEBE0		(AW_IRQ_GIC_START + 95)		/*	DE_BE0		*/
+#define AW_IRQ_DEBE1		(AW_IRQ_GIC_START + 96)		/*	DE_BE1		*/
+#define	AW_IRQ_GPU			(AW_IRQ_GIC_START + 97)		/*	GPU			*/
+
+
+
+
+
+
+
+
+
+
+#define	AW_IRQ_CTI0			(AW_IRQ_GIC_START + 108)	/*	CTI0		*/
+#define	AW_IRQ_CTI1			(AW_IRQ_GIC_START + 109)	/*	CTI1		*/
+#define	AW_IRQ_CTI2			(AW_IRQ_GIC_START + 110)	/*	CTI2		*/
+#define	AW_IRQ_CTI3			(AW_IRQ_GIC_START + 111)	/*	CTI3		*/
+#define AW_IRQ_COMMTX0		(AW_IRQ_GIC_START + 112)	/*	COMMTX0		*/
+#define AW_IRQ_COMMTX1		(AW_IRQ_GIC_START + 113)	/*	COMMTX1		*/
+#define AW_IRQ_COMMTX2		(AW_IRQ_GIC_START + 114)	/*	COMMTX2		*/
+#define AW_IRQ_COMMTX3		(AW_IRQ_GIC_START + 115)	/*	COMMTX3		*/
+#define AW_IRQ_COMMRX0		(AW_IRQ_GIC_START + 116)	/*	COMMRX0		*/
+#define AW_IRQ_COMMRX1		(AW_IRQ_GIC_START + 117)	/*	COMMRX1		*/
+#define AW_IRQ_COMMRX2		(AW_IRQ_GIC_START + 118)	/*	COMMRX2		*/
+#define AW_IRQ_COMMRX3		(AW_IRQ_GIC_START + 119)	/*	COMMRX3		*/
+#define	AW_IRQ_PMU0			(AW_IRQ_GIC_START + 120)	/*	PMU0		*/
+#define	AW_IRQ_PMU1			(AW_IRQ_GIC_START + 121)	/*	PMU1		*/
+#define	AW_IRQ_PMU2			(AW_IRQ_GIC_START + 122)	/*	PMU2		*/
+#define	AW_IRQ_PMU3			(AW_IRQ_GIC_START + 123)	/*	PMU3		*/
+#define	AW_IRQ_AXI_ERROR	(AW_IRQ_GIC_START + 124)	/*	AXI_ERROR	*/
+
+
+/*
+ * GIC
+ */
+#else
+
+#error "please select a platform"
+
+#endif
+
+#define NR_IRQS           (AW_IRQ_GIC_START + 128)
+#define MAX_GIC_NR        1
+
+#endif    /* __MACH_IRQS_AW_H */
diff --git a/arch/arm/mach-sun6i/include/mach/irqs.h b/arch/arm/mach-sun6i/include/mach/irqs.h
new file mode 100644
index 0000000..64f6bc0
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/irqs.h
@@ -0,0 +1,33 @@
+/*
+ *  arch/arm/mach-sun6i/include/mach/irqs.h
+ *
+ *  Copyright (C) 2012-2016 Allwinner Limited
+ *  Benn Huang (benn@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+#include <mach/irqs-sun6i.h>
+
+#define IRQ_GIC_START		32
+
+#ifndef NR_IRQS
+#error "NR_IRQS not defined by the board-specific files"
+#endif
+
+#endif
diff --git a/arch/arm/mach-sun6i/include/mach/memory.h b/arch/arm/mach-sun6i/include/mach/memory.h
new file mode 100644
index 0000000..35ee436
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/memory.h
@@ -0,0 +1,41 @@
+/*
+ *  arch/arm/mach-sun6i/include/mach/memory.h
+ *
+ * Copyright (c) Allwinner.  All rights reserved.
+ * Benn Huang (benn@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#define PLAT_PHYS_OFFSET        UL(0x40000000)
+#define PLAT_MEM_SIZE           SZ_2G
+
+#define SYS_CONFIG_MEMBASE      (PLAT_PHYS_OFFSET + SZ_32M + SZ_16M)    /* +48M */
+#define SYS_CONFIG_MEMSIZE      (SZ_64K)                                /* 64K */
+
+#define SUPER_STANDBY_MEM_BASE  (PLAT_PHYS_OFFSET + SZ_64M + SZ_32M)    /* +96M */
+#define SUPER_STANDBY_MEM_SIZE  (SZ_1K)                                 /* 1K */
+
+#define HW_RESERVED_MEM_BASE    (PLAT_PHYS_OFFSET + SZ_64M + SZ_32M + SZ_4M)    /* +100M */
+#define HW_RESERVED_MEM_SIZE    (SZ_128M + SZ_64M + SZ_32M + SZ_8M)   		/* 232M(DE+VE(CSI)+MP) */
+
+#if defined(CONFIG_ION) || defined(CONFIG_ION_MODULE)
+#define ION_CARVEOUT_MEM_BASE   (HW_RESERVED_MEM_BASE + HW_RESERVED_MEM_SIZE)	/* +332M */
+#define ION_CARVEOUT_MEM_SIZE   (CONFIG_ION_SUNXI_CARVEOUT_SIZE * SZ_1M)  		/* in Mbytes */
+#endif
+
+#endif
diff --git a/arch/arm/mach-sun6i/include/mach/platform.h b/arch/arm/mach-sun6i/include/mach/platform.h
new file mode 100644
index 0000000..d67c71b
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/platform.h
@@ -0,0 +1,350 @@
+/*
+ * arch/arm/mach-sun6i/include/mach/platform.h
+ *
+ * Copyright (c) Allwinner.  All rights reserved.
+ * Benn Huang (benn@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_PLATFORM_H
+#define __ASM_ARCH_PLATFORM_H
+
+/*
+ * Memory definitions
+ */
+#define AW_IO_PHYS_BASE				0x01c00000
+#define AW_IO_SIZE					0x00400000  /* 4MB(Max) */
+#define AW_SRAM_A1_BASE				0x00000000
+#define AW_SRAM_A1_SIZE				0x00008000
+#define AW_SRAM_A2_BASE				0x00040000
+#define AW_SRAM_A2_SIZE				0x00014000
+#define AW_SRAM_D_BASE				0x00010000
+#define AW_SRAM_D_SIZE				0x00001000
+#define AW_SRAM_B_BASE				0x00020000 /* Secure, 64KB */
+#define AW_SRAM_B_SIZE				0x00010000
+#define AW_SDRAM_BASE				0x40000000
+#define AW_BROM_BASE				0xffff0000
+#define AW_BROM_SIZE				0x00008000 /* 32KB*/
+#define	AW_MTC_ACC					0x00080000
+
+/*
+ *  device physical addresses
+ */
+#define	AW_SRAMCTRL_BASE			0x01c00000
+#define	AW_DMA_BASE                 0x01c02000
+#define	AW_NANDFLASHC0_BASE			0x01c03000
+#define	AW_TS_BASE					0x01c04000
+#define	AW_NANDFLASHC1_BASE			0x01c05000
+#define	AW_LCD0_BASE				0x01c0c000
+#define	AW_LCD1_BASE				0x01c0d000
+#define AW_VE_BASE					0x01c0e000
+#define AW_SDMMC0_BASE				0x01c0f000
+#define AW_SDMMC1_BASE				0x01c10000
+#define AW_SDMMC2_BASE				0x01c11000
+#define AW_SDMMC3_BASE				0x01c12000
+#define AW_SS_BASE					0x01c15000
+#define AW_HDMI_BASE				0x01c16000
+#define AW_MSGBOX_BASE				0x01c17000
+#define AW_SPINLOCK_BASE			0x01c18000
+#define AW_USB_OTG_BASE				0x01c19000
+#define	AW_USB_EHCI0_BASE			0x01c1a000
+#define	AW_USB_OHCI0_BASE			0x01c1a000
+#define	AW_USB_EHCI1_BASE			0x01c1b000
+#define	AW_USB_OHCI1_BASE			0x01c1b000
+#define	AW_USB_OHCI2_BASE			0x01c1c000
+#define	AW_TZASC_BASE				0x01c1e000
+#define AW_CCM_BASE					0x01c20000
+#define AW_PIO_BASE                 0x01c20800
+#define AW_TIMER_BASE               0x01c20c00
+#define	AW_SPDIF_BASE				0x01c21000
+#define	AW_PWM_BASE					0x01c21400
+#define	AW_DAUDIO0_BASE				0x01c22000
+#define	AW_DAUDIO1_BASE				0x01c22400
+#define	AW_LRADC01_BASE				0x01c22800
+#define	AW_AUDIOCODEC_BASE			0x01c22C00
+#define	AW_TZPC_BASE				0x01c23400
+#define	AW_SID_BASE					0x01c23800
+#define	AW_SJTAG_BASE				0x01c23c00
+#define	AW_TP_BASE					0x01c25000
+#define	AW_DMIC_BASE				0x01c25400
+#define AW_UART0_BASE				0x01c28000 /* UART 0 */
+#define AW_UART1_BASE				0x01c28400 /* UART 1 */
+#define AW_UART2_BASE				0x01c28800 /* UART 2 */
+#define AW_UART3_BASE				0x01c28c00 /* UART 3 */
+#define AW_UART4_BASE				0x01c29000 /* UART 4 */
+#define AW_UART5_BASE				0x01c29400 /* UART 5 */
+#define AW_TWI0_BASE				0x01c2ac00
+#define AW_TWI1_BASE				0x01c2b000
+#define AW_TWI2_BASE				0x01c2b400
+#define	AW_TWI3_BASE				0x01c2b800
+#define	AW_GMAC_BASE				0x01c30000
+#define	AW_GPU_BASE					0x01c40000
+#define	AW_HSTMR_BASE				0x01c60000
+#define	AW_DRAMCOM_BASE				0x01c62000
+#define	AW_DRAMCTL0_BASE			0x01c63000
+#define	AW_DRAMCTL1_BASE			0x01c64000
+#define	AW_DRAMPHY0_BASE			0x01c65000
+#define	AW_DRAMPHY1_BASE			0x01c66000
+#define	AW_SPI0_BASE				0x01c68000
+#define	AW_SPI1_BASE				0x01c69000
+#define	AW_SPI2_BASE				0x01c6a000
+#define	AW_SPI3_BASE				0x01c6b000
+#define	AW_SCU_BASE					0x01c80000
+#define	AW_MIPI_DSI0_BASE			0x01ca0000
+#define	AW_MIPI_DSI0_PHY_BASE		0x01ca1000
+#define	AW_CSI0_BASE				0x01cb0000
+#define	AW_MIPI_CSI0_BASE			0x01cb1000
+#define	AW_MIPI_CSI0_PHY_BASE		0x01cb2000
+#define	AW_CSI1_BASE				0x01cb3000
+#define	AW_ISP_BASE					0x01cb8000
+#define	AW_ISP_MEM_BASE				0x01cc0000
+#define	AW_SRAM_C_BASE				0x01d00000
+#define	AW_DE_FE0_BASE				0x01e00000
+#define	AW_DE_FE1_BASE				0x01e20000
+#define	AW_DE_BE1_BASE				0x01e40000
+#define	AW_DRC1_BASE				0x01e50000
+#define	AW_DE_BE0_BASE				0x01e60000
+#define	AW_DRC0_BASE				0x01e70000
+#define	AW_MP_BASE					0x01e80000
+#define	AW_DEU1_BASE				0x01ea0000
+#define	AW_DEU0_BASE				0x01eb0000
+#define	AW_PS_BASE					0x01ef0000
+#define	AW_RTC_BASE					0x01f00000
+#define	AW_R_TIMER_BASE				0x01f00800
+#define	AW_R_INTC_BASE				0x01f00c00
+#define	AW_R_WDOG_BASE				0x01f01000
+#define	AW_R_PRCM_BASE				0x01f01400
+#define AW_R_CPUCFG_BASE            0x01f01c00
+#define AW_R_CIR_BASE				0x01f02000
+#define	AW_R_TWI_BASE				0x01f02400
+#define AW_R_UART_BASE              0x01f02800 /* R_UART */
+#define AW_R_PIO_BASE               0x01f02c00 /* for r-pio */
+#define AW_R_ONE_WIRE_BASE			0x01f03000
+#define	AW_R_P2WI_BASE				0x01f03400
+#define	AW_CDM_BASE					0x3f500000/*coresight debug module*/
+#define	AW_TSGEN_RO_BASE			0x3f506000
+#define	AW_TSGEN_CTRL_BASE			0x3f507000
+
+
+
+
+#define AW_GIC_DIST_BASE            0x01c81000
+#define AW_GIC_CPU_BASE             0x01c82000
+#define AW_TIMER_G_BASE             0x01c80200 /* CPU global timer, not used */
+#define AW_TIMER_P_BASE             0x01c80600 /* CPU private timer, not used */
+
+
+/*
+ * Peripheral addresses
+ */
+#define AW_RTC_REG					AW_RTC_BASE
+#define	AW_RPIO_BASE				AW_R_PIO_BASE
+
+
+
+
+
+
+
+
+
+
+/*
+ *  device virtual addresses
+ */
+#define	AW_VIR_SRAMCTRL_BASE			0xf1c00000
+#define	AW_VIR_DMA_BASE                 0xf1c02000
+#define	AW_VIR_NANDFLASHC0_BASE			0xf1c03000
+#define	AW_VIR_TS_BASE					0xf1c04000
+#define	AW_VIR_NANDFLASHC1_BASE			0xf1c05000
+#define	AW_VIR_LCD0_BASE				0xf1c0c000
+#define	AW_VIR_LCD1_BASE				0xf1c0d000
+#define AW_VIR_VE_BASE					0xf1c0e000
+#define AW_VIR_SDMMC0_BASE				0xf1c0f000
+#define AW_VIR_SDMMC1_BASE				0xf1c10000
+#define AW_VIR_SDMMC2_BASE				0xf1c11000
+#define AW_VIR_SDMMC3_BASE				0xf1c12000
+#define AW_VIR_SS_BASE					0xf1c15000
+#define AW_VIR_HDMI_BASE				0xf1c16000
+#define AW_VIR_MSGBOX_BASE				0xf1c17000
+#define AW_VIR_SPINLOCK_BASE			0xf1c18000
+#define AW_VIR_USB_OTG_BASE				0xf1c19000
+#define	AW_VIR_USB_EHCI0_BASE			0xf1c1a000
+#define	AW_VIR_USB_OHCI0_BASE			0xf1c1a000
+#define	AW_VIR_USB_EHCI1_BASE			0xf1c1b000
+#define	AW_VIR_USB_OHCI1_BASE			0xf1c1b000
+#define	AW_VIR_USB_OHCI2_BASE			0xf1c1c000
+#define	AW_VIR_TZASC_BASE				0xf1c1e000
+#define AW_VIR_CCM_BASE					0xf1c20000
+#define AW_VIR_PIO_BASE                 0xf1c20800
+#define AW_VIR_TIMER_BASE               0xf1c20c00
+#define	AW_VIR_SPDIF_BASE				0xf1c21000
+#define	AW_VIR_PWM_BASE					0xf1c21400
+#define	AW_VIR_DAUDIO0_BASE				0xf1c22000
+#define	AW_VIR_DAUDIO1_BASE				0xf1c22400
+#define	AW_VIR_LRADC01_BASE				0xf1c22800
+#define	AW_VIR_AUDIOCODEC_BASE			0xf1c22C00
+#define	AW_VIR_TZPC_BASE				0xf1c23400
+#define	AW_VIR_SID_BASE					0xf1c23800
+#define	AW_VIR_SJTAG_BASE				0xf1c23c00
+#define	AW_VIR_TP_BASE					0xf1c25000
+#define	AW_VIR_DMIC_BASE				0xf1c25400
+#define AW_VIR_UART0_BASE				0xf1c28000 /* UART 0 */
+#define AW_VIR_UART1_BASE				0xf1c28400 /* UART 1 */
+#define AW_VIR_UART2_BASE				0xf1c28800 /* UART 2 */
+#define AW_VIR_UART3_BASE				0xf1c28c00 /* UART 3 */
+#define AW_VIR_UART4_BASE				0xf1c29000 /* UART 4 */
+#define AW_VIR_UART5_BASE				0xf1c29400 /* UART 5 */
+#define AW_VIR_TWI0_BASE				0xf1c2ac00
+#define AW_VIR_TWI1_BASE				0xf1c2b000
+#define AW_VIR_TWI2_BASE				0xf1c2b400
+#define	AW_VIR_TWI3_BASE				0xf1c2b800
+#define	AW_VIR_GMAC_BASE				0xf1c30000
+#define	AW_VIR_GPU_BASE					0xf1c40000
+#define	AW_VIR_HSTMR_BASE				0xf1c60000
+#define	AW_VIR_DRAMCOM_BASE				0xf1c62000
+#define	AW_VIR_DRAMCTL0_BASE			0xf1c63000
+#define	AW_VIR_DRAMCTL1_BASE			0xf1c64000
+#define	AW_VIR_DRAMPHY0_BASE			0xf1c65000
+#define	AW_VIR_DRAMPHY1_BASE			0xf1c66000
+#define	AW_VIR_SPI0_BASE				0xf1c68000
+#define	AW_VIR_SPI1_BASE				0xf1c69000
+#define	AW_VIR_SPI2_BASE				0xf1c6a000
+#define	AW_VIR_SPI3_BASE				0xf1c6b000
+#define	AW_VIR_SCU_BASE					0xf1c80000
+#define	AW_VIR_MIPI_DSI0_BASE			0xf1ca0000
+#define	AW_VIR_MIPI_DSI0_PHY_BASE		0xf1ca1000
+#define	AW_VIR_CSI0_BASE				0xf1cb0000
+#define	AW_VIR_MIPI_CSI0_BASE			0xf1cb1000
+#define	AW_VIR_MIPI_CSI0_PHY_BASE		0xf1cb2000
+#define	AW_VIR_CSI1_BASE				0xf1cb3000
+#define	AW_VIR_ISP_BASE					0xf1cb8000
+#define	AW_VIR_ISP_MEM_BASE				0xf1cc0000
+#define	AW_VIR_SRAM_C_BASE				0xf1d00000
+#define	AW_VIR_DE_FE0_BASE				0xf1e00000
+#define	AW_VIR_DE_FE1_BASE				0xf1e20000
+#define	AW_VIR_DE_BE1_BASE				0xf1e40000
+#define	AW_VIR_DRC1_BASE				0xf1e50000
+#define	AW_VIR_DE_BE0_BASE				0xf1e60000
+#define	AW_VIR_DRC0_BASE				0xf1e70000
+#define	AW_VIR_MP_BASE					0xf1e80000
+#define	AW_VIR_DEU1_BASE				0xf1ea0000
+#define	AW_VIR_DEU0_BASE				0xf1eb0000
+#define	AW_VIR_PS_BASE					0xf1ef0000
+#define	AW_VIR_RTC_BASE					0xf1f00000
+#define	AW_VIR_R_TIMER_BASE				0xf1f00800
+#define	AW_VIR_R_INTC_BASE				0xf1f00c00
+#define	AW_VIR_R_WDOG_BASE				0xf1f01000
+#define	AW_VIR_R_PRCM_BASE				0xf1f01400
+#define AW_VIR_R_CPUCFG_BASE            0xf1f01c00
+#define AW_VIR_R_CIR_BASE				0xf1f02000
+#define	AW_VIR_R_TWI_BASE				0xf1f02400
+#define AW_VIR_R_UART_BASE              0xf1f02800 /* R_UART */
+#define AW_VIR_R_PIO_BASE               0xf1f02c00 /* for r-pio */
+#define AW_VIR_R_ONE_WIRE_BASE			0xf1f03000
+#define	AW_VIR_R_P2WI_BASE				0xf1f03400
+
+
+
+
+/*
+ * Timer registers
+ */
+#define AW_TMR_IRQ_EN_REG           0x0000
+#define AW_TMR_IRQ_STA_REG          0x0004
+#define AW_TMR0_CTRL_REG            0x0010
+#define AW_TMR0_INTV_VALUE_REG      0x0014
+#define AW_TMR0_CUR_VALUE_REG       0x0018
+
+#define AW_AVS_CNT_CTL_REG          0x0080
+#define AW_AVS_CNT0_REG             0x0084
+#define AW_AVS_CNT1_REG             0x0088
+#define AW_AVS_CNT_DIV_REG          0x008c
+
+#define	AW_WDOG1_IRQ_EN_REG			0xa0
+#define	AW_WDOG1_IRQ_STA_REG		0xa4
+#define	AW_WDOG1_CTRL_REG			0xb0
+#define	AW_WDOG1_CFG_REG			0xb4
+#define	AW_WDOG1_MODE_REG			0xb8
+
+/* r-watchdog0 reg offset define */
+#define	AW_WDOG0_IRQ_EN_REG		0x0
+#define	AW_WDOG0_IRQ_STA_REG		0x4
+#define	AW_WDOG0_CTRL_REG		0x10
+#define	AW_WDOG0_CFG_REG		0x14
+#define	AW_WDOG0_MODE_REG		0x18
+
+/*
+ * CPUCFG
+ */
+#define AW_CPUCFG_P_REG0            0x01a4
+#define AW_CPUCFG_P_REG1            0x01a8
+#define CPUX_RESET_CTL(x) (0x40 + (x)*0x40)
+#define CPUX_CONTROL(x)   (0x44 + (x)*0x40)
+#define CPUX_STATUS(x)    (0x48 + (x)*0x40)
+#define AW_CPUCFG_GENCTL            0x0184
+#define AW_CPUCFG_DBGCTL0           0x01e0
+#define AW_CPUCFG_DBGCTL1           0x01e4
+
+
+/*
+ * PRCM
+ */
+#define AW_CPU_PWROFF_REG			0x100
+/* cpu0 has no clmap register! */
+#define AW_CPUX_PWR_CLAMP(x)		(0x140 + (x)*0x04)
+
+/*
+ * UART
+ */
+#define AW_UART_RBR 0x00 /* Receive Buffer Register */
+#define AW_UART_THR 0x00 /* Transmit Holding Register */
+#define AW_UART_DLL 0x00 /* Divisor Latch Low Register */
+#define AW_UART_DLH 0x04 /* Diviso Latch High Register */
+#define AW_UART_IER 0x04 /* Interrupt Enable Register */
+#define AW_UART_IIR 0x08 /* Interrrupt Identity Register */
+#define AW_UART_FCR 0x08 /* FIFO Control Register */
+#define AW_UART_LCR 0x0c /* Line Control Register */
+#define AW_UART_MCR 0x10 /* Modem Control Register */
+#define AW_UART_LSR 0x14 /* Line Status Register */
+#define AW_UART_MSR 0x18 /* Modem Status Register */
+#define AW_UART_SCH 0x1c /* Scratch Register */
+#define AW_UART_USR 0x7c /* Status Register */
+#define AW_UART_TFL 0x80 /* Transmit FIFO Level */
+#define AW_UART_RFL 0x84 /* RFL */
+#define AW_UART_HALT 0xa4 /* Halt TX Register */
+
+#define UART_USR        	(AW_UART_USR >> 2)
+#define UART_HALT       	(AW_UART_HALT >> 2)
+#define UART_SCH			(AW_UART_SCH >> 2)
+#define UART_FORCE_CFG  	(1 << 1)
+#define UART_FORCE_UPDATE	(1 << 2)
+
+#define AW_UART_LOG(fmt, args...) do {} while(0)
+#if 0
+#define AW_UART_LOG(fmt, args...)                                       \
+        do {                                                            \
+                aw_printk((u32)AW_UART0_BASE, "[%s]"fmt"\n", __FUNCTION__, ##args);   \
+        } while (0)
+#endif
+
+#define AW_R_UART_LOG(fmt, args...)                                       \
+        do {                                                              \
+                aw_printk((u32)AW_R_UART_BASE, "[%s]"fmt"\n", __FUNCTION__, ##args);   \
+        } while (0)
+
+
+#endif	/* __ASM_ARCH_PLATFORM_H */
diff --git a/arch/arm/mach-sun6i/include/mach/scene.h b/arch/arm/mach-sun6i/include/mach/scene.h
new file mode 100644
index 0000000..0c94c76
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/scene.h
@@ -0,0 +1,35 @@
+/*
+ * arch/arm/mach-sun6i/include/mach/scene.h
+ *
+ * Copyright (C) 2012 - 2016 Reuuimlla Limited
+ * Kevin <kevin@reuuimllatech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SCENE_H__
+#define __SCENE_H__
+
+#include <linux/notifier.h>
+
+enum scene_type {
+    SCENE_TYPE_DEF  = 0,
+    SCENE_TYPE1     = 1,
+    SCENE_TYPE2     = 2,
+    SCENE_TYPE3     = 3,
+    SCENE_TYPE4     = 4,
+    SCENE_TYPE5     = 5,
+    SCENE_TYPE6     = 6,
+    SCENE_TYPE7     = 7,
+    SCENE_TYPE8     = 8,
+    SCENE_TYPE9     = 9,
+    SCENE_TYPE_MAX  = 10,
+};
+
+extern int scene_register_notifier(struct notifier_block *nb);
+extern int scene_unregister_notifier(struct notifier_block *nb);
+
+#endif /* __SCENE_H__ */
diff --git a/arch/arm/mach-sun6i/include/mach/spi.h b/arch/arm/mach-sun6i/include/mach/spi.h
new file mode 100644
index 0000000..cd712f8
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/spi.h
@@ -0,0 +1,192 @@
+/*
+ * arch/arm/mach-sun6i/include/mach/spi.h
+ *
+ * Copyright (C) 2012 - 2016 Reuuimlla Limited
+ * Pan Nan <pannan@reuuimllatech.com>
+ *
+ * SUN6I SPI Register Definition
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <mach/platform.h>
+
+#ifndef _SUN6I_SPI_H_
+#define _SUN6I_SPI_H_
+
+#define SPI_MODULE_NUM		(4)
+#define SPI_FIFO_DEPTH		(128)
+#define BULK_DATA_BOUNDARY	64			/* can modify to adapt the application */
+#define SPI_MAX_FREQUENCY	80000000	/* spi controller just suppport 80Mhz */
+
+/* SPI Registers offsets from peripheral base address */
+#define SPI_VER_REG				(0x00)		/* version number register */
+#define SPI_GC_REG				(0x04)		/* global control register */
+#define SPI_TC_REG				(0x08) 		/* transfer control register */
+#define SPI_INT_CTL_REG			(0x10) 		/* interrupt control register */
+#define SPI_INT_STA_REG			(0x14) 		/* interrupt status register */
+#define SPI_FIFO_CTL_REG		(0x18) 		/* fifo control register */
+#define SPI_FIFO_STA_REG		(0x1C) 		/* fifo status register */
+#define SPI_WAIT_CNT_REG		(0x20) 		/* wait clock counter register */
+#define SPI_CLK_CTL_REG			(0x24) 		/* clock rate control register */
+#define SPI_BURST_CNT_REG		(0x30) 		/* burst counter register */
+#define SPI_TRANSMIT_CNT_REG	(0x34) 		/* transmit counter register */
+#define SPI_BCC_REG				(0x38) 		/* burst control counter register */
+#define SPI_TXDATA_REG			(0x200) 	/* tx data register */
+#define SPI_RXDATA_REG			(0x300) 	/* rx data register */
+
+
+/* SPI Global Control Register Bit Fields & Masks,defualt value:0x0000_0080 */
+#define SPI_GC_EN			(0x1 <<  0) 	/* SPI module enable control 1:enable; 0:disable; default:0 */
+#define SPI_GC_MODE   		(0x1 <<  1) 	/* SPI function mode select 1:master; 0:slave; default:0 */
+#define SPI_GC_TP_EN		(0x1 <<  7) 	/* SPI transmit stop enable 1:stop transmit data when RXFIFO is full; 0:ignore RXFIFO status; default:1 */
+#define SPI_GC_SRST			(0x1 << 31) 	/* soft reset, write 1 will clear SPI control, auto clear to 0 */
+
+/* SPI Transfer Control Register Bit Fields & Masks,defualt value:0x0000_0087 */
+#define SPI_TC_PHA			(0x1 <<  0)		/* SPI Clock/Data phase control,0: phase0,1: phase1;default:1 */
+#define SPI_TC_POL			(0x1 <<  1)		/* SPI Clock polarity control,0:low level idle,1:high level idle;default:1 */
+#define SPI_TC_SPOL	        (0x1 <<  2)  	/* SPI Chip select signal polarity control,default: 1,low effective like this:~~|_____~~ */
+#define SPI_TC_SSCTL        (0x1 <<  3)  	/* SPI chip select control,default 0:SPI_SSx remains asserted between SPI bursts,1:negate SPI_SSx between SPI bursts */
+#define SPI_TC_SS_MASK		(0x3 <<  4)		/* SPI chip select:00-SPI_SS0;01-SPI_SS1;10-SPI_SS2;11-SPI_SS3*/
+#define SPI_TC_SS_OWNER		(0x1 <<  6)		/* SS output mode select default is 0:automatic output SS;1:manual output SS */
+#define SPI_TC_SS_LEVEL		(0x1 <<  7)		/* defautl is 1:set SS to high;0:set SS to low */
+#define SPI_TC_DHB			(0x1 <<  8)		/* Discard Hash Burst,default 0:receiving all spi burst in BC period 1:discard unused,fectch WTC bursts */
+#define SPI_TC_DDB			(0x1 <<  9)		/* Dummy burst Type,default 0: dummy spi burst is zero;1:dummy spi burst is one */
+#define SPI_TC_RPSM			(0x1 << 10) 	/* select mode for high speed write,0:normal write mode,1:rapids write mode,default 0 */
+#define SPI_TC_SDC			(0x1 << 11) 	/* master sample data control, 1: delay--high speed operation;0:no delay. */
+#define SPI_TC_FBS			(0x1 << 12) 	/* LSB/MSB transfer first select 0:MSB,1:LSB,default 0:MSB first */
+#define SPI_TC_XCH          (0x1 << 31) 	/* Exchange burst default 0:idle,1:start exchange;when BC is zero,this bit cleared by SPI controller*/
+#define SPI_TC_SS_BIT_POS			(4)
+
+/* SPI Interrupt Control Register Bit Fields & Masks,defualt value:0x0000_0000 */
+#define SPI_INTEN_RX_RDY	(0x1 <<  0)  	/* rxFIFO Ready Interrupt Enable,---used for immediately received,0:disable;1:enable */
+#define SPI_INTEN_RX_EMP	(0x1 <<  1)  	/* rxFIFO Empty Interrupt Enable ---used for IRQ received */
+#define SPI_INTEN_RX_FULL	(0x1 <<  2)  	/* rxFIFO Full Interrupt Enable ---seldom used */
+#define SPI_INTEN_TX_ERQ	(0x1 <<  4)  	/* txFIFO Empty Request Interrupt Enable ---seldom used */
+#define SPI_INTEN_TX_EMP	(0x1 <<  5)  	/* txFIFO Empty Interrupt Enable ---used  for IRQ tx */
+#define SPI_INTEN_TX_FULL	(0x1 <<  6)		/* txFIFO Full Interrupt Enable ---seldom used */
+#define SPI_INTEN_RX_OVF	(0x1 <<  8)		/* rxFIFO Overflow Interrupt Enable ---used for error detect */
+#define SPI_INTEN_RX_UDR    (0x1 <<  9)		/* rxFIFO Underrun Interrupt Enable ---used for error detect */
+#define SPI_INTEN_TX_OVF    (0x1 << 10)		/* txFIFO Overflow Interrupt Enable ---used for error detect */
+#define SPI_INTEN_TX_UDR	(0x1 << 11) 	/* txFIFO Underrun Interrupt Enable ---not happened */
+#define SPI_INTEN_TC		(0x1 << 12) 	/* Transfer Completed Interrupt Enable  ---used */
+#define SPI_INTEN_SSI		(0x1 << 13) 	/* SSI interrupt Enable,chip select from valid state to invalid state,for slave used only */
+#define SPI_INTEN_ERR		(SPI_INTEN_TX_OVF|SPI_INTEN_RX_UDR|SPI_INTEN_RX_OVF) /* NO txFIFO underrun */
+#define SPI_INTEN_MASK		(0x77|(0x3f<<8))
+
+/* SPI Interrupt Status Register Bit Fields & Masks,defualt value:0x0000_0022 */
+#define SPI_INT_STA_RX_RDY		(0x1 <<  0)		/* rxFIFO ready, 0:RX_WL < RX_TRIG_LEVEL,1:RX_WL >= RX_TRIG_LEVEL */
+#define SPI_INT_STA_RX_EMP		(0x1 <<  1)		/* rxFIFO empty, this bit is set when rxFIFO is empty */
+#define SPI_INT_STA_RX_FULL		(0x1 <<  2)		/* rxFIFO full, this bit is set when rxFIFO is full */
+#define SPI_INT_STA_TX_RDY		(0x1 <<  4)		/* txFIFO ready, 0:TX_WL > TX_TRIG_LEVEL,1:TX_WL <= TX_TRIG_LEVEL */
+#define SPI_INT_STA_TX_EMP		(0x1 <<  5)		/* txFIFO empty, this bit is set when txFIFO is empty */
+#define SPI_INT_STA_TX_FULL		(0x1 <<  6)		/* txFIFO full, this bit is set when txFIFO is full */
+#define SPI_INT_STA_RX_OVF		(0x1 <<  8)		/* rxFIFO overflow, when set rxFIFO has overflowed */
+#define SPI_INT_STA_RX_UDR		(0x1 <<  9)		/* rxFIFO underrun, when set rxFIFO has underrun */
+#define SPI_INT_STA_TX_OVF		(0x1 << 10)		/* txFIFO overflow, when set txFIFO has overflowed */
+#define SPI_INT_STA_TX_UDR		(0x1 << 11)		/* fxFIFO underrun, when set txFIFO has underrun */
+#define SPI_INT_STA_TC			(0x1 << 12)		/* Transfer Completed */
+#define SPI_INT_STA_SSI			(0x1 << 13)		/* SS invalid interrupt, when set SS has changed from valid to invalid */
+#define SPI_INT_STA_ERR			(SPI_INT_STA_TX_OVF|SPI_INT_STA_RX_UDR|SPI_INT_STA_RX_OVF) /* NO txFIFO underrun */
+#define SPI_INT_STA_MASK		(0x77|(0x3f<<8))
+
+/* SPI FIFO Control Register Bit Fields & Masks,defualt value:0x0040_0001 */
+#define SPI_FIFO_CTL_RX_LEVEL	(0xFF <<  0)	/* rxFIFO reday request trigger level,default 0x1 */
+#define SPI_FIFO_CTL_RX_DRQEN	(0x1  <<  8)	/* rxFIFO DMA request enable,1:enable,0:disable */
+#define SPI_FIFO_CTL_RX_TESTEN	(0x1  << 14)	/* rxFIFO test mode enable,1:enable,0:disable */
+#define SPI_FIFO_CTL_RX_RST		(0x1  << 15)	/* rxFIFO reset, write 1, auto clear to 0 */
+#define SPI_FIFO_CTL_TX_LEVEL	(0xFF << 16)	/* txFIFO empty request trigger level,default 0x40 */
+#define SPI_FIFO_CTL_TX_DRQEN	(0x1  << 24)	/* txFIFO DMA request enable,1:enable,0:disable */
+#define SPI_FIFO_CTL_TX_TESTEN	(0x1  << 30)	/* txFIFO test mode enable,1:enable,0:disable */
+#define SPI_FIFO_CTL_TX_RST		(0x1  << 31)	/* txFIFO reset, write 1, auto clear to 0 */
+#define SPI_FIFO_CTL_DRQEN_MASK	(SPI_FIFO_CTL_TX_DRQEN|SPI_FIFO_CTL_RX_DRQEN)
+
+/* SPI FIFO Status Register Bit Fields & Masks,defualt value:0x0000_0000 */
+#define SPI_FIFO_STA_RX_CNT		(0xFF <<  0)	/* rxFIFO counter,how many bytes in rxFIFO */
+#define SPI_FIFO_STA_RB_CNT		(0x7  << 12)	/* rxFIFO read buffer counter,how many bytes in rxFIFO read buffer */
+#define SPI_FIFO_STA_RB_WR		(0x1  << 15)	/* rxFIFO read buffer write enable */
+#define SPI_FIFO_STA_TX_CNT		(0xFF << 16)	/* txFIFO counter,how many bytes in txFIFO */
+#define SPI_FIFO_STA_TB_CNT		(0x7  << 28)	/* txFIFO write buffer counter,how many bytes in txFIFO write buffer */
+#define SPI_FIFO_STA_TB_WR		(0x1  << 31)	/* txFIFO write buffer write enable */
+#define SPI_RXCNT_BIT_POS		(0)
+#define SPI_TXCNT_BIT_POS		(16)
+
+/* SPI Wait Clock Register Bit Fields & Masks,default value:0x0000_0000 */
+#define SPI_WAIT_WCC_MASK		(0xFFFF <<  0)	/* used only in master mode: Wait Between Transactions */
+#define SPI_WAIT_SWC_MASK		(0xF    << 16)	/* used only in master mode: Wait before start dual data transfer in dual SPI mode */
+
+/* SPI Clock Control Register Bit Fields & Masks,default:0x0000_0002 */
+#define SPI_CLK_CTL_CDR2		(0xFF <<  0)	/* Clock Divide Rate 2,master mode only : SPI_CLK = AHB_CLK/(2*(n+1)) */
+#define SPI_CLK_CTL_CDR1		(0xF  <<  8)	/* Clock Divide Rate 1,master mode only : SPI_CLK = AHB_CLK/2^n */
+#define SPI_CLK_CTL_DRS			(0x1  << 12)	/* Divide rate select,default,0:rate 1;1:rate 2 */
+#define SPI_CLK_SCOPE			(SPI_CLK_CTL_CDR2+1)
+
+/* SPI Master Burst Counter Register Bit Fields & Masks,default:0x0000_0000 */
+/* master mode: when SMC = 1,BC specifies total burst number, Max length is 16Mbytes */
+#define SPI_BC_CNT_MASK			(0xFFFFFF << 0) 	/* Total Burst Counter, tx length + rx length ,SMC=1 */
+
+/* SPI Master Transmit Counter reigster default:0x0000_0000 */
+#define SPI_TC_CNT_MASK			(0xFFFFFF << 0)		/* Write Transmit Counter, tx length, NOT rx length!!! */
+
+/* SPI Master Burst Control Counter reigster Bit Fields & Masks,default:0x0000_0000 */
+#define SPI_BCC_STC_MASK		(0xFFFFFF <<  0)	/* master single mode transmit counter */
+#define SPI_BCC_DBC_MASK		(0xF	  << 24)	/* master dummy burst counter */
+#define SPI_BCC_DUAL_MOD_RX_EN	(0x1	  << 28)	/* master dual mode RX enable */
+
+
+/* 设置config的bit位 */
+/***************必须跟linux的spi参数设置一致***************
+ * 工作模式，包括4种：
+ * 0: 工作模式0，POL=0,PAL=0;
+ * 1: 工作模式1，POL=0,PAL=1;
+ * 2: 工作模式2，POL=1,PAL=0;
+ * 3: 工作模式3，POL=1,PAL=1;
+ */
+#define SPI_PHA_ACTIVE_		    (0x01)
+#define SPI_POL_ACTIVE_		    (0x02)
+
+#define SPI_MODE_0_ACTIVE_		(0|0)
+#define SPI_MODE_1_ACTIVE_		(0|SPI_PHA_ACTIVE_)
+#define SPI_MODE_2_ACTIVE_		(SPI_POL_ACTIVE_|0)
+#define SPI_MODE_3_ACTIVE_		(SPI_POL_ACTIVE_|SPI_PHA_ACTIVE_) /*默认为模式3*/
+/* 下面属性少用 */
+#define SPI_CS_HIGH_ACTIVE_		    (0x04)  /*默认为片选低电平有效，即低电平选中片选*/
+#define SPI_LSB_FIRST_ACTIVE_		(0x08)  /*默认为先发送MSB，即先发送最低位*/
+#define SPI_DUMMY_ONE_ACTIVE_        (0x10)  /*默认为接收时spi控制器自动填充0放在txFIFO */
+#define SPI_RECEIVE_ALL_ACTIVE_      (0x20)  /*默认为放弃无用的burst，即发送的时候放弃rxFIFO接收到数据 */
+
+
+#define SUN6I_SPI_ADDR_SIZE		0xFFF
+#define SPI0_BASE_ADDR_START	(AW_SPI0_BASE)
+#define SPI0_BASE_ADDR_END		(SPI0_BASE_ADDR_START + SUN6I_SPI_ADDR_SIZE)
+#define SPI1_BASE_ADDR_START	(AW_SPI1_BASE)
+#define SPI1_BASE_ADDR_END		(SPI1_BASE_ADDR_START + SUN6I_SPI_ADDR_SIZE)
+#define SPI2_BASE_ADDR_START	(AW_SPI2_BASE)
+#define SPI2_BASE_ADDR_END		(SPI2_BASE_ADDR_START + SUN6I_SPI_ADDR_SIZE)
+#define SPI3_BASE_ADDR_START	(AW_SPI3_BASE)
+#define SPI3_BASE_ADDR_END		(SPI3_BASE_ADDR_START + SUN6I_SPI_ADDR_SIZE)
+
+struct sun6i_spi_platform_data {
+    int cs_bitmap; // cs0-0x1,cs1-0x2,cs0&cs1-0x3
+    int num_cs;   // number of cs
+    const char *clk_name; // ahb clk name
+};
+
+/* spi device controller state, alloc */
+struct sun6i_spi_config {
+	int bits_per_word; //8bit
+	int max_speed_hz;  //80MHz
+	int mode; // pha,pol,LSB,etc..
+};
+
+/* spi device data, used in dual spi mode */
+struct sun6i_dual_mode_dev_data {
+	int dual_mode;	//dual SPI mode, 0-single mode, 1-dual mode
+	int single_cnt;	//single mode transmit counter
+	int dummy_cnt;	//dummy counter should be sent before receive in dual mode
+};
+
+#endif
\ No newline at end of file
diff --git a/arch/arm/mach-sun6i/include/mach/sunxi_dump_reg.h b/arch/arm/mach-sun6i/include/mach/sunxi_dump_reg.h
new file mode 100644
index 0000000..a4bc5c5
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/sunxi_dump_reg.h
@@ -0,0 +1,68 @@
+/*
+ * arch/arm/mach-sun6i/include/mach/sunxi_dump_reg.h
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sunxi dump reg head file
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SUNXI_DUMP_REG_H
+#define __SUNXI_DUMP_REG_H
+
+#define MAX_COMPARE_ITEM 	256
+#define MAX_WRITE_ITEM 		256
+
+/**
+ * compare_item - reg compare item struct
+ * @reg_addr:	reg address.
+ * @val_expect: expected value, provided by caller.
+ * @val_mask:   mask value, provided by caller. only mask bits will be compared.
+ */
+struct compare_item {
+	u32 	reg_addr;
+	u32	val_expect;
+	u32	val_mask;
+};
+
+/**
+ * compare_group - reg compare group struct
+ * @num:	pitem element count. cannot exceed MAX_COMPARE_ITEM.
+ * @pitem: 	items that will be compared, provided by caller.
+ */
+struct compare_group {
+	u32	num;
+	struct compare_item *pitem;
+};
+
+/**
+ * write_item - reg write item struct
+ * @reg_addr:	reg address.
+ * @val: 	value to write
+ */
+struct write_item {
+	u32 	reg_addr;
+	u32	val;
+};
+
+/**
+ * write_group - reg write group struct
+ * @num:	pitem element count. cannot exceed MAX_WRITE_ITEM.
+ * @pitem: 	items that will be write, provided by caller.
+ */
+struct write_group {
+	u32	num;
+	struct write_item *pitem;
+};
+
+void sunxi_dump_regs(u32 start_reg, u32 end_reg);
+void sunxi_compare_regs(struct compare_group *pgroup);
+void sunxi_write_regs(struct write_group *pgroup);
+
+#endif /* __SUNXI_DUMP_REG_H */
diff --git a/arch/arm/mach-sun6i/include/mach/sys_config.h b/arch/arm/mach-sun6i/include/mach/sys_config.h
new file mode 100644
index 0000000..22583c9
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/sys_config.h
@@ -0,0 +1,77 @@
+/*
+ * arch/arch/mach-sunxi/include/mach/sys_config.h
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Kevin <Kevin@allwinnertech.com>
+ *
+ * sys_config utils (porting from 2.6.36)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SW_SYS_CONFIG_H
+#define __SW_SYS_CONFIG_H
+
+#include "gpio.h"
+
+/*
+ * define types of script item
+ * @SCIRPT_ITEM_VALUE_TYPE_INVALID:  invalid item type
+ * @SCIRPT_ITEM_VALUE_TYPE_INT: integer item type
+ * @SCIRPT_ITEM_VALUE_TYPE_STR: strint item type
+ * @SCIRPT_ITEM_VALUE_TYPE_PIO: gpio item type
+ */
+typedef enum {
+	SCIRPT_ITEM_VALUE_TYPE_INVALID = 0,
+	SCIRPT_ITEM_VALUE_TYPE_INT,
+	SCIRPT_ITEM_VALUE_TYPE_STR,
+	SCIRPT_ITEM_VALUE_TYPE_PIO,
+} script_item_value_type_e;
+
+
+/*
+ * define data structure script item
+ * @val: integer value for integer type item
+ * @str: string pointer for sting type item
+ * @gpio: gpio config for gpio type item
+ */
+typedef union {
+    int                 val;
+    char                *str;
+    struct gpio_config  gpio;
+} script_item_u;
+
+/*
+ * script_get_item
+ *      get an item from script based on main_key & sub_key
+ * @main_key    main key value in script which is marked by '[]'
+ * @sub_key     sub key value in script which is left of '='
+ * @item        item pointer for return value
+ * @return      type of the item
+ */
+script_item_value_type_e script_get_item(char *main_key, char *sub_key, script_item_u *item);
+
+
+/*
+ * script_get_pio_list
+ *      get gpio list from script baseed on main_key
+ * @main_key    main key value in script which is marked by '[]'
+ * @list        list pointer for return gpio list
+ * @return      count of the gpios
+ */
+int script_get_pio_list(char *main_key, script_item_u **list);
+
+/*
+ * script_dump_mainkey
+ *      dump main_key info
+ * @main_key    main key value in script which is marked by '[]',
+ *              if NULL, dump all main key info in script
+ * @return      0
+ */
+int script_dump_mainkey(char *main_key);
+
+#endif
diff --git a/arch/arm/mach-sun6i/include/mach/system.h b/arch/arm/mach-sun6i/include/mach/system.h
new file mode 100644
index 0000000..0e605e8
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/system.h
@@ -0,0 +1,62 @@
+/*
+ *  arch/arm/mach-sun6i/include/mach/system.h
+ *
+ *  Copyright (C) 2012-2016 Allwinner Limited
+ *  Benn Huang (benn@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+#include <linux/io.h>
+#include <asm/proc-fns.h>
+#include <mach/hardware.h>
+#include <mach/platform.h>
+#include <asm/delay.h>
+#include <asm/io.h>
+#include <linux/kernel.h>
+static inline void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode, const char *cmd)
+{
+	printk("[%s] enter\n", __func__);
+	writel(0, (AW_VIR_R_WDOG_BASE + AW_WDOG0_IRQ_EN_REG));
+	writel(1, (AW_VIR_R_WDOG_BASE + AW_WDOG0_CFG_REG));
+	writel(1, (AW_VIR_R_WDOG_BASE + AW_WDOG0_MODE_REG)); /* interval is 0.5 sec */
+	while(1); /* never return */
+}
+
+/*
+ * define chip version
+ */
+enum sw_ic_ver {
+	MAGIC_VER_NULL      = 0,        /* invalid value            */
+	MAGIC_VER_UNKNOWN   = 1,        /* unknown version          */
+	MAGIC_VER_A31A      = 0xA311,   /* chip version a31 ver. A  */
+	MAGIC_VER_A31B      = 0xA312,   /* chip version a31 ver. B  */
+	MAGIC_VER_A31C      = 0xA313,   /* chip version a31 ver. C  */
+	MAGIC_VER_A31S      = 0xA320,   /* chip version a31s        */
+	MAGIC_VER_A3XP      = 0xA340,   /* chip versiion a3x        */
+};
+enum sw_ic_ver sw_get_ic_ver(void);
+
+#endif
diff --git a/arch/arm/mach-sun6i/include/mach/timer.h b/arch/arm/mach-sun6i/include/mach/timer.h
new file mode 100644
index 0000000..c36c888
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/timer.h
@@ -0,0 +1,40 @@
+/*
+ * arch\arm\mach-sun6i\timer.c
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.reuuimllatech.com>
+ * chenpailin <huangxin@reuuimllatech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __AW_TIMER_H__
+#define __AW_TIMER_H__
+#include <mach/irqs-sun6i.h>
+
+#ifdef CONFIG_AW_ASIC_EVB_PLATFORM
+
+#define AW_CLOCK_SRC (24000000)
+
+#else
+
+#define AW_CLOCK_SRC (32000)
+
+#endif
+
+#define AW_CLOCK_DIV (1)
+
+/*
+* 1 cycle = 1/(AW_CLOCK_SRC)s
+* tickrate= 1cycle* (AW_CLOCK_SRC/(DIV*HZ)
+* TICKRATE = 10ms
+*/
+#define TIMER0_VALUE (AW_CLOCK_SRC / (AW_CLOCK_DIV*100))
+#define CLOCK_TICK_RATE   TIMER0_VALUE
+
+#endif  /* #ifndef __AW_CLOCKSRC_H__ */
diff --git a/arch/arm/mach-sun6i/include/mach/timex.h b/arch/arm/mach-sun6i/include/mach/timex.h
new file mode 100644
index 0000000..1634782
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/timex.h
@@ -0,0 +1,25 @@
+/*
+ *  arch/arm/mach-sun6i/include/mach/timex.h
+ *
+ * Copyright (c) Allwinner.  All rights reserved.
+ * Benn Huang (benn@allwinnertech.com)
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_TIMERX_H
+#define __ASM_ARCH_TIMERX_H
+#include <mach/timer.h>
+#endif
diff --git a/arch/arm/mach-sun6i/include/mach/uncompress.h b/arch/arm/mach-sun6i/include/mach/uncompress.h
new file mode 100644
index 0000000..8f17d76
--- /dev/null
+++ b/arch/arm/mach-sun6i/include/mach/uncompress.h
@@ -0,0 +1,45 @@
+/*
+ *  arch/arm/mach-sun6i/include/mach/uncompress.h
+ *
+ * Copyright (c) Allwinner.  All rights reserved.
+ * Benn Huang (benn@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+#include <mach/platform.h>
+
+static inline unsigned long get_uart_base(void)
+{
+	return IO_ADDRESS(AW_UART0_BASE);
+}
+
+/*
+ * This does not append a newline
+ */
+static inline void putc(int c)
+{
+}
+
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
diff --git a/arch/arm/mach-sun6i/localtimer.c b/arch/arm/mach-sun6i/localtimer.c
new file mode 100644
index 0000000..a9982de
--- /dev/null
+++ b/arch/arm/mach-sun6i/localtimer.c
@@ -0,0 +1,26 @@
+/*
+ *  linux/arch/arm/plat-versatile/localtimer.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/clockchips.h>
+
+#include <asm/smp_twd.h>
+#include <asm/localtimer.h>
+#include <mach/irqs.h>
+
+/*
+ * Setup the local clock events for a CPU.
+ */
+int __cpuinit local_timer_setup(struct clock_event_device *evt)
+{
+	pr_debug("[%s] Not Implemented!\n", __FUNCTION__);
+	return -1;
+}
diff --git a/arch/arm/mach-sun6i/platsmp.c b/arch/arm/mach-sun6i/platsmp.c
new file mode 100644
index 0000000..3a10b80
--- /dev/null
+++ b/arch/arm/mach-sun6i/platsmp.c
@@ -0,0 +1,143 @@
+/*
+ *  linux/arch/arm/mach-sun6i/platsmp.c
+ *
+ *  Copyright (C) 2012-2016 Allwinner Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/jiffies.h>
+#include <linux/smp.h>
+
+#include <mach/hardware.h>
+#include <asm/hardware/gic.h>
+#include <asm/mach-types.h>
+#include <asm/smp_scu.h>
+#include <asm/cacheflush.h>
+#include <asm/smp_plat.h>
+
+#include <mach/platform.h>
+
+#include "core.h"
+
+extern void sun6i_secondary_startup(void);
+
+/*
+ * control for which core is the next to come out of the secondary
+ * boot "holding pen"
+ */
+volatile int pen_release = -1;
+
+
+static DEFINE_SPINLOCK(boot_lock);
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ *
+ * Note: for arch/arm/kernel/setup.csetup_arch(..)
+ */
+static void __iomem *scu_base_addr(void)
+{
+    pr_debug("[%s] enter\n", __FUNCTION__);
+    return __io_address(AW_SCU_BASE);
+}
+
+
+void enable_aw_cpu(int cpu)
+{
+    long paddr;
+    u32 pwr_reg;
+
+    paddr = virt_to_phys(sun6i_secondary_startup);
+    writel(paddr, IO_ADDRESS(AW_R_CPUCFG_BASE) + AW_CPUCFG_P_REG0);
+
+    /* step1: Assert nCOREPORESET LOW and hold L1RSTDISABLE LOW.
+              Ensure DBGPWRDUP is held LOW to prevent any external
+              debug access to the processor.
+    */
+    /* assert cpu core reset */
+    writel(0, IO_ADDRESS(AW_R_CPUCFG_BASE) + CPUX_RESET_CTL(cpu));
+    /* L1RSTDISABLE hold low */
+    pwr_reg = readl(IO_ADDRESS(AW_R_CPUCFG_BASE) + AW_CPUCFG_GENCTL);
+    pwr_reg &= ~(1<<cpu);
+    writel(pwr_reg, IO_ADDRESS(AW_R_CPUCFG_BASE) + AW_CPUCFG_GENCTL);
+    /* DBGPWRDUP hold low */
+    pwr_reg = readl(IO_ADDRESS(AW_R_CPUCFG_BASE) + AW_CPUCFG_DBGCTL1);
+    pwr_reg &= ~(1<<cpu);
+    writel(pwr_reg, IO_ADDRESS(AW_R_CPUCFG_BASE) + AW_CPUCFG_DBGCTL1);
+
+    /* step2: release power clamp */
+    writel(0x00, IO_ADDRESS(AW_R_PRCM_BASE) + AW_CPUX_PWR_CLAMP(cpu));
+    mdelay(10);
+
+    /* step3: clear power-off gating */
+    pwr_reg = readl(IO_ADDRESS(AW_R_PRCM_BASE) + AW_CPU_PWROFF_REG);
+    pwr_reg &= ~(0x00000001<<cpu);
+    writel(pwr_reg, IO_ADDRESS(AW_R_PRCM_BASE) + AW_CPU_PWROFF_REG);
+    mdelay(1);
+
+    /* step4: de-assert core reset */
+    writel(3, IO_ADDRESS(AW_R_CPUCFG_BASE) + CPUX_RESET_CTL(cpu));
+
+    /* step5: assert DBGPWRDUP signal */
+    pwr_reg = readl(IO_ADDRESS(AW_R_CPUCFG_BASE) + AW_CPUCFG_DBGCTL1);
+    pwr_reg |= (1<<cpu);
+    writel(pwr_reg, IO_ADDRESS(AW_R_CPUCFG_BASE) + AW_CPUCFG_DBGCTL1);
+}
+
+void __init smp_init_cpus(void)
+{
+    unsigned int i, ncores;
+
+    ncores =  scu_get_core_count(NULL);
+    pr_debug("[%s] ncores=%d\n", __FUNCTION__, ncores);
+
+    for (i = 0; i < ncores; i++) {
+        set_cpu_possible(i, true);
+    }
+
+    set_smp_cross_call(gic_raise_softirq);
+}
+
+/*
+ * for arch/arm/kernel/smp.c:smp_prepare_cpus(unsigned int max_cpus)
+ */
+void __init platform_smp_prepare_cpus(unsigned int max_cpus)
+{
+    void __iomem *scu_base;
+
+    pr_debug("[%s] enter\n", __FUNCTION__);
+    scu_base = scu_base_addr();
+    scu_enable(scu_base);
+}
+
+/*
+ * for linux/arch/arm/kernel/smp.c:secondary_start_kernel(void)
+ */
+extern int arch_timer_common_register(void);
+void __cpuinit platform_secondary_init(unsigned int cpu)
+{
+    pr_debug("[%s] enter, cpu:%d\n", __FUNCTION__, cpu);
+    gic_secondary_init(0);
+}
+
+/*
+ * for linux/arch/arm/kernel/smp.c:__cpu_up(..)
+ */
+int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+    pr_debug("[%s] enter\n", __FUNCTION__);
+    spin_lock(&boot_lock);
+    enable_aw_cpu(cpu);
+    spin_unlock(&boot_lock);
+    return 0;
+}
diff --git a/arch/arm/mach-sun6i/pm/Makefile b/arch/arm/mach-sun6i/pm/Makefile
new file mode 100644
index 0000000..341e3fe7
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/Makefile
@@ -0,0 +1,22 @@
+
+obj-y	 += pm_tmp.o standby.o mem.o
+pm_tmp-y += ./mem_mapping.o
+pm_tmp-y += ./mem_divlibc.o
+pm_tmp-y += ./mem_cpu.o
+pm_tmp-y += ./mem_cpu_asm.o
+pm_tmp-y += ./mem_mmu_pc_asm.o
+pm_tmp-y += ./mem_mmu_pc.o
+pm_tmp-y += ./mem_int.o
+pm_tmp-y += ./mem_clk.o
+pm_tmp-y += ./mem_tmr.o
+pm_tmp-y += ./mem_twi.o
+pm_tmp-y += ./mem_gpio.o
+pm_tmp-y += ./mem_serial.o
+pm_tmp-y += ./mem_sram.o
+pm_tmp-y += ./mem_ccu.o
+pm_tmp-y += ./pm_debug.o
+pm_tmp-y += ./mem_timing.o
+pm_tmp-y += ./pm.o
+pm_tmp-y += ./standby/super/super_power.o
+pm_tmp-y += ./standby/super/super_twi.o
+pm_tmp-y += ./standby/super/super_clock.o
diff --git a/arch/arm/mach-sun6i/pm/Makefile-for-precompile b/arch/arm/mach-sun6i/pm/Makefile-for-precompile
new file mode 100644
index 0000000..3a0fa39
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/Makefile-for-precompile
@@ -0,0 +1,67 @@
+INCLUDE   = -I. \
+	-I$(KDIR)/include/ \
+	-I$(KDIR)/arch/arm/include/	\
+	-I$(KDIR)/arch/arm/asm-generic/	\
+	-I$(KDIR)/arch/arm/include/generated/	\
+	-I$(KDIR)/arch/arm/mach-sun6i/include/
+
+PM-OBJ	= 	pm_tmp.o 		\
+		standby.o 		\
+		mem.o			\
+		./pm.o                          \
+		./mem_context.o                 \
+		./mem_cpu.o                     \
+		./mem_context_asm.o             \
+		./mem_mmu_pc_asm.o              \
+		./mem_mmu_pc.o                  \
+		./mem_int.o                     \
+		./mem_clk.o                     \
+		./mem_tmr.o                     \
+		./mem_twi.o                     \
+		./mem_gpio.o                    \
+		./mem_serial.o                  \
+		./mem_sram.o                    \
+		./mem_ccu.o                     \
+		./pm_debug.o                    \
+		./standby/super/stack.o         \
+		./standby/super/super_power.o   \
+		./standby/super/super_twi.o     \
+		./standby/super/super_clock.o
+
+STANDBY_OUPUTFILE = pm
+CC = $(CROSS_COMPILE)gcc
+
+CFLAGS = -O0 -g -march=armv7-a -fno-unwind-tables -fno-asynchronous-unwind-tables -mlittle-endian  -E
+all:   pm
+pm:
+	$(CC) $(INCLUDE) $(CFLAGS) 			./standby.S			-o		standby.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./mem.S				-o		mem.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./pm.c				-o		./pm.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./mem_context.c			-o		./mem_context.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./mem_cpu.c			-o		./mem_cpu.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./mem_context_asm.S		-o		./mem_context_asm.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./mem_mmu_pc_asm.S		-o		./mem_mmu_pc_asm.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./mem_mmu_pc.c			-o		./mem_mmu_pc.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./mem_int.c			-o		./mem_int.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./mem_clk.c			-o		./mem_clk.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./mem_tmr.c			-o		./mem_tmr.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./mem_twi.c			-o		./mem_twi.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./mem_gpio.c			-o		./mem_gpio.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./mem_serial.c			-o		./mem_serial.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./mem_sram.c			-o		./mem_sram.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./mem_ccu.c			-o		./mem_ccu.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./pm_debug.c			-o		./pm_debug.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./standby/super/stack.S		-o		./standby/super/stack.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./standby/super/super_power.c	-o		./standby/super/super_power.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./standby/super/super_twi.c	-o		./standby/super/super_twi.o
+	$(CC) $(INCLUDE) $(CFLAGS) 			./standby/super/super_clock.c	-o		./standby/super/super_clock.o
+
+
+	//$(CROSS_COMPILE)ld -T $(STANDBY_LD_FILE)  -EL  $(STANDBY_OBJ) -o $(STANDBY_OUPUTFILE).elf  -Map $(STANDBY_OUPUTFILE).map
+	$(CROSS_COMPILE)objdump -D $(STANDBY_OUPUTFILE).elf > $(STANDBY_OUPUTFILE).lst
+	$(CROSS_COMPILE)objcopy -O binary $(STANDBY_OUPUTFILE).elf $(STANDBY_OUPUTFILE).bin
+
+
+
+	@echo ----------------------------------------
+	@echo well done!
\ No newline at end of file
diff --git a/arch/arm/mach-sun6i/pm/mem.S b/arch/arm/mach-sun6i/pm/mem.S
new file mode 100644
index 0000000..354875e
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem.S
@@ -0,0 +1,7 @@
+	.align	4
+	.globl	resume1_bin_start
+resume1_bin_start:
+	.incbin	"arch/arm/mach-sun6i/pm/standby/super/resume/resume1.code"
+	.globl	resume1_bin_end
+resume1_bin_end:
+	.align	4
diff --git a/arch/arm/mach-sun6i/pm/mem_ccu.c b/arch/arm/mach-sun6i/pm/mem_ccu.c
new file mode 100644
index 0000000..41da8cb
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_ccu.c
@@ -0,0 +1,242 @@
+#include "pm_types.h"
+#include "pm_i.h"
+
+static __ccmu_reg_list_t   CmuReg;
+/*
+*********************************************************************************************************
+*                                       MEM CCU INITIALISE
+*
+* Description: mem interrupt initialise.
+*
+* Arguments  : none.
+*
+* Returns    : 0/-1;
+*********************************************************************************************************
+*/
+__s32 mem_ccu_save(__ccmu_reg_list_t *pReg)
+{
+	// CmuReg.Pll1Ctl      	= pReg->Pll1Ctl;
+	CmuReg.Pll2Ctl      	= pReg->Pll2Ctl;
+	CmuReg.Pll3Ctl      	= pReg->Pll3Ctl;
+	CmuReg.Pll4Ctl      	= pReg->Pll4Ctl;
+	CmuReg.Pll6Ctl      	= pReg->Pll6Ctl;
+	CmuReg.Pll7Ctl      	= pReg->Pll7Ctl;
+	CmuReg.Pll8Ctl      	= pReg->Pll8Ctl;
+	CmuReg.MipiPllCtl   	= pReg->MipiPllCtl;
+	CmuReg.Pll9Ctl      	= pReg->Pll9Ctl;
+	CmuReg.Pll10Ctl      	= pReg->Pll10Ctl;
+
+	CmuReg.SysClkDiv    	= pReg->SysClkDiv;
+	CmuReg.Ahb1Div  	= pReg->Ahb1Div;
+	CmuReg.Apb2Div   	= pReg->Apb2Div;
+	CmuReg.AxiGate      	= pReg->AxiGate;
+	CmuReg.AhbGate0     	= pReg->AhbGate0;
+	CmuReg.AhbGate1     	= pReg->AhbGate1;
+	CmuReg.Apb1Gate     	= pReg->Apb1Gate;
+	CmuReg.Apb2Gate    	= pReg->Apb2Gate;
+	CmuReg.Nand0		= pReg->Nand0;
+	CmuReg.Nand1      	= pReg->Nand1;
+
+	CmuReg.Sd0	    	= pReg->Sd0;
+	CmuReg.Sd1  		= pReg->Sd1;
+	CmuReg.Sd2    		= pReg->Sd2;
+	CmuReg.Sd3    		= pReg->Sd3;
+	CmuReg.Ts		    = pReg->Ts;
+	CmuReg.Ss        	= pReg->Ss;
+	CmuReg.Spi0      	= pReg->Spi0;
+	CmuReg.Spi1      	= pReg->Spi1;
+	CmuReg.Spi2      	= pReg->Spi2;
+	CmuReg.Spi3      	= pReg->Spi3;
+
+	CmuReg.I2s0       	= pReg->I2s0;
+	CmuReg.I2s1       	= pReg->I2s1;
+	CmuReg.Spdif	    	= pReg->Spdif;
+	CmuReg.Usb	      	= pReg->Usb;
+	CmuReg.Mdfs		    = pReg->Mdfs;
+	CmuReg.DramGate     = pReg->DramGate;
+
+	CmuReg.Be0     		= pReg->Be0;
+	CmuReg.Be1    		= pReg->Be1;
+	CmuReg.Fe0    		= pReg->Fe0;
+	CmuReg.Fe1    		= pReg->Fe1;
+	CmuReg.Mp      		= pReg->Mp;
+	CmuReg.Lcd0Ch0   	= pReg->Lcd0Ch0;
+	CmuReg.Lcd1Ch0   	= pReg->Lcd1Ch0;
+	CmuReg.Lcd0Ch1   	= pReg->Lcd0Ch1;
+	CmuReg.Lcd1Ch1   	= pReg->Lcd1Ch1;
+	CmuReg.Csi0      	= pReg->Csi0;
+	CmuReg.Csi1      	= pReg->Csi1;
+	CmuReg.Ve        	= pReg->Ve;
+	CmuReg.Adda      	= pReg->Adda;
+	CmuReg.Avs       	= pReg->Avs;
+	CmuReg.Hdmi      	= pReg->Hdmi;
+	CmuReg.Ps     	 	= pReg->Ps;
+	CmuReg.MtcAcc    	= pReg->MtcAcc;
+
+	CmuReg.MBus0    	= pReg->MBus0;
+	CmuReg.MBus1    	= pReg->MBus1;
+	CmuReg.MipiDsi    	= pReg->MipiDsi;
+	CmuReg.MipiCsi    	= pReg->MipiCsi;
+	CmuReg.IepDrc0		= pReg->IepDrc0;
+	CmuReg.IepDrc1		= pReg->IepDrc1;
+	CmuReg.IepDeu0		= pReg->IepDeu0;
+	CmuReg.IepDeu1		= pReg->IepDeu1;
+
+	CmuReg.GpuCore		= pReg->GpuCore;
+	CmuReg.GpuMem		= pReg->GpuMem;
+	CmuReg.GpuHyd		= pReg->GpuHyd;
+
+    CmuReg.PllLock      = pReg->PllLock;
+    CmuReg.Pll1Lock     = pReg->Pll1Lock;
+    CmuReg.Pll1Bias     = pReg->Pll1Bias;
+    CmuReg.Pll2Bias     = pReg->Pll2Bias;
+    CmuReg.Pll3Bias     = pReg->Pll3Bias;
+    CmuReg.Pll4Bias     = pReg->Pll4Bias;
+    CmuReg.Pll5Bias     = pReg->Pll5Bias;
+    CmuReg.Pll6Bias     = pReg->Pll6Bias;
+    CmuReg.Pll7Bias     = pReg->Pll7Bias;
+    CmuReg.Pll8Bias     = pReg->Pll8Bias;
+    CmuReg.MipiBias     = pReg->MipiBias;
+    CmuReg.Pll9Bias     = pReg->Pll9Bias;
+    CmuReg.Pll10Bias    = pReg->Pll10Bias;
+    CmuReg.Pll1Tune     = pReg->Pll1Tune;
+    CmuReg.Pll5Tune     = pReg->Pll5Tune;
+    CmuReg.MipiTune     = pReg->MipiTune;
+    CmuReg.PLL1Pat      = pReg->PLL1Pat;
+    CmuReg.PLL2Pat      = pReg->PLL2Pat;
+    CmuReg.PLL3Pat      = pReg->PLL3Pat;
+    CmuReg.PLL4Pat      = pReg->PLL4Pat;
+    CmuReg.PLL5Pat      = pReg->PLL5Pat;
+    CmuReg.PLL7Pat      = pReg->PLL7Pat;
+    CmuReg.PLL8Pat      = pReg->PLL8Pat;
+    CmuReg.MipiPat      = pReg->MipiPat;
+    CmuReg.PLL9Pat      = pReg->PLL9Pat;
+    CmuReg.PLL10Pat     = pReg->PLL10Pat;
+
+	CmuReg.AhbReset0	= pReg->AhbReset0;
+	CmuReg.AhbReset1	= pReg->AhbReset1;
+	CmuReg.AhbReset2	= pReg->AhbReset2;
+
+	CmuReg.Apb1Reset	= pReg->Apb1Reset;
+	CmuReg.Apb2Reset	= pReg->Apb2Reset;
+
+	CmuReg.ClkOutA		= pReg->ClkOutA;
+	CmuReg.ClkOutB		= pReg->ClkOutB;
+	CmuReg.ClkOutC		= pReg->ClkOutC;
+
+	return 0;
+}
+
+__s32 mem_ccu_restore(__ccmu_reg_list_t *pReg)
+{
+	// pReg->Pll1Ctl      	= CmuReg.Pll1Ctl;
+	pReg->Pll2Ctl      	= CmuReg.Pll2Ctl;
+	pReg->Pll3Ctl      	= CmuReg.Pll3Ctl;
+	pReg->Pll4Ctl      	= CmuReg.Pll4Ctl;
+	pReg->Pll6Ctl      	= CmuReg.Pll6Ctl;
+	pReg->Pll7Ctl      	= CmuReg.Pll7Ctl;
+	pReg->Pll8Ctl      	= CmuReg.Pll8Ctl;
+	pReg->MipiPllCtl   	= CmuReg.MipiPllCtl;
+	pReg->Pll9Ctl     	= CmuReg.Pll9Ctl;
+	pReg->Pll10Ctl    	= CmuReg.Pll10Ctl;
+
+	pReg->SysClkDiv    	= CmuReg.SysClkDiv;
+	pReg->Ahb1Div  		= CmuReg.Ahb1Div;
+	pReg->Apb2Div   	= CmuReg.Apb2Div;
+	pReg->AxiGate      	= CmuReg.AxiGate;
+	pReg->AhbGate0     	= CmuReg.AhbGate0;
+	pReg->AhbGate1     	= CmuReg.AhbGate1;
+	pReg->Apb1Gate     	= CmuReg.Apb1Gate;
+	pReg->Apb2Gate     	= CmuReg.Apb2Gate;
+	pReg->Nand0		= CmuReg.Nand0;
+	pReg->Nand1      	= CmuReg.Nand1;
+
+	pReg->Sd0	    	= CmuReg.Sd0;
+	pReg->Sd1  		= CmuReg.Sd1;
+	pReg->Sd2    		= CmuReg.Sd2;
+	pReg->Sd3    		= CmuReg.Sd3;
+	pReg->Ts		= CmuReg.Ts;
+	pReg->Ss        	= CmuReg.Ss;
+	pReg->Spi0      	= CmuReg.Spi0;
+	pReg->Spi1      	= CmuReg.Spi1;
+	pReg->Spi2      	= CmuReg.Spi2;
+	pReg->Spi3      	= CmuReg.Spi3;
+
+	pReg->I2s0       	= CmuReg.I2s0;
+	pReg->I2s1       	= CmuReg.I2s1;
+	pReg->Spdif	    	= CmuReg.Spdif;
+	pReg->Usb	      	= CmuReg.Usb;
+	pReg->Mdfs		= CmuReg.Mdfs;
+	pReg->DramGate    	= CmuReg.DramGate;
+
+	pReg->Be0     		= CmuReg.Be0;
+	pReg->Be1    		= CmuReg.Be1;
+	pReg->Fe0    		= CmuReg.Fe0;
+	pReg->Fe1    		= CmuReg.Fe1;
+	pReg->Mp      		= CmuReg.Mp;
+	pReg->Lcd0Ch0   	= CmuReg.Lcd0Ch0;
+	pReg->Lcd1Ch0   	= CmuReg.Lcd1Ch0;
+	pReg->Lcd0Ch1   	= CmuReg.Lcd0Ch1;
+	pReg->Lcd1Ch1   	= CmuReg.Lcd1Ch1;
+	pReg->Csi0      	= CmuReg.Csi0;
+	pReg->Csi1      	= CmuReg.Csi1;
+	pReg->Ve        	= CmuReg.Ve;
+	pReg->Adda      	= CmuReg.Adda;
+	pReg->Avs       	= CmuReg.Avs;
+	pReg->Hdmi      	= CmuReg.Hdmi;
+	pReg->Ps     	 	= CmuReg.Ps;
+	pReg->MtcAcc    	= CmuReg.MtcAcc;
+
+	pReg->MBus0    		= CmuReg.MBus0;
+	pReg->MBus1    		= CmuReg.MBus1;
+	pReg->MipiDsi    	= CmuReg.MipiDsi;
+	pReg->MipiCsi    	= CmuReg.MipiCsi;
+	pReg->IepDrc0		= CmuReg.IepDrc0;
+	pReg->IepDrc1		= CmuReg.IepDrc1;
+	pReg->IepDeu0		= CmuReg.IepDeu0;
+	pReg->IepDeu1		= CmuReg.IepDeu1;
+
+	pReg->GpuCore		= CmuReg.GpuCore;
+	pReg->GpuMem		= CmuReg.GpuMem;
+	pReg->GpuHyd		= CmuReg.GpuHyd;
+
+    pReg->PllLock       = CmuReg.PllLock;
+    pReg->Pll1Lock      = CmuReg.Pll1Lock;
+    pReg->Pll1Bias      = CmuReg.Pll1Bias;
+    pReg->Pll2Bias      = CmuReg.Pll2Bias;
+    pReg->Pll3Bias      = CmuReg.Pll3Bias;
+    pReg->Pll4Bias      = CmuReg.Pll4Bias;
+    pReg->Pll5Bias      = CmuReg.Pll5Bias;
+    pReg->Pll6Bias      = CmuReg.Pll6Bias;
+    pReg->Pll7Bias      = CmuReg.Pll7Bias;
+    pReg->Pll8Bias      = CmuReg.Pll8Bias;
+    pReg->MipiBias      = CmuReg.MipiBias;
+    pReg->Pll9Bias      = CmuReg.Pll9Bias;
+    pReg->Pll10Bias     = CmuReg.Pll10Bias;
+    pReg->Pll1Tune      = CmuReg.Pll1Tune;
+    pReg->Pll5Tune      = CmuReg.Pll5Tune;
+    pReg->MipiTune      = CmuReg.MipiTune;
+    pReg->PLL1Pat       = CmuReg.PLL1Pat;
+    pReg->PLL2Pat       = CmuReg.PLL2Pat;
+    pReg->PLL3Pat       = CmuReg.PLL3Pat;
+    pReg->PLL4Pat       = CmuReg.PLL4Pat;
+    pReg->PLL5Pat       = CmuReg.PLL5Pat;
+    pReg->PLL7Pat       = CmuReg.PLL7Pat;
+    pReg->PLL8Pat       = CmuReg.PLL8Pat;
+    pReg->MipiPat       = CmuReg.MipiPat;
+    pReg->PLL9Pat       = CmuReg.PLL9Pat;
+    pReg->PLL10Pat      = CmuReg.PLL10Pat;
+
+	pReg->AhbReset0		= CmuReg.AhbReset0;
+	pReg->AhbReset1		= CmuReg.AhbReset1;
+	pReg->AhbReset2		= CmuReg.AhbReset2;
+
+	pReg->Apb1Reset		= CmuReg.Apb1Reset;
+	pReg->Apb2Reset		= CmuReg.Apb2Reset;
+
+	pReg->ClkOutA		= CmuReg.ClkOutA;
+	pReg->ClkOutB		= CmuReg.ClkOutB;
+	pReg->ClkOutC		= CmuReg.ClkOutC;
+
+	return 0;
+}
diff --git a/arch/arm/mach-sun6i/pm/mem_clk.c b/arch/arm/mach-sun6i/pm/mem_clk.c
new file mode 100644
index 0000000..64d8464
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_clk.c
@@ -0,0 +1,327 @@
+#ifdef __STANDBY_MODULE__
+#include "pm_types.h"
+#include "pm.h"
+
+#elif defined(__KERNEL__)
+#include <linux/delay.h>
+#include "pm_i.h"
+#endif
+
+//#define CHECK_RESTORE_STATUS
+static __ccmu_reg_list_t   *CmuReg;
+
+
+/*
+*********************************************************************************************************
+*                           mem_clk_save
+*
+*Description: save ccu for platform mem
+*
+*Arguments  : none
+*
+*Return     : result,
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 mem_clk_save(struct clk_state *pclk_state)
+{
+	pclk_state->CmuReg = CmuReg = (__ccmu_reg_list_t *)IO_ADDRESS(AW_CCM_BASE);
+
+	/*backup clk src and ldo*/
+	pclk_state->ccu_reg_back[0] = *(volatile __u32 *)&CmuReg->SysClkDiv;
+	pclk_state->ccu_reg_back[1] = *(volatile __u32 *)&CmuReg->Apb2Div;
+	pclk_state->ccu_reg_back[2] = *(volatile __u32 *)&CmuReg->Ahb1Div;
+
+	/* backup pll registers and tuning?*/
+	pclk_state->ccu_reg_back[3] = *(volatile __u32 *)&CmuReg->Pll1Ctl;
+	pclk_state->ccu_reg_back[4] = *(volatile __u32 *)&CmuReg->Pll2Ctl;
+	pclk_state->ccu_reg_back[5] = *(volatile __u32 *)&CmuReg->Pll3Ctl;
+	pclk_state->ccu_reg_back[6] = *(volatile __u32 *)&CmuReg->Pll4Ctl;
+	pclk_state->ccu_reg_back[7] = *(volatile __u32 *)&CmuReg->Pll5Ctl;
+	pclk_state->ccu_reg_back[8] = *(volatile __u32 *)&CmuReg->Pll6Ctl;
+	pclk_state->ccu_reg_back[9] = *(volatile __u32 *)&CmuReg->Pll7Ctl;
+
+	/*backup axi, ahb, apb gating*/
+	pclk_state->ccu_reg_back[10] = *(volatile __u32 *)&CmuReg->AxiGate;
+	pclk_state->ccu_reg_back[11] = *(volatile __u32 *)&CmuReg->AhbGate0;
+	pclk_state->ccu_reg_back[12] = *(volatile __u32 *)&CmuReg->AhbGate1;
+	pclk_state->ccu_reg_back[13] = *(volatile __u32 *)&CmuReg->Apb1Gate;
+	pclk_state->ccu_reg_back[14] = *(volatile __u32 *)&CmuReg->Apb2Gate;
+
+	return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mem_clk_exit
+*
+*Description: restore ccu for platform mem
+*
+*Arguments  : none
+*
+*Return     : result,
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 mem_clk_restore(struct clk_state *pclk_state)
+{
+	/* initialise the CCU io base */
+	CmuReg = pclk_state->CmuReg;
+
+
+	/*restore clk src and ldo*/
+	*(volatile __u32 *)&CmuReg->SysClkDiv    = pclk_state->ccu_reg_back[0];
+#ifdef CHECK_RESTORE_STATUS
+	printk("*(volatile __u32 *)&CmuReg->SysClkDiv = 0x%x, pclk_state->ccu_reg_back[0] = 0x%x. \n", \
+		*(volatile __u32 *)&CmuReg->SysClkDiv, pclk_state->ccu_reg_back[0]);
+#endif
+
+
+	*(volatile __u32 *)&CmuReg->Apb2Div  = pclk_state->ccu_reg_back[1];
+#ifdef CHECK_RESTORE_STATUS
+	printk("*(volatile __u32 *)&CmuReg->Apb2Div = 0x%x, pclk_state->ccu_reg_back[1] = 0x%x. \n", \
+		*(volatile __u32 *)&CmuReg->Apb2Div, pclk_state->ccu_reg_back[1]);
+#endif
+
+	save_mem_status(LATE_RESUME_START |0x43);
+
+	*(volatile __u32 *)&CmuReg->Ahb1Div = pclk_state->ccu_reg_back[2];
+#ifdef CHECK_RESTORE_STATUS
+	printk("*(volatile __u32 *)&CmuReg->Ahb1Div = 0x%x, pclk_state->ccu_reg_back[2] = 0x%x. \n", \
+		*(volatile __u32 *)&CmuReg->Ahb1Div, pclk_state->ccu_reg_back[2]);
+#endif
+
+	/*restore axi, ahb, apb gating*/
+	*(volatile __u32 *)&CmuReg->AxiGate    = pclk_state->ccu_reg_back[10];
+#ifdef CHECK_RESTORE_STATUS
+	printk("*(volatile __u32 *)&CmuReg->AxiGate = 0x%x, pclk_state->ccu_reg_back[10] = 0x%x. \n", \
+		*(volatile __u32 *)&CmuReg->AxiGate, pclk_state->ccu_reg_back[10]);
+#endif
+
+
+	*(volatile __u32 *)&CmuReg->AhbGate0   = pclk_state->ccu_reg_back[11];
+#ifdef CHECK_RESTORE_STATUS
+	printk("*(volatile __u32 *)&CmuReg->AhbGate0 = 0x%x, pclk_state->ccu_reg_back[11] = 0x%x. \n", \
+		*(volatile __u32 *)&CmuReg->AhbGate0, pclk_state->ccu_reg_back[11]);
+#endif
+
+
+	*(volatile __u32 *)&CmuReg->AhbGate1   = pclk_state->ccu_reg_back[12];
+#ifdef CHECK_RESTORE_STATUS
+	printk("*(volatile __u32 *)&CmuReg->AhbGate1 = 0x%x, pclk_state->ccu_reg_back[12] = 0x%x. \n", \
+		*(volatile __u32 *)&CmuReg->AhbGate1, pclk_state->ccu_reg_back[12]);
+#endif
+
+
+	*(volatile __u32 *)&CmuReg->Apb1Gate   = pclk_state->ccu_reg_back[13];
+#ifdef CHECK_RESTORE_STATUS
+	printk("*(volatile __u32 *)&CmuReg->Apb0Gate = 0x%x, pclk_state->ccu_reg_back[13] = 0x%x. \n", \
+		*(volatile __u32 *)&CmuReg->Apb1Gate, pclk_state->ccu_reg_back[13]);
+#endif
+
+	save_mem_status(LATE_RESUME_START |0x48);
+
+	*(volatile __u32 *)&CmuReg->Apb2Gate   = pclk_state->ccu_reg_back[14];
+#ifdef CHECK_RESTORE_STATUS
+	printk("*(volatile __u32 *)&CmuReg->Apb1Gate = 0x%x, pclk_state->ccu_reg_back[14] = 0x%x. \n", \
+		*(volatile __u32 *)&CmuReg->Apb2Gate, pclk_state->ccu_reg_back[14]);
+#endif
+
+	save_mem_status(LATE_RESUME_START |0x49);
+	/* restore pll registers and tuning? latency?*/
+	//notice: do not touch pll1 and pll5
+	//*(volatile __u32 *)&CmuReg->Pll1Ctl    = pclk_state->ccu_reg_back[3];
+#ifdef CHECK_RESTORE_STATUS
+	printk("*(volatile __u32 *)&CmuReg->Pll1Ctl = 0x%x, pclk_state->ccu_reg_back[3] = 0x%x. \n", \
+		*(volatile __u32 *)&CmuReg->Pll1Ctl, pclk_state->ccu_reg_back[3]);
+#endif
+
+	save_mem_status(LATE_RESUME_START |0x50);
+	*(volatile __u32 *)&CmuReg->Pll2Ctl    = pclk_state->ccu_reg_back[4];
+#ifdef CHECK_RESTORE_STATUS
+	printk("*(volatile __u32 *)&CmuReg->Pll2Ctl = 0x%x, pclk_state->ccu_reg_back[4] = 0x%x. \n", \
+		*(volatile __u32 *)&CmuReg->Pll2Ctl, pclk_state->ccu_reg_back[4]);
+#endif
+	save_mem_status(LATE_RESUME_START |0x51);
+	*(volatile __u32 *)&CmuReg->Pll3Ctl    = pclk_state->ccu_reg_back[5];
+#ifdef CHECK_RESTORE_STATUS
+	printk("*(volatile __u32 *)&CmuReg->Pll3Ctl = 0x%x, pclk_state->ccu_reg_back[5] = 0x%x. \n", \
+		*(volatile __u32 *)&CmuReg->Pll3Ctl, pclk_state->ccu_reg_back[5]);
+#endif
+	save_mem_status(LATE_RESUME_START |0x52);
+	*(volatile __u32 *)&CmuReg->Pll4Ctl    = pclk_state->ccu_reg_back[6];
+#ifdef CHECK_RESTORE_STATUS
+	printk("*(volatile __u32 *)&CmuReg->Pll4Ctl = 0x%x, pclk_state->ccu_reg_back[6] = 0x%x. \n", \
+		*(volatile __u32 *)&CmuReg->Pll4Ctl, pclk_state->ccu_reg_back[6]);
+#endif
+
+	//*(volatile __u32 *)&CmuReg->Pll5Ctl    = pclk_state->ccu_reg_back[7];
+#ifdef CHECK_RESTORE_STATUS
+	printk("*(volatile __u32 *)&CmuReg->Pll5Ctl = 0x%x, pclk_state->ccu_reg_back[7] = 0x%x. \n", \
+		*(volatile __u32 *)&CmuReg->Pll5Ctl, pclk_state->ccu_reg_back[7]);
+#endif
+	save_mem_status(LATE_RESUME_START |0x53);
+	*(volatile __u32 *)&CmuReg->Pll6Ctl    = pclk_state->ccu_reg_back[8];
+#ifdef CHECK_RESTORE_STATUS
+	printk("*(volatile __u32 *)&CmuReg->Pll6Ctl = 0x%x, pclk_state->ccu_reg_back[8] = 0x%x. \n", \
+		*(volatile __u32 *)&CmuReg->Pll6Ctl, pclk_state->ccu_reg_back[8]);
+#endif
+
+	save_mem_status(LATE_RESUME_START |0x54);
+	*(volatile __u32 *)&CmuReg->Pll7Ctl    = pclk_state->ccu_reg_back[9];
+#ifdef CHECK_RESTORE_STATUS
+	printk("*(volatile __u32 *)&CmuReg->Pll7Ctl = 0x%x, pclk_state->ccu_reg_back[9] = 0x%x. \n", \
+		*(volatile __u32 *)&CmuReg->Pll7Ctl, pclk_state->ccu_reg_back[9]);
+#endif
+
+	//is this neccessary?
+	// mdelay(2);
+
+	/* config the CCU to default status */
+	//needed?
+#if 0
+	if(MAGIC_VER_C == sw_get_ic_ver()) {
+		/* switch PLL4 to PLL6 */
+		#if(USE_PLL6M_REPLACE_PLL4)
+		CmuReg->VeClk.PllSwitch = 1;
+		#else
+		CmuReg->VeClk.PllSwitch = 0;
+		#endif
+	}
+#endif
+	save_mem_status(LATE_RESUME_START |0x55);
+
+	return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mem_clk_init
+*
+*Description: ccu init for platform mem
+*
+*Arguments  : none
+*
+*Return     : result,
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__ccmu_reg_list_t * mem_clk_init(__u32 mmu_flag )
+{
+	if(1 == mmu_flag){
+		CmuReg = (__ccmu_reg_list_t *)IO_ADDRESS(AW_CCM_BASE);
+	}else{
+		CmuReg = (__ccmu_reg_list_t *)(AW_CCM_BASE);
+	}
+
+	return CmuReg;
+}
+
+/*
+*********************************************************************************************************
+*                                     mem_clk_setdiv
+*
+* Description: set div ratio
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 mem_clk_setdiv(struct clk_div_t *clk_div)
+{
+	if(!clk_div)
+	{
+		return -1;
+	}
+
+	CmuReg = (__ccmu_reg_list_t *)(AW_CCM_BASE);
+
+	//set axi ratio
+	CmuReg->SysClkDiv.AXIClkDiv = clk_div->axi_div;
+	//set ahb1/apb1 clock divide ratio
+	*(volatile __u32 *)(&CmuReg->Ahb1Div) = clk_div->ahb_apb_div;
+
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                     mem_clk_getdiv
+*
+* Description:
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+__s32 mem_clk_getdiv(struct clk_div_t  *clk_div)
+{
+	if(!clk_div)
+	{
+		return -1;
+	}
+
+	clk_div->axi_div = CmuReg->SysClkDiv.AXIClkDiv;
+	clk_div->ahb_apb_div = *(volatile __u32 *)(&CmuReg->Ahb1Div);
+
+	return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     mem_clk_set_pll_factor
+*
+* Description: set pll factor, target cpu freq is ?M hz
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+
+__s32 mem_clk_set_pll_factor(struct pll_factor_t *pll_factor)
+{
+	CmuReg = (__ccmu_reg_list_t *)(AW_CCM_BASE);
+	//set pll factor: notice: when raise freq, N must be the last to set
+	CmuReg->Pll1Ctl.FactorK = pll_factor->FactorK;
+	CmuReg->Pll1Ctl.FactorM = pll_factor->FactorM;
+	CmuReg->Pll1Ctl.FactorN = pll_factor->FactorN;
+	//need delay?
+	//busy_waiting();
+
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                     mem_clk_get_pll_factor
+*
+* Description: get pll factor
+*
+* Arguments  : none
+*
+* Returns    : 0;
+*********************************************************************************************************
+*/
+
+__s32 mem_clk_get_pll_factor(struct pll_factor_t *pll_factor)
+{
+	pll_factor->FactorN = CmuReg->Pll1Ctl.FactorN;
+	pll_factor->FactorK = CmuReg->Pll1Ctl.FactorK;
+	pll_factor->FactorM = CmuReg->Pll1Ctl.FactorM;
+
+	//busy_waiting();
+
+	return 0;
+}
diff --git a/arch/arm/mach-sun6i/pm/mem_clk.h b/arch/arm/mach-sun6i/pm/mem_clk.h
new file mode 100644
index 0000000..b21c081
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_clk.h
@@ -0,0 +1,51 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2011-2015, gq.yang China
+*                                             All Rights Reserved
+*
+* File    : mem_clk.h
+* By      : gq.yang
+* Version : v1.0
+* Date    : 2012-11-31 15:23
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __MEM_CLK_H__
+#define __MEM_CLK_H__
+
+#include <mach/ccmu.h>
+
+struct clk_state{
+	__ccmu_reg_list_t   *CmuReg;
+	__u32    ccu_reg_back[15];
+};
+
+struct clk_div_t {
+	__u32	axi_div;      /* division of axi clock, divide cpu clock*/
+	__u32	ahb_apb_div;	/* ahb1/apb1 clock divide ratio */
+};
+
+struct pll_factor_t {
+    __u8    FactorN;
+    __u8    FactorK;
+    __u8    FactorM;
+    __u8    FactorP;
+    __u32   Pll;
+};
+
+__s32 mem_clk_save(struct clk_state *pclk_state);
+__s32 mem_clk_restore(struct clk_state *pclk_state);
+
+__ccmu_reg_list_t * mem_clk_init(__u32 mmu_flag);
+__s32 mem_clk_setdiv(struct clk_div_t *clk_div);
+__s32 mem_clk_getdiv(struct clk_div_t  *clk_div);
+__s32 mem_clk_set_pll_factor(struct pll_factor_t *pll_factor);
+__s32 mem_clk_get_pll_factor(struct pll_factor_t *pll_factor);
+
+
+#endif  //__MEM_CLK_H__
diff --git a/arch/arm/mach-sun6i/pm/mem_cpu.c b/arch/arm/mach-sun6i/pm/mem_cpu.c
new file mode 100644
index 0000000..b7767cd
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_cpu.c
@@ -0,0 +1,519 @@
+/*
+ * Hibernation support specific for ARM
+ *
+ * Copyright (C) 2010 Nokia Corporation
+ * Copyright (C) 2010 Texas Instruments, Inc.
+ * Copyright (C) 2006 Rafael J. Wysocki <rjw <at> sisk.pl>
+ *
+ * Contact: Hiroshi DOYU <Hiroshi.DOYU <at> nokia.com>
+ *
+ * License terms: GNU General Public License (GPL) version 2
+ */
+#include "pm_types.h"
+#include "./pm.h"
+
+/* Used in mem_cpu_asm.S */
+#define SYS_CONTEXT_SIZE (2)
+#define SVC_CONTEXT_SIZE (2)	//do not need backup r14? reason?
+#define FIQ_CONTEXT_SIZE (7)
+#define ABT_CONTEXT_SIZE (2 )
+#define IRQ_CONTEXT_SIZE (2)
+#define UND_CONTEXT_SIZE (2)
+#define MON_CONTEXT_SIZE (2)
+
+#define EMPTY_CONTEXT_SIZE (11 * sizeof(__u32))
+
+
+unsigned long saved_context_r13_sys[SYS_CONTEXT_SIZE];
+unsigned long saved_cpsr_svc;
+unsigned long saved_context_r12_svc[SVC_CONTEXT_SIZE];
+unsigned long saved_spsr_svc;
+unsigned long saved_context_r13_fiq[FIQ_CONTEXT_SIZE];
+unsigned long saved_spsr_fiq;
+unsigned long saved_context_r13_abt[ABT_CONTEXT_SIZE];
+unsigned long saved_spsr_abt;
+unsigned long saved_context_r13_irq[IRQ_CONTEXT_SIZE];
+unsigned long saved_spsr_irq;
+unsigned long saved_context_r13_und[UND_CONTEXT_SIZE];
+unsigned long saved_spsr_und;
+unsigned long saved_context_r13_mon[MON_CONTEXT_SIZE];
+unsigned long saved_spsr_mon;
+unsigned long saved_empty_context_svc[EMPTY_CONTEXT_SIZE];
+
+struct saved_context saved_context;
+
+static struct saved_context default_copro_value = {
+	/* CR0 */
+	.cssr = 0x00000002,		 /* Cache Size Selection */
+	/* CR1 */
+#ifdef CORTEX_A8
+	.cr = 0x00C52078,		/* Control */
+	.acr = 0x00000002,		/* Auxiliary Control Register*/
+	.cacr = 0x00000000,		/* Coprocessor Access Control */
+	.sccfgr = 0x00000000,		/* Secure Config Register*/
+	.scdbgenblr = 0x00000000,	/* Secure Debug Enable Register*/
+	.nonscacctrlr= 0x00000000,	/* Nonsecure Access Control Register*/
+#elif defined(CORTEX_A9)
+#elif defined(CORTEX_A7)
+	.cr = 0x00C50878,		/* Control */
+	.acr = 0x00006040,		/* Auxiliary Control Register: needed for smp*/
+	.cacr = 0x00000000,		/* Coprocessor Access Control */
+	.sccfgr = 0x00000000,		/* Secure Config Register*/
+	.scdbgenblr = 0x00000000,	/* Secure Debug Enable Register*/
+	.nonscacctrlr= 0x00000000,	/* Nonsecure Access Control Register*/
+#endif
+
+	/* CR2 */
+	.ttb_0r = 0x00000000,		/* Translation Table Base 0 */
+	.ttb_1r = 0x00000000,		/* Translation Table Base 1 */
+	.ttbcr = 0x00000000,		/* Translation Talbe Base Control */
+	/* CR3 */
+	.dacr = 0x00000000,		/* Domain Access Control */
+	/* CR5 */
+	.d_fsr = 0x00000000,		/* Data Fault Status */
+	.i_fsr = 0x00000000,		/* Instruction Fault Status */
+	.d_afsr = 0x00000000, 		/* Data Auxilirary Fault Status */
+	.i_afsr = 0x00000000,		/* Instruction Auxilirary Fault Status */
+	/* CR6 */
+	.d_far = 0x00000000,		/* Data Fault Address */
+	.i_far = 0x00000000,		/* Instruction Fault Address */
+	/* CR7 */
+	.par = 0x00000000,		/* Physical Address */
+	/* CR9 */				/* FIXME: Are they necessary? */
+	.pmcontrolr = 0x00000000,	/* Performance Monitor Control */
+	.cesr = 0x00000000,		/* Count Enable Set */
+	.cecr = 0x00000000,		/* Count Enable Clear */
+	.ofsr = 0x00000000,		/* Overflow Flag Status */
+#ifdef CORTEX_A8
+	.sir = 0x00000000,		/* Software Increment */
+#elif defined(CORTEX_A7)
+	.sir = 0x00000000,		/* Software Increment */
+#endif
+	.pcsr = 0x00000000,		/* Performance Counter Selection */
+	.ccr = 0x00000000,		/* Cycle Count */
+	.esr = 0x00000000,		/* Event Selection */
+	.pmcountr = 0x00000000,		/* Performance Monitor Count */
+	.uer = 0x00000000,		/* User Enable */
+	.iesr = 0x00000000,		/* Interrupt Enable Set */
+	.iecr = 0x00000000,		/* Interrupt Enable Clear */
+#ifdef CORTEX_A8
+	.l2clr = 0x00000000,		/* L2 Cache Lockdown */
+	.l2cauxctrlr = 0x00000042, 	/* L2 Cache Auxiliary Control */
+#elif defined(CORTEX_A7)
+#endif
+
+	/* CR10 */
+#ifdef CORTEX_A8
+	.d_tlblr = 0x00000000,		/* Data TLB Lockdown Register */
+	.i_tlblr = 0x00000000,		/* Instruction TLB Lockdown Register */
+#elif defined(CORTEX_A7)
+#endif
+	.prrr = 0x000A81A4,		/* Primary Region Remap Register: tex[0], c, b = 010, + A => normal memory
+					*                        tex[0], c, b = 100 || 101, + 1 => strong order or device
+					*/
+	.nrrr = 0x44E048E0,		/* Normal Memory Remap Register */
+	//.prrr = 0xFF0A81A8,		/* Primary Region Remap Register */
+	//.nrrr = 0x40E040E0,		/* Normal Memory Remap Register */
+	/* CR11 */
+#ifdef CORTEX_A8
+	.pleuar = 0x00000000,		/* PLE User Accessibility */
+	.plecnr = 0x00000000,		/* PLE Channel Number */
+	.plecr = 0x00000000,		/* PLE Control */
+	.pleisar = 0x00000000,		/* PLE Internal Start Address */
+	.pleiear = 0x00000000,		/* PLE Internal End Address */
+	.plecidr = 0x00000000,		/* PLE Context ID */
+#elif defined(CORTEX_A7)
+#endif
+
+	/* CR12 */
+#ifdef CORTEX_A8
+	.snsvbar = 0x00000000,		/* Secure or Nonsecure Vector Base Address */
+	.monvecbar = 0x00000000,	/*Monitor Vector Base*/
+#elif defined(CORTEX_A9)
+#elif defined(CORTEX_A7)
+
+#endif
+
+	/* CR13 */
+	.fcse = 0x00000000,		/* FCSE PID */
+	.cid = 0x00000000,		/* Context ID */
+	.urwtpid = 0x00000000,		/* User read/write Thread and Process ID */
+	.urotpid = 0x00000000,		/* User read-only Thread and Process ID */
+	.potpid = 0x00000000,		/* Privileged only Thread and Process ID */
+
+};
+
+/*__save_processor_state: store the co-processor state into to location point by ctxt
+*@ctxt: indicate where to store co-processor state.
+*/
+void __save_processor_state(struct saved_context *ctxt)
+{
+	/* CR0 */
+	//save_mem_status(0x101);
+	//busy_waiting();
+	asm volatile ("mrc p15, 2, %0, c0, c0, 0" : "=r"(ctxt->cssr));
+
+	/* CR1 */
+#ifdef CORTEX_A8
+	//save_mem_status(0x102);
+	//busy_waiting();
+	asm volatile ("mrc p15, 0, %0, c1, c0, 0" : "=r"(ctxt->cr));
+	asm volatile ("mrc p15, 0, %0, c1, c0, 2" : "=r"(ctxt->cacr));
+#elif defined(CORTEX_A9)
+	asm volatile ("mrc p15, 0, %0, c1, c0, 0" : "=r"(ctxt->cr));
+	//busy_waiting();
+	asm volatile ("mrc p15, 0, %0, c1, c0, 1" : "=r"(ctxt->actlr));
+	asm volatile ("mrc p15, 0, %0, c1, c0, 2" : "=r"(ctxt->cacr));
+	asm volatile ("mrc p15, 0, %0, c1, c1, 1" : "=r"(ctxt->sder));
+	asm volatile ("mrc p15, 0, %0, c1, c1, 3" : "=r"(ctxt->vcr));
+#elif defined(CORTEX_A7)
+	asm volatile ("mrc p15, 0, %0, c1, c0, 0" : "=r"(ctxt->cr));
+	asm volatile ("mrc p15, 0, %0, c1, c0, 2" : "=r"(ctxt->cacr));
+#endif
+
+	/* CR2 */
+	//save_mem_status(0x103);
+	//busy_waiting();
+	asm volatile ("mrc p15, 0, %0, c2, c0, 0" : "=r"(ctxt->ttb_0r));
+	asm volatile ("mrc p15, 0, %0, c2, c0, 1" : "=r"(ctxt->ttb_1r));
+	asm volatile ("mrc p15, 0, %0, c2, c0, 2" : "=r"(ctxt->ttbcr));
+	/* CR3 */
+	//save_mem_status(0x104);
+	//busy_waiting();
+	asm volatile ("mrc p15, 0, %0, c3, c0, 0" : "=r"(ctxt->dacr));
+	/* CR5 */
+	//save_mem_status(0x105);
+	//busy_waiting();
+	asm volatile ("mrc p15, 0, %0, c5, c0, 0" : "=r"(ctxt->d_fsr));
+	asm volatile ("mrc p15, 0, %0, c5, c0, 1" : "=r"(ctxt->i_fsr));
+	asm volatile ("mrc p15, 0, %0, c5, c1, 0" : "=r"(ctxt->d_afsr));
+	asm volatile ("mrc p15, 0, %0, c5, c1, 1" : "=r"(ctxt->i_afsr));
+	//save_mem_status(0x106);
+	//busy_waiting();
+	/* CR6 */
+	asm volatile ("mrc p15, 0, %0, c6, c0, 0" : "=r"(ctxt->d_far));
+	asm volatile ("mrc p15, 0, %0, c6, c0, 2" : "=r"(ctxt->i_far));
+	/* CR7 */
+	//save_mem_status(0x107);
+	//busy_waiting();
+	asm volatile ("mrc p15, 0, %0, c7, c4, 0" : "=r"(ctxt->par));
+	/* CR9 */
+	//save_mem_status(0x108);
+	//busy_waiting();
+	asm volatile ("mrc p15, 0, %0, c9, c12, 0" : "=r"(ctxt->pmcontrolr));
+	asm volatile ("mrc p15, 0, %0, c9, c12, 1" : "=r"(ctxt->cesr));
+	asm volatile ("mrc p15, 0, %0, c9, c12, 2" : "=r"(ctxt->cecr));
+	asm volatile ("mrc p15, 0, %0, c9, c12, 3" : "=r"(ctxt->ofsr));
+#ifdef CORTEX_A8
+	//save_mem_status(0x109);
+	//busy_waiting();
+	//asm volatile ("mrc p15, 0, %0, c9, c12, 4" : "=r"(ctxt->sir));
+#elif defined(CORTEX_A7)
+	//busy_waiting();
+	//asm volatile ("mrc p15, 0, %0, c9, c12, 4" : "=r"(ctxt->sir));
+#endif
+	//save_mem_status(0x10a);
+	//busy_waiting();
+	asm volatile ("mrc p15, 0, %0, c9, c12, 5" : "=r"(ctxt->pcsr));
+	asm volatile ("mrc p15, 0, %0, c9, c13, 0" : "=r"(ctxt->ccr));
+	asm volatile ("mrc p15, 0, %0, c9, c13, 1" : "=r"(ctxt->esr));
+	asm volatile ("mrc p15, 0, %0, c9, c13, 2" : "=r"(ctxt->pmcountr));
+	asm volatile ("mrc p15, 0, %0, c9, c14, 0" : "=r"(ctxt->uer));
+	asm volatile ("mrc p15, 0, %0, c9, c14, 1" : "=r"(ctxt->iesr));
+	asm volatile ("mrc p15, 0, %0, c9, c14, 2" : "=r"(ctxt->iecr));
+#ifdef CORTEX_A8
+	//save_mem_status(0x10b);
+	//busy_waiting();
+	asm volatile ("mrc p15, 1, %0, c9, c0, 0" : "=r"(ctxt->l2clr));
+	asm volatile ("mrc p15, 1, %0, c9, c0, 2" : "=r"(ctxt->l2cauxctrlr));
+#elif defined(CORTEX_A7)
+#endif
+
+	/* CR10 */
+#ifdef CORTEX_A8
+	//save_mem_status(0x10c);
+	//busy_waiting();
+	asm volatile ("mrc p15, 0, %0, c10, c0, 0" : "=r"(ctxt->d_tlblr));
+	//save_mem_status(0x10d);
+	//busy_waiting();
+	asm volatile ("mrc p15, 0, %0, c10, c0, 1" : "=r"(ctxt->i_tlblr));
+#elif defined(CORTEX_A7)
+
+#endif
+	asm volatile ("mrc p15, 0, %0, c10, c2, 0" : "=r"(ctxt->prrr));
+	asm volatile ("mrc p15, 0, %0, c10, c2, 1" : "=r"(ctxt->nrrr));
+
+	/* CR11 */
+#ifdef CORTEX_A8
+	asm volatile ("mrc p15, 0, %0, c11, c1, 0" : "=r"(ctxt->pleuar));
+	asm volatile ("mrc p15, 0, %0, c11, c2, 0" : "=r"(ctxt->plecnr));
+	asm volatile ("mrc p15, 0, %0, c11, c4, 0" : "=r"(ctxt->plecr));
+	asm volatile ("mrc p15, 0, %0, c11, c5, 0" : "=r"(ctxt->pleisar));
+	asm volatile ("mrc p15, 0, %0, c11, c7, 0" : "=r"(ctxt->pleiear));
+	asm volatile ("mrc p15, 0, %0, c11, c15, 0" : "=r"(ctxt->plecidr));
+#elif defined(CORTEX_A7)
+#endif
+
+	/* CR12 */
+#ifdef CORTEX_A8
+	asm volatile ("mrc p15, 0, %0, c12, c0, 0" : "=r"(ctxt->snsvbar));
+	asm volatile ("mrc p15, 0, %0, c12, c0, 1" : "=r"(ctxt->monvecbar));
+#elif defined(CORTEX_A9)
+	asm volatile ("mrc p15, 0, %0, c12, c0, 0" : "=r"(ctxt->vbar));
+	asm volatile ("mrc p15, 0, %0, c12, c0, 1" : "=r"(ctxt->mvbar));
+	asm volatile ("mrc p15, 0, %0, c12, c1, 1" : "=r"(ctxt->vir));
+#elif defined(CORTEX_A7)
+	asm volatile ("mrc p15, 0, %0, c12, c0, 0" : "=r"(ctxt->vbar));
+	asm volatile ("mrc p15, 0, %0, c12, c0, 1" : "=r"(ctxt->mvbar));
+	//asm volatile ("mrc p15, 0, %0, c12, c1, 0" : "=r"(ctxt->isr));
+#endif
+
+	/* CR13 */
+	//save_mem_status(0x10e);
+	//busy_waiting();
+	//asm volatile ("mrc p15, 0, %0, c13, c0, 0" : "=r"(ctxt->fcse));
+	asm volatile ("mrc p15, 0, %0, c13, c0, 1" : "=r"(ctxt->cid));
+	asm volatile ("mrc p15, 0, %0, c13, c0, 2" : "=r"(ctxt->urwtpid));
+	asm volatile ("mrc p15, 0, %0, c13, c0, 3" : "=r"(ctxt->urotpid));
+	asm volatile ("mrc p15, 0, %0, c13, c0, 4" : "=r"(ctxt->potpid));
+	/* CR15*/
+#ifdef CORTEX_A9
+	//save_mem_status(0x10f);
+	//busy_waiting();
+	asm volatile ("mrc p15, 5, %0, c15, c7, 2" : "=r"(ctxt->mtlbar));
+#endif
+}
+
+/*__restore_processor_state: restore the co-processor state according the info point by ctxt
+*@ctxt: indicate where to get the backuped co-processor state.
+*/
+void __restore_processor_state(struct saved_context *ctxt)
+{
+	/* CR0 */
+	asm volatile ("mcr p15, 2, %0, c0, c0, 0" : : "r"(ctxt->cssr));
+	/* CR1 */
+#if defined(CORTEX_A8)
+	//busy_waiting();
+	//asm volatile ("mcr p15, 0, %0, c1, c0, 0" : : "r"(ctxt->cr)); //will effect visible addr space, cache, instruction prediction
+	asm volatile ("mcr p15, 0, %0, c1, c0, 2" : : "r"(ctxt->cacr));
+#elif defined(CORTEX_A9)
+	//asm volatile ("mcr p15, 0, %0, c1, c0, 0" : : "r"(ctxt->cr));
+	//busy_waiting();
+	asm volatile ("mcr p15, 0, %0, c1, c0, 1" : : "r"(ctxt->actlr));
+	asm volatile ("mcr p15, 0, %0, c1, c0, 2" : : "r"(ctxt->cacr));
+	asm volatile ("mcr p15, 0, %0, c1, c1, 1" : : "r"(ctxt->sder));
+	asm volatile ("mcr p15, 0, %0, c1, c1, 3" : : "r"(ctxt->vcr));
+#elif defined(CORTEX_A7)
+	asm volatile ("mcr p15, 0, %0, c1, c0, 2" : : "r"(ctxt->cacr));
+#endif
+
+	/* CR2 */
+	asm volatile ("mcr p15, 0, %0, c2, c0, 0" : : "r"(ctxt->ttb_0r));
+	asm volatile ("dsb");
+	asm volatile ("isb");
+	asm volatile ("mcr p15, 0, %0, c2, c0, 1" : : "r"(ctxt->ttb_1r));
+	asm volatile ("dsb");
+	asm volatile ("isb");
+	asm volatile ("mcr p15, 0, %0, c2, c0, 2" : : "r"(ctxt->ttbcr));
+	asm volatile ("dsb");
+	asm volatile ("isb");
+
+	//flush_tlb_all();
+	/* CR3 */
+	asm volatile ("mcr p15, 0, %0, c3, c0, 0" : : "r"(ctxt->dacr));
+	/* CR7 */
+	asm volatile ("mcr p15, 0, %0, c7, c4, 0" : : "r"(ctxt->par));
+
+	/* CR9 */
+	asm volatile ("mcr p15, 0, %0, c9, c12, 5" : : "r"(ctxt->pcsr));
+	asm volatile ("mcr p15, 0, %0, c9, c13, 0" : : "r"(ctxt->ccr));
+	asm volatile ("mcr p15, 0, %0, c9, c13, 1" : : "r"(ctxt->esr));
+	asm volatile ("mcr p15, 0, %0, c9, c13, 2" : : "r"(ctxt->pmcountr));
+	asm volatile ("mcr p15, 0, %0, c9, c14, 0" : : "r"(ctxt->uer));
+	asm volatile ("mcr p15, 0, %0, c9, c14, 1" : : "r"(ctxt->iesr));
+	asm volatile ("mcr p15, 0, %0, c9, c14, 2" : : "r"(ctxt->iecr));
+#ifdef CORTEX_A8
+	asm volatile ("mcr p15, 1, %0, c9, c0, 0" : : "r"(ctxt->l2clr));
+	asm volatile ("mcr p15, 1, %0, c9, c0, 2" : : "r"(ctxt->l2cauxctrlr));
+#elif defined(CORTEX_A7)
+#endif
+
+	/* CR10 */
+	asm volatile ("mcr p15, 0, %0, c10, c2, 0" : : "r"(ctxt->prrr));
+	asm volatile ("mcr p15, 0, %0, c10, c2, 1" : : "r"(ctxt->nrrr));
+
+	/* CR11 */
+#ifdef CORTEX_A8
+	asm volatile ("mcr p15, 0, %0, c11, c1, 0" : : "r"(ctxt->pleuar));
+	asm volatile ("mcr p15, 0, %0, c11, c2, 0" : : "r"(ctxt->plecnr));
+	asm volatile ("mcr p15, 0, %0, c11, c4, 0" : : "r"(ctxt->plecr));
+	asm volatile ("mcr p15, 0, %0, c11, c5, 0" : : "r"(ctxt->pleisar));
+	asm volatile ("mcr p15, 0, %0, c11, c7, 0" : : "r"(ctxt->pleiear));
+	asm volatile ("mcr p15, 0, %0, c11, c15, 0" : : "r"(ctxt->plecidr));
+#elif defined(CORTEX_A7)
+#endif
+
+	/* CR12 */
+#ifdef CORTEX_A8
+	asm volatile ("mcr p15, 0, %0, c12, c0, 0" : : "r"(ctxt->snsvbar));
+	asm volatile ("mcr p15, 0, %0, c12, c0, 1" : : "r"(ctxt->monvecbar));
+#elif defined(CORTEX_A9)
+	asm volatile ("mcr p15, 0, %0, c12, c0, 0" : : "r"(ctxt->vbar));
+	asm volatile ("mcr p15, 0, %0, c12, c0, 1" : : "r"(ctxt->mvbar));
+	asm volatile ("mcr p15, 0, %0, c12, c1, 1" : : "r"(ctxt->vir));
+#elif defined(CORTEX_A7)
+	asm volatile ("mcr p15, 0, %0, c12, c0, 0" : : "r"(ctxt->vbar));
+	asm volatile ("mcr p15, 0, %0, c12, c0, 1" : : "r"(ctxt->mvbar));
+	//asm volatile ("mcr p15, 0, %0, c12, c1, 0" : : "r"(ctxt->isr));
+#endif
+
+	/* CR13 */
+	//asm volatile ("mcr p15, 0, %0, c13, c0, 0" : : "r"(ctxt->fcse));
+	asm volatile ("mcr p15, 0, %0, c13, c0, 1" : : "r"(ctxt->cid));
+	asm volatile ("mcr p15, 0, %0, c13, c0, 2" : : "r"(ctxt->urwtpid));
+	asm volatile ("mcr p15, 0, %0, c13, c0, 3" : : "r"(ctxt->urotpid));
+	asm volatile ("mcr p15, 0, %0, c13, c0, 4" : : "r"(ctxt->potpid));
+
+	/* CR15 */
+#ifdef CORTEX_A9
+	asm volatile ("mcr p15, 5, %0, c15, c7, 2" : : "r"(ctxt->mtlbar));
+#endif
+
+	asm volatile ("dsb");
+	asm volatile ("isb");
+}
+
+/*disable_cache_invalidate: disable invalidate cache when cpu reset.
+*/
+void disable_cache_invalidate(void)
+{
+	#define CPU_CONFIG_REG (0XF1C20D3C)
+	__u32 val = *(volatile __u32 *)(CPU_CONFIG_REG);
+	val &=  (~0x3);
+	val |= 0x03;	//disable invalidate
+	*(volatile __u32 *)(CPU_CONFIG_REG) = val;
+
+	return;
+}
+
+/*set_copro_default: set co-processor to default state.
+*note: the api will effect visible addr space, be careful to call it.
+*/
+void set_copro_default(void)
+{
+	struct saved_context *ctxt = &default_copro_value;
+	/* CR0 */
+	asm volatile ("mcr p15, 2, %0, c0, c0, 0" : : "r"(ctxt->cssr));
+	/* CR1 */
+#ifdef CORTEX_A8
+	//busy_waiting();
+	asm volatile ("mcr p15, 0, %0, c1, c0, 0" : : "r"(ctxt->cr)); //will effect visible addr space
+	asm volatile ("mcr p15, 0, %0, c1, c0, 1" : : "r"(ctxt->acr)); //?
+	asm volatile ("mcr p15, 0, %0, c1, c0, 2" : : "r"(ctxt->cacr));
+	asm volatile ("mcr p15, 0, %0, c1, c1, 0" : : "r"(ctxt->sccfgr)); //?
+	asm volatile ("mcr p15, 0, %0, c1, c1, 1" : : "r"(ctxt->scdbgenblr)); //?
+	asm volatile ("mcr p15, 0, %0, c1, c1, 2" : : "r"(ctxt->nonscacctrlr)); //?
+#elif defined(CORTEX_A7)
+	asm volatile ("mcr p15, 0, %0, c1, c0, 0" : : "r"(ctxt->cr)); //will effect visible addr space
+	asm volatile ("mcr p15, 0, %0, c1, c0, 1" : : "r"(ctxt->acr)); //?
+	asm volatile ("mcr p15, 0, %0, c1, c0, 2" : : "r"(ctxt->cacr));
+	asm volatile ("mcr p15, 0, %0, c1, c1, 0" : : "r"(ctxt->sccfgr)); //?
+	asm volatile ("mcr p15, 0, %0, c1, c1, 1" : : "r"(ctxt->scdbgenblr)); //?
+	asm volatile ("mcr p15, 0, %0, c1, c1, 2" : : "r"(ctxt->nonscacctrlr)); //?
+#endif
+
+	/* CR2 */
+	asm volatile ("mcr p15, 0, %0, c2, c0, 0" : : "r"(ctxt->ttb_0r));
+	//flush_tlb_all();
+	asm volatile ("mcr p15, 0, %0, c2, c0, 1" : : "r"(ctxt->ttb_1r));
+	asm volatile ("mcr p15, 0, %0, c2, c0, 2" : : "r"(ctxt->ttbcr));
+	/* CR3 */
+	asm volatile ("mcr p15, 0, %0, c3, c0, 0" : : "r"(ctxt->dacr));
+	/* CR5 */
+	asm volatile ("mcr p15, 0, %0, c5, c0, 0" : : "r"(ctxt->d_fsr));
+	asm volatile ("mcr p15, 0, %0, c5, c0, 1" : : "r"(ctxt->i_fsr));
+	asm volatile ("mcr p15, 0, %0, c5, c1, 0" : : "r"(ctxt->d_afsr));
+	asm volatile ("mcr p15, 0, %0, c5, c1, 1" : : "r"(ctxt->i_afsr));
+	/* CR6 */
+	asm volatile ("mcr p15, 0, %0, c6, c0, 0" : : "r"(ctxt->d_far));
+	asm volatile ("mcr p15, 0, %0, c6, c0, 2" : : "r"(ctxt->i_far));
+	/* CR7 */
+	asm volatile ("mcr p15, 0, %0, c7, c4, 0" : : "r"(ctxt->par));
+
+	/* CR9 */
+	asm volatile ("mcr p15, 0, %0, c9, c14, 0" : : "r"(ctxt->uer));
+	asm volatile ("mcr p15, 0, %0, c9, c14, 1" : : "r"(ctxt->iesr));
+	asm volatile ("mcr p15, 0, %0, c9, c14, 2" : : "r"(ctxt->iecr));
+#ifdef CORTEX_A8
+	asm volatile ("mcr p15, 1, %0, c9, c0, 0" : : "r"(ctxt->l2clr));
+	asm volatile ("mcr p15, 1, %0, c9, c0, 2" : : "r"(ctxt->l2cauxctrlr)); //?
+#elif defined(CORTEX_A7)
+#endif
+
+	/* CR10 */
+#ifdef CORTEX_A8
+	asm volatile ("mcr p15, 0, %0, c10, c0, 0" : : "r"(ctxt->d_tlblr));
+	asm volatile ("mcr p15, 0, %0, c10, c0, 1" : : "r"(ctxt->i_tlblr));
+#elif defined(CORTEX_A7)
+#endif
+	asm volatile ("mcr p15, 0, %0, c10, c2, 0" : : "r"(ctxt->prrr));
+	asm volatile ("mcr p15, 0, %0, c10, c2, 1" : : "r"(ctxt->nrrr));
+
+	/* CR11 */
+#ifdef CORTEX_A8
+	asm volatile ("mcr p15, 0, %0, c11, c1, 0" : : "r"(ctxt->pleuar));
+	asm volatile ("mcr p15, 0, %0, c11, c2, 0" : : "r"(ctxt->plecnr));
+	asm volatile ("mcr p15, 0, %0, c11, c4, 0" : : "r"(ctxt->plecr));
+	asm volatile ("mcr p15, 0, %0, c11, c5, 0" : : "r"(ctxt->pleisar));
+	asm volatile ("mcr p15, 0, %0, c11, c7, 0" : : "r"(ctxt->pleiear));
+	asm volatile ("mcr p15, 0, %0, c11, c15, 0" : : "r"(ctxt->plecidr));
+#elif defined(CORTEX_A7)
+#endif
+
+	/* CR12 */
+#ifdef CORTEX_A8
+	asm volatile ("mcr p15, 0, %0, c12, c0, 0" : : "r"(ctxt->snsvbar));
+	asm volatile ("mcr p15, 0, %0, c12, c0, 1" : : "r"(ctxt->monvecbar)); //?
+#elif defined(CORTEX_A7)
+	asm volatile ("mcr p15, 0, %0, c12, c0, 0" : : "r"(ctxt->vbar));
+	asm volatile ("mcr p15, 0, %0, c12, c0, 1" : : "r"(ctxt->mvbar));
+	//asm volatile ("mcr p15, 0, %0, c12, c1, 0" : : "r"(ctxt->isr));
+#endif
+
+	/* CR13 */
+	//asm volatile ("mcr p15, 0, %0, c13, c0, 0" : : "r"(ctxt->fcse));
+	asm volatile ("mcr p15, 0, %0, c13, c0, 1" : : "r"(ctxt->cid));
+	asm volatile ("mcr p15, 0, %0, c13, c0, 2" : : "r"(ctxt->urwtpid));
+	asm volatile ("mcr p15, 0, %0, c13, c0, 3" : : "r"(ctxt->urotpid));
+	asm volatile ("mcr p15, 0, %0, c13, c0, 4" : : "r"(ctxt->potpid));
+	return;
+}
+
+/*save_processor_state: save current co-proccessor state.*/
+void save_processor_state(void)
+{
+	__save_processor_state(&saved_context);
+}
+
+/*restore_processor_state: restore */
+void restore_processor_state(void)
+{
+	__restore_processor_state(&saved_context);
+}
+
+void restore_processor_ttbr0(void)
+{
+	asm volatile ("mcr p15, 0, %0, c2, c0, 0" : : "r"(saved_context.ttb_0r));
+	return;
+}
+
+void set_ttbr0(void)
+{
+	__u32 ttb = 0;
+	//read ttbr1
+	asm volatile ("mrc p15, 0, %0, c2, c0, 1"  : "=r"(ttb));
+	//write ttbr0
+	asm volatile ("mcr p15, 0, %0, c2, c0, 0" : : "r"(ttb));
+	asm volatile ("isb");
+	return;
+}
diff --git a/arch/arm/mach-sun6i/pm/mem_cpu.h b/arch/arm/mach-sun6i/pm/mem_cpu.h
new file mode 100644
index 0000000..d29efa4
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_cpu.h
@@ -0,0 +1,153 @@
+#ifndef _MEM_CONTEXT_H
+#define _MEM_CONTEXT_H
+
+/*
+ * Copyright (c) 2011-2015 yanggq.young@allwinnertech.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+/* The following architectures are known to be CORTEX_A9 */
+#if defined(CONFIG_ARCH_SUN6I)
+#define CORTEX_A7
+#elif defined(CONFIG_ARCH_SUN4I)
+/* Assume CORTEX_A8 as default */
+#define CORTEX_A8
+#elif defined(CONFIG_ARCH_SUN5I)
+#define CORTEX_A8
+#endif
+
+/*
+ * Image of the saved processor state
+ *
+ * coprocessor 15 registers(RW)
+ */
+struct saved_context {
+/*
+ * FIXME: Only support for Cortex A8 and Cortex A9 now
+ */
+	/* CR0 */
+	__u32 cssr;	/* Cache Size Selection */
+	/* CR1 */
+#ifdef CORTEX_A8
+	__u32 cr;		/* Control */
+	__u32 acr;	/* Auxiliary Control Register*/
+	__u32 cacr;	/* Coprocessor Access Control */
+	__u32 sccfgr;	/* Secure Config Register*/
+	__u32 scdbgenblr;	/* Secure Debug Enable Register*/
+	__u32 nonscacctrlr;/* Nonsecure Access Control Register*/
+#elif defined(CORTEX_A9)
+	__u32 cr;
+	__u32 actlr;
+	__u32 cacr;
+	__u32 sder;
+	__u32 vcr;
+#elif defined(CORTEX_A7)
+	__u32 cr;		/* Control */
+	__u32 acr;	/* Auxiliary Control Register*/
+	__u32 cacr;	/* Coprocessor Access Control */
+	__u32 sccfgr;	/* Secure Config Register*/
+	__u32 scdbgenblr;	/* Secure Debug Enable Register*/
+	__u32 nonscacctrlr;/* Nonsecure Access Control Register*/
+#endif
+
+	/* CR2 */
+	__u32 ttb_0r;	/* Translation Table Base 0 */
+	__u32 ttb_1r;	/* Translation Table Base 1 */
+	__u32 ttbcr;	/* Translation Talbe Base Control */
+	/* CR3 */
+	__u32 dacr;	/* Domain Access Control */
+	/* CR5 */
+	__u32 d_fsr;	/* Data Fault Status */
+	__u32 i_fsr;	/* Instruction Fault Status */
+	__u32 d_afsr;	/* Data Auxilirary Fault Status */	 ;
+	__u32 i_afsr;	/* Instruction Auxilirary Fault Status */;
+	/* CR6 */
+	__u32 d_far;	/* Data Fault Address */
+	__u32 i_far;	/* Instruction Fault Address */
+	/* CR7 */
+	__u32 par;	/* Physical Address */
+	/* CR9 */	/* FIXME: Are they necessary? */
+	__u32 pmcontrolr;	/* Performance Monitor Control */
+	__u32 cesr;	/* Count Enable Set */
+	__u32 cecr;	/* Count Enable Clear */
+	__u32 ofsr;	/* Overflow Flag Status */
+#ifdef CORTEX_A8
+	__u32 sir;	/* Software Increment */
+#elif defined(CORTEX_A7)
+	__u32 sir;	/* Software Increment */
+#endif
+	__u32 pcsr;	/* Performance Counter Selection */
+	__u32 ccr;	/* Cycle Count */
+	__u32 esr;	/* Event Selection */
+	__u32 pmcountr;	/* Performance Monitor Count */
+	__u32 uer;	/* User Enable */
+	__u32 iesr;	/* Interrupt Enable Set */
+	__u32 iecr;	/* Interrupt Enable Clear */
+#ifdef CORTEX_A8
+	__u32 l2clr;	/* L2 Cache Lockdown */
+	__u32 l2cauxctrlr;	/* L2 Cache Auxiliary Control */
+#elif defined(CORTEX_A7)
+
+#endif
+
+	/* CR10 */
+#ifdef CORTEX_A8
+	__u32 d_tlblr;	/* Data TLB Lockdown Register */
+	__u32 i_tlblr;	/* Instruction TLB Lockdown Register */
+#elif defined(CORTEX_A7)
+#endif
+	__u32 prrr;	/* Primary Region Remap Register */
+	__u32 nrrr;	/* Normal Memory Remap Register */
+
+	/* CR11 */
+#ifdef CORTEX_A8
+	__u32 pleuar;	/* PLE User Accessibility */
+	__u32 plecnr;	/* PLE Channel Number */
+	__u32 plecr;	/* PLE Control */
+	__u32 pleisar;	/* PLE Internal Start Address */
+	__u32 pleiear;	/* PLE Internal End Address */
+	__u32 plecidr;	/* PLE Context ID */
+#elif defined(CORTEX_A7)
+#endif
+
+	/* CR12 */
+#ifdef CORTEX_A8
+	__u32 snsvbar;	/* Secure or Nonsecure Vector Base Address */
+	__u32 monvecbar; /*Monitor Vector Base*/
+#elif defined(CORTEX_A9)
+	__u32 vbar;
+	__u32 mvbar;
+	__u32 vir;
+#elif defined(CORTEX_A7)
+	__u32 vbar;
+	__u32 mvbar;
+	__u32 isr;
+#endif
+
+	/* CR13 */
+	__u32 fcse;	/* FCSE PID */
+	__u32 cid;	/* Context ID */
+	__u32 urwtpid;	/* User read/write Thread and Process ID */
+	__u32 urotpid;	/* User read-only Thread and Process ID */
+	__u32 potpid;	/* Privileged only Thread and Process ID */
+
+	/* CR15 */
+#ifdef CORTEX_A9
+	__u32 mtlbar;
+#endif
+} __attribute__((packed));
+
+void __save_processor_state(struct saved_context *ctxt);
+void __restore_processor_state(struct saved_context *ctxt);
+void disable_cache_invalidate(void);
+void set_copro_default(void);
+
+void save_processor_state(void);
+void restore_processor_state(void);
+void restore_processor_ttbr0(void);
+void set_ttbr0(void);
+
+#endif /*_MEM_CONTEXT_H*/
diff --git a/arch/arm/mach-sun6i/pm/mem_cpu_asm.S b/arch/arm/mach-sun6i/pm/mem_cpu_asm.S
new file mode 100644
index 0000000..2a9b4a5
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_cpu_asm.S
@@ -0,0 +1,358 @@
+/*
+ * mem support specific for ARM
+ * based on hibernate support specific for ARM
+ * Copyright (C) 2010 Nokia Corporation
+ * Copyright (C) 2010 Texas Instruments, Inc.
+ * Copyright (C) 2006 Rafael J. Wysocki <rjw <at> sisk.pl>
+ *
+ * Contact: Hiroshi DOYU <Hiroshi.DOYU <at> nokia.com>
+ *
+ * License terms: GNU General Public License (GPL) version 2
+ */
+
+#include <linux/linkage.h>
+/*
+ * function: mem_arch_suspend
+ * discription: save main part of general purpose register.
+ */
+	.text
+	.globl mem_arch_suspend
+mem_arch_suspend:
+	push    {r0-r3}
+	/*
+	 * Save current program status register
+	 */
+	ldr     r3, .Lsaved_cpsr_svc
+	mrs     r0, cpsr
+	str     r0, [r3]
+
+	/*
+	 * Change to system(user) mode
+	 */
+	mov     r1, r0
+	orr     r1, r1, #0x1f
+	msr     cpsr_c, r1
+
+	/*
+	 * Save User context
+	 */
+	ldr     r3, .Lsaved_context_r13_sys
+	stmia   r3, {r13-r14}
+
+	/*
+	 * Change to fiq mode
+	 */
+	mov     r1, r0
+	bic	r1, r1, #0x1f
+	orr     r1, r1, #0x11
+	msr     cpsr_c, r1
+
+	 /*
+	 * Save fiq context
+	 */
+	ldr     r3, .Lsaved_context_r13_fiq
+	stmia   r3, {r8-r14}
+	ldr     r3, .Lsaved_spsr_fiq
+	mrs     r1, spsr
+	str     r1, [r3]
+
+	 /*
+	 * Change to abt mode
+	 */
+	mov     r1, r0
+	bic	r1, r1, #0x1f
+	orr     r1, r1, #0x17
+	msr     cpsr_c, r1
+
+	 /*
+	 * Save abt context
+	 */
+	ldr     r3, .Lsaved_context_r13_abt
+	stmia   r3, {r13-r14}
+	ldr     r3, .Lsaved_spsr_abt
+	mrs     r1, spsr
+	str     r1, [r3]
+
+	 /*
+	 * Change to irq mode
+	 */
+	mov     r1, r0
+	bic	r1, r1, #0x1f
+	orr     r1, r1, #0x12
+	msr     cpsr_c, r1
+
+	 /*
+	 * Save irq context
+	 */
+	ldr     r3, .Lsaved_context_r13_irq
+	stmia   r3, {r13-r14}
+	ldr     r3, .Lsaved_spsr_irq
+	mrs     r1, spsr
+	str     r1, [r3]
+
+	 /*
+	 * Change to und mode
+	 */
+	mov     r1, r0
+	bic	r1, r1, #0x1f
+	orr     r1, r1, #0x1b
+	msr     cpsr_c, r1
+
+	 /*
+	 * Save und context
+	 */
+	ldr     r3, .Lsaved_context_r13_und
+	stmia   r3, {r13-r14}
+	ldr     r3, .Lsaved_spsr_und
+	mrs     r1, spsr
+	str     r1, [r3]
+
+	 /*
+	 * Change to mon mode
+	 */
+	mov     r1, r0
+	bic	r1, r1, #0x1f
+	orr     r1, r1, #0x16
+	msr     cpsr_c, r1
+
+	 /*
+	 * Save mon context
+	 */
+	ldr     r3, .Lsaved_context_r13_mon
+	stmia   r3, {r13-r14}
+	ldr     r3, .Lsaved_spsr_mon
+	mrs     r1, spsr
+	str     r1, [r3]
+
+	/*
+	 * Go back to original SVC mode
+	 */
+	msr     cpsr_c, r0
+
+	/*
+	 * Save SVC context
+	 */
+	ldr     r3, .Lsaved_context_r12_svc
+	stmia   r3, {r12-r13}
+	ldr     r3, .Lsaved_spsr_svc
+	mrs     r1, spsr
+	str     r1, [r3]
+
+        pop     {r0-r3}
+	/*
+	 *  return
+	 */
+	mov     pc, lr
+
+/*
+ * function: mem_arch_resume
+ * discription: retore main part of general purpose register.
+ */
+	.align	4
+        .globl  mem_arch_resume
+mem_arch_resume:
+	push    {r0-r3}
+
+	mrs     r0, cpsr
+	/*
+	 * Restore SVC context
+	 */
+	ldr     r3, .Lsaved_context_r12_svc
+	ldmia   r3, {r12-r13}
+	ldr     r3, .Lsaved_spsr_svc
+	ldr     r1, [r3]
+	msr     spsr_cxsf, r1
+
+        /*
+	 * Change to system(user) mode
+	 */
+	mov     r1, r0
+	orr     r1, r1, #0x1f
+	msr     cpsr_c, r1
+
+	/*
+	 * Restore User context
+	 */
+	ldr     r3, .Lsaved_context_r13_sys
+	ldmia   r3, {r13-r14}
+
+	/*
+	 * Change to fiq mode
+	 */
+	mov     r1, r0
+	bic	r1, r1, #0x1f
+	orr     r1, r1, #0x11
+	msr     cpsr_c, r1
+
+	 /*
+	 * Restore fiq context
+	 */
+	ldr     r3, .Lsaved_context_r13_fiq
+	ldmia   r3, {r8-r14}
+	ldr     r3, .Lsaved_spsr_fiq
+	ldr     r1, [r3]
+	msr     spsr_cxsf, r1
+
+	 /*
+	 * Change to abt mode
+	 */
+	mov     r1, r0
+	bic	r1, r1, #0x1f
+	orr     r1, r1, #0x17
+	msr     cpsr_c, r1
+
+	  /*
+	 * Restore abt context
+	 */
+	ldr     r3, .Lsaved_context_r13_abt
+	ldmia   r3, {r13-r14}
+	ldr     r3, .Lsaved_spsr_abt
+	ldr     r1, [r3]
+	msr     spsr_cxsf, r1
+	 /*
+	 * Change to irq mode
+	 */
+	mov     r1, r0
+	bic	r1, r1, #0x1f
+	orr     r1, r1, #0x12
+	msr     cpsr_c, r1
+
+	 /*
+	 * Restore irq context
+	 */
+	ldr     r3, .Lsaved_context_r13_irq
+	ldmia   r3, {r13-r14}
+	ldr     r3, .Lsaved_spsr_irq
+	ldr     r1, [r3]
+	msr     spsr_cxsf, r1
+
+	 /*
+	 * Change to und mode
+	 */
+	mov     r1, r0
+	bic	r1, r1, #0x1f
+	orr     r1, r1, #0x1b
+	msr     cpsr_c, r1
+
+	 /*
+	 * Restore und context
+	 */
+	ldr     r3, .Lsaved_context_r13_und
+	ldmia   r3, {r13-r14}
+	ldr     r3, .Lsaved_spsr_und
+	ldr     r1, [r3]
+	msr     spsr_cxsf, r1
+
+	 /*
+	 * Change to mon mode
+	 */
+	mov     r1, r0
+	bic	r1, r1, #0x1f
+	orr     r1, r1, #0x16
+	msr     cpsr_c, r1
+
+	 /*
+	 * Restore mon context
+	 */
+	ldr     r3, .Lsaved_context_r13_mon
+	ldmia   r3, {r13-r14}
+	ldr     r3, .Lsaved_spsr_mon
+	ldr     r1, [r3]
+	msr     spsr_cxsf, r1
+
+	/*
+	 * Restore CPSR, and Change to svc mode
+	 */
+	ldr     r3, .Lsaved_cpsr_svc
+	ldr     r1, [r3]
+	msr     cpsr_cxsf, r1
+
+	/*
+	 * Flush TLB (Invalidate unified TLB unlocked entries)
+	 */
+	mov     r1, #0
+	mcr     p15, 0, r1, c8, c7, 0
+
+        pop     {r0-r3}
+
+	/* Set the return value */
+	mov	r0, #0
+
+	/* return*/
+        mov     pc, lr
+
+	.align	4
+
+ENTRY(mem_clear_runtime_context)
+	push    {r0-r3}
+	/*
+	 * Save empty context for clear r0 - r10
+	 */
+	ldr     r3, .Lsaved_empty_context_svc
+	mov	r0, #0
+	str     r0, [r3], #0x4
+	str     r0, [r3], #0x4
+	str     r0, [r3], #0x4
+	str     r0, [r3], #0x4
+	str     r0, [r3], #0x4
+	str     r0, [r3], #0x4
+	str     r0, [r3], #0x4
+	str     r0, [r3], #0x4
+	str     r0, [r3], #0x4
+	str     r0, [r3], #0x4
+	str     r0, [r3], #0x4
+
+	/*
+	 * clear SVC context
+	 */
+	ldr     r3, .Lsaved_empty_context_svc
+	ldmia   r3, {r0-r10}
+
+	pop     {r0-r3}
+	/* return*/
+        mov     pc, lr
+ENDPROC(mem_clear_runtime_context)
+	.align	4
+
+	.align	4
+	.globl save_runtime_context
+save_runtime_context:
+	/*save r0-r13 register*/
+	stmia   r0, {r0 - r13}
+	mov	pc, lr
+
+
+	.align	4
+	.globl clear_reg_context
+clear_reg_context:
+	/*clear r0-r11 register*/
+	mov	r0, #0
+	mov	r1, #0
+	mov	r2, #0
+	mov	r3, #0
+	mov	r4, #0
+	mov	r5, #0
+	mov	r6, #0
+	mov	r7, #0
+	mov	r8, #0
+	mov	r9, #0
+	mov	r10,#0
+	mov	r11,#0
+	mov	r12,#0
+	mov	pc, lr
+
+.Lsaved_context_r13_sys:	.long	saved_context_r13_sys
+.Lsaved_cpsr_svc:		.long	saved_cpsr_svc
+.Lsaved_context_r12_svc: 	.long	saved_context_r12_svc
+.Lsaved_spsr_svc:		.long	saved_spsr_svc
+.Lsaved_context_r13_fiq: 	.long	saved_context_r13_fiq
+.Lsaved_spsr_fiq:		.long	saved_spsr_fiq
+.Lsaved_context_r13_abt: 	.long	saved_context_r13_abt
+.Lsaved_spsr_abt:		.long	saved_spsr_abt
+.Lsaved_context_r13_irq: 	.long	saved_context_r13_irq
+.Lsaved_spsr_irq:		.long	saved_spsr_irq
+.Lsaved_context_r13_und: 	.long	saved_context_r13_und
+.Lsaved_spsr_und:		.long	saved_spsr_und
+.Lsaved_context_r13_mon: 	.long	saved_context_r13_mon
+.Lsaved_spsr_mon:		.long	saved_spsr_mon
+.Lsaved_empty_context_svc:	.long	saved_empty_context_svc
diff --git a/arch/arm/mach-sun6i/pm/mem_divlib.S b/arch/arm/mach-sun6i/pm/mem_divlib.S
new file mode 100644
index 0000000..11d8daf
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_divlib.S
@@ -0,0 +1,180 @@
+/*
+ * linux/arch/arm/lib/lib1funcs.S: Optimized ARM division routines
+ *
+ * Author: Nicolas Pitre <nico@fluxnic.net>
+ *   - contributed to gcc-3.4 on Sep 30, 2003
+ *   - adapted for the Linux kernel on Oct 2, 2003
+ */
+
+
+.macro ARM_DIV_BODY dividend, divisor, result, curbit
+
+	clz	\curbit, \divisor
+	clz	\result, \dividend
+	sub	\result, \curbit, \result
+	mov	\curbit, #1
+	mov	\divisor, \divisor, lsl \result
+	mov	\curbit, \curbit, lsl \result
+	mov	\result, #0
+
+	@ Division loop
+1:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	orrhs	\result,   \result,   \curbit
+	cmp	\dividend, \divisor,  lsr #1
+	subhs	\dividend, \dividend, \divisor, lsr #1
+	orrhs	\result,   \result,   \curbit,  lsr #1
+	cmp	\dividend, \divisor,  lsr #2
+	subhs	\dividend, \dividend, \divisor, lsr #2
+	orrhs	\result,   \result,   \curbit,  lsr #2
+	cmp	\dividend, \divisor,  lsr #3
+	subhs	\dividend, \dividend, \divisor, lsr #3
+	orrhs	\result,   \result,   \curbit,  lsr #3
+	cmp	\dividend, #0			@ Early termination?
+	movnes	\curbit,   \curbit,  lsr #4	@ No, any more bits to do?
+	movne	\divisor,  \divisor, lsr #4
+	bne	1b
+
+.endm
+
+
+.macro ARM_DIV2_ORDER divisor, order
+	clz	\order, \divisor
+	rsb	\order, \order, #31
+.endm
+
+
+.macro ARM_MOD_BODY dividend, divisor, order, spare
+	clz	\order, \divisor
+	clz	\spare, \dividend
+	sub	\order, \order, \spare
+	mov	\divisor, \divisor, lsl \order
+
+	@ Perform all needed substractions to keep only the reminder.
+	@ Do comparisons in batch of 4 first.
+	subs	\order, \order, #3		@ yes, 3 is intended here
+	blt	2f
+
+1:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	cmp	\dividend, \divisor,  lsr #1
+	subhs	\dividend, \dividend, \divisor, lsr #1
+	cmp	\dividend, \divisor,  lsr #2
+	subhs	\dividend, \dividend, \divisor, lsr #2
+	cmp	\dividend, \divisor,  lsr #3
+	subhs	\dividend, \dividend, \divisor, lsr #3
+	cmp	\dividend, #1
+	mov	\divisor, \divisor, lsr #4
+	subges	\order, \order, #4
+	bge	1b
+
+	tst	\order, #3
+	teqne	\dividend, #0
+	beq	5f
+
+	@ Either 1, 2 or 3 comparison/substractions are left.
+2:	cmn	\order, #2
+	blt	4f
+	beq	3f
+	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	mov	\divisor,  \divisor,  lsr #1
+3:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	mov	\divisor,  \divisor,  lsr #1
+4:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+5:
+.endm
+
+    .text
+    .globl Ldiv0
+Ldiv0:
+	str	lr, [sp, #-8]!
+	bl	__div0
+	mov	r0, #0			@ About as wrong as it could be.
+	ldr	pc, [sp], #8
+
+    .text
+    .globl __aeabi_uidiv
+__aeabi_uidiv:
+	subs	r2, r1, #1
+	moveq	pc, lr
+	bcc	Ldiv0
+	cmp	r0, r1
+	bls	11f
+	tst	r1, r2
+	beq	12f
+
+	ARM_DIV_BODY r0, r1, r2, r3
+
+	mov	r0, r2
+	mov	pc, lr
+
+11:	moveq	r0, #1
+	movne	r0, #0
+	mov	pc, lr
+
+12:	ARM_DIV2_ORDER r1, r2
+
+	mov	r0, r0, lsr r2
+	mov	pc, lr
+
+
+    .text
+    .globl __aeabi_idiv
+__aeabi_idiv:
+	cmp	r1, #0
+	eor	ip, r0, r1			@ save the sign of the result.
+	beq	Ldiv0
+	rsbmi	r1, r1, #0			@ loops below use unsigned.
+	subs	r2, r1, #1			@ division by 1 or -1 ?
+	beq	10f
+	movs	r3, r0
+	rsbmi	r3, r0, #0			@ positive dividend value
+	cmp	r3, r1
+	bls	11f
+	tst	r1, r2				@ divisor is power of 2 ?
+	beq	12f
+
+	ARM_DIV_BODY r3, r1, r0, r2
+
+	cmp	ip, #0
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+10:	teq	ip, r0				@ same sign ?
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+11:	movlo	r0, #0
+	moveq	r0, ip, asr #31
+	orreq	r0, r0, #1
+	mov	pc, lr
+
+12:	ARM_DIV2_ORDER r1, r2
+
+	cmp	ip, #0
+	mov	r0, r3, lsr r2
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+    .text
+    .globl __aeabi_uidivmod
+__aeabi_uidivmod:
+	stmfd	sp!, {r0, r1, ip, lr}
+	bl	__aeabi_uidiv
+	ldmfd	sp!, {r1, r2, ip, lr}
+	mul	r3, r0, r2
+	sub	r1, r1, r3
+	mov	pc, lr
+
+    .text
+    .globl __aeabi_idivmod
+__aeabi_idivmod:
+	stmfd	sp!, {r0, r1, ip, lr}
+	bl	__aeabi_idiv
+	ldmfd	sp!, {r1, r2, ip, lr}
+	mul	r3, r0, r2
+	sub	r1, r1, r3
+	mov	pc, lr
\ No newline at end of file
diff --git a/arch/arm/mach-sun6i/pm/mem_divlibc.c b/arch/arm/mach-sun6i/pm/mem_divlibc.c
new file mode 100644
index 0000000..9d25390
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_divlibc.c
@@ -0,0 +1,49 @@
+#ifdef __STANDBY_MODULE__
+#include "pm_types.h"
+#include "pm.h"
+
+void __div0(void)
+{
+	printk("Attempting division by 0!");
+}
+
+#elif defined(__KERNEL__)
+#include <linux/module.h>
+#include "pm_i.h"
+#endif
+
+__u32 raw_lib_udiv(__u32 dividend, __u32 divisior)
+{
+    __u32   tmpDiv = (__u32)divisior;
+    __u32   tmpQuot = 0;
+    __s32   shift = 0;
+
+    if(!divisior)
+    {
+        /* divide 0 error abort */
+        return 0;
+    }
+
+    while(!(tmpDiv & ((__u32)1<<31)))
+    {
+        tmpDiv <<= 1;
+        shift ++;
+    }
+
+    do
+    {
+        if(dividend >= tmpDiv)
+        {
+            dividend -= tmpDiv;
+            tmpQuot = (tmpQuot << 1) | 1;
+        }
+        else
+        {
+            tmpQuot = (tmpQuot << 1) | 0;
+        }
+        tmpDiv >>= 1;
+        shift --;
+    } while(shift >= 0);
+
+    return tmpQuot;
+}
\ No newline at end of file
diff --git a/arch/arm/mach-sun6i/pm/mem_divlibc.h b/arch/arm/mach-sun6i/pm/mem_divlibc.h
new file mode 100644
index 0000000..319af7e
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_divlibc.h
@@ -0,0 +1,11 @@
+#ifndef _MEM_MISC_H
+#define _MEM_MISC_H
+
+void __div0(void);
+__u32 raw_lib_udiv(__u32 dividend, __u32 divisior);
+extern void __aeabi_idiv(void);
+extern void __aeabi_idivmod(void);
+extern void __aeabi_uidiv(void);
+extern void __aeabi_uidivmod(void);
+
+#endif /*_MEM_MISC_H*/
\ No newline at end of file
diff --git a/arch/arm/mach-sun6i/pm/mem_gpio.c b/arch/arm/mach-sun6i/pm/mem_gpio.c
new file mode 100644
index 0000000..65e6f13f
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_gpio.c
@@ -0,0 +1,52 @@
+#include "pm_types.h"
+#include "pm_i.h"
+
+/*
+*********************************************************************************************************
+*                                       MEM gpio INITIALISE
+*
+* Description: mem gpio initialise.
+*
+* Arguments  : none.
+*
+* Returns    : 0/-1;
+*********************************************************************************************************
+*/
+__s32 mem_gpio_save(struct gpio_state *pgpio_state)
+{
+	int i=0;
+
+	/*save all the gpio reg*/
+	for(i=0; i<(GPIO_REG_LENGTH); i++){
+		pgpio_state->gpio_reg_back[i] = *(volatile __u32 *)(IO_ADDRESS(AW_PIO_BASE) + i*0x04);
+	}
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                       MEM gpio INITIALISE
+*
+* Description: mem gpio initialise.
+*
+* Arguments  : none.
+*
+* Returns    : 0/-1;
+*********************************************************************************************************
+*/
+__s32 mem_gpio_restore(struct gpio_state *pgpio_state)
+{
+	int i=0;
+
+	/*restore all the gpio reg*/
+	for(i=0; i<(GPIO_REG_LENGTH); i++){
+		 *(volatile __u32 *)(IO_ADDRESS(AW_PIO_BASE) + i*0x04) = pgpio_state->gpio_reg_back[i];
+	}
+
+	/* restore watch-dog registers, to avoid IC's bug */
+	*(volatile __u32 *)IO_ADDRESS(0x1C20CD8) = 0;
+	*(volatile __u32 *)IO_ADDRESS(0x1C20CF8) = 0;
+	*(volatile __u32 *)IO_ADDRESS(0x1C20D18) = 0;
+
+	return 0;
+}
diff --git a/arch/arm/mach-sun6i/pm/mem_int.c b/arch/arm/mach-sun6i/pm/mem_int.c
new file mode 100644
index 0000000..3a2b75c
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_int.c
@@ -0,0 +1,164 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : mem_int.c
+* By      : gq.yang
+* Version : v1.0
+* Date    : 2012-11-3 20:13
+* Descript: interrupt for platform mem
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifdef __STANDBY_MODULE__
+#include "pm_types.h"
+#include "pm.h"
+#elif defined(__KERNEL__)
+#include <linux/module.h>
+#include "pm_i.h"
+#endif
+
+static void *GicDDisc;
+static void *GicCDisc;
+
+/*
+*********************************************************************************************************
+*                                       STANDBY INTERRUPT INITIALISE
+*
+* Description: mem interrupt initialise.
+*
+* Arguments  : none.
+*
+* Returns    : 0/-1;
+*********************************************************************************************************
+*/
+__s32 mem_int_init(void)
+{
+	__u32 i = 0;
+	GicDDisc = (void *)IO_ADDRESS(AW_GIC_DIST_BASE);
+	GicCDisc = (void *)IO_ADDRESS(AW_GIC_CPU_BASE);
+
+	//printk("gic iar == 0x%x. \n", *(volatile __u32	 *)(IO_ADDRESS(AW_GIC_CPU_BASE)+0x0c));
+
+	/* initialise interrupt enable and mask for mem */
+
+	/*
+	 * Disable all interrupts.  Leave the PPI and SGIs alone
+	 * as these enables are banked registers.
+	 */
+	for (i = 4; i < (GIC_400_ENABLE_LEN); i += 4)
+		*(volatile __u32 *)(GicDDisc + GIC_DIST_ENABLE_CLEAR + i) = 0xffffffff;
+
+	/*config cpu interface*/
+#if 0
+	*(volatile __u32 *)(GicCDisc + GIC_CPU_PRIMASK) = 0xf0;
+	*(volatile __u32 *)(GicCDisc + GIC_CPU_CTRL) = 0x1;
+#endif
+
+#if 1
+	/* clear external irq pending: needed */
+	for (i = 4; i < (GIC_400_ENABLE_LEN); i += 4)
+		*(volatile __u32 *)(GicDDisc + GIC_DIST_PENDING_CLEAR + i) = 0xffffffff;
+#endif
+	//the print info just to check the pending state, actually, after u read iar, u need to access end of interrupt reg;
+	i = *(volatile __u32   *)(GicCDisc + 0x0c);
+
+	if(i != 0x3ff){
+		//u need to
+		*(volatile __u32 *)(GicCDisc + 0x10) = i;
+		printk("notice: gic iar == 0x%x. \n", i);
+	}
+
+
+	return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                       STANDBY INTERRUPT INITIALISE
+*
+* Description: mem interrupt exit.
+*
+* Arguments  : none.
+*
+* Returns    : 0/-1;
+*********************************************************************************************************
+*/
+__s32 mem_int_exit(void)
+{
+	int i = 0;
+	volatile __u32 enable_bit = 0;
+
+	//all the disable-int-src pending, need to be clear
+	for(i = 0; i < GIC_400_ENABLE_LEN; i += 4){
+		enable_bit = *(volatile __u32 *)(GicDDisc + GIC_DIST_ENABLE_SET + i);
+		*(volatile __u32 *)(GicDDisc + GIC_DIST_PENDING_CLEAR + i) &= (~enable_bit);
+	}
+
+	return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                       QUERY INTERRUPT
+*
+* Description: enable interrupt.
+*
+* Arguments  : src  interrupt source number.
+*
+* Returns    : 0/-1;
+*********************************************************************************************************
+*/
+__s32 mem_enable_int(enum interrupt_source_e src)
+{
+	__u32   tmpGrp = (__u32)src >> 5;
+	__u32   tmpSrc = (__u32)src & 0x1f;
+
+	GicDDisc = (void *)IO_ADDRESS(AW_GIC_DIST_BASE);
+	GicCDisc = (void *)IO_ADDRESS(AW_GIC_CPU_BASE);
+
+	//enable interrupt source
+	*(volatile __u32 *)(GicDDisc + GIC_DIST_ENABLE_SET + tmpGrp*4) |= (1<<tmpSrc);
+	//printk("GicDDisc + GIC_DIST_ENABLE_SET + tmpGrp*4 = 0x%x. tmpGrp = 0x%x.\n", GicDDisc + GIC_DIST_ENABLE_SET + tmpGrp*4, tmpGrp);
+	//printk("tmpSrc = 0x%x. \n", tmpSrc);
+
+	//need to care mask or priority?
+
+	return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                       QUERY INTERRUPT
+*
+* Description: query interrupt.
+*
+* Arguments  : src  interrupt source number.
+*
+* Returns    : 0/-1;
+*********************************************************************************************************
+*/
+__s32 mem_query_int(enum interrupt_source_e src)
+{
+	__s32   result = 0;
+	__u32   tmpGrp = (__u32)src >> 5;
+	__u32   tmpSrc = (__u32)src & 0x1f;
+
+	GicDDisc = (void *)IO_ADDRESS(AW_GIC_DIST_BASE);
+	GicCDisc = (void *)IO_ADDRESS(AW_GIC_CPU_BASE);
+
+	result = *(volatile __u32 *)(GicDDisc + GIC_DIST_PENDING_SET + tmpGrp*4) & (1<<tmpSrc);
+
+	//printk("GicDDisc + GIC_DIST_PENDING_SET + tmpGrp*4 = 0x%x. tmpGrp = 0x%x.\n", GicDDisc + GIC_DIST_PENDING_SET + tmpGrp*4, tmpGrp);
+	//printk("tmpSrc = 0x%x. result = 0x%x. \n", tmpSrc, result);
+
+	return result? 0:-1;
+}
diff --git a/arch/arm/mach-sun6i/pm/mem_int.h b/arch/arm/mach-sun6i/pm/mem_int.h
new file mode 100644
index 0000000..fcb1b34
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_int.h
@@ -0,0 +1,66 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : mem_int.h
+* By      : gq.yang
+* Version : v1.0
+* Date    : 2012-11-3 20:13
+* Descript: intterupt bsp for platform mem.
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __MEM_INT_H__
+#define __MEM_INT_H__
+
+#define GIC_400_ENABLE_LEN (0x40) //unit is byte. so in 32bit unit, the reg offset is 0-0x3c
+
+/* define interrupt source */
+enum interrupt_source_e{
+#ifdef SUN6I_FPGA_SIM
+	INT_SOURCE_TOUCHPNL = 24 + 32,
+	INT_SOURCE_LRADC    = 24 + 32,
+	INT_SOURCE_MSG_BOX  = 11 + 32,
+#else
+	INT_SOURCE_TIMER0   = 50,
+	INT_SOURCE_TIMER1   = 51,
+	INT_SOURCE_TOUCHPNL = 60,
+	INT_SOURCE_LRADC    = 62,
+	INT_SOURCE_EXTNMI   = 64,
+	INT_SOURCE_MSG_BOX  = 81,
+#endif
+};
+
+#define GIC_CPU_CTRL			0x00
+#define GIC_CPU_PRIMASK			0x04
+#define GIC_CPU_BINPOINT		0x08
+#define GIC_CPU_INTACK			0x0c
+#define GIC_CPU_EOI			0x10
+#define GIC_CPU_RUNNINGPRI		0x14
+#define GIC_CPU_HIGHPRI			0x18
+
+#define GIC_DIST_CTRL			0x000
+#define GIC_DIST_CTR			0x004
+#define GIC_DIST_ENABLE_SET		0x100
+#define GIC_DIST_ENABLE_CLEAR		0x180
+#define GIC_DIST_PENDING_SET		0x200
+#define GIC_DIST_PENDING_CLEAR		0x280
+#define GIC_DIST_ACTIVE_BIT		0x300
+#define GIC_DIST_PRI			0x400
+#define GIC_DIST_TARGET			0x800
+#define GIC_DIST_CONFIG			0xc00
+#define GIC_DIST_SOFTINT		0xf00
+
+
+extern __s32 mem_int_init(void);
+extern __s32 mem_int_exit(void);
+extern __s32 mem_enable_int(enum interrupt_source_e src);
+extern __s32 mem_query_int(enum interrupt_source_e src);
+
+
+#endif  //__MEM_INT_H__
diff --git a/arch/arm/mach-sun6i/pm/mem_mapping.c b/arch/arm/mach-sun6i/pm/mem_mapping.c
new file mode 100644
index 0000000..a7ecbd8
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_mapping.c
@@ -0,0 +1,117 @@
+/*
+ * Hibernation support specific for ARM
+ *
+ * Copyright (C) 2010 Nokia Corporation
+ * Copyright (C) 2010 Texas Instruments, Inc.
+ * Copyright (C) 2006 Rafael J. Wysocki <rjw <at> sisk.pl>
+ *
+ * Contact: Hiroshi DOYU <Hiroshi.DOYU <at> nokia.com>
+ *
+ * License terms: GNU General Public License (GPL) version 2
+ */
+#include <linux/module.h>
+#include <linux/suspend.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/syscalls.h>
+#include <linux/slab.h>
+#include <linux/major.h>
+#include <linux/device.h>
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <linux/power/aw_pm.h>
+#include <linux/module.h>
+#include <asm/io.h>
+#include <asm/mach/map.h>
+#include <asm/cacheflush.h>
+#include <asm/tlbflush.h>
+#include <asm/pgtable.h>
+#include "pm_i.h"
+
+/*
+ * "Linux" PTE definitions.
+ *
+ * We keep two sets of PTEs - the hardware and the linux version.
+ * This allows greater flexibility in the way we map the Linux bits
+ * onto the hardware tables, and allows us to have YOUNG and DIRTY
+ * bits.
+ *
+ * The PTE table pointer refers to the hardware entries; the "Linux"
+ * entries are stored 1024 bytes below.
+ */
+
+#define L_PTE_WRITE		(1 << 7)
+#define L_PTE_EXEC		(1 << 9)
+#define PAGE_TBL_ADDR 		(0xc0004000)
+
+struct saved_mmu_level_one {
+	u32 vaddr;
+	u32 entry_val;
+};
+
+static struct saved_mmu_level_one backup_tbl[1];
+
+/*
+ * Create the page directory entries for 0x0000,0000 <-> 0x0000,0000
+ */
+void create_mapping(void)
+{
+	//busy_waiting();
+	//__cpuc_flush_kern_all();
+	//__cpuc_flush_user_all();
+	*((volatile __u32 *)(PAGE_TBL_ADDR)) = 0xc4a;
+	//clean cache
+	__cpuc_flush_dcache_area((void *)(PAGE_TBL_ADDR), (long unsigned int)(PAGE_TBL_ADDR + 64*(sizeof(u32))));
+#if 0
+	__cpuc_coherent_user_range((long unsigned int)(PAGE_TBL_ADDR), (long unsigned int)(PAGE_TBL_ADDR + 64*(sizeof(u32))));
+	__cpuc_coherent_kern_range((long unsigned int)(PAGE_TBL_ADDR), (long unsigned int)(PAGE_TBL_ADDR + 64*(sizeof(u32))));
+	//v7_dma_clean_range((long unsigned int)(PAGE_TBL_ADDR), (long unsigned int)(PAGE_TBL_ADDR + (sizeof(u32))));
+	dmac_flush_range((long unsigned int)(PAGE_TBL_ADDR), (long unsigned int)(PAGE_TBL_ADDR + 64*(sizeof(u32))));
+	//actually, not need, just for test.
+	//flush_tlb_all();
+#endif
+	return;
+}
+
+/**save the va: 0x0000,0000 mapping.
+*@vaddr: the va of mmu mapping to save;
+*/
+void save_mapping(unsigned long vaddr)
+{
+	unsigned long addr;
+
+	//busy_waiting();
+	addr = vaddr & PAGE_MASK;
+
+	//__cpuc_flush_kern_all();
+	backup_tbl[0].vaddr = addr;
+	backup_tbl[0].entry_val = *((volatile __u32 *)(PAGE_TBL_ADDR));
+	//flush_tlb_all();
+
+	return;
+}
+
+/**restore the va: 0x0000,0000 mapping.
+*@vaddr: the va of mmu mapping to restore.
+*
+*/
+void restore_mapping(unsigned long vaddr)
+{
+	unsigned long addr;
+
+	addr = vaddr & PAGE_MASK;
+
+	if(addr != backup_tbl[0].vaddr){
+		while(1);
+		return;
+	}
+
+	//__cpuc_flush_kern_all();
+	*((volatile __u32 *)(PAGE_TBL_ADDR)) = backup_tbl[0].entry_val;
+	//clean cache
+	__cpuc_coherent_user_range((long unsigned int)(PAGE_TBL_ADDR), (long unsigned int)(PAGE_TBL_ADDR + (sizeof(u32))));
+	flush_tlb_all();
+
+	return;
+}
diff --git a/arch/arm/mach-sun6i/pm/mem_mapping.h b/arch/arm/mach-sun6i/pm/mem_mapping.h
new file mode 100644
index 0000000..f68eed8
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_mapping.h
@@ -0,0 +1,21 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, gq.yang China
+*                                             All Rights Reserved
+*
+* File    : mem_mapping.h
+* By      :
+* Version : v1.0
+* Date    : 2012-5-31 14:34
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __MEM_MAPPING_H__
+#define __MEM_MAPPING_H__
+
+#endif  /* __MEM_MAPPING_H__ */
diff --git a/arch/arm/mach-sun6i/pm/mem_mmu_pc.c b/arch/arm/mach-sun6i/pm/mem_mmu_pc.c
new file mode 100644
index 0000000..77fc450
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_mmu_pc.c
@@ -0,0 +1,90 @@
+#include <linux/power/aw_pm.h>
+#include "pm_types.h"
+#include "./pm.h"
+
+
+
+void save_mmu_state(struct mmu_state *saved_mmu_state)
+{
+	/* CR0 */
+	asm volatile ("mrc p15, 2, %0, c0, c0, 0" : "=r"(saved_mmu_state->cssr));
+	/* CR1 */
+	asm volatile ("mrc p15, 0, %0, c1, c0, 2" : "=r"(saved_mmu_state->cacr));
+
+	/* CR3 */
+	asm volatile ("mrc p15, 0, %0, c3, c0, 0" : "=r"(saved_mmu_state->dacr));
+
+	//save ttb
+	/* CR2 */
+	//busy_waiting();
+	asm volatile ("mrc p15, 0, %0, c2, c0, 0" : "=r"(saved_mmu_state->ttb_0r));
+	asm volatile ("mrc p15, 0, %0, c2, c0, 1" : "=r"(saved_mmu_state->ttb_1r));
+	asm volatile ("mrc p15, 0, %0, c2, c0, 2" : "=r"(saved_mmu_state->ttbcr));
+	/* CR1 */
+	//busy_waiting();
+	asm volatile ("mrc p15, 0, %0, c1, c0, 0" : "=r"(saved_mmu_state->cr));  //will effect visible addr space
+
+	return;
+}
+
+void restore_mmu_state(struct mmu_state *saved_mmu_state)
+{
+
+	//busy_waiting();
+	/* CR0 */
+	asm volatile ("mcr p15, 2, %0, c0, c0, 0" : : "r"(saved_mmu_state->cssr));
+	/* CR1 */
+	asm volatile ("mcr p15, 0, %0, c1, c0, 2" : : "r"(saved_mmu_state->cacr));
+	/* CR3 */
+	asm volatile ("mcr p15, 0, %0, c3, c0, 0" : : "r"(saved_mmu_state->dacr));
+
+	/* CR2 */
+	/*when translate 0x0000,0000, use ttb0, while ttb0 shoudbe the same with ttb1*/
+	asm volatile ("mcr p15, 0, %0, c2, c0, 0" : : "r"(saved_mmu_state->ttb_1r));
+	asm volatile ("mcr p15, 0, %0, c2, c0, 1" : : "r"(saved_mmu_state->ttb_1r));
+	asm volatile ("mcr p15, 0, %0, c2, c0, 2" : : "r"(saved_mmu_state->ttbcr));
+	asm("b __turn_mmu_on");
+	asm(".align 5");
+	asm(".type __turn_mmu_on, %function");
+	asm("__turn_mmu_on:");
+	asm("mov r0, r0");
+
+	/* CR1 */
+	/*cr: will effect visible addr space*/
+	asm volatile ("mcr p15, 0, %0, c1, c0, 0" : : "r"(saved_mmu_state->cr));
+	/*read id reg*/
+	asm volatile ("mrc p15, 0, r3, c0, c0, 0" : : );
+	asm("mov r3, r3");
+	asm("mov r3, r3");
+	asm("isb");
+
+	return;
+}
+
+#if 0
+void disable_mmu(void)
+{
+	__u32 c1format = 0;
+
+	asm volatile("mrc p15,0,%0,c1,c0,0" :"=r"(c1format) :);
+	c1format &= ~ 0x1007;
+	c1format |= 0;
+	asm volatile("mcr p15,0,%0,c1,c0,0" : :"r"(c1format));
+
+	/*read id reg*/
+	asm volatile ("mrc p15, 0, r3, c0, c0, 0" : : );
+	asm("mov r3, r3");
+	asm("mov r3, r3");
+	asm("isb");
+
+	return;
+}
+#endif
+
+//
+//void jump_to_resume(void* pointer)
+//{
+//	asm("mov lr, r0");
+//	asm("mov pc, lr");
+//	return;
+//}
diff --git a/arch/arm/mach-sun6i/pm/mem_mmu_pc_asm.S b/arch/arm/mach-sun6i/pm/mem_mmu_pc_asm.S
new file mode 100644
index 0000000..02a10fb
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_mmu_pc_asm.S
@@ -0,0 +1,489 @@
+#include <mach/platform.h>
+#include "./pm_config.h"
+
+/**-----------------------------stack point address in sram-----------------------------------------*/
+#define SP_IN_SRAM	0xf0007ffc //32k
+#define SP_IN_SRAM_PA   0x00007ffc //32k
+/*save_sp*/
+/*save_sp_nommu*/
+/*restore_sp*/
+/*get_sp*/
+
+    .text
+    .globl save_sp
+save_sp:
+    mov r0, r13
+    ldr  r13, =SP_IN_SRAM
+    mov pc,lr
+
+    .text
+    .globl save_sp_nommu
+save_sp_nommu:
+    mov r0, r13
+    ldr  r13, =SP_IN_SRAM_PA
+    mov pc,lr
+
+    .text
+    .globl restore_sp
+restore_sp:
+    mov r13, r0
+    mov pc,lr
+
+    .text
+    .globl get_sp
+get_sp:
+    mov r0, r13
+    mov pc,lr
+
+/*--------------------------------cache related api: ----------------------------------------------- */
+/*invalidate_dcache*/
+/*invalidate_icache*/
+/*flush_dcache*/
+/*flush_icache*/
+/*disable_cache*/
+/*disable_dcache*/
+/*disable_icache*/
+/*disable_l2cache*/
+/*enable_cache*/
+/*enable_icache*/
+
+	.align	4
+	.text
+	.globl invalidate_dcache	        /*can not use push and pop, because inval will discard the data in the stack*/
+invalidate_dcache:
+	/* Corrupted registers: r0-r7, r9-r11 (r6 only in Thumb mode) */
+	dmb					/* ensure ordering with previous memory accesses */
+	MRC     p15, 1, r0, c0, c0, 1       /*read clidr                              */
+	ANDS    r3, r0, #0x7000000          /*extract loc from clidr                  */
+	MOV     r3, r3, lsr #23             /*left align loc bit field                */
+	BEQ     inv_finished                    /*if loc is 0, then no need to clean      */
+	mov     r10, #0                     /*start clean at cache level 0            */
+inv_loop1:
+	ADD     r2, r10, r10, lsr #1        /*work out 3x current cache level         */
+	MOV     r1, r0, lsr r2              /*extract cache type bits from clidr      */
+	AND     r1, r1, #7                  /*mask of the bits for current cache only */
+	CMP     r1, #2                      /*see what cache we have at this level    */
+	BLT     inv_skip                        /*skip if no cache, or just i-cache       */
+	MCR     p15, 2, r10, c0, c0, 0      /*select current cache level in cssr      */
+	ISB                                 /*isb to sych the new cssr&csidr          */
+	MRC     p15, 1, r1, c0, c0, 0       /*read the new csidr                      */
+	AND     r2, r1, #7                  /*extract the length of the cache lines   */
+	ADD     r2, r2, #4                  /*add 4 (line length offset)              */
+	LDR     r4, =0x3ff
+	ANDS    r4, r4, r1, lsr #3          /*find maximum number on the way size     */
+	CLZ     r5, r4                      /*find bit position of way size increment */
+	LDR     r7, =0x7fff
+	ANDS    r7, r7, r1, lsr #13         /*extract max number of the index size    */
+inv_loop2:
+	MOV     r9, r4                      /*create working copy of max way size     */
+inv_loop3:
+	ORR     r11, r10, r9, lsl r5        /*factor way and cache number into r11    */
+	ORR     r11, r11, r7, lsl r2        /*factor index number into r11            */
+	MCR     p15, 0, r11, c7, c6, 2	      /*invalidate by set/way                  */
+	SUBS    r9, r9, #1                  /*decrement the way                       */
+	BGE     inv_loop3                       /*                                        */
+	SUBS    r7, r7, #1                  /*decrement the index                     */
+	BGE     inv_loop2                       /*                                        */
+inv_skip:                                   /*                                        */
+	ADD     r10, r10, #2                /*increment cache number                  */
+	CMP     r3, r10                     /*                                        */
+	BGT     inv_loop1                       /*                                        */
+inv_finished:                                /*                                        */
+	MOV     r10, #0                     /*swith back to cache level 0             */
+
+	MCR     p15, 2, r10, c0, c0, 0      /*select current cache level in cssr      */
+	dsb
+	ISB                                 /*                                        */
+
+	MOV     pc, lr                      /*                                        */
+
+	.text
+	.globl invalidate_icache
+invalidate_icache:
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c1, 0		@ invalidate I-cache inner shareable
+	mcr	p15, 0, r0, c7, c5, 0		@ I+BTB cache invalidate
+	dsb
+	ISB
+	mov	pc, lr
+
+    .text
+    .globl flush_dcache
+flush_dcache:
+    push    {r0-r12}
+    dmb					/* ensure ordering with previous memory accesses */
+    MRC     p15, 1, r0, c0, c0, 1       /*read clidr                              */
+    ANDS    r3, r0, #0x7000000          /*extract loc from clidr                  */
+    MOV     r3, r3, lsr #23             /*left align loc bit field                */
+    BEQ     finished                    /*if loc is 0, then no need to clean      */
+    mov     r10, #0                     /*start clean at cache level 0            */
+loop1:
+    ADD     r2, r10, r10, lsr #1        /*work out 3x current cache level         */
+    MOV     r1, r0, lsr r2              /*extract cache type bits from clidr      */
+    AND     r1, r1, #7                  /*mask of the bits for current cache only */
+    CMP     r1, #2                      /*see what cache we have at this level    */
+    BLT     skip                        /*skip if no cache, or just i-cache       */
+    MCR     p15, 2, r10, c0, c0, 0      /*select current cache level in cssr      */
+    ISB                                 /*isb to sych the new cssr&csidr          */
+    MRC     p15, 1, r1, c0, c0, 0       /*read the new csidr                      */
+    AND     r2, r1, #7                  /*extract the length of the cache lines   */
+    ADD     r2, r2, #4                  /*add 4 (line length offset)              */
+    LDR     r4, =0x3ff
+    ANDS    r4, r4, r1, lsr #3          /*find maximum number on the way size     */
+    CLZ     r5, r4                      /*find bit position of way size increment */
+    LDR     r7, =0x7fff
+    ANDS    r7, r7, r1, lsr #13         /*extract max number of the index size    */
+loop2:
+    MOV     r9, r4                      /*create working copy of max way size     */
+loop3:
+    ORR     r11, r10, r9, lsl r5        /*factor way and cache number into r11    */
+    ORR     r11, r11, r7, lsl r2        /*factor index number into r11            */
+    MCR     p15, 0, r11, c7, c14, 2	      /*clean & invalidate by set/way                  */
+    SUBS    r9, r9, #1                  /*decrement the way                       */
+    BGE     loop3                       /*                                        */
+    SUBS    r7, r7, #1                  /*decrement the index                     */
+    BGE     loop2                       /*                                        */
+skip:                                   /*                                        */
+    ADD     r10, r10, #2                /*increment cache number                  */
+    CMP     r3, r10                     /*                                        */
+    BGT     loop1                       /*                                        */
+finished:                                /*                                        */
+    MOV     r10, #0                     /*swith back to cache level 0             */
+
+    MCR     p15, 2, r10, c0, c0, 0      /*select current cache level in cssr      */
+    dsb
+    ISB                                 /*                                        */
+    pop    {r0-r12}
+    MOV     pc, lr                      /*                                        */
+
+
+    .text
+    .globl flush_icache
+flush_icache:
+    push    {r0-r3}
+    MOV     r0, #0
+    MCR     p15, 0, r0, c7, c5, 0       /*Instruction cache invalidate all to PoU    */
+    MCR     p15, 0, r0, c7, c1, 0 	/*Instruction cache invalidate all to PoUa Inner Shareable*/
+    MCR     p15, 0, r0, c7, c1, 6	/*Branch predictor invalidate all Inner Shareable*/
+    ISB
+    dsb
+    pop     {r0-r3}
+    MOV     pc, lr
+
+    .text
+    .globl disable_cache
+disable_cache:
+    push    {r0-r3}
+    MRC     p15, 0, r0, c1, c0, 0       /*read cr                  */
+    BIC	    r0, r0, #0x1 << 12
+    BIC	    r0, r0, #0x1 << 2
+    MCR     p15, 0, r0, c1, c0, 0       /*disable cache                  */
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+
+    .text
+    .globl disable_dcache
+disable_dcache:
+    push    {r0-r3}
+    MRC     p15, 0, r0, c1, c0, 0       /*read cr                  */
+    BIC	    r0, r0, #(0x1 << 2)
+    MCR     p15, 0, r0, c1, c0, 0       /*disable dcache                  */
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+
+    .text
+    .globl disable_icache
+disable_icache:
+    push    {r0-r3}
+    MRC     p15, 0, r0, c1, c0, 0       /*read cr                  */
+    BIC	    r0, r0, #(0x1 << 12)
+    MCR     p15, 0, r0, c1, c0, 0       /*disable icache                  */
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+
+
+    .text
+    .globl disable_l2cache
+disable_l2cache:
+    push    {r0-r3}
+    MRC     p15, 0, r0, c1, c0, 1       /*read acr                  */
+    BIC	    r0, r0, #0x1 << 1
+    MCR     p15, 0, r0, c1, c0, 1       /*disable l2cache                  */
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+
+    .text
+    .globl enable_cache
+enable_cache:
+    push    {r0-r3}
+    MRC     p15, 0, r0, c1, c0, 0       /*read cr                  */
+    ORR	    r0, r0, #0x1 << 12
+    ORR	    r0, r0, #0x1 << 2
+    MCR     p15, 0, r0, c1, c0, 0       /*enable cache                  */
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+
+    .text
+    .globl enable_icache
+enable_icache:
+    push    {r0-r3}
+    MRC     p15, 0, r0, c1, c0, 0       /*read cr                  */
+    ORR	    r0, r0, #(0x1 << 12)
+    MCR     p15, 0, r0, c1, c0, 0       /*disable dcache                  */
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+
+/*--------------------------------------prediction----------------------------------------*/
+/*invalidate_branch_predictor*/
+/*disable_program_flow_prediction*/
+/*enable_program_flow_prediction*/
+
+    .text
+    .globl invalidate_branch_predictor
+invalidate_branch_predictor:
+    push    {r0-r3}
+    MOV	    r0, #0
+    MCR     p15, 0, r0, c7, c5, 6       /*(invalidate entire branch predictor array)*/
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+
+
+    .text
+    .globl disable_program_flow_prediction
+disable_program_flow_prediction:
+    push    {r0-r3}
+    MRC     p15, 0, r0, c1, c0, 0       /*read cr                  */
+    BIC	    r0, r0, #0x800
+    MCR     p15, 0, r0, c1, c0, 0       /*disable  program_flow_prediction                 */
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+
+    .text
+    .globl enable_program_flow_prediction
+enable_program_flow_prediction:
+    push    {r0-r3}
+    MRC     p15, 0, r0, c1, c0, 0       /*read cr                  */
+    ORR	    r0, r0, #0x800
+    MCR     p15, 0, r0, c1, c0, 0       /*disable  program_flow_prediction                 */
+    ISB
+    pop     {r0-r3}
+    MOV     pc, lr
+
+/*-------------------------------------tlb related api:----------------------------------------*/
+/*mem_flush_tlb*/
+/*mem_preload_tlb*/
+
+	.text
+	.globl mem_flush_tlb
+mem_flush_tlb:
+	push    {r0-r3}
+	MOV     r0, #0
+	/*instruction entire instruction tlb*/
+	mcr p15, 0, r0, c8, c5, 0
+	/* invalid entire data tlb */
+	mcr p15, 0, r0, c8, c6, 0
+	/*invalidate entire unified TLB inner shareable*/
+	mcr p15, 0, r0, c8, c3, 0
+	dsb
+    ISB
+	pop     {r0-r3}
+	mov pc,lr
+
+    .text
+    .globl mem_preload_tlb
+mem_preload_tlb:
+	push    {r0-r3}
+	/*32k*/
+	ldr r0, =IO_ADDRESS(AW_SRAM_A1_BASE)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A1_BASE + 0x1000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A1_BASE + 0x2000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A1_BASE + 0x3000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A1_BASE + 0x4000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A1_BASE + 0x5000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A1_BASE + 0x6000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A1_BASE + 0x7000)
+	ldr r1, [r0]
+
+	/*80k*/
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0x1000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0x2000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0x3000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0x4000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0x5000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0x6000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0x7000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0x8000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0x9000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0xa000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0xb000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0xc000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0xd000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0xe000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0xf000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0x10000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0x11000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0x12000)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SRAM_A2_BASE + 0x13000)
+	ldr r1, [r0]
+
+	ldr r0, =IO_ADDRESS(AW_MSGBOX_BASE)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_SPINLOCK_BASE)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_PIO_BASE)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_R_PRCM_BASE)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_UART0_BASE)
+	ldr r1, [r0]
+	ldr r0, =IO_ADDRESS(AW_RTC_REG)
+	ldr r1, [r0]
+
+	dsb
+	isb
+
+	pop     {r0-r3}
+	mov pc,lr
+
+/*--------------------------------------mmu----------------------------------------*/
+/*disable_mmu*/
+/*enable_mmu*/
+
+    .text
+    .globl disable_mmu
+disable_mmu:
+		/*read cr*/
+                MRC p15,0,r1,c1,c0,0
+                BIC r1, #0x1000
+                BIC r1, #0x0005
+                b __turn_mmu_off
+                .align 5
+
+                .type __turn_mmu_off, %function
+__turn_mmu_off:
+                /*write cr: disable cache and mmu*/
+                MCR p15,0,r1,c1,c0,0
+		/*read id reg*/
+                mrc p15, 0, r3, c0, c0, 0
+                mov r3, r3
+                mov r3, r3
+                /*return*/
+                mov pc, lr
+
+    .text
+    .globl enable_mmu
+enable_mmu:
+		/*read cr*/
+                MRC p15,0,r1,c1,c0,0
+                ORR r1, #0x1000
+                ORR r1, #0x0005
+                b __turn_mmu_on
+                .align 5
+
+                .type __turn_mmu_on, %function
+__turn_mmu_on:
+                /*write cr: enable cache and mmu*/
+                MCR p15,0,r1,c1,c0,0
+		/*read id reg*/
+                mrc p15, 0, r3, c0, c0, 0
+                mov r3, r3
+                mov r3, r3
+                /*return*/
+                mov pc, lr
+
+/*----------------------------------------pc related api:---------------------------------------*/
+/*jump_to_suspend*/
+/*jump_to_resume*/
+/*jump_to_resume0*/
+/*jump_to_resume0_nommu*/
+
+	.text
+	.globl jump_to_suspend
+jump_to_suspend:
+	/*enable 0x0000 <-->  0x0000 mapping */
+	/*write ttbr0*/
+	mcr p15, 0, r0, c2, c0, 0
+	dsb
+	isb
+
+	mov pc, r1
+
+	.align	4
+	.text
+	.globl jump_to_resume
+jump_to_resume:
+	/*before jump to resume:
+	 * 1st: invalidate the data
+	 * 2nd: restore r0-r13.
+	 * 3rd: jump (para 1).
+	 */
+	/* Set the return pointer */
+	mov     r12, r0
+	mov 	r8, r1
+	bl	invalidate_dcache
+	mov	r1, r8
+	mov	lr, r12
+	ldmia   r1, {r0 - r13}
+        mov     pc, lr
+
+	.align	4
+	.globl jump_to_resume0
+jump_to_resume0:
+        /* Set the return pointer */
+	mov     lr, r0
+	mov     pc, lr
+
+	.align	4
+
+	.globl jump_to_resume0_nommu
+jump_to_resume0_nommu:
+	/*read cr*/
+        MRC p15,0,r1,c1,c0,0
+        BIC r1, #0x1000
+        BIC r1, #0x0007
+        /*write cr: disable cache and mmu*/
+        MCR p15,0,r1,c1,c0,0
+	/*read id reg*/
+        mrc p15, 0, r3, c0, c0, 0
+        mov r3, r3
+        mov r3, r3
+	/* Set the return pointer */
+	mov     lr, r0
+	isb
+
+	mov     pc, lr
diff --git a/arch/arm/mach-sun6i/pm/mem_printk.c b/arch/arm/mach-sun6i/pm/mem_printk.c
new file mode 100644
index 0000000..5aee069
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_printk.c
@@ -0,0 +1,486 @@
+/**
+ * common.c - common operations
+ * date:    2012-2-13 8:42:56
+ * author:  Aaron<leafy.myeh@allwinnertech.com>
+ * history: V0.1
+ */
+
+
+#ifdef __STANDBY_MODULE__
+#include "pm_types.h"
+#include "pm.h"
+#include <stdarg.h>
+#elif defined(__KERNEL__)
+#include <linux/module.h>
+#include "pm_i.h"
+__s32 print_align(char *string, __s32 len, __s32 align);
+
+#endif
+
+#define NUM_TYPE long long
+
+#define ZEROPAD	1		/* pad with zero */
+#define SIGN	2		/* unsigned/signed long */
+#define PLUS	4		/* show plus */
+#define SPACE	8		/* space if plus */
+#define LEFT	16		/* left justified */
+#define SMALL	32		/* Must be 32 == 0x20 */
+#define SPECIAL	64		/* 0x */
+#define is_digit(c)	((c) >= '0' && (c) <= '9')
+
+
+/* Basic string functions */
+
+/*
+  s t r l e n
+
+  returns number of characters in s (not including terminating null character)
+*/
+size_t strlen(const char *s)
+{
+	const char *sc;
+
+	for (sc = s; *sc != '\0'; ++sc)
+	{
+		/* nothing */
+		;
+	}
+	return sc - s;
+}
+
+/*
+  s t r c p y
+
+  Copy 'src' to 'dest'. Strings may not overlap.
+*/
+char *strcpy(char *dest, const char *src)
+{
+	char *tmp = dest;
+
+	while ((*dest++ = *src++) != '\0')
+	{
+		/* nothing */
+		;
+	}
+	return tmp;
+}
+
+char *strncpy(char *dest, const char *src, size_t count)
+{
+	char *tmp = dest;
+
+	while (count)
+	{
+		if ((*tmp = *src) != 0)
+		{
+			src++;
+		}
+		tmp++;
+		count--;
+	}
+	return dest;
+}
+
+
+char *strcat(char *dest, const char *src)
+{
+	char *tmp = dest;
+
+	while (*dest)
+	{
+		dest++;
+	}
+	while ((*dest++ = *src++) != '\0')
+	{
+		;
+	}
+	return tmp;
+}
+
+
+char *strncat(char *dest, const char *src, size_t count)
+{
+	char *tmp = dest;
+
+	if (count)
+	{
+		while (*dest)
+		{
+			dest++;
+		}
+		while ((*dest++ = *src++) != 0)
+		{
+			if (--count == 0)
+			{
+				*dest = '\0';
+				break;
+			}
+		}
+	}
+	return tmp;
+}
+
+int strcmp(const char *cs, const char *ct)
+{
+	unsigned char c1, c2;
+
+	while (1)
+	{
+		c1 = *cs++;
+		c2 = *ct++;
+		if (c1 != c2)
+		{
+			return c1 < c2 ? -1 : 1;
+		}
+		if (!c1)
+		{
+			break;
+		}
+	}
+	return 0;
+}
+
+
+int strncmp(const char *cs, const char *ct, size_t count)
+{
+	unsigned char c1, c2;
+
+	while (count) {
+		c1 = *cs++;
+		c2 = *ct++;
+		if (c1 != c2)
+			return c1 < c2 ? -1 : 1;
+		if (!c1)
+			break;
+		count--;
+	}
+	return 0;
+}
+
+static int skip_atoi(const char **s)
+{
+	int i=0;
+
+	while (is_digit(**s))
+		i = i*10 + *((*s)++) - '0';
+	return i;
+}
+
+char *itoa(int value, char *string, int radix)
+{
+	char stack[16];
+	int  negative = 0;			//defualt is positive value
+	int  i;
+	int  j;
+	char digit_string[] = "0123456789ABCDEF";
+
+	if(value == 0)
+	{
+		//zero
+		string[0] = '0';
+		string[1] = '\0';
+		return string;
+	}
+
+	if(value < 0)
+	{
+		//'value' is negative, convert to postive first
+		negative = 1;
+		value = -value ;
+	}
+
+	for(i = 0; value > 0; ++i)
+	{
+		// characters in reverse order are put in 'stack'.
+		stack[i] = digit_string[value % radix];
+		value /= radix;
+	}
+
+	//restore reversed order result to user string
+    j = 0;
+	if(negative)
+	{
+		//add sign at first charset.
+		string[j++] = '-';
+	}
+	for(--i; i >= 0; --i, ++j)
+	{
+		string[j] = stack[i];
+	}
+	//must end with '\0'.
+	string[j] = '\0';
+
+	return string;
+}
+
+char *utoa(unsigned int value, char *string, int radix)
+{
+	char stack[16];
+	int  i;
+	int  j;
+	char digit_string[] = "0123456789ABCDEF";
+
+	if(value == 0)
+	{
+		//zero
+		string[0] = '0';
+		string[1] = '\0';
+		return string;
+	}
+
+	for(i = 0; value > 0; ++i)
+	{
+		// characters in reverse order are put in 'stack'.
+		stack[i] = digit_string[value % radix];
+		value /= radix;
+	}
+
+	//restore reversed order result to user string
+    for(--i, j = 0; i >= 0; --i, ++j)
+	{
+		string[j] = stack[i];
+	}
+	//must end with '\0'.
+	string[j] = '\0';
+
+	return string;
+}
+
+/*
+*********************************************************************************************************
+*                                       	FORMATTED PRINTF
+*
+* Description: 	print out a formatted string, similar to ANSI-C function printf().
+*				This function can support and only support the following conversion specifiers:
+*              	%d	signed decimal integer.
+*              	%u	unsigned decimal integer.
+*              	%x	unsigned hexadecimal integer, using hex digits 0x.
+*              	%c	single character.
+*              	%s	character string.
+*
+* Arguments  : 	format	: format control.
+*				...		: arguments.
+*
+* Returns    : 	the number of characters printed out.
+*
+* Note		 : 	the usage refer to ANSI-C function printf().
+*********************************************************************************************************
+*/
+char debugger_buffer[DEBUG_BUFFER_SIZE];
+__s32 printk(const char *format, ...)
+{
+	va_list args;
+	char 	string[16];	//align by cpu word
+	char 	*pdest;
+	char 	*psrc;
+	__s32 	align;
+	__s32		len = 0;
+
+	//dump current timestemp
+	//print_current_time();
+
+	pdest = debugger_buffer;
+	va_start(args, format);
+	while(*format)
+	{
+		if(*format == '%')
+		{
+			++format;
+			if (('0' < (*format)) && ((*format) <= '9'))
+			{
+				//we just suport wide from 1 to 9.
+				align = *format - '0';
+				++format;
+			}
+			else
+			{
+				align = 0;
+			}
+			switch(*format)
+			{
+				case 'd':
+				{
+					//int
+					itoa(va_arg(args, int), string, 10);
+                    len = strlen(string);
+                    len += print_align(string, len, align);
+                    strcpy(pdest, string);
+                    pdest += len;
+                    break;
+				}
+				case 'x':
+				case 'p':
+				{
+					//hex
+					utoa(va_arg(args, int), string, 16);
+					len = strlen(string);
+					len += print_align(string, len, align);
+					strcpy(pdest, string);
+                    pdest += len;
+                    break;
+				}
+				case 'u':
+				{
+					//unsigned int
+					utoa(va_arg(args, int), string, 10);
+                    len = strlen(string);
+                    len += print_align(string, len, align);
+                    strcpy(pdest, string);
+					pdest += len;
+					break;
+				}
+				case 'c':
+				{
+					//charset, aligned by cpu word
+					*pdest = (char)va_arg(args, int);
+					break;
+				}
+				case 's':
+				{
+					//string
+					psrc = va_arg(args, char *);
+					strcpy(pdest, psrc);
+					pdest += strlen(psrc);
+					break;
+				}
+				default :
+				{
+					//no-conversion
+					*pdest++ = '%';
+					*pdest++ = *format;
+				}
+			}
+		}
+		else
+		{
+			*pdest++ = *format;
+		}
+		//parse next token
+		++format;
+	}
+	va_end(args);
+
+	//must end with '\0'
+	*pdest = '\0';
+	pdest++;
+	serial_puts(debugger_buffer);
+
+	return (pdest - debugger_buffer);
+}
+
+
+__s32 print_align(char *string, __s32 len, __s32 align)
+{
+	//fill with space ' ' when align request,
+	//the max align length is 16 byte.
+	char fill_ch[] = "                ";
+	if (len < align)
+	{
+		//fill at right
+		strncat(string, fill_ch, align - len);
+		return align - len;
+	}
+	//not fill anything
+	return 0;
+}
+
+__s32 printk_nommu(const char *format, ...)
+{
+	va_list args;
+	char 	string[16];	//align by cpu word
+	char 	*pdest;
+	char 	*psrc;
+	__s32 	align;
+	__s32		len = 0;
+
+	//dump current timestemp
+	//print_current_time();
+
+	pdest = debugger_buffer;
+	va_start(args, format);
+	while(*format)
+	{
+		if(*format == '%')
+		{
+			++format;
+			if (('0' < (*format)) && ((*format) <= '9'))
+			{
+				//we just suport wide from 1 to 9.
+				align = *format - '0';
+				++format;
+			}
+			else
+			{
+				align = 0;
+			}
+			switch(*format)
+			{
+				case 'd':
+				{
+					//int
+					itoa(va_arg(args, int), string, 10);
+                    len = strlen(string);
+                    len += print_align(string, len, align);
+                    strcpy(pdest, string);
+                    pdest += len;
+                    break;
+				}
+				case 'x':
+				case 'p':
+				{
+					//hex
+					utoa(va_arg(args, int), string, 16);
+					len = strlen(string);
+					len += print_align(string, len, align);
+					strcpy(pdest, string);
+                    pdest += len;
+                    break;
+				}
+				case 'u':
+				{
+					//unsigned int
+					utoa(va_arg(args, int), string, 10);
+                    len = strlen(string);
+                    len += print_align(string, len, align);
+                    strcpy(pdest, string);
+					pdest += len;
+					break;
+				}
+				case 'c':
+				{
+					//charset, aligned by cpu word
+					*pdest = (char)va_arg(args, int);
+					break;
+				}
+				case 's':
+				{
+					//string
+					psrc = va_arg(args, char *);
+					strcpy(pdest, psrc);
+					pdest += strlen(psrc);
+					break;
+				}
+				default :
+				{
+					//no-conversion
+					*pdest++ = '%';
+					*pdest++ = *format;
+				}
+			}
+		}
+		else
+		{
+			*pdest++ = *format;
+		}
+		//parse next token
+		++format;
+	}
+	va_end(args);
+
+	//must end with '\0'
+	*pdest = '\0';
+	pdest++;
+	serial_puts_nommu(debugger_buffer);
+
+	return (pdest - debugger_buffer);
+}
diff --git a/arch/arm/mach-sun6i/pm/mem_printk.h b/arch/arm/mach-sun6i/pm/mem_printk.h
new file mode 100644
index 0000000..2e43960
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_printk.h
@@ -0,0 +1,27 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2012-2015,  China
+*                                             All Rights Reserved
+*
+* File    : mem_printk.h
+* By      : young
+* Version : v1.0
+* Date    : 2011-5-30 19:50
+* Descript: intterupt bsp for platform standby.
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __MEM_PRINTK_H__
+#define __MEM_PRINTK_H__
+
+#define DEBUG_BUFFER_SIZE (256)
+//other module may define printk, while its declaration may not be the same with this.
+//so, it not proper to export this symbols to global.
+__s32 printk(const char *format, ...);
+__s32 printk_nommu(const char *format, ...);
+
+#endif  //__MEM_PRINTK_H__
\ No newline at end of file
diff --git a/arch/arm/mach-sun6i/pm/mem_serial.c b/arch/arm/mach-sun6i/pm/mem_serial.c
new file mode 100644
index 0000000..0e27d5a
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_serial.c
@@ -0,0 +1,235 @@
+/**
+ * serial.c - common operations
+ * date:    2012-2-13 8:42:56
+ * author:  Aaron<leafy.myeh@allwinnertech.com>
+ * history: V0.1
+ */
+
+#include "pm_types.h"
+#include "pm.h"
+
+//------------------------------------------------------------------------------
+//return value defines
+//------------------------------------------------------------------------------
+#define	OK		(0)
+#define	FAIL	(-1)
+#define TRUE	(1)
+#define	FALSE	(0)
+
+#define NULL	(0)
+
+#define readb(addr)		(*((volatile unsigned char  *)(addr)))
+#define readw(addr)		(*((volatile unsigned short *)(addr)))
+#define readl(addr)		(*((volatile unsigned long  *)(addr)))
+#define writeb(v, addr)	(*((volatile unsigned char  *)(addr)) = (unsigned char)(v))
+#define writew(v, addr)	(*((volatile unsigned short *)(addr)) = (unsigned short)(v))
+#define writel(v, addr)	(*((volatile unsigned long  *)(addr)) = (unsigned long)(v))
+
+void serial_init_nommu(void)
+{
+	__u32 p2clk;
+	__u32 df;
+	__u32 lcr;
+	volatile unsigned int *reg;
+	__u32 port = 0;
+	__u32 i = 0;
+
+	p2clk = (24000000);
+
+	//config uart clk
+	reg = (volatile unsigned int *)(CCU_UART_PA);
+	*reg &= ~(1 << (16 + port));
+	for( i = 0; i < 100; i++ );
+	*reg |=  (1 << (16 + port));
+	//de-assert uart reset
+	reg = (volatile unsigned int *)(CCU_UART_RESET_PA);
+	*reg &= ~(1 << (16 + port));
+	for( i = 0; i < 100; i++ );
+	*reg |=  (1 << (16 + port));
+
+	// config uart gpio
+	// config tx gpio
+	//fpga not need care gpio config;
+	reg = (volatile unsigned int *)(0x01c20800 + 0x104);
+	*reg &= ~(0x77 << (16 + port));
+	for( i = 0; i < 100; i++ );
+	*reg |=  (0x22 << (16 + port));
+
+	/* set baudrate */
+	df = (p2clk + (SUART_BAUDRATE<<3))/(SUART_BAUDRATE<<4);
+	lcr = readl(SUART_LCR_PA);
+	writel(1, SUART_HALT_PA);
+	writel(lcr|0x80, SUART_LCR_PA);
+	writel(df>>8, SUART_DLH_PA);
+	writel(df&0xff, SUART_DLL_PA);
+	writel(lcr&(~0x80), SUART_LCR_PA);
+	writel(0, SUART_HALT_PA);
+
+	/* set mode, Set Lin Control Register*/
+	writel(3, SUART_LCR_PA);
+	/* enable fifo */
+	writel(0xe1, SUART_FCR_PA);
+
+}
+
+static void serial_put_char_nommu(char c)
+{
+	while (!(readb(SUART_USR_PA) & 2));
+	writeb(c, SUART_THR_PA);
+}
+
+static char serial_get_char_nommu(void)
+{
+	__u32 time = 0xffff;
+	while(!(readb(SUART_USR_PA)&0x08) && time);
+	if (!time)
+		return 0;
+	return readb(SUART_RBR_PA);
+}
+
+__s32 serial_puts_nommu(const char *string)
+{
+	//ASSERT(string != NULL);
+
+	while(*string != '\0')
+	{
+		if(*string == '\n')
+		{
+			// if current character is '\n',
+			// insert output with '\r'.
+			serial_put_char_nommu('\r');
+		}
+		serial_put_char_nommu(*string++);
+	}
+
+	return OK;
+}
+
+__u32 serial_gets_nommu(char* buf, __u32 n)
+{
+	__u32 i;
+	char c;
+
+	for (i=0; i<n; i++) {
+		c = serial_get_char_nommu();
+		if (c == 0)
+			break;
+		buf[i] = c;
+	}
+	return i+1;
+}
+
+void serial_init(void)
+{
+	__u32 p2clk;
+	__u32 df;
+	__u32 lcr;
+	volatile unsigned int *reg;
+	__u32 port = 0;
+	__u32 i = 0;
+
+	p2clk = (24000000);
+
+	//judge uart clk
+
+	//config uart clk
+	reg = (volatile unsigned int *)(CCU_UART_VA);
+	*reg &= ~(1 << (16 + port));
+	for( i = 0; i < 100; i++ );
+	*reg |=  (1 << (16 + port));
+	//de-assert uart reset
+	reg = (volatile unsigned int *)(IO_ADDRESS(CCU_UART_RESET_PA));
+	*reg &= ~(1 << (16 + port));
+	for( i = 0; i < 100; i++ );
+	*reg |=  (1 << (16 + port));
+	// config uart gpio
+	//de-assert uart reset
+	reg = (volatile unsigned int *)(CCU_UART_RESET_VA);
+	*reg &= ~(1 << (16 + port));
+	for( i = 0; i < 100; i++ );
+	*reg |=  (1 << (16 + port));
+
+	// config tx gpio
+	//fpga not need care gpio config;
+	reg = (volatile unsigned int *)(0xf1c20800 + 0x104);
+	*reg &= ~(0x77 << (16 + port));
+	for( i = 0; i < 100; i++ );
+	*reg |=  (0x22 << (16 + port));
+
+	/* set baudrate */
+	df = (p2clk + (SUART_BAUDRATE<<3))/(SUART_BAUDRATE<<4);
+	lcr = readl(SUART_LCR);
+	writel(1, SUART_HALT);
+	writel(lcr|0x80, SUART_LCR);
+	writel(df>>8, SUART_DLH);
+	writel(df&0xff, SUART_DLL);
+	writel(lcr&(~0x80), SUART_LCR);
+	writel(0, SUART_HALT);
+
+	/* set mode, Set Lin Control Register*/
+	writel(3, SUART_LCR);
+	/* enable fifo */
+	writel(0xe1, SUART_FCR);
+
+}
+
+
+static void serial_put_char(char c)
+{
+	while (!(readb(SUART_USR) & 2));
+	writeb(c, SUART_THR);
+}
+
+static char serial_get_char(void)
+{
+	__u32 time = 0xffff;
+	while(!(readb(SUART_USR)&0x08) && time);
+	if (!time)
+		return 0;
+	return readb(SUART_RBR);
+}
+
+
+/*
+*********************************************************************************************************
+*                                       	PUT A STRING
+*
+* Description: 	put out a string.
+*
+* Arguments  : 	string	: the string which we want to put out.
+*
+* Returns    : 	OK if put out string succeeded, others if failed.
+*********************************************************************************************************
+*/
+__s32 serial_puts(const char *string)
+{
+	//ASSERT(string != NULL);
+
+	while(*string != '\0')
+	{
+		if(*string == '\n')
+		{
+			// if current character is '\n',
+			// insert output with '\r'.
+			serial_put_char('\r');
+		}
+		serial_put_char(*string++);
+	}
+
+	return OK;
+}
+
+
+__u32 serial_gets(char* buf, __u32 n)
+{
+	__u32 i;
+	char c;
+
+	for (i=0; i<n; i++) {
+		c = serial_get_char();
+		if (c == 0)
+			break;
+		buf[i] = c;
+	}
+	return i+1;
+}
diff --git a/arch/arm/mach-sun6i/pm/mem_serial.h b/arch/arm/mach-sun6i/pm/mem_serial.h
new file mode 100644
index 0000000..f3216a2
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_serial.h
@@ -0,0 +1,59 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : mem_serial.h
+* By      :
+* Version : v1.0
+* Date    : 2011-5-31 14:34
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __MEM_SERIAL_H__
+#define __MEM_SERIAL_H__
+#include "pm.h"
+
+
+#define SUART_BASE_PA	(AW_UART0_BASE)
+#define SUART_BASE_VA	IO_ADDRESS(SUART_BASE_PA)
+
+#define SUART_RBR_PA	(SUART_BASE_PA + 0x00)
+#define SUART_THR_PA	(SUART_BASE_PA + 0x00)
+#define SUART_DLL_PA	(SUART_BASE_PA + 0x00)
+#define SUART_DLH_PA	(SUART_BASE_PA + 0x04)
+#define SUART_FCR_PA	(SUART_BASE_PA + 0x08)
+#define SUART_LCR_PA	(SUART_BASE_PA + 0x0c)
+#define SUART_USR_PA	(SUART_BASE_PA + 0x7c)
+#define SUART_HALT_PA	(SUART_BASE_PA + 0xa4)
+
+#define SUART_RBR	(SUART_BASE_VA + 0x00)
+#define SUART_THR	(SUART_BASE_VA + 0x00)
+#define SUART_DLL	(SUART_BASE_VA + 0x00)
+#define SUART_DLH	(SUART_BASE_VA + 0x04)
+#define SUART_FCR	(SUART_BASE_VA + 0x08)
+#define SUART_LCR	(SUART_BASE_VA + 0x0c)
+#define SUART_USR	(SUART_BASE_VA + 0x7c)
+#define SUART_HALT	(SUART_BASE_VA + 0xa4)
+
+#define SUART_BAUDRATE	(115200)
+#define CCU_UART_PA		(0x01c2006C)
+#define CCU_UART_RESET_PA		(0x01c202D8)
+
+#define CCU_UART_VA		(0xF1c2006C)
+#define CCU_UART_RESET_VA		(0xF1c202D8)
+
+void serial_init(void);
+__s32 serial_puts(const char *string);
+__u32 serial_gets(char* buf, __u32 n);
+void serial_init_nommu(void);
+__s32 serial_puts_nommu(const char *string);
+__u32 serial_gets_nommu(char* buf, __u32 n);
+
+
+#endif  /* __MEM_SERIAL_H__ */
diff --git a/arch/arm/mach-sun6i/pm/mem_sram.c b/arch/arm/mach-sun6i/pm/mem_sram.c
new file mode 100644
index 0000000..c9c7bd4
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_sram.c
@@ -0,0 +1,47 @@
+#include "pm_types.h"
+#include "pm_i.h"
+
+/*
+*********************************************************************************************************
+*                                       MEM SRAM SAVE
+*
+* Description: mem sram save.
+*
+* Arguments  : none.
+*
+* Returns    : 0/-1;
+*********************************************************************************************************
+*/
+__s32 mem_sram_save(struct sram_state *psram_state)
+{
+	int i=0;
+
+	/*save all the sram reg*/
+	for(i=0; i<(SRAM_REG_LENGTH); i++){
+		psram_state->sram_reg_back[i] = *(volatile __u32 *)(IO_ADDRESS(AW_SRAMCTRL_BASE) + i*0x04);
+	}
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                       MEM sram restore
+*
+* Description: mem sram restore.
+*
+* Arguments  : none.
+*
+* Returns    : 0/-1;
+*********************************************************************************************************
+*/
+__s32 mem_sram_restore(struct sram_state *psram_state)
+{
+	int i=0;
+
+	/*restore all the sram reg*/
+	for(i=0; i<(SRAM_REG_LENGTH); i++){
+		 *(volatile __u32 *)(IO_ADDRESS(AW_SRAMCTRL_BASE) + i*0x04) = psram_state->sram_reg_back[i];
+	}
+
+	return 0;
+}
diff --git a/arch/arm/mach-sun6i/pm/mem_timing.c b/arch/arm/mach-sun6i/pm/mem_timing.c
new file mode 100644
index 0000000..c89cd10
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_timing.c
@@ -0,0 +1,288 @@
+#include "pm_types.h"
+#include "./pm.h"
+
+#define CCU_REG_VA (0xF1c20000)
+#define CCU_REG_PA (0x01c20000)
+
+static __u32 cpu_freq = 0;
+static __u32 overhead = 0;
+static __u32 backup_perf_counter_ctrl_reg = 0;
+static __u32 backup_perf_counter_enable_reg = 0;
+
+static __u32 match_event_counter(enum counter_type_e type);
+
+void init_perfcounters (__u32 do_reset, __u32 enable_divider)
+{
+	// in general enable all counters (including cycle counter)
+	__u32 value = 1;
+
+	// peform reset:
+	if (do_reset)
+	{
+		value |= 2;     // reset all counters to zero.
+		value |= 4;     // reset cycle counter to zero.
+	}
+
+	if (enable_divider)
+		value |= 8;     // enable "by 64" divider for CCNT.
+
+	value |= 16;
+
+	// program the performance-counter control-register:
+	asm volatile ("mcr p15, 0, %0, c9, c12, 0" : : "r"(value));
+
+	// enable all counters:
+	value = 0x8000000f;
+	asm volatile ("mcr p15, 0, %0, c9, c12, 1" : : "r"(value));
+
+	// clear overflows:
+	asm volatile ("MCR p15, 0, %0, c9, c12, 3" : : "r"(value));
+
+	return;
+}
+
+void backup_perfcounter(void)
+{
+	//backup performance-counter ctrl reg
+	asm volatile ("MRC p15, 0, %0, c9, c12, 0\t\n": "=r"(backup_perf_counter_ctrl_reg));
+
+	//backup enable reg
+	asm volatile ("MRC p15, 0, %0, c9, c12, 1\t\n": "=r"(backup_perf_counter_enable_reg));
+
+}
+
+void restore_perfcounter(void)
+{
+
+	// restore performance-counter control-register:
+	asm volatile ("mcr p15, 0, %0, c9, c12, 0" : : "r"(backup_perf_counter_ctrl_reg));
+
+	// restore enable reg
+	asm volatile ("mcr p15, 0, %0, c9, c12, 1" : : "r"(backup_perf_counter_enable_reg));
+
+}
+
+__u32 get_cyclecount (void)
+{
+	__u32 value;
+	// Read CCNT Register
+	asm volatile ("MRC p15, 0, %0, c9, c13, 0\t\n": "=r"(value));
+	return value;
+}
+
+void reset_counter(void)
+{
+	__u32 value = 0;
+
+	asm volatile ("mrc p15, 0, %0, c9, c12, 0" : : "r"(value));
+	value |= 4;     // reset cycle counter to zero.
+	// program the performance-counter control-register:
+	//__asm {MCR p15, 0, value, c9, c12, 0}
+	asm volatile ("mcr p15, 0, %0, c9, c12, 0" : : "r"(value));
+}
+
+void change_runtime_env(__u32 mmu_flag)
+{
+	__u32 factor_n = 0;
+	__u32 factor_k = 0;
+	__u32 factor_m = 0;
+	__u32 start = 0;
+	__u32 cmu_reg = 0;
+	volatile __u32 reg_val = 0;
+
+	if(mmu_flag){
+		cmu_reg = CCU_REG_VA;
+	}else{
+		cmu_reg = CCU_REG_PA;
+	}
+	//init counters:
+	//init_perfcounters (1, 0);
+	// measure the counting overhead:
+	start = get_cyclecount();
+	overhead = get_cyclecount() - start;
+	//busy_waiting();
+	//get runtime freq: clk src + divider ratio
+	//src selection
+	reg_val = *(volatile int *)(cmu_reg + 0x50);
+	reg_val >>= 16;
+	reg_val &= 0x3;
+	if(0 == reg_val){
+		//32khz osc
+		cpu_freq = 32;
+
+	}else if(1 == reg_val){
+		//hosc, 24Mhz
+		cpu_freq = 24000; 			//unit is khz
+	}else if(2 == reg_val || 3 == reg_val){
+		//get pll_factor
+		reg_val = *(volatile int *)(cmu_reg + 0x00);
+		factor_n = 0x1f & (reg_val >> 8); 	//the range is 0-31
+		factor_k = (0x3 & (reg_val >> 4)) + 1; 	//the range is 1-4
+		factor_m = (0x3 & (reg_val >> 0)) + 1; 	//the range is 1-4
+
+		//cpu_freq = (24000*factor_n*factor_k)/(factor_p*factor_m);
+		cpu_freq = raw_lib_udiv(24000*factor_n*factor_k, factor_m);
+		//printk("cpu_freq = dec(%d). \n", cpu_freq);
+		//busy_waiting();
+	}
+
+}
+
+/*
+ * input para range: 1-1000 us, so the max us_cnt equal = 1008*1000;
+ */
+void delay_us(__u32 us)
+{
+	__u32 us_cnt = 0;
+	__u32 cur = 0;
+	__u32 target = 0;
+	//__u32 cnt = 0;
+
+
+	if(cpu_freq > 1000){
+		us_cnt = ((raw_lib_udiv(cpu_freq, 1000)) + 1)*us;
+	}else{
+		//32 <--> 32k, 1cycle = 1s/32k =32us
+		return;
+	}
+
+	cur = get_cyclecount();
+	target = cur - overhead + us_cnt;
+
+#if 1
+	while(!counter_after_eq(cur, target)){
+		cur = get_cyclecount();
+		//cnt++;
+	}
+#endif
+
+
+#if 0
+	__s32 s_cur = 0;
+	__s32 s_target = 0;
+	__s32 result = 0;
+
+	s_cur = (__s32)(cur);
+	s_target = (__s32)(target);
+	result = s_cur - s_target;
+	if(s_cur - s_target >= 0){
+		cnt++;
+	}
+	while((typecheck(__u32, cur) && \
+			typecheck(__u32, target) && \
+			((__s32)(cur) - (__s32)(target) >= 0))){
+
+			s_cur = (__s32)(cur);
+			s_target = (__s32)(target);
+			if(s_cur - s_target >= 0){
+				cnt++;
+			}
+			cur = get_cyclecount();
+	}
+#endif
+	//busy_waiting();
+
+
+	return;
+}
+
+void delay_ms(__u32 ms)
+{
+	delay_us(ms*1000);
+
+	return;
+}
+
+/*============================================== event counter ==========================*/
+static __u32 match_event_counter(enum counter_type_e type)
+{
+	int cnter = 0;
+
+	switch(type){
+		case I_CACHE_MISS:
+			cnter = 0;
+			break;
+		case I_TLB_MISS:
+			cnter = 1;
+			break;
+		case D_CACHE_MISS:
+			cnter = 2;
+			break;
+		case D_TLB_MISS:
+			cnter = 3;
+			break;
+
+		default:
+			break;
+
+	}
+	return cnter;
+
+}
+
+void init_event_counter (__u32 do_reset, __u32 enable_divider)
+{
+	// in general enable all counters (including cycle counter)
+	__u32 value = 1;
+
+	// peform reset:
+	if (do_reset)
+	{
+		value |= 2;     // reset all counters to zero.
+		value |= 4;     // reset cycle counter to zero.
+	}
+
+	if (enable_divider)
+		value |= 8;     // enable "by 64" divider for CCNT.
+
+	value |= 16;
+
+	// program the performance-counter control-register:
+	asm volatile ("mcr p15, 0, %0, c9, c12, 0" : : "r"(value));
+
+	// enable all counters:
+	value = 0x8000000f;
+	asm volatile ("mcr p15, 0, %0, c9, c12, 1" : : "r"(value));
+
+	// clear overflows:
+	asm volatile ("MCR p15, 0, %0, c9, c12, 3" : : "r"(value));
+
+	return;
+}
+
+void set_event_counter(enum counter_type_e type)
+{
+
+	__u32 cnter = 0;
+	cnter = match_event_counter(type);
+
+	//set counter selection reg
+	asm volatile ("MCR p15, 0, %0, c9, c12, 5" : : "r"(cnter));
+
+	//set event type
+	asm volatile ("MCR p15, 0, %0, c9, c13, 1" : : "r"(type));
+
+	asm volatile ("dsb");
+	asm volatile ("isb");
+
+	return;
+}
+
+
+int get_event_counter(enum counter_type_e type)
+{
+	int cnter = 0;
+	int event_cnt = 0;
+	cnter = match_event_counter(type);
+
+	//set counter selection reg
+	asm volatile ("MCR p15, 0, %0, c9, c12, 5" : : "r"(cnter));
+
+	//read event counter
+	asm volatile ("MRC p15, 0, %0, c9, c13, 2\t\n": "=r"(event_cnt));
+
+	asm volatile ("dsb");
+	asm volatile ("isb");
+
+	return event_cnt;
+}
diff --git a/arch/arm/mach-sun6i/pm/mem_timing.h b/arch/arm/mach-sun6i/pm/mem_timing.h
new file mode 100644
index 0000000..00603f0
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_timing.h
@@ -0,0 +1,34 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, gq.yang China
+*                                             All Rights Reserved
+*
+* File    : mem_timing.h
+* By      :
+* Version : v1.0
+* Date    : 2012-5-31 14:34
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __MEM_TIMING_H__
+#define __MEM_TIMING_H__
+
+__u32 get_cyclecount (void);
+void backup_perfcounter(void);
+void init_perfcounters (__u32 do_reset, __u32 enable_divider);
+void restore_perfcounter(void);
+void reset_counter(void);
+void change_runtime_env(__u32 mmu_flag);
+void delay_us(__u32 us);
+void delay_ms(__u32 ms);
+
+void init_event_counter (__u32 do_reset, __u32 enable_divider);
+void set_event_counter(enum counter_type_e type);
+int get_event_counter(enum counter_type_e type);
+
+#endif  /* __MEM_TIMING_H__ */
diff --git a/arch/arm/mach-sun6i/pm/mem_tmr.c b/arch/arm/mach-sun6i/pm/mem_tmr.c
new file mode 100644
index 0000000..14e60d3
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_tmr.c
@@ -0,0 +1,166 @@
+#include "pm_types.h"
+#include "pm.h"
+
+static __mem_tmr_reg_t  *TmrReg;
+static __u32 WatchDog1_Config_Reg_Bak, WatchDog1_Mod_Reg_Bak, WatchDog1_Irq_En_Bak;
+
+/*
+*********************************************************************************************************
+*                                     TIMER save
+*
+* Description: save timer for mem.
+*
+* Arguments  : none
+*
+* Returns    : EPDK_TRUE/EPDK_FALSE;
+*********************************************************************************************************
+*/
+__s32 mem_tmr_save(__mem_tmr_reg_t *ptmr_state)
+{
+
+	/* set timer register base */
+	TmrReg = (__mem_tmr_reg_t *)IO_ADDRESS(AW_TIMER_BASE);
+
+	/* backup timer registers */
+	ptmr_state->IntCtl   = TmrReg->IntCtl;
+	ptmr_state->Tmr0Ctl     = TmrReg->Tmr0Ctl;
+	ptmr_state->Tmr0IntVal  = TmrReg->Tmr0IntVal;
+	ptmr_state->Tmr0CntVal  = TmrReg->Tmr0CntVal;
+	ptmr_state->Tmr1Ctl     = TmrReg->Tmr1Ctl;
+	ptmr_state->Tmr1IntVal  = TmrReg->Tmr1IntVal;
+	ptmr_state->Tmr1CntVal  = TmrReg->Tmr1CntVal;
+
+	return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     TIMER restore
+*
+* Description: restore timer for mem.
+*
+* Arguments  : none
+*
+* Returns    : EPDK_TRUE/EPDK_FALSE;
+*********************************************************************************************************
+*/
+__s32 mem_tmr_restore(__mem_tmr_reg_t *ptmr_state)
+{
+	/* restore timer0 parameters */
+	TmrReg->Tmr0IntVal  = ptmr_state->Tmr0IntVal;
+	TmrReg->Tmr0CntVal  = ptmr_state->Tmr0CntVal;
+	TmrReg->Tmr0Ctl     = ptmr_state->Tmr0Ctl;
+	TmrReg->Tmr1IntVal  = ptmr_state->Tmr1IntVal;
+	TmrReg->Tmr1CntVal  = ptmr_state->Tmr1CntVal;
+	TmrReg->Tmr1Ctl     = ptmr_state->Tmr1Ctl;
+	TmrReg->IntCtl      = ptmr_state->IntCtl;
+
+	return 0;
+}
+
+//=================================================use for normal standby ============================
+/*
+*********************************************************************************************************
+*                                     TIMER INIT
+*
+* Description: initialise timer for mem.
+*
+* Arguments  : none
+*
+* Returns    : EPDK_TRUE/EPDK_FALSE;
+*********************************************************************************************************
+*/
+__s32 mem_tmr_init(void)
+{
+	/* set timer register base */
+	TmrReg = (__mem_tmr_reg_t *)(IO_ADDRESS(AW_TIMER_BASE));
+
+	WatchDog1_Config_Reg_Bak = (TmrReg->WDog1_Cfg_Reg);
+	WatchDog1_Mod_Reg_Bak = (TmrReg->WDog1_Mode_Reg);
+	WatchDog1_Irq_En_Bak = (TmrReg->WDog1_Irq_En);
+
+	return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     TIMER EXIT
+*
+* Description: exit timer for mem.
+*
+* Arguments  : none
+*
+* Returns    : EPDK_TRUE/EPDK_FALSE;
+*********************************************************************************************************
+*/
+__s32 mem_tmr_exit(void)
+{
+	(TmrReg->WDog1_Cfg_Reg) = WatchDog1_Config_Reg_Bak;
+	(TmrReg->WDog1_Mode_Reg) = WatchDog1_Mod_Reg_Bak;
+	(TmrReg->WDog1_Irq_En) = WatchDog1_Irq_En_Bak;
+
+	return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mem_tmr_enable_watchdog
+*
+*Description: enable watch-dog.
+*
+*Arguments  : none.
+*
+*Return     : none;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void mem_tmr_enable_watchdog(void)
+{
+
+	/* set watch-dog reset to whole system*/
+	(TmrReg->WDog1_Cfg_Reg) &= ~(0x3);
+	(TmrReg->WDog1_Cfg_Reg) |= 0x1;
+	/*  timeout is 16 seconds */
+	(TmrReg->WDog1_Mode_Reg) = (0xb<<4);
+
+	/* enable watch-dog interrupt*/
+	(TmrReg->WDog1_Irq_En) |= (1<<0);
+
+	/* enable watch-dog */
+	(TmrReg->WDog1_Mode_Reg) |= (1<<0);
+
+	return;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mem_tmr_disable_watchdog
+*
+*Description: disable watch-dog.
+*
+*Arguments  : none.
+*
+*Return     : none;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void mem_tmr_disable_watchdog(void)
+{
+	/* disable watch-dog reset: only intterupt */
+	(TmrReg->WDog1_Cfg_Reg) &= ~(0x3);
+	(TmrReg->WDog1_Cfg_Reg) |= 0x2;
+
+	/* disable watch-dog intterupt */
+	(TmrReg->WDog1_Irq_En) &= ~(1<<0);
+
+	/* disable watch-dog */
+	TmrReg->WDog1_Mode_Reg &= ~(1<<0);
+}
diff --git a/arch/arm/mach-sun6i/pm/mem_tmr.h b/arch/arm/mach-sun6i/pm/mem_tmr.h
new file mode 100644
index 0000000..57063d8
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_tmr.h
@@ -0,0 +1,86 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2011-2015, gq.yang China
+*                                             All Rights Reserved
+*
+* File    : mem_tmr.h
+* By      : gq.yang
+* Version : v1.0
+* Date    : 2012-11-31 15:23
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __MEM_TMR_H__
+#define __MEM_TMR_H__
+
+typedef struct __MEM_TMR_REG
+{
+	// offset:0x00
+	volatile __u32   IntCtl;
+	volatile __u32   IntSta;
+	volatile __u32   reserved0[2];
+	// offset:0x10
+	volatile __u32   Tmr0Ctl;
+	volatile __u32   Tmr0IntVal;
+	volatile __u32   Tmr0CntVal;
+	volatile __u32   reserved1;
+	// offset:0x20
+	volatile __u32   Tmr1Ctl;
+	volatile __u32   Tmr1IntVal;
+	volatile __u32   Tmr1CntVal;
+	volatile __u32   reserved2;
+	// offset:0x30
+	volatile __u32   Tmr2Ctl;
+	volatile __u32   Tmr2IntVal;
+	volatile __u32   Tmr2CntVal;
+	volatile __u32   reserved3;
+	// offset:0x40
+	volatile __u32   Tmr3Ctl;
+	volatile __u32   Tmr3IntVal;
+	volatile __u32   reserved4[2];
+	// offset:0x50
+	volatile __u32   Tmr4Ctl;
+	volatile __u32   Tmr4IntVal;
+	volatile __u32   Tmr4CntVal;
+	volatile __u32   reserved5;
+	// offset:0x60
+	volatile __u32   Tmr5Ctl;
+	volatile __u32   Tmr5IntVal;
+	volatile __u32   Tmr5CntVal;
+	volatile __u32   reserved6[5];
+	// offset:0x80
+	volatile __u32   AvsCtl;
+	volatile __u32   Avs0Cnt;
+	volatile __u32   Avs1Cnt;
+	volatile __u32   AvsDiv;
+
+	// offset:0x90: reserved
+	volatile __u32   reserved7[4];
+
+	// offset:0xa0
+	volatile __u32   WDog1_Irq_En;
+	volatile __u32   WDog1_Irq_Sta;
+	volatile __u32   reserved8[2];
+
+	// offset:0xb0
+	volatile __u32   WDog1_Ctrl_Reg;
+	volatile __u32   WDog1_Cfg_Reg;
+	volatile __u32   WDog1_Mode_Reg;
+
+} __mem_tmr_reg_t;
+
+//for super standby;
+__s32 mem_tmr_save(__mem_tmr_reg_t *ptmr_state);
+__s32 mem_tmr_restore(__mem_tmr_reg_t *ptmr_state);
+//for normal standby;
+__s32 mem_tmr_init(void);
+__s32 mem_tmr_exit(void);
+void mem_tmr_enable_watchdog(void);
+void mem_tmr_disable_watchdog(void);
+
+#endif  //__MEM_TMR_H__
diff --git a/arch/arm/mach-sun6i/pm/mem_twi.c b/arch/arm/mach-sun6i/pm/mem_twi.c
new file mode 100644
index 0000000..ff4e12a
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/mem_twi.c
@@ -0,0 +1,38 @@
+#include <linux/delay.h>
+//#define __uxx_sxx_name
+#include "pm_i.h"
+
+
+/*
+*********************************************************************************************************
+*                                   mem_twi_save
+*
+*Description: save twi status before enter super standby.
+*
+*Arguments  :
+*
+*Return     :
+*
+*********************************************************************************************************
+*/
+__s32 mem_twi_save(struct twi_state *ptwi_state)
+{
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                   mem_twi_restore
+*
+*Description: restore twi status after resume.
+*
+*Arguments  :
+*
+*Return     :
+*
+*********************************************************************************************************
+*/
+__s32 mem_twi_restore(struct twi_state *ptwi_state)
+{
+	return 0;
+}
diff --git a/arch/arm/mach-sun6i/pm/pm.c b/arch/arm/mach-sun6i/pm/pm.c
new file mode 100644
index 0000000..11de7ea
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/pm.c
@@ -0,0 +1,945 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : pm.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-27 14:08
+* Descript: power manager for allwinners chips platform.
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+
+#include <linux/module.h>
+#include <linux/suspend.h>
+#include <linux/cpufreq.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/syscalls.h>
+#include <linux/slab.h>
+#include <linux/major.h>
+#include <linux/device.h>
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/tlbflush.h>
+#include <linux/power/aw_pm.h>
+#include <asm/mach/map.h>
+#include <asm/cacheflush.h>
+#include "pm_i.h"
+
+#include <mach/sys_config.h>
+#include <mach/system.h>
+
+//#define CROSS_MAPPING_STANDBY
+
+#define AW_PM_DBG   1
+#undef PM_DBG
+#if(AW_PM_DBG)
+    #define PM_DBG(format,args...)   printk("[pm]"format,##args)
+#else
+    #define PM_DBG(format,args...)   do{}while(0)
+#endif
+
+#ifdef RETURN_FROM_RESUME0_WITH_NOMMU
+#define PRE_DISABLE_MMU    //actually, mean ,prepare condition to disable mmu
+#endif
+
+#ifdef ENTER_SUPER_STANDBY
+#undef PRE_DISABLE_MMU
+#endif
+
+#ifdef ENTER_SUPER_STANDBY_WITH_NOMMU
+#define PRE_DISABLE_MMU    //actually, mean ,prepare condition to disable mmu
+#endif
+
+#ifdef RETURN_FROM_RESUME0_WITH_MMU
+#undef PRE_DISABLE_MMU
+#endif
+
+#ifdef WATCH_DOG_RESET
+#define PRE_DISABLE_MMU    //actually, mean ,prepare condition to disable mmu
+#endif
+
+//#define VERIFY_RESTORE_STATUS
+
+/* define major number for power manager */
+#define AW_PMU_MAJOR    267
+
+static int debug_mask = PM_STANDBY_PRINT_STANDBY | PM_STANDBY_PRINT_RESUME;
+static int suspend_freq = SUSPEND_FREQ;
+static int suspend_delay_ms = SUSPEND_DELAY_MS;
+
+extern char *standby_bin_start;
+extern char *standby_bin_end;
+extern char *suspend_bin_start;
+extern char *suspend_bin_end;
+
+#ifdef RESUME_FROM_RESUME1
+extern char *resume1_bin_start;
+extern char *resume1_bin_end;
+#endif
+
+/*mem_cpu_asm.S*/
+extern int mem_arch_suspend(void);
+extern int mem_arch_resume(void);
+extern asmlinkage int mem_clear_runtime_context(void);
+extern void save_runtime_context(__u32 *addr);
+extern void clear_reg_context(void);
+
+/*mem_mapping.c*/
+void create_mapping(void);
+void save_mapping(unsigned long vaddr);
+void restore_mapping(unsigned long vaddr);
+
+int (*mem)(void) = 0;
+
+#ifdef CONFIG_CPU_FREQ_USR_EVNT_NOTIFY
+extern void cpufreq_user_event_notify(void);
+#endif
+
+static struct aw_pm_info standby_info = {
+    .standby_para = {
+		.event = CPU0_WAKEUP_MSGBOX,
+		.axp_event = CPUS_MEM_WAKEUP,
+		.timeout = 0,
+    },
+    .pmu_arg = {
+        .twi_port = 0,
+        .dev_addr = 10,
+    },
+};
+
+static struct clk_state saved_clk_state;
+static __mem_tmr_reg_t saved_tmr_state;
+static struct twi_state saved_twi_state;
+static struct gpio_state saved_gpio_state;
+static struct sram_state saved_sram_state;
+
+#ifdef GET_CYCLE_CNT
+static int start = 0;
+static int resume0_period = 0;
+static int resume1_period = 0;
+
+static int pm_start = 0;
+static int invalidate_data_time = 0;
+static int invalidate_instruct_time = 0;
+static int before_restore_processor = 0;
+static int after_restore_process = 0;
+//static int restore_runtime_peroid = 0;
+
+//late_resume timing
+static int late_resume_start = 0;
+static int backup_area_start = 0;
+static int backup_area1_start = 0;
+static int backup_area2_start = 0;
+static int clk_restore_start = 0;
+static int gpio_restore_start = 0;
+static int twi_restore_start = 0;
+static int int_restore_start = 0;
+static int tmr_restore_start = 0;
+static int sram_restore_start = 0;
+static int late_resume_end = 0;
+#endif
+
+struct aw_mem_para mem_para_info;
+struct super_standby_para super_standby_para_info;
+
+standby_type_e standby_type = NON_STANDBY;
+EXPORT_SYMBOL(standby_type);
+standby_level_e standby_level = STANDBY_INITIAL;
+EXPORT_SYMBOL(standby_level);
+
+//static volatile int enter_flag = 0;
+static int standby_mode = 0;
+static int suspend_status_flag = 0;
+
+/*
+*********************************************************************************************************
+*                           aw_pm_valid
+*
+*Description: determine if given system sleep state is supported by the platform;
+*
+*Arguments  : state     suspend state;
+*
+*Return     : if the state is valid, return 1, else return 0;
+*
+*Notes      : this is a call-back function, registered into PM core;
+*
+*********************************************************************************************************
+*/
+static int aw_pm_valid(suspend_state_t state)
+{
+#ifdef CHECK_IC_VERSION
+	enum sw_ic_ver version = MAGIC_VER_NULL;
+#endif
+
+    PM_DBG("valid\n");
+
+    if(!((state > PM_SUSPEND_ON) && (state < PM_SUSPEND_MAX))){
+        PM_DBG("state (%d) invalid!\n", state);
+        return 0;
+    }
+
+#ifdef CHECK_IC_VERSION
+	if(1 == standby_mode){
+			version = sw_get_ic_ver();
+			if(!(MAGIC_VER_A13B == version || MAGIC_VER_A12B == version || MAGIC_VER_A10SB == version)){
+				pr_info("ic version: %d not support super standby. \n", version);
+				standby_mode = 0;
+			}
+	}
+#endif
+
+	//if 1 == standby_mode, actually, mean mem corresponding with super standby
+	if(PM_SUSPEND_STANDBY == state){
+		if(1 == standby_mode){
+			standby_type = NORMAL_STANDBY;
+		}else{
+			standby_type = SUPER_STANDBY;
+		}
+	}else if(PM_SUSPEND_MEM == state || PM_SUSPEND_BOOTFAST == state){
+		if(1 == standby_mode){
+			standby_type = SUPER_STANDBY;
+		}else{
+			standby_type = NORMAL_STANDBY;
+		}
+	}
+
+#ifdef GET_CYCLE_CNT
+		// init counters:
+		init_perfcounters (1, 0);
+#endif
+
+    return 1;
+
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_pm_begin
+*
+*Description: Initialise a transition to given system sleep state;
+*
+*Arguments  : state     suspend state;
+*
+*Return     : return 0 for process successed;
+*
+*Notes      : this is a call-back function, registered into PM core, and this function
+*             will be called before devices suspened;
+*********************************************************************************************************
+*/
+int aw_pm_begin(suspend_state_t state)
+{
+	struct cpufreq_policy policy;
+
+	PM_DBG("%d state begin\n", state);
+
+	//set freq max
+#ifdef CONFIG_CPU_FREQ_USR_EVNT_NOTIFY
+	//cpufreq_user_event_notify();
+#endif
+
+	if (cpufreq_get_policy(&policy, 0))
+		goto out;
+
+	cpufreq_driver_target(&policy, suspend_freq, CPUFREQ_RELATION_L);
+
+
+	/*must init perfcounter, because delay_us and delay_ms is depandant perf counter*/
+#ifndef GET_CYCLE_CNT
+	backup_perfcounter();
+	init_perfcounters (1, 0);
+#endif
+
+	return 0;
+
+out:
+	return -1;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_pm_prepare
+*
+*Description: Prepare the platform for entering the system sleep state.
+*
+*Arguments  : none;
+*
+*Return     : return 0 for process successed, and negative code for error;
+*
+*Notes      : this is a call-back function, registered into PM core, this function
+*             will be called after devices suspended, and before device late suspend
+*             call-back functions;
+*********************************************************************************************************
+*/
+int aw_pm_prepare(void)
+{
+    PM_DBG("prepare\n");
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_pm_prepare_late
+*
+*Description: Finish preparing the platform for entering the system sleep state.
+*
+*Arguments  : none;
+*
+*Return     : return 0 for process successed, and negative code for error;
+*
+*Notes      : this is a call-back function, registered into PM core.
+*             prepare_late is called before disabling nonboot CPUs and after
+*              device drivers' late suspend callbacks have been executed;
+*********************************************************************************************************
+*/
+int aw_pm_prepare_late(void)
+{
+    PM_DBG("prepare_late\n");
+
+    return 0;
+}
+
+int aw_suspend_cpu_die(void)
+{
+	unsigned long actlr;
+
+    /* step1: disable cache */
+    asm("mrc    p15, 0, %0, c1, c0, 0" : "=r" (actlr) );
+    actlr &= ~(1<<2);
+    asm("mcr    p15, 0, %0, c1, c0, 0\n" : : "r" (actlr));
+
+    /* step2: clean and ivalidate L1 cache */
+    flush_cache_all();
+
+    /* step3: execute a CLREX instruction */
+    asm("clrex" : : : "memory", "cc");
+
+    /* step4: switch cpu from SMP mode to AMP mode, aim is to disable cache coherency */
+    asm("mrc    p15, 0, %0, c1, c0, 1" : "=r" (actlr) );
+    actlr &= ~(1<<6);
+    asm("mcr    p15, 0, %0, c1, c0, 1\n" : : "r" (actlr));
+
+    /* step5: execute an ISB instruction */
+    isb();
+    /* step6: execute a DSB instruction  */
+    dsb();
+
+    /* step7: execute a WFI instruction */
+    asm("wfi" : : : "memory", "cc");
+
+    return 0;
+}
+
+/*
+*********************************************************************************************************
+*                           aw_early_suspend
+*
+*Description: prepare necessary info for suspend&resume;
+*
+*Return     : return 0 is process successed;
+*
+*Notes      : -1: data is ok;
+*			-2: data has been destory.
+*********************************************************************************************************
+*/
+static int aw_early_suspend(void)
+{
+#define MAX_RETRY_TIMES (5)
+
+	//backup device state
+	mem_ccu_save((__ccmu_reg_list_t *)(IO_ADDRESS(AW_CCM_BASE)));
+	mem_clk_save(&(saved_clk_state));
+	mem_gpio_save(&(saved_gpio_state));
+	mem_tmr_save(&(saved_tmr_state));
+	mem_twi_save(&(saved_twi_state));
+	mem_sram_save(&(saved_sram_state));
+
+#if 0
+	//backup volt and freq state, after backup device state
+	mem_twi_init(AXP_IICBUS);
+	/* backup voltages */
+	while(-1 == (mem_para_info.suspend_dcdc2 = mem_get_voltage(POWER_VOL_DCDC2)) && --retry){
+		;
+	}
+	if(0 == retry){
+		return -1;
+	}else{
+		retry = MAX_RETRY_TIMES;
+	}
+
+	while(-1 == (mem_para_info.suspend_dcdc3 = mem_get_voltage(POWER_VOL_DCDC3)) && --retry){
+		;
+	}
+	if(0 == retry){
+		return -1;
+	}else{
+		retry = MAX_RETRY_TIMES;
+	}
+#endif
+
+#if 1
+	mem_clk_init(1);
+	/*backup bus ratio*/
+	mem_clk_getdiv(&mem_para_info.clk_div);
+	/*backup pll ratio*/
+	mem_clk_get_pll_factor(&mem_para_info.pll_factor);
+#endif
+
+	//backup mmu
+	save_mmu_state(&(mem_para_info.saved_mmu_state));
+
+	//backup 0x0000,0000 page entry, size?
+	save_mapping(MEM_SW_VA_SRAM_BASE);
+
+	if((sizeof(__u32)*DRAM_BACKUP_SIZE1) < sizeof(mem_para_info)){
+		//judge the reserved space for mem para is enough or not.
+		return -1;
+
+	}
+
+	//clean all the data into dram
+	memcpy((void *)phys_to_virt(DRAM_BACKUP_BASE_ADDR1_PA), (void *)&mem_para_info, sizeof(mem_para_info));
+	dmac_flush_range((void *)phys_to_virt(DRAM_BACKUP_BASE_ADDR1_PA), (void *)(phys_to_virt(DRAM_BACKUP_BASE_ADDR1_PA) + (sizeof(u32)) * DRAM_BACKUP_SIZE1));
+
+	mem_arch_suspend();
+	save_processor_state();
+
+	//create 0x0000,0000 mapping table: 0x0000,0000 -> 0x0000,0000
+	create_mapping();
+
+#ifdef ENTER_SUPER_STANDBY
+	//print_call_info();
+	super_standby_para_info.event = mem_para_info.axp_event;
+
+#ifdef RESUME_FROM_RESUME1
+	super_standby_para_info.resume_code_src = (unsigned long)(virt_to_phys((void *)&resume1_bin_start));
+	super_standby_para_info.resume_code_length = ((int)&resume1_bin_end - (int)&resume1_bin_start);
+	super_standby_para_info.resume_entry = SRAM_FUNC_START_PA;
+#endif
+
+	super_standby_para_info.timeout = 0;
+
+	if(unlikely(debug_mask&PM_STANDBY_PRINT_STANDBY)){
+		pr_info("resume1_bin_start = 0x%x, resume1_bin_end = 0x%x. \n", (int)&resume1_bin_start, (int)&resume1_bin_end);
+		pr_info("resume_code_src = 0x%lx, resume_code_length = %ld. resume_code_length = %lx \n", super_standby_para_info.resume_code_src, super_standby_para_info.resume_code_length, super_standby_para_info.resume_code_length);
+	}
+
+	//disable int to make sure the cpu0 into wfi state.
+	mem_int_init();
+	ar100_standby_super((struct super_standby_para *)(&super_standby_para_info), NULL, NULL);
+
+	aw_suspend_cpu_die();
+	pr_info("standby suspend failed\n");
+	//busy_waiting();
+#endif
+
+	return -2;
+
+}
+
+/*
+*********************************************************************************************************
+*                           verify_restore
+*
+*Description: verify src and dest region is the same;
+*
+*Return     : 0: same;
+*                -1: different;
+*
+*Notes      :
+*********************************************************************************************************
+*/
+#ifdef VERIFY_RESTORE_STATUS
+static int verify_restore(void *src, void *dest, int count)
+{
+	volatile char *s = (volatile char *)src;
+	volatile char *d = (volatile char *)dest;
+
+	while(count--){
+		if(*(s+(count)) != *(d+(count))){
+			//busy_waiting();
+			return -1;
+		}
+	}
+
+	return 0;
+}
+#endif
+
+/*
+*********************************************************************************************************
+*                           aw_late_resume
+*
+*Description: prepare necessary info for suspend&resume;
+*
+*Return     : return 0 is process successed;
+*
+*Notes      :
+*********************************************************************************************************
+*/
+static void aw_late_resume(void)
+{
+	memcpy((void *)&mem_para_info, (void *)phys_to_virt(DRAM_BACKUP_BASE_ADDR1_PA), sizeof(mem_para_info));
+	mem_para_info.mem_flag = 0;
+
+	//restore device state
+	mem_clk_restore(&(saved_clk_state));
+	mem_gpio_restore(&(saved_gpio_state));
+	mem_twi_restore(&(saved_twi_state));
+	mem_tmr_restore(&(saved_tmr_state));
+	//mem_int_restore(&(saved_gic_state));
+	mem_sram_restore(&(saved_sram_state));
+	mem_ccu_restore((__ccmu_reg_list_t *)(IO_ADDRESS(AW_CCM_BASE)));
+
+	return;
+}
+
+/*
+*********************************************************************************************************
+*                           aw_super_standby
+*
+*Description: enter super standby;
+*
+*Return     : return 0 is process successed;
+*
+*Notes      :
+*********************************************************************************************************
+*/
+static int aw_super_standby(suspend_state_t state)
+{
+	int result = 0;
+	int i = 0;
+	suspend_status_flag = 0;
+
+mem_enter:
+	if( 1 == mem_para_info.mem_flag){
+		save_mem_status(BEFORE_LATE_RESUME |0x1);
+		//print_call_info();
+		invalidate_branch_predictor();
+		//print_call_info();
+		//must be called to invalidate I-cache inner shareable?
+		// I+BTB cache invalidate
+		__cpuc_flush_icache_all();
+		save_mem_status(BEFORE_LATE_RESUME |0x2);
+		//print_call_info();
+		//disable 0x0000 <---> 0x0000 mapping
+		save_mem_status(BEFORE_LATE_RESUME |0x3);
+		restore_processor_state();
+		//destroy 0x0000 <---> 0x0000 mapping
+		save_mem_status(BEFORE_LATE_RESUME |0x4);
+		restore_mapping(MEM_SW_VA_SRAM_BASE);
+		save_mem_status(BEFORE_LATE_RESUME |0x5);
+		mem_arch_resume();
+		save_mem_status(BEFORE_LATE_RESUME |0x6);
+		goto resume;
+	}
+
+	save_runtime_context(mem_para_info.saved_runtime_context_svc);
+	mem_para_info.mem_flag = 1;
+	standby_level = STANDBY_WITH_POWER_OFF;
+	mem_para_info.resume_pointer = (void *)&&mem_enter;
+	mem_para_info.debug_mask = debug_mask;
+	mem_para_info.suspend_delay_ms = suspend_delay_ms;
+	//busy_waiting();
+	if(unlikely(debug_mask&PM_STANDBY_PRINT_STANDBY)){
+		pr_info("resume_pointer = 0x%x. \n", (unsigned int)(mem_para_info.resume_pointer));
+	}
+
+
+	/* config cpus wakeup evetn type */
+	if(PM_SUSPEND_MEM == state || PM_SUSPEND_STANDBY == state){
+		mem_para_info.axp_event = CPUS_MEM_WAKEUP;
+	}else if(PM_SUSPEND_BOOTFAST == state){
+		mem_para_info.axp_event = CPUS_BOOTFAST_WAKEUP;
+	}
+
+	result = aw_early_suspend();
+	if(-2 == result){
+		//mem_para_info.mem_flag = 1;
+		//busy_waiting();
+		suspend_status_flag = 2;
+		goto mem_enter;
+	}else if(-1 == result){
+		suspend_status_flag = 1;
+		goto suspend_err;
+	}
+
+resume:
+	if(unlikely(debug_mask&PM_STANDBY_PRINT_RESUME_IO_STATUS)){
+		printk("before aw_late_resume. \n");
+		printk(KERN_INFO "IO status as follow:");
+		for(i=0; i<(GPIO_REG_LENGTH); i++){
+			printk(KERN_INFO "ADDR = %x, value = %x .\n", \
+				IO_ADDRESS(AW_PIO_BASE) + i*0x04, *(volatile __u32 *)(IO_ADDRESS(AW_PIO_BASE) + i*0x04));
+		}
+	}
+
+	aw_late_resume();
+
+	//have been disable dcache in resume1
+	//enable_cache();
+	if(unlikely(debug_mask&PM_STANDBY_PRINT_RESUME)){
+		print_call_info();
+	}
+	save_mem_status(LATE_RESUME_START |0x4);
+
+	//before creating mapping, build the coherent between cache and memory
+	//clean and flush
+	__cpuc_flush_kern_all();
+	__cpuc_flush_user_all();
+
+	__cpuc_coherent_user_range(0x00000000, 0xc0000000-1);
+	__cpuc_coherent_kern_range(0xc0000000, 0xffffffff-1);
+
+suspend_err:
+	if(unlikely(debug_mask&PM_STANDBY_PRINT_RESUME)){
+		pr_info("suspend_status_flag = %d. \n", suspend_status_flag);
+	}
+	save_mem_status(LATE_RESUME_START |0x5);
+
+	return 0;
+
+}
+
+/*
+*********************************************************************************************************
+*                           aw_pm_enter
+*
+*Description: Enter the system sleep state;
+*
+*Arguments  : state     system sleep state;
+*
+*Return     : return 0 is process successed;
+*
+*Notes      : this function is the core function for platform sleep.
+*********************************************************************************************************
+*/
+static int aw_pm_enter(suspend_state_t state)
+{
+	int (*standby)(struct aw_pm_info *arg);
+	int i = 0;
+
+	PM_DBG("enter state %d\n", state);
+
+	if(unlikely(debug_mask&PM_STANDBY_PRINT_IO_STATUS)){
+		printk(KERN_INFO "IO status as follow:");
+		for(i=0; i<(GPIO_REG_LENGTH); i++){
+			printk(KERN_INFO "ADDR = %x, value = %x .\n", \
+				IO_ADDRESS(AW_PIO_BASE) + i*0x04, *(volatile __u32 *)(IO_ADDRESS(AW_PIO_BASE) + i*0x04));
+		}
+	}
+
+	if(unlikely(debug_mask&PM_STANDBY_PRINT_CPUS_IO_STATUS)){
+		printk(KERN_INFO "CPUS IO status as follow:");
+		for(i=0; i<(CPUS_GPIO_REG_LENGTH); i++){
+			printk(KERN_INFO "ADDR = %x, value = %x .\n", \
+				IO_ADDRESS(AW_R_PIO_BASE) + i*0x04, *(volatile __u32 *)(IO_ADDRESS(AW_R_PIO_BASE) + i*0x04));
+		}
+	}
+
+	if(unlikely(debug_mask&PM_STANDBY_PRINT_CCU_STATUS)){
+		printk(KERN_INFO "CCU status as follow:");
+		for(i=0; i<(CCU_REG_LENGTH); i++){
+			printk(KERN_INFO "ADDR = %x, value = %x .\n", \
+				IO_ADDRESS(AW_CCM_BASE) + i*0x04, *(volatile __u32 *)(IO_ADDRESS(AW_CCM_BASE) + i*0x04));
+		}
+	}
+
+	if(NORMAL_STANDBY== standby_type){
+		standby = (int (*)(struct aw_pm_info *arg))SRAM_FUNC_START;
+		//move standby code to sram
+		memcpy((void *)SRAM_FUNC_START, (void *)&standby_bin_start, (int)&standby_bin_end - (int)&standby_bin_start);
+		/* config system wakeup evetn type */
+		if(PM_SUSPEND_MEM == state || PM_SUSPEND_STANDBY == state){
+			standby_info.standby_para.axp_event = CPUS_MEM_WAKEUP;
+			standby_info.standby_para.event = CPU0_MEM_WAKEUP;
+		}else if(PM_SUSPEND_BOOTFAST == state){
+			standby_info.standby_para.axp_event = CPUS_BOOTFAST_WAKEUP;
+			standby_info.standby_para.event = CPU0_BOOTFAST_WAKEUP;
+		}
+
+		standby_info.standby_para.gpio_enable_bitmap = mem_para_info.cpus_gpio_wakeup;
+		standby_info.standby_para.timeout = 0;
+		standby_info.standby_para.debug_mask = debug_mask;
+
+		// build the coherent between cache and memory
+		//clean and flush: the data is already in cache, so can clean the data into sram;
+		//while, in dma transfer condition, the data is not in cache, so can not use this api in dma ops.
+		//at current situation, no need to clean & invalidate cache;
+		//__cpuc_flush_kern_all();
+
+		//config int src.
+		mem_int_init();
+
+		/* goto sram and run */
+		standby(&standby_info);
+
+		mem_int_exit();
+
+		PM_DBG("platform wakeup, normal standby cpu0 wakesource is:0x%x\n, normal standby cpus wakesource is:0x%x. \n", \
+			standby_info.standby_para.event, standby_info.standby_para.axp_event);
+
+	}else if(SUPER_STANDBY == standby_type){
+		aw_super_standby(state);
+
+		ar100_cpux_ready_notify();
+		ar100_query_wakeup_source((unsigned long *)(&(mem_para_info.axp_event)));
+		PM_DBG("platform wakeup, super standby wakesource is:0x%x\n", mem_para_info.axp_event);
+	}
+
+	return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_pm_wake
+*
+*Description: platform wakeup;
+*
+*Arguments  : none;
+*
+*Return     : none;
+*
+*Notes      : This function called when the system has just left a sleep state, right after
+*             the nonboot CPUs have been enabled and before device drivers' early resume
+*             callbacks are executed. This function is opposited to the aw_pm_prepare_late;
+*********************************************************************************************************
+*/
+static void aw_pm_wake(void)
+{
+	return;
+}
+
+/*
+*********************************************************************************************************
+*                           aw_pm_finish
+*
+*Description: Finish wake-up of the platform;
+*
+*Arguments  : none
+*
+*Return     : none
+*
+*Notes      : This function is called right prior to calling device drivers' regular suspend
+*              callbacks. This function is opposited to the aw_pm_prepare function.
+*********************************************************************************************************
+*/
+void aw_pm_finish(void)
+{
+    PM_DBG("platform wakeup finish\n");
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_pm_end
+*
+*Description: Notify the platform that system is in work mode now.
+*
+*Arguments  : none
+*
+*Return     : none
+*
+*Notes      : This function is called by the PM core right after resuming devices, to indicate to
+*             the platform that the system has returned to the working state or
+*             the transition to the sleep state has been aborted. This function is opposited to
+*             aw_pm_begin function.
+*********************************************************************************************************
+*/
+void aw_pm_end(void)
+{
+#ifndef GET_CYCLE_CNT
+	#ifndef IO_MEASURE
+			restore_perfcounter();
+	#endif
+#endif
+
+	PM_DBG("aw_pm_end!\n");
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_pm_recover
+*
+*Description: Recover platform from a suspend failure;
+*
+*Arguments  : none
+*
+*Return     : none
+*
+*Notes      : This function alled by the PM core if the suspending of devices fails.
+*             This callback is optional and should only be implemented by platforms
+*             which require special recovery actions in that situation.
+*********************************************************************************************************
+*/
+void aw_pm_recover(void)
+{
+    PM_DBG("aw_pm_recover\n");
+}
+
+
+/*
+    define platform_suspend_ops which is registered into PM core.
+*/
+static struct platform_suspend_ops aw_pm_ops = {
+    .valid = aw_pm_valid,
+    .begin = aw_pm_begin,
+    .prepare = aw_pm_prepare,
+    .prepare_late = aw_pm_prepare_late,
+    .enter = aw_pm_enter,
+    .wake = aw_pm_wake,
+    .finish = aw_pm_finish,
+    .end = aw_pm_end,
+    .recover = aw_pm_recover,
+};
+
+
+/*
+*********************************************************************************************************
+*                           aw_pm_init
+*
+*Description: initial pm sub-system for platform;
+*
+*Arguments  : none;
+*
+*Return     : result;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static int __init aw_pm_init(void)
+{
+	script_item_u item;
+	script_item_u   *list = NULL;
+	int cpu0_en = 0;
+	int dram_selfresh_en = 0;
+	int wakeup_src_cnt = 0;
+	unsigned gpio = 0;
+	int i = 0;
+
+	PM_DBG("aw_pm_init!\n");
+
+	//get standby_mode.
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != script_get_item("pm_para", "standby_mode", &item)){
+		pr_err("%s: script_parser_fetch err. \n", __func__);
+		standby_mode = 0;
+		//standby_mode = 1;
+		pr_err("notice: standby_mode = %d.\n", standby_mode);
+	}else{
+		standby_mode = item.val;
+		pr_info("standby_mode = %d. \n", standby_mode);
+		if(1 != standby_mode){
+			pr_err("%s: not support super standby. \n",  __func__);
+		}
+	}
+
+	//get wakeup_src_para cpu_en
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != script_get_item("wakeup_src_para", "cpu_en", &item)){
+		cpu0_en = 0;
+	}else{
+		cpu0_en = item.val;
+	}
+	pr_info("cpu0_en = %d.\n", cpu0_en);
+
+	//get dram_selfresh en
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != script_get_item("wakeup_src_para", "dram_selfresh_en", &item)){
+		dram_selfresh_en = 1;
+	}else{
+		dram_selfresh_en = item.val;
+	}
+	pr_info("dram_selfresh_en = %d.\n", dram_selfresh_en);
+
+	if(0 == dram_selfresh_en && 0 == cpu0_en){
+		pr_err("Notice: if u don't want the dram enter selfresh mode,\n \
+				make sure the cpu0 is not allowed to be powered off.\n");
+		goto script_para_err;
+	}else{
+		//defaultly, 0 == cpu0_en && 1 ==  dram_selfresh_en
+		if(1 == cpu0_en){
+			standby_mode = 0;
+			pr_info("notice: only support ns, standby_mode = %d.\n", standby_mode);
+		}
+	}
+
+	//get wakeup_src_cnt
+	wakeup_src_cnt = script_get_pio_list("wakeup_src_para",&list);
+	pr_info("wakeup src cnt is : %d. \n", wakeup_src_cnt);
+
+	//script_dump_mainkey("wakeup_src_para");
+	mem_para_info.cpus_gpio_wakeup = 0;
+	if(0 != wakeup_src_cnt){
+		while(wakeup_src_cnt--){
+			gpio = (list + (i++) )->gpio.gpio;
+			//pr_info("gpio == 0x%x.\n", gpio);
+			if( gpio > GPIO_INDEX_END){
+				pr_info("gpio config err. \n");
+			}else if( gpio >= AXP_NR_BASE){
+				mem_para_info.cpus_gpio_wakeup |= (WAKEUP_GPIO_AXP((gpio - AXP_NR_BASE)));
+				//pr_info("gpio - AXP_NR_BASE == 0x%x.\n", gpio - AXP_NR_BASE);
+			}else if( gpio >= PM_NR_BASE){
+				mem_para_info.cpus_gpio_wakeup |= (WAKEUP_GPIO_PM((gpio - PM_NR_BASE)));
+				//pr_info("gpio - PM_NR_BASE == 0x%x.\n", gpio - PM_NR_BASE);
+			}else if( gpio >= PL_NR_BASE){
+				mem_para_info.cpus_gpio_wakeup |= (WAKEUP_GPIO_PL((gpio - PL_NR_BASE)));
+				//pr_info("gpio - PL_NR_BASE == 0x%x.\n", gpio - PL_NR_BASE);
+			}else{
+				pr_info("cpux need care gpio %d. but, notice, currently, \
+					cpux not support it.\n", gpio);
+			}
+		}
+		super_standby_para_info.gpio_enable_bitmap = mem_para_info.cpus_gpio_wakeup;
+		pr_info("cpus need care gpio: mem_para_info.cpus_gpio_wakeup = 0x%x. \n",\
+			mem_para_info.cpus_gpio_wakeup);
+	}
+
+	suspend_set_ops(&aw_pm_ops);
+
+	return 0;
+
+script_para_err:
+	return -1;
+
+}
+
+
+/*
+*********************************************************************************************************
+*                           aw_pm_exit
+*
+*Description: exit pm sub-system on platform;
+*
+*Arguments  : none
+*
+*Return     : none
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static void __exit aw_pm_exit(void)
+{
+	PM_DBG("aw_pm_exit!\n");
+	suspend_set_ops(NULL);
+}
+
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+module_param_named(suspend_freq, suspend_freq, int, S_IRUGO | S_IWUSR | S_IWGRP);
+module_param_named(suspend_delay_ms, suspend_delay_ms, int, S_IRUGO | S_IWUSR | S_IWGRP);
+module_init(aw_pm_init);
+module_exit(aw_pm_exit);
diff --git a/arch/arm/mach-sun6i/pm/pm.h b/arch/arm/mach-sun6i/pm/pm.h
new file mode 100644
index 0000000..8fc67dc
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/pm.h
@@ -0,0 +1,135 @@
+#ifndef _PM_H
+#define _PM_H
+
+/*
+ * Copyright (c) 2011-2015 yanggq.young@allwinnertech.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+//#include "pm_types.h"
+#include "pm_config.h"
+#include "pm_errcode.h"
+#include "pm_debug.h"
+#include "mem_cpu.h"
+#include "mem_serial.h"
+#include "mem_printk.h"
+#include "mach/platform.h"
+#include "mem_divlibc.h"
+#include "mem_int.h"
+#include "mem_tmr.h"
+#include <mach/ccmu.h>
+#include "mem_clk.h"
+#include "mem_timing.h"
+
+typedef enum{
+	PM_STANDBY_PRINT_STANDBY = (1U << 0),
+	PM_STANDBY_PRINT_RESUME = (1U << 1),
+	PM_STANDBY_PRINT_IO_STATUS = (1U << 2),
+	PM_STANDBY_PRINT_CACHE_TLB_MISS = (1U << 3),
+	PM_STANDBY_PRINT_CCU_STATUS = (1U << 4),
+	PM_STANDBY_PRINT_CPUS_IO_STATUS = (1U << 5),
+	PM_STANDBY_PRINT_RESUME_IO_STATUS = (1U << 6)
+}debug_mask_flag;
+
+#ifdef CONFIG_ARCH_SUN4I
+#define INT_REG_LENGTH	((0x90+0x4)>>2)
+#define GPIO_REG_LENGTH	((0x218+0x4)>>2)
+#define SRAM_REG_LENGTH	((0x94+0x4)>>2)
+#elif defined CONFIG_ARCH_SUN5I
+#define INT_REG_LENGTH	((0x94+0x4)>>2)
+#define GPIO_REG_LENGTH	((0x218+0x4)>>2)
+#define SRAM_REG_LENGTH	((0x94+0x4)>>2)
+#elif defined CONFIG_ARCH_SUN6I
+#define GPIO_REG_LENGTH		((0x278+0x4)>>2)
+#define CPUS_GPIO_REG_LENGTH	((0x238+0x4)>>2)
+#define SRAM_REG_LENGTH		((0x94+0x4)>>2)
+#define CCU_REG_LENGTH		((0x308+0x4)>>2)
+
+#elif defined CONFIG_ARCH_SUN7I
+#define GPIO_REG_LENGTH	((0x218+0x4)>>2)
+#define SRAM_REG_LENGTH	((0x94+0x4)>>2)
+#endif
+
+#define likely(x)	__builtin_expect(!!(x), 1)
+#define unlikely(x)	__builtin_expect(!!(x), 0)
+
+struct mmu_state {
+	/* CR0 */
+	__u32 cssr;	/* Cache Size Selection */
+	/* CR1 */
+	__u32 cr;		/* Control */
+	__u32 cacr;	/* Coprocessor Access Control */
+	/* CR2 */
+	__u32  ttb_0r;	/* Translation Table Base 0 */
+	__u32  ttb_1r;	/* Translation Table Base 1 */
+	__u32  ttbcr;	/* Translation Talbe Base Control */
+
+	/* CR3 */
+	__u32 dacr;	/* Domain Access Control */
+
+	/*cr10*/
+	__u32 prrr;	/* Primary Region Remap Register */
+	__u32 nrrr;	/* Normal Memory Remap Register */
+};
+
+/**
+*@brief struct of super mem
+*/
+struct aw_mem_para{
+	void **resume_pointer;
+	volatile __u32 mem_flag;
+	__u32 axp_event;
+	__u32 sys_event;
+	__u32 cpus_gpio_wakeup;
+	__u32 debug_mask;
+	__u32 suspend_delay_ms;
+	__u32 saved_runtime_context_svc[RUNTIME_CONTEXT_SIZE];
+	struct clk_div_t clk_div;
+	struct pll_factor_t pll_factor;
+	struct mmu_state saved_mmu_state;
+	struct saved_context saved_cpu_context;
+};
+
+typedef  int (*suspend_func)(void);
+
+/*mem_mmu_pc_asm.S*/
+extern unsigned int save_sp_nommu(void);
+extern unsigned int save_sp(void);
+extern void clear_reg_context(void);
+extern void restore_sp(unsigned int sp);
+
+//cache
+extern void invalidate_dcache(void);
+extern void flush_icache(void);
+extern void flush_dcache(void);
+extern void disable_cache(void);
+extern void disable_dcache(void);
+extern void disable_l2cache(void);
+extern void enable_cache(void);
+extern void enable_icache(void);
+
+extern void disable_program_flow_prediction(void);
+extern void invalidate_branch_predictor(void);
+extern void enable_program_flow_prediction(void);
+
+extern void mem_flush_tlb(void);
+extern void mem_preload_tlb(void);
+
+void disable_mmu(void);
+void enable_mmu(void);
+
+extern int jump_to_resume(void* pointer, __u32 *addr);
+extern int jump_to_resume0(void* pointer);
+void jump_to_suspend(__u32 ttbr1, suspend_func p);
+extern int jump_to_resume0_nommu(void* pointer);
+
+/*mmu_pc.c*/
+extern void save_mmu_state(struct mmu_state *saved_mmu_state);
+extern void restore_mmu_state(struct mmu_state *saved_mmu_state);
+void set_ttbr0(void);
+extern void invalidate_dcache(void);
+
+#endif /*_PM_H*/
diff --git a/arch/arm/mach-sun6i/pm/pm_config.h b/arch/arm/mach-sun6i/pm/pm_config.h
new file mode 100644
index 0000000..483aa5a
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/pm_config.h
@@ -0,0 +1,74 @@
+#ifndef _PM_CONFIG_H
+#define _PM_CONFIG_H
+
+#include "mach/memory.h"
+#include "asm-generic/sizes.h"
+//#include <generated/autoconf.h>
+#define CONFIG_AW_ASIC_EVB_PLATFORM 1
+
+/*
+* Copyright (c) 2011-2015 yanggq.young@allwinnertech.com
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License version 2 as published by
+* the Free Software Foundation.
+*/
+#ifdef CONFIG_ARCH_SUN6I
+#undef CONFIG_ARCH_SUN6I
+#endif
+
+#define CONFIG_ARCH_SUN6I
+#define ENABLE_SUPER_STANDBY
+
+#ifndef CONFIG_AW_ASIC_EVB_PLATFORM
+#define SUN6I_FPGA_SIM
+#else
+#if 0 == CONFIG_AW_ASIC_EVB_PLATFORM
+#define SUN6I_FPGA_SIM
+#endif
+#endif
+
+
+//#define CHECK_IC_VERSION
+
+//#define RETURN_FROM_RESUME0_WITH_MMU    //suspend: 0xf000, resume0: 0xc010, resume1: 0xf000
+//#define RETURN_FROM_RESUME0_WITH_NOMMU // suspend: 0x0000, resume0: 0x4010, resume1: 0x0000
+//#define DIRECT_RETURN_FROM_SUSPEND //not support yet
+#define ENTER_SUPER_STANDBY    //suspend: 0xf000, resume0: 0x4010, resume1: 0x0000
+//#define ENTER_SUPER_STANDBY_WITH_NOMMU //not support yet, suspend: 0x0000, resume0: 0x4010, resume1: 0x0000
+//#define WATCH_DOG_RESET
+
+//NOTICE: only need one definiton
+#define RESUME_FROM_RESUME1
+
+/**start address for function run in sram*/
+#define SRAM_FUNC_START    (0xf0000000)
+#define SRAM_FUNC_START_PA (0x00000000)
+
+#define DRAM_BASE_ADDR      0xc0000000
+#define DRAM_BASE_ADDR_PA      0x40000000
+#define DRAM_TRANING_SIZE   (16)
+
+#define DRAM_BACKUP_BASE_ADDR1_PA (SUPER_STANDBY_MEM_BASE)	//0x4600,0000-0x4600,0000+1k;
+#define DRAM_BACKUP_SIZE1 (0x0100) // 2^8 * 4 = 1K bytes.
+
+#define RUNTIME_CONTEXT_SIZE (14 * sizeof(__u32)) //r0-r13
+
+#define DRAM_COMPARE_DATA_ADDR (0xc0100000) //1Mbytes offset
+#define DRAM_COMPARE_SIZE (0x10000) //?
+
+
+//for mem mapping
+#define MEM_SW_VA_SRAM_BASE (0x00000000)
+#define MEM_SW_PA_SRAM_BASE (0x00000000)
+
+#define __AC(X,Y)	(X##Y)
+#define _AC(X,Y)	__AC(X,Y)
+#define _AT(T,X)	((T)(X))
+#define UL(x) _AC(x, UL)
+#define IO_ADDRESS(x)		((x) + 0xf0000000)
+
+#define SUSPEND_FREQ (720000)	//720M
+#define SUSPEND_DELAY_MS (10)
+
+#endif /*_PM_CONFIG_H*/
diff --git a/arch/arm/mach-sun6i/pm/pm_debug.c b/arch/arm/mach-sun6i/pm/pm_debug.c
new file mode 100644
index 0000000..1fd8f96
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/pm_debug.c
@@ -0,0 +1,133 @@
+#include "pm_types.h"
+#include "pm.h"
+
+//for io-measure time
+#define PORT_E_CONFIG (0xf1c20890)
+#define PORT_E_DATA (0xf1c208a0)
+#define PORT_CONFIG PORT_E_CONFIG
+#define PORT_DATA PORT_E_DATA
+
+volatile int  print_flag = 0;
+
+void busy_waiting(void)
+{
+#if 1
+	volatile __u32 loop_flag = 1;
+	while(1 == loop_flag);
+
+#endif
+	return;
+}
+
+void fake_busy_waiting(void)
+{
+#if 1
+	volatile __u32 loop_flag = 2;
+	while(1 == loop_flag);
+
+#endif
+	return;
+}
+
+/*
+ * notice: when resume, boot0 need to clear the flag,
+ * in case the data in dram be destoryed result in the system is re-resume in cycle.
+*/
+void save_mem_flag(void)
+{
+#if 0
+	__u32 saved_flag = *(volatile __u32 *)(PERMANENT_REG);
+	saved_flag &= 0xfffffffe;
+	saved_flag |= 0x00000001;
+	*(volatile __u32 *)(PERMANENT_REG) = saved_flag;
+#endif
+	return;
+}
+
+/*
+ * before enter suspend, need to clear mem flag,
+ * in case the flag is failed to clear by resume code
+ *
+*/
+void clear_mem_flag(void)
+{
+#if 0
+	__u32 saved_flag = *(volatile __u32 *)(PERMANENT_REG);
+	saved_flag &= 0xfffffffe;
+	*(volatile __u32 *)(PERMANENT_REG) = saved_flag;
+#endif
+	return;
+}
+
+
+void save_mem_status(volatile __u32 val)
+{
+	*(volatile __u32 *)(STATUS_REG  + 0x04) = val;
+	return;
+}
+
+__u32 get_mem_status(void)
+{
+	return *(volatile __u32 *)(STATUS_REG  + 0x04);
+}
+
+void save_mem_status_nommu(volatile __u32 val)
+{
+	*(volatile __u32 *)(STATUS_REG_PA  + 0x04) = val;
+	return;
+}
+
+
+
+/*
+ * notice: dependant with perf counter to delay.
+ */
+void io_init(void)
+{
+	//config port output
+	*(volatile unsigned int *)(PORT_CONFIG)  = 0x111111;
+
+	return;
+}
+
+void io_init_high(void)
+{
+	__u32 data;
+
+	//set port to high
+	data = *(volatile unsigned int *)(PORT_DATA);
+	data |= 0x3f;
+	*(volatile unsigned int *)(PORT_DATA) = data;
+
+	return;
+}
+
+void io_init_low(void)
+{
+	__u32 data;
+
+	data = *(volatile unsigned int *)(PORT_DATA);
+	//set port to low
+	data &= 0xffffffc0;
+	*(volatile unsigned int *)(PORT_DATA) = data;
+
+	return;
+}
+
+/*
+ * set pa port to high, num range is 0-7;
+ */
+void io_high(int num)
+{
+	__u32 data;
+	data = *(volatile unsigned int *)(PORT_DATA);
+	//pull low 10ms
+	data &= (~(1<<num));
+	*(volatile unsigned int *)(PORT_DATA) = data;
+	delay_us(10000);
+	//pull high
+	data |= (1<<num);
+	*(volatile unsigned int *)(PORT_DATA) = data;
+
+	return;
+}
diff --git a/arch/arm/mach-sun6i/pm/pm_debug.h b/arch/arm/mach-sun6i/pm/pm_debug.h
new file mode 100644
index 0000000..3446a8f
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/pm_debug.h
@@ -0,0 +1,94 @@
+#ifndef _PM_DEBUG_H
+#define _PM_DEBUG_H
+
+#include "pm_config.h"
+/*
+ * Copyright (c) 2011-2015 yanggq.young@allwinnertech.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#ifdef CONFIG_ARCH_SUN4I
+	#define PERMANENT_REG (0xf1c20d20)
+	#define PERMANENT_REG_PA (0x01c20d20)
+	#define STATUS_REG (0xf1c20d20)
+	#define STATUS_REG_PA (0x01c20d20)
+#elif defined(CONFIG_ARCH_SUN5I)
+	#define PERMANENT_REG (0xF1c0123c)
+	#define PERMANENT_REG_PA (0x01c0123c)
+	#define STATUS_REG (0xf0000740)
+	#define STATUS_REG_PA (0x00000740)
+	//notice: the address is located in the last word of (DRAM_BACKUP_BASE_ADDR + DRAM_BACKUP_SIZE)
+	#define SUN5I_STATUS_REG (DRAM_BACKUP_BASE_ADDR + (DRAM_BACKUP_SIZE<<2) -0x4)
+	#define SUN5I_STATUS_REG_PA (DRAM_BACKUP_BASE_ADDR_PA + (DRAM_BACKUP_SIZE<<2) -0x4)
+#elif defined(CONFIG_ARCH_SUN6I)
+	#define STATUS_REG (0xf1f00100)
+	#define STATUS_REG_PA (0x01f00100)
+
+#endif
+
+
+
+//#define GET_CYCLE_CNT
+#define IO_MEASURE
+extern volatile int print_flag;
+
+enum counter_type_e{
+	I_CACHE_MISS = 0X01,
+	I_TLB_MISS = 0X02,
+	D_CACHE_MISS = 0X03,
+	D_TLB_MISS = 0X05,
+};
+
+void set_event_counter(enum counter_type_e type);
+int get_event_counter(enum counter_type_e type);
+void init_event_counter (__u32 do_reset, __u32 enable_divider);
+
+/*
+ * Check at compile time that something is of a particular type.
+ * Always evaluates to 1 so you may use it easily in comparisons.
+ */
+#define typecheck(type,x) \
+({	type __dummy; \
+	typeof(x) __dummy2; \
+	(void)(&__dummy == &__dummy2); \
+	1; \
+})
+
+/*
+ * if return true, means a is after b;
+ */
+#define counter_after(a,b) \
+(typecheck(__u32, a) && \
+typecheck(__u32, b) && \
+((__s32)(b) - (__s32)(a) < 0))
+#define counter_before(a,b) counter_after(b,a)
+
+#define counter_after_eq(a,b) \
+(typecheck(__u32, a) && \
+typecheck(__u32, b) && \
+((__s32)(a) - (__s32)(b) >= 0))
+#define counter_before_eq(a,b) counter_after_eq(b,a)
+
+
+void busy_waiting(void);
+/*
+ * notice: when resume, boot0 need to clear the flag,
+ * in case the data in dram be destoryed result in the system is re-resume in cycle.
+*/
+void save_mem_flag(void);
+void clear_mem_flag(void);
+void save_mem_status(volatile __u32 val);
+void save_mem_status_nommu(volatile __u32 val);
+__u32 get_mem_status(void);
+__u32 save_sun5i_mem_status_nommu(volatile __u32 val);
+__u32 save_sun5i_mem_status(volatile __u32 val);
+
+void io_init(void);
+void io_init_high(void);
+void io_init_low(void);
+void io_high(int num);
+
+#endif /*_PM_DEBUG_H*/
diff --git a/arch/arm/mach-sun6i/pm/pm_errcode.h b/arch/arm/mach-sun6i/pm/pm_errcode.h
new file mode 100644
index 0000000..d72b985
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/pm_errcode.h
@@ -0,0 +1,22 @@
+#ifndef _PM_ERR_CODE_H
+#define _PM_ERR_CODE_H
+
+/*
+ * Copyright (c) 2011-2015 yanggq.young@allwinnertech.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+ #define BEFORE_EARLY_SUSPEND	(0x0001)
+ #define EARLY_SUSPEND_START		(0x1000)
+#define  STANDBY_START			(0x2000)
+ #define SUSPEND_START			(0x3000)
+ #define TWI_TRANSFER_STATUS		(0x4000)
+ #define RUSUME0_START			(0x5000)
+ #define RESUME1_START			(0x7000)
+ #define BEFORE_LATE_RESUME		(0x8000)
+ #define LATE_RESUME_START		(0x9000)
+
+#endif /*_PM_ERR_CODE_H*/
diff --git a/arch/arm/mach-sun6i/pm/pm_i.h b/arch/arm/mach-sun6i/pm/pm_i.h
new file mode 100644
index 0000000..24504f0
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/pm_i.h
@@ -0,0 +1,165 @@
+#ifndef _PM_I_H
+#define _PM_I_H
+
+/*
+ * Copyright (c) 2011-2015 njubie@allwinnertech.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#include <mach/platform.h>
+#include <mach/ccmu.h>
+#include <mach/hardware.h>
+#include "pm.h"
+#include <mach/ar100.h>
+#include "mem_mapping.h"
+
+#include "standby/super/super_clock.h"
+#include "standby/super/super_power.h"
+#include "standby/super/super_twi.h"
+
+
+/* define register for interrupt controller */
+typedef struct __MEM_INT_REG{
+
+    volatile __u32   Vector;
+    volatile __u32   BaseAddr;
+    volatile __u32   reserved0;
+    volatile __u32   NmiCtrl;
+
+    volatile __u32   IrqPend[3];
+    volatile __u32   reserved1;
+
+    volatile __u32   FiqPend[3];
+    volatile __u32   reserved2;
+
+    volatile __u32   TypeSel[3];
+    volatile __u32   reserved3;
+
+    volatile __u32   IrqEn[3];
+    volatile __u32   reserved4;
+
+    volatile __u32   IrqMask[3];
+    volatile __u32   reserved5;
+
+    volatile __u32   IrqResp[3];
+    volatile __u32   reserved6;
+
+    volatile __u32   IrqForce[3];
+    volatile __u32   reserved7;
+
+    volatile __u32   IrqPrio[5];
+} __mem_int_reg_t;
+
+
+typedef struct __MEM_TWIC_REG
+{
+    volatile __u32 reg_saddr;
+    volatile __u32 reg_xsaddr;
+    volatile __u32 reg_data;
+    volatile __u32 reg_ctl;
+    volatile __u32 reg_status;
+    volatile __u32 reg_clkr;
+    volatile __u32 reg_reset;
+    volatile __u32 reg_efr;
+    volatile __u32 reg_lctl;
+
+} __mem_twic_reg_t;
+
+
+struct gic_distributor_state{
+	//distributor
+	volatile __u32 GICD_CTLR;					//offset 0x00, distributor Contrl reg
+	volatile __u32 GICD_IGROUPRn;					//offset 0x80, Interrupt Grp Reg ?
+	volatile __u32 GICD_ISENABLERn[0x180/4];			//offset 0x100-0x17c, Interrupt Set-Enable Reg
+	volatile __u32 GICD_ICENABLERn[0x180/4];			//offset 0x180-0x1fc, Iterrupt Clear-Enable Reg
+	volatile __u32 GICD_ISPENDRn[0x180/4];				//offset 0x200-0x27c, Iterrupt Set-Pending Reg
+	volatile __u32 GICD_ICPENDRn[0x180/4];				//offset 0x280-0x2fc, Iterrupt Clear-Pending Reg
+	volatile __u32 GICD_ISACTIVERn[0x180/4]; 			//offset 0x300-0x37c, GICv2 Iterrupt Set-Active Reg
+	volatile __u32 GICD_ICACTIVERn[0x180/4]; 			//offset 0x380-0x3fc, Iterrupt Clear-Active Reg
+	volatile __u32 GICD_IPRIORITYRn[0x180/4]; 			//offset 0x400-0x7F8, Iterrupt Priority Reg
+	volatile __u32 GICD_ITARGETSRn[(0x400-0x20)/4];			//offset 0x820-0xbf8, Iterrupt Processor Targets Reg
+	volatile __u32 GICD_ICFGRn[0x100/4];				//offset 0xc00-0xcfc, Iterrupt Config Reg
+	volatile __u32 GICD_NSACRn[0x100/4];				//offset 0xE00-0xEfc, non-secure Access Ctrl Reg ?
+	volatile __u32 GICD_CPENDSGIRn[0x10/4];				//offset 0xf10-0xf1c, SGI Clear-Pending Reg
+	volatile __u32 GICD_SPENDSGIRn[0x10/4];				//offset 0xf20-0xf2c, SGI Set-Pending Reg
+};
+
+struct gic_cpu_interface_state{
+	//cpu interface reg
+	volatile __u32 GICC_CTLR_PMR_BPR[0xc/4];			//offset 0x00-0x08, cpu interface Ctrl Reg	+ 	Interrupt Priority Mask Reg	 + 	  Binary Point Reg
+	volatile __u32 GICC_ABPR;				//offset 0x1c, Aliased Binary Point Reg
+	volatile __u32 GICC_APRn[0x10/4];			//offset 0xd0-0xdc, Active Priorities Reg
+	volatile __u32 GICC_NSAPRn[0x10/4];			//offset 0xe0-0xec, Non-secure Active Priorities Reg
+};
+
+struct gic_distributor_disc{
+	//distributor
+	volatile __u32 GICD_CTLR;					//offset 0x00, distributor Contrl reg
+	volatile __u32 reserved0[0x7c/4];				//0ffset 0x04-0x7c
+	volatile __u32 GICD_IGROUPRn;					//offset 0x80, Interrupt Grp Reg ?
+	volatile __u32 reserved1[0x7c/4];				//0ffset 0x84-0xfc
+	volatile __u32 GICD_ISENABLERn[0x180/4];			//offset 0x100-0x17c, Interrupt Set-Enable Reg
+	volatile __u32 GICD_ICENABLERn[0x180/4];			//offset 0x180-0x1fc, Iterrupt Clear-Enable Reg
+	volatile __u32 GICD_ISPENDRn[0x180/4];				//offset 0x200-0x27c, Iterrupt Set-Pending Reg
+	volatile __u32 GICD_ICPENDRn[0x180/4];				//offset 0x280-0x2fc, Iterrupt Clear-Pending Reg
+	volatile __u32 GICD_ISACTIVERn[0x180/4]; 			//offset 0x300-0x37c, GICv2 Iterrupt Set-Active Reg
+	volatile __u32 GICD_ICACTIVERn[0x180/4]; 			//offset 0x380-0x3fc, Iterrupt Clear-Active Reg
+	volatile __u32 GICD_IPRIORITYRn[0x180/4]; 			//offset 0x400-0x7F8, Iterrupt Priority Reg
+	volatile __u32 reserved2[0x24/4];				//0ffset 0x7fc-0x81c
+	volatile __u32 GICD_ITARGETSRn[(0x400-0x20)/4];			//offset 0x820-0xbf8, Iterrupt Processor Targets Reg
+	volatile __u32 reserved3;					//0ffset 0xbfc
+	volatile __u32 GICD_ICFGRn[0x100/4];				//offset 0xc00-0xcfc, Iterrupt Config Reg
+	volatile __u32 reserved4[0x100/4];				//0ffset 0xd00-0xdfc
+	volatile __u32 GICD_NSACRn[0x100/4];				//offset 0xE00-0xEfc, non-secure Access Ctrl Reg ?
+	volatile __u32 reserved5[0x10/4];				//0ffset 0xf00-0xf0c
+	volatile __u32 GICD_CPENDSGIRn[0x10/4];				//offset 0xf10-0xf1c, SGI Clear-Pending Reg
+	volatile __u32 GICD_SPENDSGIRn[0x10/4];				//offset 0xf20-0xf2c, SGI Set-Pending Reg
+	volatile __u32 reserved6[0xd0/4];				//0ffset 0xf30-0xffc
+
+};
+
+struct gic_cpu_interface_disc{
+	//cpu interface reg
+	volatile __u32 GICC_CTLR_PMR_BPR[0xc/4];			//offset 0x00-0x08, cpu interface Ctrl Reg	+ 	Interrupt Priority Mask Reg	 + 	  Binary Point Reg
+	volatile __u32 reserved7[0x10/4];			//0ffset 0xC-0x18, readonly or writeonly
+	volatile __u32 GICC_ABPR;				//offset 0x1c, Aliased Binary Point Reg
+	volatile __u32 reserved8[0xb0/4];			//0ffset 0x20-0xcf, readonly or writeonly
+	volatile __u32 GICC_APRn[0x10/4];			//offset 0xd0-0xdc, Active Priorities Reg
+	volatile __u32 GICC_NSAPRn[0x10/4];			//offset 0xe0-0xec, Non-secure Active Priorities Reg
+	volatile __u32 reserved9[0x10/4];			//0ffset 0xf0-0xfc, readonly or writeonly
+	volatile __u32 reserved10[0xf00/4];			//0ffset 0x100-0xffc, readonly or writeonly
+	volatile __u32 reserved11;				//0ffset 0x1000, readonly or writeonly
+
+};
+
+struct gic_state{
+	struct gic_distributor_state m_distributor;
+	struct gic_cpu_interface_state m_interface;
+};
+
+struct twi_state{
+	__mem_twic_reg_t *twi_reg;
+	__u32 twi_reg_backup[7];
+};
+
+struct gpio_state{
+	__u32 gpio_reg_back[GPIO_REG_LENGTH];
+};
+
+struct sram_state{
+	__u32 sram_reg_back[SRAM_REG_LENGTH];
+};
+
+//save module state
+__s32 mem_twi_save(struct twi_state *ptwi_state);
+__s32 mem_twi_restore(struct twi_state *ptwi_state);
+__s32 mem_gpio_save(struct gpio_state *pgpio_state);
+__s32 mem_gpio_restore(struct gpio_state *pgpio_state);
+__s32 mem_sram_save(struct sram_state *psram_state);
+__s32 mem_sram_restore(struct sram_state *psram_state);
+__s32 mem_ccu_save(__ccmu_reg_list_t *pReg);
+__s32 mem_ccu_restore(__ccmu_reg_list_t *pReg);
+
+#endif /*_PM_I_H*/
diff --git a/arch/arm/mach-sun6i/pm/pm_types.h b/arch/arm/mach-sun6i/pm/pm_types.h
new file mode 100644
index 0000000..e390dbd
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/pm_types.h
@@ -0,0 +1,27 @@
+#ifndef _PM_TYPES_H
+#define _PM_TYPES_H
+
+/*
+ * Copyright (c) 2011-2015 njubie@allwinnertech.com
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#ifndef __uxx_sxx_name
+#define __uxx_sxx_name
+typedef signed char         __s8;
+typedef unsigned char       __u8;
+typedef signed short        __s16;
+typedef unsigned short      __u16;
+typedef signed int          __s32;
+typedef unsigned int        __u32;
+typedef signed long long    __s64;
+typedef unsigned long long  __u64;
+#endif
+
+typedef unsigned int		size_t;
+typedef unsigned int		ptrdiff_t;
+
+#endif /*_PM_TYPES_H*/
\ No newline at end of file
diff --git a/arch/arm/mach-sun6i/pm/standby.S b/arch/arm/mach-sun6i/pm/standby.S
new file mode 100644
index 0000000..5c76622
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby.S
@@ -0,0 +1,6 @@
+	.globl	standby_bin_start
+standby_bin_start:
+	.incbin	"arch/arm/mach-sun6i/pm/standby/standby.code"
+	.globl	standby_bin_end
+standby_bin_end:
+	.align	2
diff --git a/arch/arm/mach-sun6i/pm/standby/Makefile b/arch/arm/mach-sun6i/pm/standby/Makefile
new file mode 100644
index 0000000..6af3fd4
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/Makefile
@@ -0,0 +1,143 @@
+#makefile for standby.bin
+
+INCLUDE   = -I. \
+	-I$(KDIR)/include \
+	-I$(KDIR)/arch/arm/mach-sun6i/include
+
+STANDBY_OBJ = 	common.o         	\
+		standby.o        	\
+		standby_clock.o  	\
+		standby_ir.o     	\
+		standby_key.o    	\
+		standby_power.o  	\
+		standby_twi.o    	\
+		standby_usb.o    	\
+		standby_delay.o  	\
+		./ar100/standby_ar100.o 	\
+		./ar100/ar100_hwmsgbox.o 	\
+		./ar100/ar100_hwspinlock.o 	\
+		./ar100/ar100_message_manager.o	\
+		./../pm_debug.o       		\
+		./../mem_timing.o      		\
+		./../mem_mmu_pc.o               \
+		./../mem_mmu_pc_asm.o           \
+		./../mem_serial.o		\
+		./../mem_printk.o  		\
+		./../mem_divlib.o		\
+		./../mem_divlibc.o		\
+		./../mem_int.o			\
+		./../mem_tmr.o
+
+RESUME1_OBJ =	./super/common.o             	\
+		./super/super_twi.o        	\
+		./super/super_delay.o      	\
+		./super/super_clock.o      	\
+		./super/super_power.o      	\
+		./super/resume/resume1.o 	\
+		./super/resume/resume_head.o 	\
+		./super/resume/resume1_c_part.o \
+		./../pm_debug.o                 \
+		./../mem_timing.o               \
+		./../mem_mmu_pc.o               \
+		./../mem_mmu_pc_asm.o           \
+		./../mem_cpu.o                  \
+		./../mem_serial.o		\
+		./../mem_printk.o		\
+		./../mem_divlib.o		\
+		./../mem_divlibc.o		\
+		./../mem_int.o			\
+		./../mem_tmr.o			\
+		./../mem_clk.o
+
+STANDBY_OUPUTFILE = standby
+RESUME1_OUPUTFILE = resume1
+
+STANDBY_LD_FILE = standby.xn
+RESUME1_LD_FILE = resume1_scatter.scat
+
+CC = $(CROSS_COMPILE)gcc
+
+#CFLAGS = -g -c -nostdlib -march=armv7-a -marm -fno-unwind-tables -fno-asynchronous-unwind-tables -mlittle-endian  --min_array_alignment=4 --no_unaligned_access -O2
+CFLAGS = -g -c -nostdlib -march=armv7-a -marm -D__STANDBY_MODULE__ -fno-unwind-tables -fno-asynchronous-unwind-tables -mlittle-endian -O2 --min_array_alignment=4 --no_unaligned_access
+
+LD_FLAGS = -static
+LIBS =
+
+all: standby resume1
+standby:
+	$(CC) $(INCLUDE) $(CFLAGS) common.c           			-o common.o
+	$(CC) $(INCLUDE) $(CFLAGS) standby.c          			-o standby.o
+	$(CC) $(INCLUDE) $(CFLAGS) standby_clock.c    			-o standby_clock.o
+	$(CC) $(INCLUDE) $(CFLAGS) standby_ir.c       			-o standby_ir.o
+	$(CC) $(INCLUDE) $(CFLAGS) standby_key.c      			-o standby_key.o
+	$(CC) $(INCLUDE) $(CFLAGS) standby_power.c    			-o standby_power.o
+	$(CC) $(INCLUDE) $(CFLAGS) standby_twi.c      			-o standby_twi.o
+	$(CC) $(INCLUDE) $(CFLAGS) standby_usb.c      			-o standby_usb.o
+	$(CC) $(INCLUDE) $(CFLAGS) standby_delay.S    			-o standby_delay.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./ar100/standby_ar100.c    		-o ./ar100/standby_ar100.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./ar100/ar100_hwmsgbox.c   		-o ./ar100/ar100_hwmsgbox.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./ar100/ar100_hwspinlock.c 		-o ./ar100/ar100_hwspinlock.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./ar100/ar100_message_manager.c	-o ./ar100/ar100_message_manager.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../pm_debug.c    			-o ./../pm_debug.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_timing.c    		-o ./../mem_timing.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_mmu_pc.c                   -o ./../mem_mmu_pc.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_mmu_pc_asm.S               -o ./../mem_mmu_pc_asm.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_serial.c    -o 		./../mem_serial.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_printk.c    -o 		./../mem_printk.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_divlib.S    -o 		./../mem_divlib.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_divlibc.c    -o 		./../mem_divlibc.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_int.c    -o 		./../mem_int.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_tmr.c    -o 		./../mem_tmr.o
+
+	$(CROSS_COMPILE)ld -T $(STANDBY_LD_FILE) $(LD_FLAGS) $(LIBS) -EL  $(STANDBY_OBJ) -o $(STANDBY_OUPUTFILE).elf  -Map $(STANDBY_OUPUTFILE).map
+	$(CROSS_COMPILE)objdump -D $(STANDBY_OUPUTFILE).elf > $(STANDBY_OUPUTFILE).lst
+	$(CROSS_COMPILE)objcopy -O binary $(STANDBY_OUPUTFILE).elf $(STANDBY_OUPUTFILE).bin
+
+	rm -rf *.o ../*.o
+
+	cp standby.bin standby.code
+
+	@echo ----------------------------------------
+	@echo well done!
+
+
+resume1:
+	$(CC) $(INCLUDE) $(CFLAGS) ./super/common.c                    -o ./super/common.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./super/super_twi.c               -o ./super/super_twi.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./super/super_delay.S             -o ./super/super_delay.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./super/super_clock.c             -o ./super/super_clock.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./super/super_power.c             -o ./super/super_power.o
+
+	$(CC) $(INCLUDE) $(CFLAGS) ./super/resume/resume1_c_part.c     	-o ./super/resume/resume1_c_part.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./super/resume/resume_head.c     	-o ./super/resume/resume_head.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./super/resume/resume1.S        -o ./super/resume/resume1.o
+
+
+	$(CC) $(INCLUDE) $(CFLAGS) ./../pm_debug.c                     -o ./../pm_debug.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_timing.c    		-o ./../mem_timing.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_mmu_pc.c                   -o ./../mem_mmu_pc.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_mmu_pc_asm.S               -o ./../mem_mmu_pc_asm.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_cpu.c		       -o ./../mem_cpu.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_serial.c    		-o ./../mem_serial.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_printk.c    		-o ./../mem_printk.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_divlib.S    -o 		./../mem_divlib.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_divlibc.c    -o 		./../mem_divlibc.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_int.c    	-o 		./../mem_int.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_tmr.c    -o 		./../mem_tmr.o
+	$(CC) $(INCLUDE) $(CFLAGS) ./../mem_clk.c    -o 		./../mem_clk.o
+
+	$(CROSS_COMPILE)ld -T $(RESUME1_LD_FILE)  -EL  $(RESUME1_OBJ) -o $(RESUME1_OUPUTFILE).elf  -Map $(RESUME1_OUPUTFILE).map
+	$(CROSS_COMPILE)objdump -D $(RESUME1_OUPUTFILE).elf > $(RESUME1_OUPUTFILE).lst
+	$(CROSS_COMPILE)objcopy -O binary $(RESUME1_OUPUTFILE).elf $(RESUME1_OUPUTFILE).bin
+
+	rm -rf *.o ../*.o
+
+	#cp resume1.bin ./super/resume/resume1.code
+	./gen_check_code ./resume1.bin ./super/resume/resume1.code
+
+	@echo ----------------------------------------
+	@echo well done!
+
+
+clean:
+	-rm *.o *.map *.lst *.bin *.elf *.exe dram/*.o
diff --git a/arch/arm/mach-sun6i/pm/standby/ar100/ar100_cfgs.h b/arch/arm/mach-sun6i/pm/standby/ar100/ar100_cfgs.h
new file mode 100644
index 0000000..f8f0da5
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/ar100/ar100_cfgs.h
@@ -0,0 +1,53 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/include/ar100_cfgs.h
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__AR100_CFGS_H__
+#define __AR100_CFGS_H__
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+//debugger system
+#define	AR100_DEBUG_LEVEL			(3)		//debug level
+
+//the max number of cached message frame
+#define	AR100_MESSAGE_CACHED_MAX	(4)
+
+//the start address of message pool
+#define AR100_MESSAGE_POOL_START	(0x13000)
+#define AR100_MESSAGE_POOL_END		(0x14000)
+
+//spinlock max timeout, base on ms
+#define AR100_SPINLOCK_TIMEOUT		(10)
+
+//send message max timeout, base on ms
+#define AR100_SEND_MSG_TIMEOUT		(10)
+
+//hwmsgbox channels configure
+#define	AR100_HWMSGBOX_AR100_ASYN_TX_CH	(0)
+#define	AR100_HWMSGBOX_AR100_ASYN_RX_CH	(1)
+#define	AR100_HWMSGBOX_AR100_SYN_TX_CH	(2)
+#define	AR100_HWMSGBOX_AR100_SYN_RX_CH	(3)
+#define	AR100_HWMSGBOX_AC327_SYN_TX_CH	(4)
+#define	AR100_HWMSGBOX_AC327_SYN_RX_CH	(5)
+
+#endif //__AR100_CFGS_H__
diff --git a/arch/arm/mach-sun6i/pm/standby/ar100/ar100_dbgs.h b/arch/arm/mach-sun6i/pm/standby/ar100/ar100_dbgs.h
new file mode 100644
index 0000000..d549aa0
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/ar100/ar100_dbgs.h
@@ -0,0 +1,55 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/include/ar100_bgs.h
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__AR100_DBGS_H__
+#define	__AR100_DBGS_H__
+
+//debug level define,
+//level 0 : dump debug information--none;
+//level 1 : dump debug information--error;
+//level 2 : dump debug information--error+warning;
+//level 3 : dump debug information--error+warning+information;
+#define DEBUG_ENABLE
+
+//extern void printk(const char *, ...);
+#if		(AR100_DEBUG_LEVEL == 0)
+#define	AR100_INF(...)
+#define	AR100_WRN(...)
+#define	AR100_ERR(...)
+#define	AR100_LOG(...)
+#elif 	(AR100_DEBUG_LEVEL == 1)
+#define	AR100_INF(...)
+#define	AR100_WRN(...)
+#define	AR100_ERR(...)		printk(__VA_ARGS__)
+#define	AR100_LOG(...)		printk(__VA_ARGS__)
+#elif 	(AR100_DEBUG_LEVEL == 2)
+#define	AR100_INF(...)
+#define	AR100_WRN(...)		printk(__VA_ARGS__)
+#define	AR100_ERR(...)		printk(__VA_ARGS__)
+#define	AR100_LOG(...)		printk(__VA_ARGS__)
+#elif 	(AR100_DEBUG_LEVEL == 3)
+#define	AR100_INF(...)		printk(__VA_ARGS__)
+#define	AR100_WRN(...)		printk(__VA_ARGS__)
+#define	AR100_ERR(...)		printk(__VA_ARGS__)
+#define	AR100_LOG(...)		printk(__VA_ARGS__)
+#endif	//AR100_DEBUG_LEVEL
+
+#endif	//__AR100_DBGS_H__
diff --git a/arch/arm/mach-sun6i/pm/standby/ar100/ar100_hwmsgbox.c b/arch/arm/mach-sun6i/pm/standby/ar100/ar100_hwmsgbox.c
new file mode 100644
index 0000000..1f9da4a
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/ar100/ar100_hwmsgbox.c
@@ -0,0 +1,297 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/hwmsgbox/hwmsgbox.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "standby_ar100_i.h"
+
+//local functions
+int ar100_hwmsgbox_clear_receiver_pending(int queue, int user);
+int ar100_hwmsgbox_query_receiver_pending(int queue, int user);
+int ar100_hwmsgbox_enable_receiver_int(int queue, int user);
+int ar100_hwmsgbox_set_receiver(int queue, int user);
+int ar100_hwmsgbox_set_transmitter(int queue, int user);
+int ar100_hwmsgbox_wait_message_feedback(struct ar100_message *pmessage);
+int ar100_hwmsgbox_message_feedback(struct ar100_message *pmessage);
+int ar100_message_valid(struct ar100_message *pmessage);
+
+/*
+*********************************************************************************************************
+*                                       	INITIALIZE HWMSGBOX
+*
+* Description: 	initialize hwmsgbox.
+*
+* Arguments  : 	none.
+*
+* Returns    : 	0 if initialize hwmsgbox succeeded, others if failed.
+*********************************************************************************************************
+*/
+int ar100_hwmsgbox_init(void)
+{
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                       	EXIT HWMSGBOX
+*
+* Description: 	exit hwmsgbox.
+*
+* Arguments  : 	none.
+*
+* Returns    : 	0 if exit hwmsgbox succeeded, others if failed.
+*********************************************************************************************************
+*/
+int ar100_hwmsgbox_exit(void)
+{
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                       SEND MESSAGE BY HWMSGBOX
+*
+* Description: 	send one message to another processor by hwmsgbox.
+*
+* Arguments  : 	pmessage 	: the pointer of sended message frame.
+*				timeout		: the wait time limit when message fifo is full,
+*							  it is valid only when parameter mode = HWMSG_SEND_WAIT_TIMEOUT.
+*
+* Returns    : 	0 if send message succeeded, other if failed.
+*********************************************************************************************************
+*/
+int ar100_hwmsgbox_send_message(struct ar100_message *pmessage, unsigned int timeout)
+{
+	volatile unsigned long value;
+
+	if (pmessage == NULL) {
+		return -EINVAL;
+	}
+	if (pmessage->attr & AR100_MESSAGE_ATTR_HARDSYN) {
+		//use ac327 hwsyn transmit channel.
+		while (readl(IO_ADDRESS(AW_MSGBOX_FIFO_STATUS_REG(AR100_HWMSGBOX_AC327_SYN_TX_CH))) == 1) {
+			//message-queue fifo is full, waiting always
+			;
+		}
+		value = ((volatile unsigned long)pmessage) - ar100_sram_a2_vbase;
+		AR100_INF("ac327 send hard syn message : %x\n", (unsigned int)value);
+		writel(value, IO_ADDRESS(AW_MSGBOX_MSG_REG(AR100_HWMSGBOX_AC327_SYN_TX_CH)));
+
+		//hwsyn messsage must feedback use syn rx channel
+		while (readl(IO_ADDRESS(AW_MSGBOX_MSG_STATUS_REG(AR100_HWMSGBOX_AC327_SYN_RX_CH))) == 0) {
+			//message not valid
+			;
+		}
+		//check message valid
+		if (value != (readl(IO_ADDRESS(AW_MSGBOX_MSG_REG(AR100_HWMSGBOX_AC327_SYN_RX_CH))))) {
+			AR100_ERR("hard syn message error\n");
+			return -EINVAL;
+		}
+		AR100_INF("ac327 hard syn message [%x, %x] feedback\n", (unsigned int)value, (unsigned int)pmessage->type);
+		return 0;
+	}
+
+	//use ac327 asyn transmit channel.
+	while (readl(IO_ADDRESS(AW_MSGBOX_FIFO_STATUS_REG(AR100_HWMSGBOX_AR100_ASYN_RX_CH))) == 1) {
+		//message-queue fifo is full, waiting always
+		;
+	}
+	//write message to message-queue fifo.
+	value = ((volatile unsigned long)pmessage) - ar100_sram_a2_vbase;
+	AR100_LOG("ac327 send message : %x\n", (unsigned int)value);
+	writel(value, IO_ADDRESS(AW_MSGBOX_MSG_REG(AR100_HWMSGBOX_AR100_ASYN_RX_CH)));
+
+	//syn messsage must wait message feedback
+	if (pmessage->attr & AR100_MESSAGE_ATTR_SOFTSYN) {
+		AR100_ERR("standby ar100 driver not support soft syn message transfer\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int ar100_hwmsgbox_feedback_message(struct ar100_message *pmessage, unsigned int timeout)
+{
+	volatile unsigned long value;
+
+	if (pmessage->attr & AR100_MESSAGE_ATTR_HARDSYN) {
+		//use ac327 hard syn receiver channel.
+		while (readl(IO_ADDRESS(AW_MSGBOX_FIFO_STATUS_REG(AR100_HWMSGBOX_AR100_SYN_RX_CH))) == 1) {
+			//message-queue fifo is full, waiting.
+			;
+		}
+		value = ((volatile unsigned long)pmessage) - ar100_sram_a2_vbase;
+		AR100_INF("ar100 feedback hard syn message : %x\n", (unsigned int)value);
+		writel(value, IO_ADDRESS(AW_MSGBOX_MSG_REG(AR100_HWMSGBOX_AR100_SYN_RX_CH)));
+		return 0;
+	}
+	//soft syn use asyn tx channel
+	if (pmessage->attr & AR100_MESSAGE_ATTR_SOFTSYN) {
+		while (readl(IO_ADDRESS(AW_MSGBOX_FIFO_STATUS_REG(AR100_HWMSGBOX_AR100_ASYN_RX_CH))) == 1) {
+			//fifo is full, wait
+			;
+		}
+		//write message to message-queue fifo.
+		value = ((volatile unsigned long)pmessage) - ar100_sram_a2_vbase;
+		AR100_INF("ar100 send asyn or soft syn message : %x\n", (unsigned int)value);
+		writel(value, IO_ADDRESS(AW_MSGBOX_MSG_REG(AR100_HWMSGBOX_AR100_ASYN_RX_CH)));
+		return 0;
+	}
+
+	//invalid syn message
+	return -EINVAL;
+}
+
+/*
+*********************************************************************************************************
+*                                       	ENABLE RECEIVER INT
+*
+* Description: 	enbale the receiver interrupt of message-queue.
+*
+* Arguments  : 	queue 	: the number of message-queue which we want to enable interrupt.
+*				user	: the user which we want to enable interrupt.
+*
+* Returns    : 	0 if enable interrupt succeeded, others if failed.
+*********************************************************************************************************
+*/
+int ar100_hwmsgbox_enable_receiver_int(int queue, int user)
+{
+	volatile unsigned int value;
+
+	value  =  readl(IO_ADDRESS(AW_MSGBOX_IRQ_EN_REG(user)));
+	value &= ~(0x1 << (queue * 2));
+	value |=  (0x1 << (queue * 2));
+	writel(value, IO_ADDRESS(AW_MSGBOX_IRQ_EN_REG(user)));
+
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                       	QUERY PENDING
+*
+* Description: 	query the receiver interrupt pending of message-queue.
+*
+* Arguments  : 	queue 	: the number of message-queue which we want to query.
+*				user	: the user which we want to query.
+*
+* Returns    : 	0 if query pending succeeded, others if failed.
+*********************************************************************************************************
+*/
+int ar100_hwmsgbox_query_receiver_pending(int queue, int user)
+{
+	volatile unsigned long value;
+
+	value  =  readl(IO_ADDRESS((AW_MSGBOX_IRQ_STATUS_REG(user))));
+
+	return value & (0x1 << (queue * 2));
+}
+
+/*
+*********************************************************************************************************
+*                                       	CLEAR PENDING
+*
+* Description: 	clear the receiver interrupt pending of message-queue.
+*
+* Arguments  : 	queue 	: the number of message-queue which we want to clear.
+*				user	: the user which we want to clear.
+*
+* Returns    : 	0 if clear pending succeeded, others if failed.
+*********************************************************************************************************
+*/
+int ar100_hwmsgbox_clear_receiver_pending(int queue, int user)
+{
+	writel((0x1 << (queue * 2)), IO_ADDRESS(AW_MSGBOX_IRQ_STATUS_REG(user)));
+
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                        QUERY MESSAGE
+*
+* Description: 	query message of hwmsgbox by hand, mainly for.
+*
+* Arguments  : 	none.
+*
+* Returns    : 	the point of message, NULL if timeout.
+*********************************************************************************************************
+*/
+struct ar100_message *ar100_hwmsgbox_query_message(void)
+{
+	struct ar100_message *pmessage = NULL;
+
+	//query ac327 asyn received channel
+	if (readl(IO_ADDRESS(AW_MSGBOX_MSG_STATUS_REG(AR100_HWMSGBOX_AR100_ASYN_TX_CH)))) {
+		volatile unsigned long value;
+		value = readl(IO_ADDRESS(AW_MSGBOX_MSG_REG(AR100_HWMSGBOX_AR100_ASYN_TX_CH)));
+		pmessage = (struct ar100_message *)(value + ar100_sram_a2_vbase);
+		if (ar100_message_valid(pmessage)) {
+			//message state switch
+			if (pmessage->state == AR100_MESSAGE_PROCESSED) {
+				//AR100_MESSAGE_PROCESSED->AR100_MESSAGE_FEEDBACKED
+				pmessage->state = AR100_MESSAGE_FEEDBACKED;
+			} else {
+				//AR100_MESSAGE_INITIALIZED->AR100_MESSAGE_RECEIVED
+				pmessage->state = AR100_MESSAGE_RECEIVED;
+			}
+		} else {
+			//print_call_info();
+			AR100_ERR("invalid message received: 1 pmessage = 0x%x. \n", (__u32)pmessage);
+			return NULL;
+		}
+		//clear pending
+		ar100_hwmsgbox_clear_receiver_pending(AR100_HWMSGBOX_AR100_ASYN_TX_CH, AW_HWMSG_QUEUE_USER_AC327);
+		return pmessage;
+	}
+	//query ac327 syn received channel
+	if (readl(IO_ADDRESS(AW_MSGBOX_MSG_STATUS_REG(AR100_HWMSGBOX_AR100_SYN_TX_CH)))) {
+		volatile unsigned long value;
+		value = readl(IO_ADDRESS(AW_MSGBOX_MSG_REG(AR100_HWMSGBOX_AR100_SYN_TX_CH)));
+		pmessage = (struct ar100_message *)(value + ar100_sram_a2_vbase);
+		if (ar100_message_valid(pmessage)) {
+			//message state switch
+			if (pmessage->state == AR100_MESSAGE_PROCESSED) {
+				//AR100_MESSAGE_PROCESSED->AR100_MESSAGE_FEEDBACKED
+				pmessage->state = AR100_MESSAGE_FEEDBACKED;
+			} else {
+				//AR100_MESSAGE_INITIALIZED->AR100_MESSAGE_RECEIVED
+				pmessage->state = AR100_MESSAGE_RECEIVED;
+			}
+		} else {
+			//print_call_info();
+			AR100_ERR("invalid message received: 2 pmessage = 0x%x. \n", (__u32)pmessage);
+			return NULL;
+		}
+		ar100_hwmsgbox_clear_receiver_pending(AR100_HWMSGBOX_AR100_SYN_TX_CH, AW_HWMSG_QUEUE_USER_AC327);
+		return pmessage;
+	}
+	//no valid message
+	return NULL;
+}
+
+int ar100_message_valid(struct ar100_message *pmessage)
+{
+	if ((((__u32)pmessage) >= (AR100_MESSAGE_POOL_START + ar100_sram_a2_vbase)) &&
+		(((__u32)pmessage) <  (AR100_MESSAGE_POOL_END   + ar100_sram_a2_vbase))) {
+		//valid message
+		return 1;
+	}
+	return 0;
+}
diff --git a/arch/arm/mach-sun6i/pm/standby/ar100/ar100_hwspinlock.c b/arch/arm/mach-sun6i/pm/standby/ar100/ar100_hwspinlock.c
new file mode 100644
index 0000000..e52be55
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/ar100/ar100_hwspinlock.c
@@ -0,0 +1,98 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/hwspinlock/hwspinlock.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "standby_ar100_i.h"
+
+/*
+*********************************************************************************************************
+*                                       INITIALIZE HWSPINLOCK
+*
+* Description: 	initialize hwspinlock.
+*
+* Arguments  : 	none.
+*
+* Returns    : 	0 if initialize hwspinlock succeeded, others if failed.
+*********************************************************************************************************
+*/
+int ar100_hwspinlock_init(void)
+{
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                       	EXIT HWSPINLOCK
+*
+* Description: 	exit hwspinlock.
+*
+* Arguments  : 	none.
+*
+* Returns    : 	0 if exit hwspinlock succeeded, others if failed.
+*********************************************************************************************************
+*/
+int ar100_hwspinlock_exit(void)
+{
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                       	LOCK HWSPINLOCK WITH TIMEOUT
+*
+* Description:	lock an hwspinlock with timeout limit.
+*
+* Arguments  : 	hwid : an hwspinlock id which we want to lock.
+*
+* Returns    : 	0 if lock hwspinlock succeeded, other if failed.
+*********************************************************************************************************
+*/
+int ar100_hwspin_lock_timeout(int hwid, unsigned int timeout)
+{
+	//try to take spinlock
+	while (readl(IO_ADDRESS(AW_SPINLOCK_LOCK_REG(hwid))) == AW_SPINLOCK_TAKEN) {
+		/*
+		 * The lock is already taken, let's check if the user wants
+		 * us to try again
+		 */
+		 ;
+	}
+
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                       	UNLOCK HWSPINLOCK
+*
+* Description:	unlock a specific hwspinlock.
+*
+* Arguments  : 	hwid : an hwspinlock id which we want to unlock.
+*
+* Returns    : 	0 if unlock hwspinlock succeeded, other if failed.
+*********************************************************************************************************
+*/
+int ar100_hwspin_unlock(int hwid)
+{
+	//untaken the spinlock
+	writel(0x0, IO_ADDRESS(AW_SPINLOCK_LOCK_REG(hwid)));
+
+	return 0;
+}
diff --git a/arch/arm/mach-sun6i/pm/standby/ar100/ar100_message_manager.c b/arch/arm/mach-sun6i/pm/standby/ar100/ar100_message_manager.c
new file mode 100644
index 0000000..901d09a
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/ar100/ar100_message_manager.c
@@ -0,0 +1,132 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/message_manager/message_manager.c
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#include "standby_ar100_i.h"
+
+//the start and end of message pool
+static struct ar100_message *message_start;
+static struct ar100_message *message_end;
+
+/*
+*********************************************************************************************************
+*                                       INIT MESSAGE MANAGER
+*
+* Description: 	initialize message manager.
+*
+* Arguments  : 	none.
+*
+* Returns    : 	0 if initialize succeeded, others if failed.
+*********************************************************************************************************
+*/
+int ar100_message_manager_init(void)
+{
+	//initialize message pool start and end
+	message_start = (struct ar100_message *)(ar100_sram_a2_vbase + AR100_MESSAGE_POOL_START);
+	message_end   = (struct ar100_message *)(ar100_sram_a2_vbase + AR100_MESSAGE_POOL_END);
+
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                       EXIT MESSAGE MANAGER
+*
+* Description: 	exit message manager.
+*
+* Arguments  : 	none.
+*
+* Returns    : 	0 if exit succeeded, others if failed.
+*********************************************************************************************************
+*/
+int ar100_message_manager_exit(void)
+{
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                       ALLOCATE MESSAGE FRAME
+*
+* Description: 	allocate one message frame. mainly use for send message by message-box,
+*			   	the message frame allocate form messages pool shared memory area.
+*
+* Arguments  : 	none.
+*
+* Returns    : 	the pointer of allocated message frame, NULL if failed;
+*********************************************************************************************************
+*/
+struct ar100_message *ar100_message_allocate(unsigned int msg_attr)
+{
+	struct ar100_message *pmessage = NULL;
+	struct ar100_message *palloc   = NULL;
+
+	//use spinlock 0 to exclusive with ar100.
+	ar100_hwspin_lock_timeout(0, AR100_SPINLOCK_TIMEOUT);
+
+	//seach from the start of message pool every time.
+	//maybe have other more good choice.
+	//by sunny at 2012-5-13 10:36:50.
+	pmessage = message_start;
+	while (pmessage < message_end) {
+		if (pmessage->state == AR100_MESSAGE_FREED) {
+			//find free message in message pool, allocate it.
+			palloc = pmessage;
+			palloc->state  = AR100_MESSAGE_ALLOCATED;
+			palloc->next   = 0;
+			AR100_INF("message allocate from message pool\n");
+			break;
+		}
+		//next message frame
+		pmessage++;
+	}
+
+	//unlock hwspinlock 0
+	ar100_hwspin_unlock(0);
+
+	if (palloc == NULL) {
+		AR100_ERR("allocate message frame fail\n");
+	}
+
+	return palloc;
+}
+
+/*
+*********************************************************************************************************
+*                                       FREE MESSAGE FRAME
+*
+* Description: 	free one message frame. mainly use for process message finished,
+*			   	free it to messages pool or add to free message queue.
+*
+* Arguments  : 	pmessage : the pointer of free message frame.
+*
+* Returns    : 	none.
+*********************************************************************************************************
+*/
+void ar100_message_free(struct ar100_message *pmessage)
+{
+	//free to message pool directly.
+	//set message state as FREED.
+	ar100_hwspin_lock_timeout(0, AR100_SPINLOCK_TIMEOUT);
+	pmessage->state = AR100_MESSAGE_FREED;
+	pmessage->next  = NULL;
+	ar100_hwspin_unlock(0);
+}
diff --git a/arch/arm/mach-sun6i/pm/standby/ar100/ar100_messages.h b/arch/arm/mach-sun6i/pm/standby/ar100/ar100_messages.h
new file mode 100644
index 0000000..7f7e8d4
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/ar100/ar100_messages.h
@@ -0,0 +1,88 @@
+/*
+ *  arch/arm/mach-sun6i/ar100/include/ar100_messages.h
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#ifndef	__AR100_MESSAGES_H__
+#define	__AR100_MESSAGES_H__
+
+//message attributes(only use 8bit)
+#define	AR100_MESSAGE_ATTR_SOFTSYN		(1<<0)	//need soft syn with another cpu
+#define	AR100_MESSAGE_ATTR_HARDSYN		(1<<1)	//need hard syn with another cpu
+
+//message states
+#define	AR100_MESSAGE_FREED			(0x0)	//freed state
+#define	AR100_MESSAGE_ALLOCATED		(0x1)	//allocated state
+#define AR100_MESSAGE_INITIALIZED	(0x2)	//initialized state
+#define	AR100_MESSAGE_RECEIVED		(0x3)	//received state
+#define	AR100_MESSAGE_PROCESSING	(0x4)	//processing state
+#define	AR100_MESSAGE_PROCESSED		(0x5)	//processed state
+#define	AR100_MESSAGE_FEEDBACKED	(0x6)	//feedback state
+
+typedef int (*ar100_cb_t)(void *arg);
+
+/* call back struct */
+typedef struct ar100_msg_cb
+{
+	ar100_cb_t   handler;
+	void        *arg;
+} ar100_msg_cb_t;
+
+//the structure of message frame,
+//this structure will transfer between ar100 and ac327.
+//sizeof(struct message) : 32Byte.
+typedef struct ar100_message
+{
+	volatile unsigned char   		 state;		/* identify the used status of message frame */
+	volatile unsigned char   		 attr;		/* message attribute : SYN OR ASYN           */
+	volatile unsigned char   		 type;		/* message type : DVFS_REQ                   */
+	volatile unsigned char   		 result;	/* message process result                    */
+	volatile struct ar100_message	*next;		/* pointer of next message frame             */
+	volatile struct ar100_msg_cb		 cb;		/* the callback function and arg of message  */
+	volatile void    	   			*private;	/* message private data                      */
+	volatile unsigned int   			 paras[11];	/* the parameters of message                 */
+} ar100_message_t;
+
+//the base of messages
+#define	AR100_MESSAGE_BASE	(0x10)
+
+//standby commands
+#define	AR100_SSTANDBY_ENTER_REQ	 	(AR100_MESSAGE_BASE + 0x00)  //request to enter(ac327 to ar100)
+#define	AR100_SSTANDBY_RESTORE_NOTIFY   (AR100_MESSAGE_BASE + 0x01)  //restore finished(ac327 to ar100)
+#define	AR100_NSTANDBY_ENTER_REQ	 	(AR100_MESSAGE_BASE + 0x02)  //request to enter(ac327 to ar100)
+#define	AR100_NSTANDBY_WAKEUP_NOTIFY    (AR100_MESSAGE_BASE + 0x03)  //wakeup notify   (ar100 to ac327)
+#define	AR100_NSTANDBY_RESTORE_REQ      (AR100_MESSAGE_BASE + 0x04)  //request to restore    (ac327 to ar100)
+#define	AR100_NSTANDBY_RESTORE_COMPLETE (AR100_MESSAGE_BASE + 0x05)  //ar100 restore complete(ar100 to ac327)
+
+//dvfs commands
+#define	AR100_CPUX_DVFS_REQ		 	(AR100_MESSAGE_BASE + 0x20)  //request dvfs    (ac327 to ar100)
+
+//pmu commands
+#define	AR100_AXP_POWEROFF_REQ	 	(AR100_MESSAGE_BASE + 0x40)  //request power-off(ac327 to ar100)
+#define	AR100_AXP_READ_REGS		 	(AR100_MESSAGE_BASE + 0x41)  //read registers	(ac327 to ar100)
+#define	AR100_AXP_WRITE_REGS		(AR100_MESSAGE_BASE + 0x42)  //write registers  (ac327 to ar100)
+#define AR100_AXP_SET_BATTERY		(AR100_MESSAGE_BASE + 0x43)  //set battery 		(ac327 to ar100)
+#define AR100_AXP_GET_BATTERY		(AR100_MESSAGE_BASE + 0x44)  //get battery 		(ac327 to ar100)
+#define AR100_AXP_INT_COMING_NOTIFY (AR100_MESSAGE_BASE + 0x45)  //interrupt coming notify(ar100 to ac327)
+
+//ar100 initialize state notify commands
+#define AR100_STARTUP_NOTIFY	 	(AR100_MESSAGE_BASE + 0x80)  //ar100 init state notify(ar100 to ac327)
+
+#endif	//__AR100_MESSAGES_H__
diff --git a/arch/arm/mach-sun6i/pm/standby/ar100/standby_ar100.c b/arch/arm/mach-sun6i/pm/standby/ar100/standby_ar100.c
new file mode 100644
index 0000000..12c839b
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/ar100/standby_ar100.c
@@ -0,0 +1,238 @@
+/*
+ * arch/arm/mach-sun6i/include/mach/ar100.h
+ *
+ * Copyright 2012 (c) Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include "standby_ar100_i.h"
+
+//sram a2 virtual base address
+unsigned long ar100_sram_a2_vbase = (unsigned long)IO_ADDRESS(AW_SRAM_A2_BASE);
+
+//record wakeup event information
+static unsigned long wakeup_event;
+
+//record restore status information
+static unsigned long restore_completed;
+
+int standby_ar100_init(void)
+{
+	//initialize wakeup_event as invalid
+	wakeup_event = 0;
+
+	//initialize restore as uncompleted
+	restore_completed = 0;
+
+	//initialize hwspinlock
+	ar100_hwspinlock_init();
+
+	//initialize hwmsgbox
+	ar100_hwmsgbox_init();
+
+	//initialize message manager
+	ar100_message_manager_init();
+
+	return 0;
+}
+
+int standby_ar100_exit(void)
+{
+	//exit message manager
+	ar100_message_manager_exit();
+
+	//exit hwmsgbox
+	ar100_hwmsgbox_exit();
+
+	//exit hwspinlock
+	ar100_hwspinlock_exit();
+
+	restore_completed = 0;
+
+	wakeup_event = 0;
+
+	return 0;
+}
+
+/*
+ * standby_ar100_notify_restore:
+ * function: notify ar100 to wakeup: restore cpus freq, volt, and init_dram.
+ * para:  mode.
+ * STANDBY_AR100_SYNC:
+ * STANDBY_AR100_ASYNC:
+ * return: result, 0 - notify successed, !0 - notify failed;
+ */
+int standby_ar100_notify_restore(unsigned long mode)
+{
+	struct ar100_message *pmessage;
+	unsigned char         attr;
+
+	//allocate a message frame
+	pmessage = ar100_message_allocate(0);
+	if (pmessage == NULL) {
+		AR100_ERR("allocate message for normal-standby notify restore failed\n");
+		return -ENOMEM;
+	}
+	//initialize message attributes
+	attr = 0;
+	if (mode & STANDBY_AR100_SYNC) {
+		attr |= AR100_MESSAGE_ATTR_HARDSYN;
+	}
+	//initialize message
+	pmessage->type     = AR100_NSTANDBY_RESTORE_REQ;
+	pmessage->attr     = attr;
+	pmessage->state    = AR100_MESSAGE_INITIALIZED;
+
+	//send enter normal-standby restore request to ar100
+	ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+
+	//syn message must free message frame by self.
+	if (mode & STANDBY_AR100_SYNC) {
+		ar100_message_free(pmessage);
+	}
+	return 0;
+}
+
+/*
+ * standby_ar100_check_restore_status
+ * function: check ar100 restore status.
+ * para:  none.
+ * return: result, 0 - restore completion successed, !0 - notify failed;
+ */
+int standby_ar100_check_restore_status(void)
+{
+	struct ar100_message *pmessage;
+
+	//check restore completion flag first
+	if (restore_completed) {
+		//ar100 restore completion already.
+		return 0;
+	}
+	//try ot query message for hwmsgbox
+	pmessage = ar100_hwmsgbox_query_message();
+	if (pmessage == NULL) {
+		//no valid message
+		return -EINVAL;
+	}
+	if (pmessage->type == AR100_NSTANDBY_RESTORE_COMPLETE) {
+		//restore complete message received
+		pmessage->state = AR100_MESSAGE_PROCESSED;
+		if ((pmessage->attr & AR100_MESSAGE_ATTR_SOFTSYN) ||
+			(pmessage->attr & AR100_MESSAGE_ATTR_HARDSYN)) {
+			//synchronous message, should feedback process result.
+			ar100_hwmsgbox_feedback_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+		} else {
+			//asyn message, no need feedback message result,
+			//free message directly.
+			ar100_message_free(pmessage);
+		}
+		//ar100 restore completion
+		restore_completed = 1;
+		return 0;
+	} else {
+		AR100_ERR("invalid message received when check restore status\n");
+		return -EINVAL;
+	}
+
+	//not received restore completion
+	return -EINVAL;
+}
+
+/*
+ * standby_ar100_query_wakeup_src
+ * function: query standby wakeup source.
+ * para:  point of buffer to store wakeup event informations.
+ * return: result, 0 - query successed, !0 - query failed;
+ */
+int standby_ar100_query_wakeup_src(unsigned long *event)
+{
+	struct ar100_message *pmessage;
+
+	//check parameter valid or not
+	if (event == NULL) {
+		AR100_WRN("invalid buffer to query wakeup source\n");
+		return -EINVAL;
+	}
+
+	//check wakeup event received first
+	if (wakeup_event) {
+		//ar100 wakeup event received already.
+		*event = wakeup_event;
+		return 0;
+	}
+	//try ot query message for hwmsgbox
+	pmessage = ar100_hwmsgbox_query_message();
+	if (pmessage == NULL) {
+		//no valid message
+		return -EINVAL;
+	}
+	if (pmessage->type == AR100_NSTANDBY_WAKEUP_NOTIFY) {
+		//wakeup notify message received
+		wakeup_event = pmessage->paras[0];
+		pmessage->state = AR100_MESSAGE_PROCESSED;
+		if ((pmessage->attr & AR100_MESSAGE_ATTR_SOFTSYN) ||
+			(pmessage->attr & AR100_MESSAGE_ATTR_HARDSYN)) {
+			//synchronous message, should feedback process result.
+			ar100_hwmsgbox_feedback_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+		} else {
+			//asyn message, no need feedback message result,
+			//free message directly.
+			ar100_message_free(pmessage);
+		}
+		//ar100 wakeup_event valid
+		AR100_INF("standby wakeup source : 0x%x\n", (unsigned int)wakeup_event);
+		*event = wakeup_event;
+		return 0;
+	} else {
+		AR100_ERR("invalid message received when check restore status\n");
+		return -EINVAL;
+	}
+	//not received wakup event
+	return -EINVAL;
+}
+
+/*
+ * standby_ar100_standby_normal
+ * function: enter normal standby.
+ * para:  parameter for enter normal standby.
+ * return: result, 0 - normal standby successed, !0 - normal standby failed;
+ */
+int standby_ar100_standby_normal(struct normal_standby_para *para)
+{
+	struct ar100_message *pmessage;
+	int result = 0;
+
+	//allocate a message frame
+	pmessage = ar100_message_allocate(0);
+	if (pmessage == NULL) {
+		AR100_ERR("allocate message for normal-standby request failed\n");
+		return -ENOMEM;
+	}
+
+	//check normal_standby_para size valid or not
+	if (sizeof(struct normal_standby_para) > sizeof(pmessage->paras)) {
+		AR100_ERR("normal-standby parameters number too long\n");
+		return -EINVAL;
+	}
+	//initialize message
+	pmessage->type     = AR100_NSTANDBY_ENTER_REQ;
+	//pmessage->attr     = AR100_MESSAGE_ATTR_HARDSYN;
+	pmessage->attr       = 0;
+	standby_memcpy(pmessage->paras, para, sizeof(struct normal_standby_para));
+	pmessage->state    = AR100_MESSAGE_INITIALIZED;
+
+	//send enter normal-standby request to ar100
+	ar100_hwmsgbox_send_message(pmessage, AR100_SEND_MSG_TIMEOUT);
+
+	result = (int)(pmessage->result);
+	//syn message, free it after feedbacked.
+        ar100_message_free(pmessage);
+
+	return result;
+}
diff --git a/arch/arm/mach-sun6i/pm/standby/ar100/standby_ar100_i.h b/arch/arm/mach-sun6i/pm/standby/ar100/standby_ar100_i.h
new file mode 100644
index 0000000..1c33149
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/ar100/standby_ar100_i.h
@@ -0,0 +1,57 @@
+/*
+ *  arch/arm/mach-sun6i/pm/standby/ar100/standby_ar100_i.h
+ *
+ * Copyright (c) 2012 Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__STANDBY_AR100_I_H__
+#define	__STANDBY_AR100_I_H__
+
+#include <linux/power/aw_pm.h>
+#include <mach/platform.h>
+#include <mach/hwmsgbox.h>
+#include <mach/hwspinlock.h>
+#include "ar100_cfgs.h"
+#include "ar100_messages.h"
+#include "ar100_dbgs.h"
+#include "standby_ar100.h"
+#include "standby_i.h"
+#include "asm-generic/errno-base.h"
+
+extern unsigned long ar100_sram_a2_vbase;
+
+//hwspinlock interfaces
+int ar100_hwspinlock_init(void);
+int ar100_hwspinlock_exit(void);
+int ar100_hwspin_lock_timeout(int hwid, unsigned int timeout);
+int ar100_hwspin_unlock(int hwid);
+
+//hwmsgbox interfaces
+int ar100_hwmsgbox_init(void);
+int ar100_hwmsgbox_exit(void);
+int ar100_hwmsgbox_send_message(struct ar100_message *pmessage, unsigned int timeout);
+int ar100_hwmsgbox_feedback_message(struct ar100_message *pmessage, unsigned int timeout);
+struct ar100_message *ar100_hwmsgbox_query_message(void);
+
+//message manager interfaces
+int ar100_message_manager_init(void);
+int ar100_message_manager_exit(void);
+struct ar100_message *ar100_message_allocate(unsigned int msg_attr);
+void ar100_message_free(struct ar100_message *pmessage);
+
+#endif	//__STANDBY_AR100_I_H__
diff --git a/arch/arm/mach-sun6i/pm/standby/common.c b/arch/arm/mach-sun6i/pm/standby/common.c
new file mode 100644
index 0000000..b40901f
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/common.c
@@ -0,0 +1,70 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : common.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-30 19:38
+* Descript: common lib for standby
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#include "standby_i.h"
+
+
+/*
+*********************************************************************************************************
+*                           standby_memcpy
+*
+*Description: memory copy function for standby.
+*
+*Arguments  :
+*
+*Return     :
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void standby_memcpy(void *dest, void *src, int n)
+{
+    char    *tmp_src = (char *)src;
+    char    *tmp_dst = (char *)dest;
+
+    if(!dest || !src){
+        /* parameter is invalid */
+        return;
+    }
+
+    for( ; n > 0; n--){
+        *tmp_dst ++ = *tmp_src ++;
+    }
+
+    return;
+}
+
+
+/*
+*********************************************************************************************************
+*                           mdelay
+*
+*Description: mdelay function
+*
+*Arguments  :
+*
+*Return     :
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void standby_mdelay(int ms)
+{
+    standby_delay(ms * cpu_ms_loopcnt);
+}
diff --git a/arch/arm/mach-sun6i/pm/standby/common.h b/arch/arm/mach-sun6i/pm/standby/common.h
new file mode 100644
index 0000000..458fbf3
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/common.h
@@ -0,0 +1,66 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : common.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-30 17:21
+* Descript: common lib for standby.
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __COMMON_H__
+#define __COMMON_H__
+
+
+
+static inline __u64 standby_uldiv(__u64 dividend, __u32 divisior)
+{
+    __u64   tmpDiv = (__u64)divisior;
+    __u64   tmpQuot = 0;
+    __s32   shift = 0;
+
+    if(!divisior)
+    {
+        /* divide 0 error abort */
+        return 0;
+    }
+
+    while(!(tmpDiv & ((__u64)1<<63)))
+    {
+        tmpDiv <<= 1;
+        shift ++;
+    }
+
+    do
+    {
+        if(dividend >= tmpDiv)
+        {
+            dividend -= tmpDiv;
+            tmpQuot = (tmpQuot << 1) | 1;
+        }
+        else
+        {
+            tmpQuot = (tmpQuot << 1) | 0;
+        }
+        tmpDiv >>= 1;
+        shift --;
+    } while(shift >= 0);
+
+    return tmpQuot;
+}
+
+
+
+void standby_memcpy(void *dest, void *src, int n);
+void standby_mdelay(int ms);
+void standby_delay(int cycle);
+void standby_delay_cycle(int cycle);
+
+#endif  //__COMMON_H__
diff --git a/arch/arm/mach-sun6i/pm/standby/gen_check_code b/arch/arm/mach-sun6i/pm/standby/gen_check_code
new file mode 100644
index 0000000..84899b7
Binary files /dev/null and b/arch/arm/mach-sun6i/pm/standby/gen_check_code differ
diff --git a/arch/arm/mach-sun6i/pm/standby/gen_check_code.exe b/arch/arm/mach-sun6i/pm/standby/gen_check_code.exe
new file mode 100644
index 0000000..dd5328e
Binary files /dev/null and b/arch/arm/mach-sun6i/pm/standby/gen_check_code.exe differ
diff --git a/arch/arm/mach-sun6i/pm/standby/makefile.bat b/arch/arm/mach-sun6i/pm/standby/makefile.bat
new file mode 100644
index 0000000..b8bacfe
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/makefile.bat
@@ -0,0 +1,8 @@
+@echo
+@echo on
+copy .\resume0.bin .\super\resume\resume0.code
+gen_check_code.exe .\super\resume\resume0.code .\super\resume\resume0.code.tmp
+copy .\super\resume\resume0.code.tmp .\super\resume\resume0.code
+echo done!
+pause
+@echo Finished!
diff --git a/arch/arm/mach-sun6i/pm/standby/resume1_scatter.scat b/arch/arm/mach-sun6i/pm/standby/resume1_scatter.scat
new file mode 100644
index 0000000..d35a9a3
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/resume1_scatter.scat
@@ -0,0 +1,56 @@
+;/*
+;************************************************************************************************************************
+;*                                                         eGON
+;*                                         the Embedded GO-ON Bootloader System
+;*
+;*                             Copyright(C), 2006-2008, SoftWinners Microelectronic Co., Ltd.
+;*											       All Rights Reserved
+;*
+;* File Name : resume0_scatter.sct
+;*
+;* Author : Gary.Wang
+;*
+;* Version : 1.1.0
+;*
+;* Date : 2007.11.6
+;*
+;* Description : scatter file of resume0
+;*
+;* Functions list :
+;*
+;* Others : None at present.
+;*
+;*
+;* History :
+;*
+;*  <Author>        <time>       <version>      <description>
+;*
+;* Gary.Wang       2007.11.6       1.1.0        build the file
+;*
+;************************************************************************************************************************
+;*/
+
+
+;/*---------------------------------------------------------------------------*/
+;/*                          --+++-- NOTE --+++--                             */
+;/*             RW and ZI datas MUST NOT appear in Resume project!              */
+;/*---------------------------------------------------------------------------*/
+OUTPUT_ARCH(arm)
+ENTRY(main)
+
+SECTIONS
+{
+	__resume1_start = . ;
+	.text  0x00000000:
+	{	./super/resume/resume_head.o( .rodata )
+		./super/resume/resume1.o( .text )
+		*(.text)
+	}
+	.rodata : { *(.rodata) }
+	.data   : { *(.data) }
+
+	__bss_start = . ;
+	.bss : { *(.sbss) *(.scommon) *(.bss) *(COMMON) }
+	__bss_end = .;
+	__resume1_end = . ;
+}
diff --git a/arch/arm/mach-sun6i/pm/standby/standby.c b/arch/arm/mach-sun6i/pm/standby/standby.c
new file mode 100644
index 0000000..aa5c481
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby.c
@@ -0,0 +1,365 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-30 18:34
+* Descript: platform standby fucntion.
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#include "standby_i.h"
+
+static void restore_ccu(void);
+static void backup_ccu(void);
+static void destory_mmu(void);
+static void restore_mmu(void);
+static void cache_count_init(void);
+static void cache_count_get(void);
+static void cache_count_output(void);
+
+extern char *__bss_start;
+extern char *__bss_end;
+extern char *__standby_start;
+extern char *__standby_end;
+
+static __u32 sp_backup;
+static __u32 ttb_0r_backup = 0;
+#define MMU_START	(0xc0004000)
+#define MMU_END 	(0xc0007ffc) //reserve 0xffff0000 range.
+__u32 mmu_backup[(MMU_END - MMU_START)>>2 + 1];
+
+static void standby(void);
+
+#ifdef CHECK_CACHE_TLB_MISS
+int d_cache_miss_start	= 0;
+int d_tlb_miss_start	= 0;
+int i_tlb_miss_start	= 0;
+int i_cache_miss_start	= 0;
+int d_cache_miss_end	= 0;
+int d_tlb_miss_end	= 0;
+int i_tlb_miss_end	= 0;
+int i_cache_miss_end	= 0;
+#endif
+
+
+/* parameter for standby, it will be transfered from sys_pwm module */
+struct aw_pm_info  pm_info;
+struct normal_standby_para normal_standby_para_info;
+
+/*
+*********************************************************************************************************
+*                                   STANDBY MAIN PROCESS ENTRY
+*
+* Description: standby main process entry.
+*
+* Arguments  : arg  pointer to the parameter that transfered from sys_pwm module.
+*
+* Returns    : none
+*
+* Note       : the code&data may resident in cache.
+*********************************************************************************************************
+*/
+int main(struct aw_pm_info *arg)
+{
+	char    *tmpPtr = (char *)&__bss_start;
+
+	serial_init();
+	if(!arg){
+		/* standby parameter is invalid */
+		return -1;
+	}
+
+	/* flush data and instruction tlb, there is 32 items of data tlb and 32 items of instruction tlb,
+	The TLB is normally allocated on a rotating basis. The oldest entry is always the next allocated */
+	mem_flush_tlb();
+
+	/* clear bss segment */
+	do{*tmpPtr ++ = 0;}while(tmpPtr <= (char *)&__bss_end);
+
+	/* save stack pointer registger, switch stack to sram */
+	sp_backup = save_sp();
+
+	/* copy standby parameter from dram */
+	standby_memcpy(&pm_info, arg, sizeof(pm_info));
+
+	/* preload tlb for standby */
+	mem_preload_tlb();
+
+	/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
+	/* init module before dram enter selfrefresh */
+	/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
+
+	/* initialise standby modules */
+	standby_ar100_init();
+	standby_clk_init();
+	mem_tmr_init();
+
+	if(unlikely(pm_info.standby_para.debug_mask&PM_STANDBY_PRINT_STANDBY)){
+		//don't need init serial ,depend kernel?
+		serial_init();
+		printk("pm_info.standby_para.event = 0x%x. \n", pm_info.standby_para.event);
+	}
+
+	/* init some system wake source */
+	if(pm_info.standby_para.event & CPU0_WAKEUP_MSGBOX){
+		if(unlikely(pm_info.standby_para.debug_mask&PM_STANDBY_PRINT_STANDBY)){
+			printk("enable CPU0_WAKEUP_MSGBOX. \n");
+		}
+		mem_enable_int(INT_SOURCE_MSG_BOX);
+	}
+	if(pm_info.standby_para.event & CPU0_WAKEUP_KEY){
+		standby_key_init();
+		mem_enable_int(INT_SOURCE_LRADC);
+	}
+
+	/* process standby */
+	if(unlikely(pm_info.standby_para.debug_mask&PM_STANDBY_PRINT_CACHE_TLB_MISS)){
+		cache_count_init();
+	}
+
+	//busy_waiting();
+	standby();
+
+	/* check system wakeup event */
+	pm_info.standby_para.event = 0;
+	//actually, msg_box int will be clear by ar100-driver.
+	pm_info.standby_para.event |= mem_query_int(INT_SOURCE_MSG_BOX)? 0:CPU0_WAKEUP_MSGBOX;
+	pm_info.standby_para.event |= mem_query_int(INT_SOURCE_LRADC)? 0:CPU0_WAKEUP_KEY;
+
+	//restore intc config.
+	if(pm_info.standby_para.event & CPU0_WAKEUP_KEY){
+		standby_key_exit();
+	}
+
+	/*check completion status: only after restore completion, access dram is allowed. */
+	while(standby_ar100_check_restore_status()){
+		if(unlikely(pm_info.standby_para.debug_mask&PM_STANDBY_PRINT_STANDBY)){
+			printk("0xf1c20050 value: 0x%x. \n", *((volatile unsigned int *)0xf1c20050));
+			printk("0xf1c20000 value: 0x%x. \n", *((volatile unsigned int *)0xf1c20000));
+		}
+		;
+	}
+
+	if(unlikely(pm_info.standby_para.debug_mask&PM_STANDBY_PRINT_CACHE_TLB_MISS)){
+		cache_count_get();
+		if(d_cache_miss_end || d_tlb_miss_end || i_tlb_miss_end || i_cache_miss_end){
+		printk("=============================NOTICE====================================. \n");
+		cache_count_output();
+		}else{
+			printk("no miss. \n");
+			//cache_count_output();
+		}
+	}
+
+	/* disable watch-dog */
+	mem_tmr_disable_watchdog();
+	if(unlikely(pm_info.standby_para.debug_mask&PM_STANDBY_PRINT_STANDBY)){
+		printk("after mem_tmr_disable_watchdog. \n");
+	}
+
+	/* exit standby module */
+	mem_tmr_exit();
+	standby_clk_exit();
+	standby_ar100_exit();
+
+	if(unlikely(pm_info.standby_para.debug_mask&PM_STANDBY_PRINT_STANDBY)){
+		printk("after standby_ar100_exit. \n");
+	}
+	/* restore stack pointer register, switch stack back to dram */
+	restore_sp(sp_backup);
+
+	if(unlikely(pm_info.standby_para.debug_mask&PM_STANDBY_PRINT_STANDBY)){
+		printk("after restore_sp. \n");
+	}
+
+	/* report which wake source wakeup system */
+	arg->standby_para.event = pm_info.standby_para.event;
+	arg->standby_para.axp_event = pm_info.standby_para.axp_event;
+
+	//enable_cache();
+
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                     SYSTEM PWM ENTER STANDBY MODE
+*
+* Description: enter standby mode.
+*
+* Arguments  : none
+*
+* Returns    : none;
+*********************************************************************************************************
+*/
+static void standby(void)
+{
+	/*backup clk freq and voltage*/
+	backup_ccu();
+
+	/*notify ar100 enter normal standby*/
+	normal_standby_para_info.event = pm_info.standby_para.axp_event;
+	normal_standby_para_info.timeout = pm_info.standby_para.timeout;
+	normal_standby_para_info.gpio_enable_bitmap = pm_info.standby_para.gpio_enable_bitmap;
+
+
+	standby_ar100_standby_normal((&normal_standby_para_info));
+
+	/* cpu enter sleep, wait wakeup by interrupt */
+	asm("WFI");
+
+	/*restore cpu0 ccu: enable hosc and change to 24M. */
+	restore_ccu();
+
+	/*query wakeup src*/
+	standby_ar100_query_wakeup_src((unsigned long *)&(pm_info.standby_para.axp_event));
+	/* enable watch-dog to prevent in case dram training failed */
+	mem_tmr_enable_watchdog();
+
+	/* notify for cpus to: restore cpus freq and volt, restore dram */
+	standby_ar100_notify_restore(STANDBY_AR100_ASYNC);
+
+	return;
+}
+
+static void backup_ccu(void)
+{
+	return;
+}
+
+/*change clk src to hosc*/
+static void restore_ccu(void)
+{
+
+#if(ALLOW_DISABLE_HOSC)
+		/* enable LDO, ldo1, enable HOSC */
+		standby_clk_ldoenable();
+		standby_clk_pll1enable();
+		/* delay 10ms for power be stable */
+		standby_delay_cycle(1); //?ms
+		//switch to 24M src
+		standby_clk_core2hosc();
+#endif
+
+		return;
+}
+
+/*
+*********************************************************************************************************
+*                                    destory_mmu
+*
+* Description: to destory the mmu mapping, so, the tlb miss will result in an data/cache abort
+*              while not accessing dram.
+* Arguments  : none
+*
+* Returns    : none;
+*********************************************************************************************************
+*/
+static void destory_mmu(void)
+{
+	__u32 ttb_1r = 0;
+	int i = 0;
+	volatile  __u32 * p_mmu = (volatile  __u32 *)MMU_START;
+
+	for(p_mmu = (volatile  __u32 *)MMU_START; p_mmu < (volatile  __u32 *)MMU_END; p_mmu++, i++)
+	{
+		mmu_backup[i] = *p_mmu;
+		*p_mmu = 0;
+	}
+	flush_dcache();
+
+	//u need to set ttbr0 to 0xc0004000?
+	//backup
+	asm volatile ("mrc p15, 0, %0, c2, c0, 0" : "=r"(ttb_0r_backup));
+	//get ttbr1
+	asm volatile ("mrc p15, 0, %0, c2, c0, 1" : "=r"(ttb_1r));
+	//use ttbr1 to set ttbr0
+	asm volatile ("mcr p15, 0, %0, c2, c0, 0" : : "r"(ttb_1r));
+	asm volatile ("dsb");
+	asm volatile ("isb");
+
+	return;
+}
+
+static void restore_mmu(void)
+{
+	volatile  __u32 * p_mmu = (volatile  __u32 *)MMU_START;
+	int i = 0;
+
+	//restore ttbr0
+	asm volatile ("mcr p15, 0, %0, c2, c0, 0" : : "r"(ttb_0r_backup));
+	asm volatile ("dsb");
+	asm volatile ("isb");
+
+	for(p_mmu = (volatile  __u32 *)MMU_START; p_mmu < (volatile  __u32 *)MMU_END; p_mmu++, i++)
+	{
+			*p_mmu = mmu_backup[i];
+	}
+
+	flush_dcache();
+	return;
+}
+
+#ifdef CHECK_CACHE_TLB_MISS
+
+static void cache_count_init(void)
+{
+	set_event_counter(D_CACHE_MISS);
+	set_event_counter(D_TLB_MISS);
+	set_event_counter(I_CACHE_MISS);
+	set_event_counter(I_TLB_MISS);
+	init_event_counter(1, 0);
+	d_cache_miss_start = get_event_counter(D_CACHE_MISS);
+	d_tlb_miss_start = get_event_counter(D_TLB_MISS);
+	i_tlb_miss_start = get_event_counter(I_TLB_MISS);
+	i_cache_miss_start = get_event_counter(I_CACHE_MISS);
+
+	return;
+}
+
+static void cache_count_get(void)
+{
+	d_cache_miss_end = get_event_counter(D_CACHE_MISS);
+	d_tlb_miss_end = get_event_counter(D_TLB_MISS);
+	i_tlb_miss_end = get_event_counter(I_TLB_MISS);
+	i_cache_miss_end = get_event_counter(I_CACHE_MISS);
+
+	return;
+}
+
+static void cache_count_output(void)
+{
+	printk("d_cache_miss_start = %d, d_cache_miss_end= %d. \n", d_cache_miss_start, d_cache_miss_end);
+	printk("d_tlb_miss_start = %d, d_tlb_miss_end= %d. \n", d_tlb_miss_start, d_tlb_miss_end);
+	printk("i_cache_miss_start = %d, i_cache_miss_end= %d. \n", i_cache_miss_start, i_cache_miss_end);
+	printk("i_tlb_miss_start = %d, i_tlb_miss_end= %d. \n", i_tlb_miss_start, i_tlb_miss_end);
+
+	return;
+}
+
+#else
+static void cache_count_init(void)
+{
+	return;
+}
+
+static void cache_count_get(void)
+{
+	return;
+}
+
+static void cache_count_output(void)
+{
+	return;
+}
+
+
+#endif
diff --git a/arch/arm/mach-sun6i/pm/standby/standby.xn b/arch/arm/mach-sun6i/pm/standby/standby.xn
new file mode 100644
index 0000000..1fa80cd
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby.xn
@@ -0,0 +1,20 @@
+
+OUTPUT_ARCH(arm)
+ENTRY(main)
+
+SECTIONS
+{
+	__standby_start = . ;
+	.text 0xf0000000 :
+	{
+		standby.o(.text.startup)
+		*(.text)
+		*(.rodata)
+	}
+
+	.data   : { *(.data) }
+	__bss_start = . ;
+	.bss : { *(.sbss) *(.scommon) *(.bss) *(COMMON) }
+	__bss_end = .;
+	__standby_end = . ;
+}
diff --git a/arch/arm/mach-sun6i/pm/standby/standby_ar100.h b/arch/arm/mach-sun6i/pm/standby/standby_ar100.h
new file mode 100644
index 0000000..e1f2714
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby_ar100.h
@@ -0,0 +1,52 @@
+/*
+ * arch/arm/mach-sun6i/pm/standby/standby_ar100.h
+ *
+ * Copyright 2012 (c) Allwinner.
+ * sunny (sunny@allwinnertech.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef	__ASM_ARCH_STANDBY_A100_H
+#define	__ASM_ARCH_STANDBY_A100_H
+
+//the sync mode between ar100 and ac327
+#define STANDBY_AR100_SYNC (1<<1)
+#define STANDBY_AR100_ASYNC (1<<2)
+
+ int standby_ar100_init(void);
+ int standby_ar100_exit(void);
+
+/*
+ * notify ar100 to wakeup: restore cpus freq, volt, and init_dram.
+ * para:  mode.
+ * STANDBY_AR100_SYNC:
+ * STANDBY_AR100_ASYNC:
+ * return: result, 0 - notify successed, !0 - notify failed;
+ */
+int standby_ar100_notify_restore(unsigned long mode);
+/*
+ * check ar100 restore status.
+ * para:  none.
+ * return: result, 0 - restore completion successed, !0 - notify failed;
+ */
+int standby_ar100_check_restore_status(void);
+/*
+ * query standby wakeup source.
+ * para:  point of buffer to store wakeup event informations.
+ * return: result, 0 - query successed, !0 - query failed;
+ */
+int standby_ar100_query_wakeup_src(unsigned long *event);
+/*
+ * enter normal standby.
+ * para:  parameter for enter normal standby.
+ * return: result, 0 - normal standby successed, !0 - normal standby failed;
+ */
+int standby_ar100_standby_normal(struct normal_standby_para *para);
+
+
+#endif	//__ASM_ARCH_STANDBY_A100_H
diff --git a/arch/arm/mach-sun6i/pm/standby/standby_cfg.h b/arch/arm/mach-sun6i/pm/standby/standby_cfg.h
new file mode 100644
index 0000000..83e5475
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby_cfg.h
@@ -0,0 +1,35 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_cfg.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 14:29
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __STANDBY_CFG_H__
+#define __STANDBY_CFG_H__
+
+
+//config wakeup source for standby
+#define ALLOW_DISABLE_HOSC          (1)     // if allow disable hosc
+
+#define STANDBY_LDO1_VOL            (1300)  //LDO1 voltage value
+#define STANDBY_LDO2_VOL            (3000)  //LDO2 voltage value
+#define STANDBY_LDO3_VOL            (2800)  //LDO3 voltage value
+#define STANDBY_LDO4_VOL            (3300)  //LDO4 voltage value
+#define STANDBY_DCDC2_VOL           (700)   //DCDC2 voltage value
+#define STANDBY_DCDC3_VOL           (1000)  //DCDC3 voltage value
+
+#define CHECK_CACHE_TLB_MISS
+//#undef CHECK_CACHE_TLB_MISS
+
+#endif  /* __STANDBY_CFG_H__ */
diff --git a/arch/arm/mach-sun6i/pm/standby/standby_clock.c b/arch/arm/mach-sun6i/pm/standby/standby_clock.c
new file mode 100644
index 0000000..06f4aa0
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby_clock.c
@@ -0,0 +1,147 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_clock.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 13:40
+* Descript: ccmu process for platform standby;
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+
+#include "standby_i.h"
+
+#define readb(addr)		(*((volatile unsigned char  *)(addr)))
+#define readw(addr)		(*((volatile unsigned short *)(addr)))
+#define readl(addr)		(*((volatile unsigned long  *)(addr)))
+#define writeb(v, addr)	(*((volatile unsigned char  *)(addr)) = (unsigned char)(v))
+#define writew(v, addr)	(*((volatile unsigned short *)(addr)) = (unsigned short)(v))
+#define writel(v, addr)	(*((volatile unsigned long  *)(addr)) = (unsigned long)(v))
+
+static void *r_prcm;
+static __ccmu_reg_list_t   *CmuReg;
+__u32   cpu_ms_loopcnt;
+
+//==============================================================================
+// CLOCK SET FOR SYSTEM STANDBY
+//==============================================================================
+
+
+
+
+/*
+*********************************************************************************************************
+*                           standby_clk_init
+*
+*Description: ccu init for platform standby
+*
+*Arguments  : none
+*
+*Return     : result,
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 standby_clk_init(void)
+{
+    r_prcm = (void *)IO_ADDRESS(AW_R_PRCM_BASE);
+    CmuReg = (__ccmu_reg_list_t   *)IO_ADDRESS(AW_CCM_BASE);
+
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_clk_exit
+*
+*Description: ccu exit for platform standby
+*
+*Arguments  : none
+*
+*Return     : result,
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 standby_clk_exit(void)
+{
+
+    return 0;
+}
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_core2hosc
+*
+* Description: switch core clock to 24M high osc.
+*
+* Arguments  : none
+*
+*********************************************************************************************************
+*/
+void standby_clk_core2hosc(void)
+{
+	CmuReg->SysClkDiv.CpuClkSrc = 1;
+	return ;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_ldoenable
+*
+* Description: enable LDO, ld01, hosc.
+*
+* Arguments  : none
+*
+*********************************************************************************************************
+*/
+void standby_clk_ldoenable(void)
+{
+	//cpus power domain, offset 0x44, how to enable?
+	__u32 tmp;
+	tmp = readl(r_prcm + PLL_CTRL_REG1_OFFSET );
+	tmp &= ~(0xff000000);
+	tmp |= (0xa7000000);
+	writel(tmp, r_prcm + PLL_CTRL_REG1_OFFSET);
+
+	//enalbe ldo, ldo1,crystal
+	tmp = readl(r_prcm + PLL_CTRL_REG1_OFFSET );
+	tmp &= ~(0x00000007);
+	tmp |= (0x00000007);
+	writel(tmp, r_prcm + PLL_CTRL_REG1_OFFSET);
+
+	//disable change.
+	tmp = readl(r_prcm + PLL_CTRL_REG1_OFFSET );
+	tmp &= ~(0xff000000);
+	writel(tmp, r_prcm + PLL_CTRL_REG1_OFFSET);
+
+	return ;
+}
+
+/*
+*********************************************************************************************************
+*                                     standby_clk_pll1enable
+*
+* Description: enable pll1.
+*
+* Arguments  : none
+*
+*********************************************************************************************************
+*/
+void standby_clk_pll1enable()
+{
+	CmuReg->Pll1Ctl.PLLEn = 1;
+	return ;
+}
\ No newline at end of file
diff --git a/arch/arm/mach-sun6i/pm/standby/standby_clock.h b/arch/arm/mach-sun6i/pm/standby/standby_clock.h
new file mode 100644
index 0000000..f55e25d
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby_clock.h
@@ -0,0 +1,42 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_clock.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 21:05
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __STANDBY_CLOCK_H__
+#define __STANDBY_CLOCK_H__
+
+#include "standby_cfg.h"
+#include <mach/ccmu.h>
+
+struct sun4i_clk_div_t {
+    __u32   cpu_div:4;      /* division of cpu clock, divide core_pll */
+    __u32   axi_div:4;      /* division of axi clock, divide cpu clock*/
+    __u32   ahb_div:4;      /* division of ahb clock, divide axi clock*/
+    __u32   apb_div:4;      /* division of apb clock, divide ahb clock*/
+    __u32   reserved:16;
+};
+
+#define PLL_CTRL_REG0_OFFSET	(0x40)
+#define PLL_CTRL_REG1_OFFSET	(0x44)
+
+__s32 standby_clk_init(void);
+__s32 standby_clk_exit(void);
+void standby_clk_core2hosc(void);
+void standby_clk_pll1enable();
+void standby_clk_ldoenable(void);
+extern __u32   cpu_ms_loopcnt;
+
+#endif  /* __STANDBY_CLOCK_H__ */
diff --git a/arch/arm/mach-sun6i/pm/standby/standby_delay.S b/arch/arm/mach-sun6i/pm/standby/standby_delay.S
new file mode 100644
index 0000000..a0f4ab9
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby_delay.S
@@ -0,0 +1,26 @@
+//for 1008M
+#define STANDBY_COEFFICIENT (17)
+
+    .text
+    .globl standby_delay
+standby_delay:
+	push    {r0-r3}
+	ldr  	r1, =STANDBY_COEFFICIENT
+	mov	r3, r0
+loop2:
+	subs    r0, r0, #1
+	bhi	loop2
+	mov	r0, r3
+	subs	r1, r1, #1
+	bhi	loop2
+
+	pop     {r0-r3}
+	mov     pc, lr
+
+    .text
+    .globl standby_delay_cycle
+standby_delay_cycle:
+loop3:
+	subs    r0, r0, #1
+	bhi	loop3
+	mov     pc, lr
diff --git a/arch/arm/mach-sun6i/pm/standby/standby_i.h b/arch/arm/mach-sun6i/pm/standby/standby_i.h
new file mode 100644
index 0000000..e6c2085
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby_i.h
@@ -0,0 +1,58 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_i.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-30 17:21
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __STANDBY_I_H__
+#define __STANDBY_I_H__
+
+#include "../pm_types.h"
+#include "../pm.h"
+
+#include <linux/power/aw_pm.h>
+#include <mach/platform.h>
+
+#include "standby_cfg.h"
+#include "common.h"
+#include "standby_clock.h"
+#include "standby_key.h"
+#include "standby_power.h"
+#include "standby_usb.h"
+#include "standby_twi.h"
+#include "standby_ir.h"
+#include "standby_ar100.h"
+
+
+#define readb(addr)		(*((volatile unsigned char  *)(addr)))
+#define readw(addr)		(*((volatile unsigned short *)(addr)))
+#define readl(addr)		(*((volatile unsigned long  *)(addr)))
+#define writeb(v, addr)	(*((volatile unsigned char  *)(addr)) = (unsigned char)(v))
+#define writew(v, addr)	(*((volatile unsigned short *)(addr)) = (unsigned short)(v))
+#define writel(v, addr)	(*((volatile unsigned long  *)(addr)) = (unsigned long)(v))
+
+extern struct aw_pm_info  pm_info;
+
+#ifdef CHECK_CACHE_TLB_MISS
+extern int d_cache_miss_start;
+extern int d_tlb_miss_start;
+extern int i_tlb_miss_start;
+extern int i_cache_miss_start;
+extern int d_cache_miss_end;
+extern int d_tlb_miss_end;
+extern int i_tlb_miss_end;
+extern int i_cache_miss_end;
+#endif
+
+#endif  //__STANDBY_I_H__
diff --git a/arch/arm/mach-sun6i/pm/standby/standby_ir.c b/arch/arm/mach-sun6i/pm/standby/standby_ir.c
new file mode 100644
index 0000000..a07d562
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby_ir.c
@@ -0,0 +1,94 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_ir.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 14:36
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#include  "standby_i.h"
+
+
+
+/*
+*********************************************************************************************************
+*                           INIT IR FOR STANDBY
+*
+*Description: init ir for standby;
+*
+*Arguments  : none
+*
+*Return     : result;
+*               EPDK_OK,    init ir successed;
+*               EPDK_FAIL,  init ir failed;
+*********************************************************************************************************
+*/
+__s32  standby_ir_init(void)
+{
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           EXIT IR FOR STANDBY
+*
+*Description: exit ir for standby;
+*
+*Arguments  : none;
+*
+*Return     : result.
+*               EPDK_OK,    exit ir successed;
+*               EPDK_FAIL,  exit ir failed;
+*********************************************************************************************************
+*/
+__s32 standby_ir_exit(void)
+{
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           DETECT IR FOR STANDBY
+*
+*Description: detect ir for standby;
+*
+*Arguments  : none
+*
+*Return     : result;
+*               EPDK_OK,    receive some signal;
+*               EPDK_FAIL,  no signal;
+*********************************************************************************************************
+*/
+__s32 standby_ir_detect(void)
+{
+    return 0;
+}
+
+/*
+*********************************************************************************************************
+*                           VERIFY IR SIGNAL FOR STANDBY
+*
+*Description: verify ir signal for standby;
+*
+*Arguments  : none
+*
+*Return     : result;
+*               EPDK_OK,    valid ir signal;
+*               EPDK_FAIL,  invalid ir signal;
+*********************************************************************************************************
+*/
+__s32 standby_ir_verify(void)
+{
+    return -1;
+}
diff --git a/arch/arm/mach-sun6i/pm/standby/standby_ir.h b/arch/arm/mach-sun6i/pm/standby/standby_ir.h
new file mode 100644
index 0000000..f46f4b0
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby_ir.h
@@ -0,0 +1,29 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_ir.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 15:15
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+
+#ifndef __STANDBY_IR_H__
+#define __STANDBY_IR_H__
+
+#include "standby_cfg.h"
+
+extern __s32 standby_ir_init(void);
+extern __s32 standby_ir_exit(void);
+extern __s32 standby_ir_detect(void);
+extern __s32 standby_ir_verify(void);
+
+#endif  /*__STANDBY_IR_H__*/
diff --git a/arch/arm/mach-sun6i/pm/standby/standby_key.c b/arch/arm/mach-sun6i/pm/standby/standby_key.c
new file mode 100644
index 0000000..33c0743
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby_key.c
@@ -0,0 +1,95 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_key.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 15:16
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#include "standby_i.h"
+
+static __standby_key_reg_t  *KeyReg;
+static __u32 KeyCtrl, KeyIntc, KeyInts, KeyData0, KeyData1;
+
+//==============================================================================
+// QUERRY KEY FOR WAKE UP SYSTEM FROM STANDBY
+//==============================================================================
+
+
+/*
+*********************************************************************************************************
+*                                     INIT KEY FOR STANDBY
+*
+* Description: init key for standby.
+*
+* Arguments  : none
+*
+* Returns    : EPDK_OK;
+*********************************************************************************************************
+*/
+__s32 standby_key_init(void)
+{
+    /* set key register base */
+    KeyReg = (__standby_key_reg_t *)(IO_ADDRESS(AW_LRADC01_BASE));
+
+    /* backup LRADC registers */
+    KeyCtrl = KeyReg->Lradc_Ctrl;
+    KeyIntc = KeyReg->Lradc_Intc;
+    KeyReg->Lradc_Ctrl = 0;
+    standby_mdelay(10);
+    KeyReg->Lradc_Ctrl = (0x1<<6)|(0x1<<0);
+    KeyReg->Lradc_Intc = (0x1<<1);
+    KeyReg->Lradc_Ints = (0x1<<1);
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     EXIT KEY FOR STANDBY
+*
+* Description: exit key for standby.
+*
+* Arguments  : none
+*
+* Returns    : EPDK_OK;
+*********************************************************************************************************
+*/
+__s32 standby_key_exit(void)
+{
+    KeyReg->Lradc_Ctrl =  KeyCtrl;
+    KeyReg->Lradc_Intc =  KeyIntc;
+    return 0;
+}
+/*
+*********************************************************************************************************
+*                                     QUERY KEY FOR WAKEUP STANDBY
+*
+* Description: query key for wakeup standby.
+*
+* Arguments  : none
+*
+* Returns    : result;
+*               EPDK_TRUE,      get a key;
+*               EPDK_FALSE,     no key;
+*********************************************************************************************************
+*/
+__s32 standby_query_key(void)
+{
+    if(KeyReg->Lradc_Ints & 0x2)
+    {
+        KeyReg->Lradc_Ints = 0x2;
+        return 0;
+    }
+    return -1;
+}
diff --git a/arch/arm/mach-sun6i/pm/standby/standby_key.h b/arch/arm/mach-sun6i/pm/standby/standby_key.h
new file mode 100644
index 0000000..b59a7c4
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby_key.h
@@ -0,0 +1,38 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_key.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 15:16
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __STANDBY_KEY_H__
+#define __STANDBY_KEY_H__
+
+#include "standby_cfg.h"
+//define key controller registers
+typedef struct __STANDBY_KEY_REG
+{
+    // offset:0x00
+    volatile __u32   Lradc_Ctrl;
+    volatile __u32   Lradc_Intc;
+    volatile __u32   Lradc_Ints;
+    volatile __u32   Lradc_Data0;
+    volatile __u32   Lradc_Data1;
+} __standby_key_reg_t;
+
+extern __s32 standby_key_init(void);
+extern __s32 standby_key_exit(void);
+extern __s32 standby_query_key(void);
+
+
+#endif  /* __STANDBY_KEY_H__ */
diff --git a/arch/arm/mach-sun6i/pm/standby/standby_power.c b/arch/arm/mach-sun6i/pm/standby/standby_power.c
new file mode 100644
index 0000000..c18db0de
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby_power.c
@@ -0,0 +1,155 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_power.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 14:34
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#include "standby_i.h"
+
+
+static inline int check_range(struct axp_info *info,__s32 voltage)
+{
+	if (voltage < info->min_uV || voltage > info->max_uV)
+		return -1;
+
+	return 0;
+}
+
+static int axp20_ldo4_data[] = {
+    1250, 1300, 1400, 1500, 1600, 1700,
+    1800, 1900, 2000, 2500, 2700, 2800,
+    3000, 3100, 3200, 3300
+};
+
+static struct axp_info axp20_info[] = {
+	AXP(POWER_VOL_LDO1,	 AXP20LDO1,	AXP20LDO1,	  0, AXP20_LDO1,  0, 0),//ldo1 for rtc
+	AXP(POWER_VOL_LDO2,	      1800,      3300,  100, AXP20_LDO2,  4, 4),//ldo2 for analog1
+	AXP(POWER_VOL_LDO3,	       700,      3500,   25, AXP20_LDO3,  0, 7),//ldo3 for digital
+	AXP(POWER_VOL_LDO4,	      1250,      3300,  100, AXP20_LDO4,  0, 4),//ldo4 for analog2
+	AXP(POWER_VOL_DCDC2,       700,      2275,   25, AXP20_BUCK2, 0, 6),//buck2 for core
+	AXP(POWER_VOL_DCDC3,       700,      3500,   25, AXP20_BUCK3, 0, 7),//buck3 for memery
+};
+
+static inline struct axp_info *find_info(int id)
+{
+	struct axp_info *ri;
+	int i;
+
+	for (i = 0; i < sizeof(axp20_info)/sizeof(struct axp_info); i++) {
+		ri = &axp20_info[i];
+		if (ri->id == id)
+			return ri;
+	}
+	return 0;
+}
+
+/*
+*********************************************************************************************************
+*                           standby_set_voltage
+*
+*Description: set voltage for standby;
+*
+*Arguments  : type      voltage type, defined as "enum power_vol_type_e";
+*             voltage   voltage value, based on "mv";
+*
+*Return     : none;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void  standby_set_voltage(enum power_vol_type_e type, __s32 voltage)
+{
+	struct axp_info *info = 0;
+	__u8 val, mask, reg_val;
+
+	info = find_info(type);
+	if (info == 0) {
+		return;
+	}
+
+	if (check_range(info, voltage)) {
+		return;
+	}
+
+	if (type != POWER_VOL_LDO4)
+		val = raw_lib_udiv((voltage-info->min_uV+info->step_uV-1), info->step_uV);
+	else{
+		if(voltage == 1250000 ){
+			val = 0;
+		}
+		else{
+			val = raw_lib_udiv((voltage-1200000+info->step_uV-1), info->step_uV);
+			if(val > 16){
+				val = val - 6;
+			}
+			else if(val > 13){
+				val = val - 5;
+			}
+			else if(val > 12){
+				val = val - 4;
+			}
+			else if(val > 8)
+				val = 8;
+		}
+	}
+
+
+	val <<= info->vol_shift;
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+
+	twi_byte_rw(TWI_OP_RD,AXP_ADDR,info->vol_reg, &reg_val);
+
+	if ((reg_val & mask) != val) {
+		reg_val = (reg_val & ~mask) | val;
+		twi_byte_rw(TWI_OP_WR,AXP_ADDR,info->vol_reg, &reg_val);
+	}
+
+	return;
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_get_voltage
+*
+*Description: get voltage for standby;
+*
+*Arguments  : type  voltage type, defined as "enum power_vol_type_e";
+*
+*Return     : voltage value, based on "mv";
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__u32 standby_get_voltage(enum power_vol_type_e type)
+{
+	struct axp_info *info = 0;
+	__u8 val, mask;
+
+	info = find_info(type);
+	if (info == 0) {
+		return -1;
+	}
+
+	twi_byte_rw(TWI_OP_RD,AXP_ADDR,info->vol_reg, &val);
+
+	mask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;
+	val = (val & mask) >> info->vol_shift;
+	if (type != POWER_VOL_LDO4)
+		return info->min_uV + info->step_uV * val;
+	else
+		return axp20_ldo4_data[val]*1000;
+}
diff --git a/arch/arm/mach-sun6i/pm/standby/standby_power.h b/arch/arm/mach-sun6i/pm/standby/standby_power.h
new file mode 100644
index 0000000..c1cef94
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby_power.h
@@ -0,0 +1,89 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_power.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 14:34
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __STANDBY_POWER_H__
+#define __STANDBY_POWER_H__
+
+#include "standby_cfg.h"
+
+enum power_vol_type_e{
+
+    POWER_VOL_DCDC1,
+    POWER_VOL_DCDC2,
+    POWER_VOL_DCDC3,
+    POWER_VOL_LDO1,
+    POWER_VOL_LDO2,
+    POWER_VOL_LDO3,
+    POWER_VOL_LDO4,
+
+};
+
+#define AXP_ADDR        (0x34)
+#define AXP_IICBUS      (0)
+#define AXP20_LDO1      (0x00)
+#define AXP20_LDO2      (0x28)
+#define AXP20_LDO3      (0x29)
+#define AXP20_LDO4      (0x28)
+#define AXP20_BUCK2     (0x23)
+#define AXP20_BUCK3     (0x27)
+
+#define AXP20_PEK    	(0x36)
+
+#define AXP20_IRQEN1    (0x40)
+#define AXP20_IRQEN2    (0x41)
+#define AXP20_IRQEN3    (0x42)
+#define AXP20_IRQEN4    (0x43)
+#define AXP20_IRQEN5    (0x44)
+
+#define AXP20_IRQ1      (0x48)
+#define AXP20_IRQ2      (0x49)
+#define AXP20_IRQ3      (0x4A)
+#define AXP20_IRQ4      (0x4B)
+#define AXP20_IRQ5      (0x4C)
+
+#define AXP20LDO1       1300
+
+
+#define AXP(_id, min, max, step, vreg, shift, nbits)    \
+{                               \
+    .id = _id,                  \
+    .min_uV        = (min),     \
+    .max_uV        = (max),     \
+    .step_uV    = (step),       \
+    .vol_reg    =  (vreg),      \
+    .vol_shift    = (shift),    \
+    .vol_nbits    = (nbits),    \
+}
+
+struct axp_info {
+    enum    power_vol_type_e id;
+    int     min_uV;
+    int     max_uV;
+    int     step_uV;
+    int     vol_reg;
+    int     vol_shift;
+    int     vol_nbits;
+};
+
+
+extern __s32 standby_power_init(__u32 wakeup_src);
+extern __s32 standby_power_exit(__u32 wakeup_src);
+extern void  standby_set_voltage(enum power_vol_type_e type, __s32 voltage);
+extern __u32 standby_get_voltage(enum power_vol_type_e type);
+
+
+#endif  /* __STANDBY_POWER_H__ */
diff --git a/arch/arm/mach-sun6i/pm/standby/standby_twi.c b/arch/arm/mach-sun6i/pm/standby/standby_twi.c
new file mode 100644
index 0000000..89ad5d6
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby_twi.c
@@ -0,0 +1,285 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_twi.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 15:22
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#include "standby_i.h"
+
+#define TWI_CHECK_TIMEOUT       (0x2ff)
+
+static __twic_reg_t*   TWI_REG_BASE[3] = {
+    (__twic_reg_t*)IO_ADDRESS(AW_TWI0_BASE),
+    (__twic_reg_t*)IO_ADDRESS(AW_TWI1_BASE),
+    (__twic_reg_t*)IO_ADDRESS(AW_TWI2_BASE)
+};
+
+static __u32 TwiClkRegBak = 0;
+static __u32 TwiCtlRegBak = 0;
+static __twic_reg_t *twi_reg  = 0;
+
+
+
+/*
+*********************************************************************************************************
+*                                   standby_twi_init
+*
+*Description: init twi transfer.
+*
+*Arguments  :
+*
+*Return     :
+*
+*********************************************************************************************************
+*/
+__s32 standby_twi_init(int group)
+{
+	twi_reg  = TWI_REG_BASE[group];
+	TwiClkRegBak = twi_reg->reg_clkr;
+	TwiCtlRegBak = 0x80&twi_reg->reg_ctl;/* backup INT_EN;no need for BUS_EN(0xc0)  */
+	//twi_reg->reg_clkr = (2<<3)|3; //100k
+	twi_reg->reg_clkr = (5<<3)|0; //400k, M = 5, N=0;
+
+	twi_reg->reg_reset |= 0x1;
+	while(twi_reg->reg_reset&0x1);
+
+	return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                   standby_twi_exit
+*
+*Description: exit twi transfer.
+*
+*Arguments  :
+*
+*Return     :
+*
+*********************************************************************************************************
+*/
+__s32 standby_twi_exit(void)
+{
+    /* softreset twi module  */
+    twi_reg->reg_reset |= 0x1;
+    /* delay */
+    standby_mdelay(10);
+
+    /* restore clock division */
+    twi_reg->reg_clkr = TwiClkRegBak;
+    /* restore INT_EN */
+    twi_reg->reg_ctl |= TwiCtlRegBak;
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                   _standby_twi_stop
+*
+*Description: stop current twi transfer.
+*
+*Arguments  :
+*
+*Return     :
+*
+*********************************************************************************************************
+*/
+static int _standby_twi_stop(void)
+{
+    unsigned int   nop_read;
+    unsigned int   timeout = TWI_CHECK_TIMEOUT;
+
+    twi_reg->reg_ctl = (twi_reg->reg_ctl & 0xc0) | 0x10;/* set stop+clear int flag */
+
+    nop_read = twi_reg->reg_ctl;/* apb时钟低时必须假读一次stop bit,下一个周期才生效 */
+    nop_read = nop_read;
+    // 1. stop bit is zero.
+    while((twi_reg->reg_ctl & 0x10)&&(timeout--));
+    if(timeout == 0)
+    {
+        return -1;
+    }
+    // 2. twi fsm is idle(0xf8).
+    timeout = TWI_CHECK_TIMEOUT;
+    while((0xf8 != twi_reg->reg_status)&&(timeout--));
+    if(timeout == 0)
+    {
+        return -1;
+    }
+    // 3. twi scl & sda must high level.
+    timeout = TWI_CHECK_TIMEOUT;
+    while((0x3a != twi_reg->reg_lctl)&&(timeout--));
+    if(timeout == 0)
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                   twi_byte_rw
+*
+*Description: twi byte read and write.
+*
+*Arguments  : op        operation read or write;
+*             saddr     slave address;
+*             baddr     byte address;
+*             data      pointer to the data to be read or write;
+*
+*Return     : result;
+*               = EPDK_OK,      byte read or write successed;
+*               = EPDK_FAIL,    btye read or write failed!
+*********************************************************************************************************
+*/
+__s32 twi_byte_rw(enum twi_op_type_e op, __u8 saddr, __u8 baddr, __u8 *data)
+{
+    unsigned char state_tmp;
+    unsigned int   timeout;
+    int   ret = -1;
+
+    twi_reg->reg_efr = 0;/* 标准读写必须置0 */
+
+    state_tmp = twi_reg->reg_status;
+    if(state_tmp != 0xf8)
+    {
+        goto stop_out;
+    }
+
+    /* control registser bitmap
+         7      6       5     4       3       2    1    0
+      INT_EN  BUS_EN  START  STOP  INT_FLAG  ACK  NOT  NOT
+    */
+
+    //1.Send Start
+    twi_reg->reg_ctl |= 0x20;
+    timeout = TWI_CHECK_TIMEOUT;
+    while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+    if(timeout == 0)
+    {
+        goto stop_out;
+    }
+    state_tmp = twi_reg->reg_status;
+    if(state_tmp != 0x08)
+    {
+        goto stop_out;
+    }
+
+    //2.Send Slave Address
+    twi_reg->reg_data = (saddr<<1) | 0; /* slave address + write */
+    twi_reg->reg_ctl &= 0xf7;/* clear int flag */
+    timeout = TWI_CHECK_TIMEOUT;
+    while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+    if(timeout == 0)
+    {
+        goto stop_out;
+    }
+    state_tmp = twi_reg->reg_status;
+    if(state_tmp != 0x18)
+    {
+        goto stop_out;
+    }
+
+    //3.Send Byte Address
+    twi_reg->reg_data = baddr;
+    twi_reg->reg_ctl &= 0xf7;/* clear int flag */
+    timeout = TWI_CHECK_TIMEOUT;
+    while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+    if(timeout == 0)
+    {
+        goto stop_out;
+    }
+    state_tmp = twi_reg->reg_status;
+    if(state_tmp != 0x28)
+    {
+        goto stop_out;
+    }
+
+    if(op == TWI_OP_WR)
+    {
+        //4.Send Data to be write
+        twi_reg->reg_data = *data;
+        twi_reg->reg_ctl &= 0xf7;/* clear int flag */
+        timeout = TWI_CHECK_TIMEOUT;
+        while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+        if(timeout == 0)
+        {
+            goto stop_out;
+        }
+        state_tmp = twi_reg->reg_status;
+        if(state_tmp != 0x28)
+        {
+            goto stop_out;
+        }
+    }
+    else
+    {
+        //4. Send restart for read
+        twi_reg->reg_ctl = (twi_reg->reg_ctl & 0xc0) | 0x20;/* set start+clear int flag */
+        timeout = TWI_CHECK_TIMEOUT;
+        while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+        if(timeout == 0)
+        {
+            goto stop_out;
+        }
+        state_tmp = twi_reg->reg_status;
+        if(state_tmp != 0x10)
+        {
+            goto stop_out;
+        }
+
+        //5.Send Slave Address
+        twi_reg->reg_data = (saddr<<1) | 1;/* slave address+ read */
+        twi_reg->reg_ctl &= 0xf7;/* clear int flag then 0x40 come in */
+        timeout = TWI_CHECK_TIMEOUT;
+        while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+        if(timeout == 0)
+        {
+            goto stop_out;
+        }
+        state_tmp = twi_reg->reg_status;
+        if(state_tmp != 0x40)
+        {
+            goto stop_out;
+        }
+
+        //6.Get data
+        twi_reg->reg_ctl &= 0xf7;/* clear int flag then data come in */
+        timeout = TWI_CHECK_TIMEOUT;
+        while((!(twi_reg->reg_ctl & 0x08))&&(timeout--));
+        if(timeout == 0)
+        {
+            goto stop_out;
+        }
+        *data = twi_reg->reg_data;
+        state_tmp = twi_reg->reg_status;
+        if(state_tmp != 0x58)
+        {
+          goto stop_out;
+        }
+    }
+
+    ret = 0;
+
+stop_out:
+    //WRITE: step 5; READ: step 7
+    //Send Stop
+    _standby_twi_stop();
+
+    return ret;
+}
diff --git a/arch/arm/mach-sun6i/pm/standby/standby_twi.h b/arch/arm/mach-sun6i/pm/standby/standby_twi.h
new file mode 100644
index 0000000..24afa13
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby_twi.h
@@ -0,0 +1,53 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_twi.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 15:22
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+
+#ifndef __STANDBY_TWI_H__
+#define __STANDBY_TWI_H__
+
+#include "standby_cfg.h"
+
+
+typedef struct tag_twic_reg
+{
+    volatile unsigned int reg_saddr;
+    volatile unsigned int reg_xsaddr;
+    volatile unsigned int reg_data;
+    volatile unsigned int reg_ctl;
+    volatile unsigned int reg_status;
+    volatile unsigned int reg_clkr;
+    volatile unsigned int reg_reset;
+    volatile unsigned int reg_efr;
+    volatile unsigned int reg_lctl;
+
+}__twic_reg_t;
+
+
+
+enum twi_op_type_e{
+    TWI_OP_RD,
+    TWI_OP_WR,
+};
+
+
+extern __s32 standby_twi_init(int group);
+extern __s32 standby_twi_exit(void);
+extern __s32 twi_byte_rw(enum twi_op_type_e op, __u8 saddr, __u8 baddr, __u8 *data);
+
+
+
+#endif  /* __STANDBY_TWI_H__ */
diff --git a/arch/arm/mach-sun6i/pm/standby/standby_usb.c b/arch/arm/mach-sun6i/pm/standby/standby_usb.c
new file mode 100644
index 0000000..e02d491
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby_usb.c
@@ -0,0 +1,97 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_usb.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 15:18
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#include "standby_i.h"
+
+
+
+//==============================================================================
+// USB CHECK FOR WAKEUP SYSTEM FROM STANDBY
+//==============================================================================
+
+
+/*
+*********************************************************************************************************
+*                                     standby_usb_init
+*
+* Description: init usb for standby.
+*
+* Arguments  : none;
+*
+* Returns    : none;
+*********************************************************************************************************
+*/
+__s32 standby_usb_init(void)
+{
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_usb_exit
+*
+* Description: exit usb for standby.
+*
+* Arguments  : none;
+*
+* Returns    : none;
+*********************************************************************************************************
+*/
+__s32 standby_usb_exit(void)
+{
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                           standby_is_usb_status_change
+*
+*Description: check if usb status is change.
+*
+*Arguments  : port  usb port number;
+*
+*Return     : result, 0 status not change, !0 status changed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+__s32 standby_is_usb_status_change(__u32 port)
+{
+    return 0;
+}
+
+
+/*
+*********************************************************************************************************
+*                                     standby_query_usb_event
+*
+* Description: query usb event for wakeup system from standby.
+*
+* Arguments  : none;
+*
+* Returns    : result;
+*               EPDK_TRUE,  some usb event happenned;
+*               EPDK_FALSE, none usb event;
+*********************************************************************************************************
+*/
+__s32 standby_query_usb_event(void)
+{
+    return -1;
+}
diff --git a/arch/arm/mach-sun6i/pm/standby/standby_usb.h b/arch/arm/mach-sun6i/pm/standby/standby_usb.h
new file mode 100644
index 0000000..be838bc
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/standby_usb.h
@@ -0,0 +1,28 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : standby_usb.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 15:17
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __STANDBY_USB_H__
+#define __STANDBY_USB_H__
+
+#include "standby_cfg.h"
+
+
+extern __s32 standby_usb_init(void);
+extern __s32 standby_usb_exit(void);
+extern __s32 standby_query_usb_event(void);
+
+#endif  /* __STANDBY_USB_H__ */
diff --git a/arch/arm/mach-sun6i/pm/standby/super/common.c b/arch/arm/mach-sun6i/pm/standby/super/common.c
new file mode 100644
index 0000000..aee17aa
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/super/common.c
@@ -0,0 +1,50 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : common.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-30 19:38
+* Descript: common lib for mem
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#include "super_i.h"
+
+
+/*
+*********************************************************************************************************
+*                           mem_memcpy
+*
+*Description: memory copy function for mem.
+*
+*Arguments  :
+*
+*Return     :
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+void mem_memcpy(void *dest, void *src, int n)
+{
+    char    *tmp_src = (char *)src;
+    char    *tmp_dst = (char *)dest;
+
+  //  if(!dest || !src){
+        /* parameter is invalid */
+  //      return;
+ //   }
+
+    for( ; n > 0; n--){
+        *tmp_dst ++ = *tmp_src ++;
+    }
+
+    return;
+}
diff --git a/arch/arm/mach-sun6i/pm/standby/super/common.h b/arch/arm/mach-sun6i/pm/standby/super/common.h
new file mode 100644
index 0000000..dd14a41
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/super/common.h
@@ -0,0 +1,67 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : common.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-30 17:21
+* Descript: common lib for mem.
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __COMMON_H__
+#define __COMMON_H__
+
+static inline __u64 mem_uldiv(__u64 dividend, __u32 divisior)
+{
+    __u64   tmpDiv = (__u64)divisior;
+    __u64   tmpQuot = 0;
+    __s32   shift = 0;
+
+    if(!divisior)
+    {
+        /* divide 0 error abort */
+        return 0;
+    }
+
+    while(!(tmpDiv & ((__u64)1<<63)))
+    {
+        tmpDiv <<= 1;
+        shift ++;
+    }
+
+    do
+    {
+        if(dividend >= tmpDiv)
+        {
+            dividend -= tmpDiv;
+            tmpQuot = (tmpQuot << 1) | 1;
+        }
+        else
+        {
+            tmpQuot = (tmpQuot << 1) | 0;
+        }
+        tmpDiv >>= 1;
+        shift --;
+    } while(shift >= 0);
+
+    return tmpQuot;
+}
+
+
+
+void mem_memcpy(void *dest, void *src, int n);
+
+/*notice: all the delay cycle is measured by 60M hz
+ *when in super mem, the os is running in 1008M
+ *so, the delay cycle need reconsideration.
+ */
+void mem_delay(int cycle);
+
+#endif  //__COMMON_H__
diff --git a/arch/arm/mach-sun6i/pm/standby/super/readme.txt b/arch/arm/mach-sun6i/pm/standby/super/readme.txt
new file mode 100644
index 0000000..34a7eb9
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/super/readme.txt
@@ -0,0 +1 @@
+this directory is for mem(suspend to ram) source code.
\ No newline at end of file
diff --git a/arch/arm/mach-sun6i/pm/standby/super/resume/readme.txt b/arch/arm/mach-sun6i/pm/standby/super/resume/readme.txt
new file mode 100644
index 0000000..9e3e454
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/super/resume/readme.txt
@@ -0,0 +1 @@
+all code in this fold will reside in dram, waiting for resume the system;
\ No newline at end of file
diff --git a/arch/arm/mach-sun6i/pm/standby/super/resume/resume1.S b/arch/arm/mach-sun6i/pm/standby/super/resume/resume1.S
new file mode 100644
index 0000000..d269bb7
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/super/resume/resume1.S
@@ -0,0 +1,94 @@
+/***********************************************************************************************************************
+;                             Copyright(C), 2012-2015, Newbie Microelectronic Co., Ltd.
+;                                                  All Rights Reserved
+;
+; File Name : resume1.S
+;
+; Author : yanggq
+;
+; Version : 1.1.0
+;
+; Date : 2012.7.11
+;
+; Description :
+;
+; Functions list : none.
+;
+; Others : None at present.
+;
+;
+; History :
+;
+;  <Author>        <time>       <version>      <description>
+;
+; gq.Yang       2012.7.11      1.1.0        build the file
+;
+***********************************************************************************************************************/
+#define  ARMV7_USR_MODE        0x10
+#define  ARMV7_FIQ_MODE        0x11
+#define  ARMV7_IRQ_MODE        0x12
+#define  ARMV7_SVC_MODE        0x13
+#define  ARMV7_MON_MODE        0x16
+#define  ARMV7_ABT_MODE        0x17
+#define  ARMV7_UND_MODE        0x1b
+#define  ARMV7_SYSTEM_MODE     0x1f
+#define  ARMV7_MODE_MASK       0x1f
+#define  ARMV7_FIQ_MASK        0x40
+#define  ARMV7_IRQ_MASK        0x80
+
+
+#define   ARMV7_THUMB_MASK    (1<<5)
+#define   ARMV7_END_MASK      (1<<9)
+
+#define   ARMV7_IT_MASK       ((0x3f<<10)|(0x03<<25))
+#define   ARMV7_GE_MASK       (0x0f<<16)
+#define   ARMV7_JAVA_MASK     (1<<24)
+
+#define   ARMV7_QFLAG_BIT     (1 << 27)
+#define   ARMV7_CC_V_BIT      (1 << 28)
+#define   ARMV7_CC_C_BIT      (1 << 29)
+#define   ARMV7_CC_Z_BIT      (1 << 30)
+#define   ARMV7_CC_N_BIT      (1 << 31)
+#define   ARMV7_CC_E_BIT      (1 << 9)
+
+#define   ARMV7_C1_M_BIT         ( 1 << 0 )
+#define   ARMV7_C1_A_BIT         ( 1 << 1 )
+#define   ARMV7_C1_C_BIT         ( 1 << 2 )
+#define   ARMV7_C1_Z_BIT         ( 1 << 11 )
+#define   ARMV7_C1_I_BIT         ( 1 << 12 )
+
+	.extern resume1_c_part
+	.text
+	.arm
+/*********************************the begin of initializing system********************************/
+	.globl _start
+_start:
+	mrs r0, cpsr
+	bic r0, r0, #ARMV7_MODE_MASK
+	orr r0, r0, #ARMV7_SVC_MODE
+	orr r0, r0, #( ARMV7_IRQ_MASK | ARMV7_FIQ_MASK )    ;// After reset, ARM automaticly disables IRQ and FIQ, and runs in SVC mode.
+	bic r0, r0, #ARMV7_CC_E_BIT                         ;// set little-endian
+	msr cpsr_c, r0
+
+// configure memory system : disable MMU,cache and write buffer; set little_endian;
+	mrc p15, 0, r0, c1, c0
+	bic r0, r0, #( ARMV7_C1_M_BIT | ARMV7_C1_C_BIT )  ;// disable MMU, data cache
+	bic r0, r0, #( ARMV7_C1_I_BIT | ARMV7_C1_Z_BIT )  ;// disable instruction cache, disable flow prediction
+	bic r0, r0, #( ARMV7_C1_A_BIT)                    ;// disable align
+	mcr p15, 0, r0, c1, c0
+
+    ldr r0, =0x01c00044
+    ldr r1,[r0]
+    orr r1,#0x1800
+    str r1,[r0]
+
+// set SP for C language
+	ldr sp, =0x00007ffc
+
+/**********************************the end of initializing system*********************************/
+	bl set_pll
+	bl  resume1_c_part
+
+	b .                                 ;// infinite loop
+
+	.end
diff --git a/arch/arm/mach-sun6i/pm/standby/super/resume/resume1_c_part.c b/arch/arm/mach-sun6i/pm/standby/super/resume/resume1_c_part.c
new file mode 100644
index 0000000..ff62e5a
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/super/resume/resume1_c_part.c
@@ -0,0 +1,152 @@
+/* these code will be removed to sram.
+ * function: open the mmu, and jump to dram, for continuing resume*/
+#include "./../super_i.h"
+
+
+static struct aw_mem_para mem_para_info;
+
+extern char *__bss_start;
+extern char *__bss_end;
+static __s32 dcdc2, dcdc3;
+static __u32 sp_backup;
+static char    *tmpPtr = (char *)&__bss_start;
+static __u32 status = 0;
+
+#ifdef RETURN_FROM_RESUME0_WITH_MMU
+#define MMU_OPENED
+#undef POWER_OFF
+#define FLUSH_TLB
+#define FLUSH_ICACHE
+#define INVALIDATE_DCACHE
+#endif
+
+#ifdef RETURN_FROM_RESUME0_WITH_NOMMU
+#undef MMU_OPENED
+#undef POWER_OFF
+#define FLUSH_TLB
+#define FLUSH_ICACHE
+#define INVALIDATE_DCACHE
+#endif
+
+#if defined(ENTER_SUPER_STANDBY) || defined(ENTER_SUPER_STANDBY_WITH_NOMMU) || defined(WATCH_DOG_RESET)
+#undef MMU_OPENED
+#define POWER_OFF
+#define FLUSH_TLB
+#define SET_COPRO_REG
+//#define FLUSH_ICACHE
+#define INVALIDATE_DCACHE
+#endif
+
+int resume1_c_part(void)
+{
+	//
+	//busy_waiting();
+	/* clear bss segment */
+	do{*tmpPtr ++ = 0;}while(tmpPtr <= (char *)&__bss_end);
+
+#ifdef SET_COPRO_REG
+	set_copro_default();
+#endif
+
+#ifdef MMU_OPENED
+	save_mem_status(RESUME1_START |0x02);
+
+	//move other storage to sram: saved_resume_pointer(virtual addr), saved_mmu_state
+	mem_memcpy((void *)&mem_para_info, (void *)(DRAM_BACKUP_BASE_ADDR1), sizeof(mem_para_info));
+#else
+	//config jtag gpio
+	*(volatile __u32 * )(0x01c20800 + 0x100) = 0x00033330;
+
+	save_mem_status_nommu(RESUME1_START |0x02);
+
+	//move other storage to sram: saved_resume_pointer(virtual addr), saved_mmu_state
+	mem_memcpy((void *)&mem_para_info, (void *)(DRAM_BACKUP_BASE_ADDR1_PA), sizeof(mem_para_info));
+
+	if(unlikely(mem_para_info.debug_mask&PM_STANDBY_PRINT_RESUME)){
+		//config uart
+		serial_init_nommu();
+		serial_puts_nommu("resume1: 0. \n");
+	}
+#if 1
+	/*restore freq from 408M to orignal freq.*/
+	//busy_waiting();
+	mem_clk_setdiv(&mem_para_info.clk_div);
+	mem_clk_set_pll_factor(&mem_para_info.pll_factor);
+	change_runtime_env(0);
+	delay_ms(mem_para_info.suspend_delay_ms);
+
+	if(unlikely(mem_para_info.debug_mask&PM_STANDBY_PRINT_RESUME)){
+		serial_puts_nommu("resume1: 1. before restore mmu. \n");
+	}
+#endif
+	/*restore mmu configuration*/
+	save_mem_status_nommu(RESUME1_START |0x03);
+	//save_mem_status(RESUME1_START |0x03);
+
+	restore_mmu_state(&(mem_para_info.saved_mmu_state));
+	save_mem_status(RESUME1_START |0x13);
+
+#endif
+
+//before jump to late_resume
+#ifdef FLUSH_TLB
+	save_mem_status(RESUME1_START |0x9);
+	mem_flush_tlb();
+#endif
+
+#ifdef FLUSH_ICACHE
+	save_mem_status(RESUME1_START |0xa);
+	flush_icache();
+#endif
+
+	if(unlikely(mem_para_info.debug_mask&PM_STANDBY_PRINT_RESUME)){
+		serial_puts("resume1: 3. after restore mmu, before jump.\n");
+	}
+
+	//busy_waiting();
+	jump_to_resume((void *)mem_para_info.resume_pointer, mem_para_info.saved_runtime_context_svc);
+
+	return;
+}
+
+
+/*******************************************************************************
+* interface : set_pll
+*	prototype		：void set_pll( void )
+*	function		: adjust CPU frequence, from 24M hosc to pll1 384M
+*	input para	: void
+*	return value	: void
+*	note:
+*******************************************************************************/
+void set_pll( void )
+{
+	/*when enter this func, state is as follow:
+	 *	1. mmu is disable.
+	 *	2. clk is 24M hosc (?)
+	 *
+	 */
+	__ccmu_reg_list_t   *CmuReg;
+
+	CmuReg = (__ccmu_reg_list_t   *)mem_clk_init(0);
+
+	save_mem_status_nommu(RESUME1_START |0x26);
+	//switch to 24M
+	*(volatile __u32 *)(&CmuReg->SysClkDiv) = 0x00010000;
+	//enable pll1 and setting PLL1 to 408M
+	*(volatile __u32 *)(&CmuReg->Pll1Ctl) = (0x00001000) | (0x80000000); //N = 16, K=M=1 -> pll1 = 17*24 = 408M
+	//setting pll6 to 600M
+	//enable pll6
+	*(volatile __u32 *)(&CmuReg->Pll6Ctl) = 0x80041811;
+	//delay
+	//need reconstruction!!
+	save_mem_status_nommu(RESUME1_START |0x27);
+	init_perfcounters(1, 0); //need double check..
+	change_runtime_env(0);
+	delay_ms(10);
+
+	save_mem_status_nommu(RESUME1_START |0x28);
+	//switch to PLL1
+	*(volatile __u32 *)(&CmuReg->SysClkDiv) = 0x00020000;
+
+	return ;
+}
diff --git a/arch/arm/mach-sun6i/pm/standby/super/resume/resume_head.c b/arch/arm/mach-sun6i/pm/standby/super/resume/resume_head.c
new file mode 100644
index 0000000..80e31f0
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/super/resume/resume_head.c
@@ -0,0 +1,129 @@
+/*
+************************************************************************************************************************
+*                                                         eGON
+*                                         the Embedded GO-ON Resumeloader System
+*
+*                             Copyright(C), 2006-2008, SoftWinners Microelectronic Co., Ltd.
+*											       All Rights Reserved
+*
+* File Name : Resume_head.c
+*
+* Author : Gary.Wang
+*
+* Version : 1.1.0
+*
+* Date : 2007.11.06
+*
+* Description : This file defines the file head part of Resume, which contains some important
+*             infomations such as magic, platform infomation and so on, and MUST be allocted in the
+*             head of Resume.
+*
+* Others : None at present.
+*
+*
+* History :
+*
+*  <Author>        <time>       <version>      <description>
+*
+* Gary.Wang       2007.11.06      1.1.0        build the file
+*
+************************************************************************************************************************
+*/
+
+
+typedef signed char		  __s8;
+typedef unsigned char		  __u8;
+typedef short int		  __s16;
+typedef unsigned short		  __u16;
+typedef int			  __s32;
+typedef unsigned int		  __u32;
+
+
+#define RESUMEX_MAGIC             "eGON.BT0"
+#define STAMP_VALUE               0x5F0A6C39
+#define RESUME_FILE_HEAD_VERSION  "1100"     // X.X.XX
+#define RESUME_VERSION            "1100"     // X.X.XX
+#define PLATFORM                  "1633"
+
+#define NF_ALIGN_SIZE			1024
+#define RESUMEX_ALIGN_SIZE  		NF_ALIGN_SIZE
+#define RESUME_PUB_HEAD_VERSION         "1100"    // X.X.XX
+#define RESUMEX_FILE_HEAD_VERSION       "1230"    // X.X.XX
+#define RESUMEX_VERSION                 "1230"    // X.X.XX
+#define EGON_VERSION                    "1100"    // X.X.XX
+
+/******************************************************************************/
+/*                              file head of Resume                             */
+/******************************************************************************/
+typedef struct _Resume_file_head
+{
+	__u32  jump_instruction;   // one intruction jumping to real code
+	__u8   magic[8];           // ="eGON.BT0" or "eGON.BT1",  not C-style string.
+	__u32  check_sum;          // generated by PC
+	__u32  length;             // generated by PC
+	__u32  pub_head_size;      // the size of resume_file_head_t
+	__u8   pub_head_vsn[4];    // the version of resume_file_head_t
+	__u8   file_head_vsn[4];   // the version of resume0_file_head_t or resume1_file_head_t
+	__u8   Resume_vsn[4];      // Resume version
+	__u8   eGON_vsn[4];        // eGON version
+	__u8   platform[8];        // platform information
+}resume_file_head_t;
+
+
+#pragma  arm section  rodata="head"
+
+const resume_file_head_t  resume_head =
+{
+		/* jump_instruction */
+		( 0xEA000000 | ( ( ( sizeof( resume_file_head_t ) + sizeof( int ) - 1 ) / sizeof( int ) - 2 ) & 0x00FFFFFF ) ),
+		//0xe3a0f000,
+		RESUMEX_MAGIC,
+		STAMP_VALUE,
+		RESUMEX_ALIGN_SIZE,
+		sizeof( resume_file_head_t ),
+		RESUME_PUB_HEAD_VERSION,
+		RESUMEX_FILE_HEAD_VERSION,
+		RESUMEX_VERSION,
+		EGON_VERSION,
+};
+
+
+
+
+
+/*******************************************************************************
+*
+*                  关于Resume_file_head中的jump_instruction字段
+*
+*  jump_instruction字段存放的是一条跳转指令：( B  BACK_OF_Resume_file_head )，此跳
+*转指令被执行后，程序将跳转到Resume_file_head后面第一条指令。
+*
+*  ARM指令中的B指令编码如下：
+*          +--------+---------+------------------------------+
+*          | 31--28 | 27--24  |            23--0             |
+*          +--------+---------+------------------------------+
+*          |  cond  | 1 0 1 0 |        signed_immed_24       |
+*          +--------+---------+------------------------------+
+*  《ARM Architecture Reference Manual》对于此指令有如下解释：
+*  Syntax :
+*  B{<cond>}  <target_address>
+*    <cond>    Is the condition under which the instruction is executed. If the
+*              <cond> is ommitted, the AL(always,its code is 0b1110 )is used.
+*    <target_address>
+*              Specified the address to branch to. The branch target address is
+*              calculated by:
+*              1.  Sign-extending the 24-bit signed(wro's complement)immediate
+*                  to 32 bits.
+*              2.  Shifting the result left two bits.
+*              3.  Adding to the contents of the PC, which contains the address
+*                  of the branch instruction plus 8.
+*
+*  由此可知，此指令编码的最高8位为：0b11101010，低24位根据Resume_file_head的大小动
+*态生成，所以指令的组装过程如下：
+*  ( sizeof( brom_file_head_t ) + sizeof( int ) - 1 ) / sizeof( int )     求出文件
+*                                              头占用的“字”的个数
+*  - 2                                         减去PC预取的指令条数
+*  & 0x00FFFFFF                                求出signed-immed-24
+*  | 0xEA000000                                组装成B指令
+*
+*******************************************************************************/
diff --git a/arch/arm/mach-sun6i/pm/standby/super/resume1_asm.S b/arch/arm/mach-sun6i/pm/standby/super/resume1_asm.S
new file mode 100644
index 0000000..62be921
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/super/resume1_asm.S
@@ -0,0 +1,6 @@
+	.globl	resume1_bin_start
+resume1_bin_start:
+	.incbin	"./super/resume/resume1.code"
+	.globl	resume1_bin_end
+resume1_bin_end:
+	.align	4
\ No newline at end of file
diff --git a/arch/arm/mach-sun6i/pm/standby/super/super_cfg.h b/arch/arm/mach-sun6i/pm/standby/super/super_cfg.h
new file mode 100644
index 0000000..b565c2a
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/super/super_cfg.h
@@ -0,0 +1,33 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : super_cfg.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 14:29
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __SUPER_CFG_H__
+#define __SUPER_CFG_H__
+
+
+//config wakeup source for mem
+#define ALLOW_DISABLE_HOSC          (1)     // if allow disable hosc
+
+#define STANDBY_LDO1_VOL            (1300)  //LDO1 voltage value
+#define STANDBY_LDO2_VOL            (3000)  //LDO2 voltage value
+#define STANDBY_LDO3_VOL            (2800)  //LDO3 voltage value
+#define STANDBY_LDO4_VOL            (3300)  //LDO4 voltage value
+#define STANDBY_DCDC2_VOL           (700)   //DCDC2 voltage value
+#define STANDBY_DCDC3_VOL           (1000)  //DCDC3 voltage value
+
+
+#endif  /* __SUPER_CFG_H__ */
diff --git a/arch/arm/mach-sun6i/pm/standby/super/super_clock.c b/arch/arm/mach-sun6i/pm/standby/super/super_clock.c
new file mode 100644
index 0000000..09a0cd3
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/super/super_clock.c
@@ -0,0 +1,21 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : super_clock.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 13:40
+* Descript: ccmu process for platform mem;
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+
+#include "super_i.h"
+
+
diff --git a/arch/arm/mach-sun6i/pm/standby/super/super_clock.h b/arch/arm/mach-sun6i/pm/standby/super/super_clock.h
new file mode 100644
index 0000000..9cea121
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/super/super_clock.h
@@ -0,0 +1,29 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : super_clock.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 21:05
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __SUPER_CLOCK_H__
+#define __SUPER_CLOCK_H__
+
+#include "super_cfg.h"
+#include <mach/ccmu.h>
+
+#define REGS_BASE_PA	   			(0x01C00000)		//寄存器物理地址
+#define CCMU_REGS_BASE_PA         		(REGS_BASE_PA + 0x20000)    //clock manager unit
+
+extern __u32   cpu_ms_loopcnt;
+
+#endif  /* __SUPER_CLOCK_H__ */
diff --git a/arch/arm/mach-sun6i/pm/standby/super/super_delay.S b/arch/arm/mach-sun6i/pm/standby/super/super_delay.S
new file mode 100644
index 0000000..eba97fa
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/super/super_delay.S
@@ -0,0 +1,25 @@
+#include "./../../pm_config.h"
+
+#define ENABLE_SUPER_STANDBY
+
+#ifdef ENABLE_SUPER_STANDBY
+#define STANDBY_COEFFICIENT (17)
+#else
+#define STANDBY_COEFFICIENT (1)
+#endif
+
+    .text
+    .globl mem_delay
+mem_delay:
+	push    {r0-r3}
+	ldr  	r1, =STANDBY_COEFFICIENT
+	mov	r3, r0
+loop2:
+	subs    r0, r0, #1
+	bhi	loop2
+	mov	r0, r3
+	subs	r1, r1, #1
+	bhi	loop2
+
+	pop     {r0-r3}
+	mov     pc, lr
diff --git a/arch/arm/mach-sun6i/pm/standby/super/super_i.h b/arch/arm/mach-sun6i/pm/standby/super/super_i.h
new file mode 100644
index 0000000..eaaad96
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/super/super_i.h
@@ -0,0 +1,35 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : super_i.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-30 17:21
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __SUPER_I_H__
+#define __SUPER_I_H__
+
+#include "../../pm_config.h"
+#include "../../pm_types.h"
+#include "../../pm.h"
+#include <linux/power/aw_pm.h>
+#include <mach/platform.h>
+
+#include "super_cfg.h"
+#include "common.h"
+#include "super_clock.h"
+#include "super_power.h"
+#include "super_twi.h"
+
+extern struct aw_pm_info  pm_info;
+
+#endif  //__SUPER_I_H__
diff --git a/arch/arm/mach-sun6i/pm/standby/super/super_power.c b/arch/arm/mach-sun6i/pm/standby/super/super_power.c
new file mode 100644
index 0000000..55b2d0d
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/super/super_power.c
@@ -0,0 +1,18 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : super_power.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 14:34
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#include "super_i.h"
diff --git a/arch/arm/mach-sun6i/pm/standby/super/super_power.h b/arch/arm/mach-sun6i/pm/standby/super/super_power.h
new file mode 100644
index 0000000..d088b9d
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/super/super_power.h
@@ -0,0 +1,25 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : super_power.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 14:34
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#ifndef __SUPER_POWER_H__
+#define __SUPER_POWER_H__
+
+#include "super_cfg.h"
+
+
+
+#endif  /* __SUPER_POWER_H__ */
diff --git a/arch/arm/mach-sun6i/pm/standby/super/super_twi.c b/arch/arm/mach-sun6i/pm/standby/super/super_twi.c
new file mode 100644
index 0000000..0fd04c4
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/super/super_twi.c
@@ -0,0 +1,20 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : super_twi.c
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 15:22
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+#include "super_i.h"
+
+#define TWI_CHECK_TIMEOUT       (0xf2ff) //how to decide proper value?
diff --git a/arch/arm/mach-sun6i/pm/standby/super/super_twi.h b/arch/arm/mach-sun6i/pm/standby/super/super_twi.h
new file mode 100644
index 0000000..950be24
--- /dev/null
+++ b/arch/arm/mach-sun6i/pm/standby/super/super_twi.h
@@ -0,0 +1,26 @@
+/*
+*********************************************************************************************************
+*                                                    LINUX-KERNEL
+*                                        AllWinner Linux Platform Develop Kits
+*                                                   Kernel Module
+*
+*                                    (c) Copyright 2006-2011, kevin.z China
+*                                             All Rights Reserved
+*
+* File    : super_twi.h
+* By      : kevin.z
+* Version : v1.0
+* Date    : 2011-5-31 15:22
+* Descript:
+* Update  : date                auther      ver     notes
+*********************************************************************************************************
+*/
+
+#ifndef __SUPER_TWI_H__
+#define __SUPER_TWI_H__
+
+#include "super_cfg.h"
+
+
+
+#endif  /* __SUPER_TWI_H__ */
diff --git a/arch/arm/mach-sun6i/printk.c b/arch/arm/mach-sun6i/printk.c
new file mode 100644
index 0000000..6a522a0
--- /dev/null
+++ b/arch/arm/mach-sun6i/printk.c
@@ -0,0 +1,71 @@
+/*
+ *  arch/arm/mach-$chip/printk.c
+ *
+ *  Copyright (C) 2012 AllWinner Limited
+ *  Benn Huang <benn@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/console.h>
+#include <linux/init.h>
+
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/platform.h>
+
+void aw_put_char(u32 uart_base, u8 val)
+{
+	while (!(readl(IO_ADDRESS(uart_base) + AW_UART_USR) & 0x2));
+	writel(val, IO_ADDRESS(uart_base) + AW_UART_THR);
+}
+
+void aw_put_string(u32 uart_base, char *buf, int n)
+{
+	int len = n;
+	int i = 0;
+
+	for (i=0; i<len; i++) {
+		aw_put_char(uart_base, buf[i]);
+	}
+}
+
+static char aw_printk_buf[4096];
+int aw_printk(u32 uart_base, const char *fmt, ...)
+{
+        int n = 0;
+        va_list ap;
+
+        va_start(ap, fmt);
+        n = vscnprintf(aw_printk_buf, sizeof(aw_printk_buf), fmt, ap);
+        aw_put_string(uart_base, aw_printk_buf, n);
+        va_end(ap);
+        return (int)0;
+}
+
+#if 0
+int printk(const char *fmt, ...)
+{
+        int n = 0;
+        va_list ap;
+
+        va_start(ap, fmt);
+        n = vscnprintf(aw_printk_buf, sizeof(aw_printk_buf), fmt, ap);
+        aw_put_string(0x1c28000, aw_printk_buf, n);
+        va_end(ap);
+        return (int)0;
+}
+#endif
diff --git a/arch/arm/mach-sun6i/rf/Makefile b/arch/arm/mach-sun6i/rf/Makefile
new file mode 100644
index 0000000..7dc8df6
--- /dev/null
+++ b/arch/arm/mach-sun6i/rf/Makefile
@@ -0,0 +1,14 @@
+
+#
+# Makefile for wifi bluetooth power controller drivers
+#
+
+obj-$(CONFIG_MMC)    += wifi_gpio.o
+
+wifi_gpio-y := wifi_pm.o  wifi_pm_bcm40181.o wifi_pm_bcm40183.o \
+	           wifi_pm_rtl8723as.o wifi_pm_rtl8189es.o wifi_pm_rtl8192cu.o \
+	           wifi_pm_rtl8188eu.o wifi_pm_mtk6620.o
+
+obj-$(CONFIG_RFKILL)  += bt_gpio.o
+
+bt_gpio-y := bt_pm.o
\ No newline at end of file
diff --git a/arch/arm/mach-sun6i/rf/bt_pm.c b/arch/arm/mach-sun6i/rf/bt_pm.c
new file mode 100644
index 0000000..708db18
--- /dev/null
+++ b/arch/arm/mach-sun6i/rf/bt_pm.c
@@ -0,0 +1,134 @@
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/rfkill.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <mach/sys_config.h>
+
+#define RF_MSG(...)     do {printk("[rfkill]: "__VA_ARGS__);} while(0)
+
+#if (defined CONFIG_MMC)
+extern int wifi_pm_get_mod_type(void);
+extern int wifi_pm_gpio_ctrl(char* name, int level);
+#else
+static __inline int wifi_pm_get_mod_type(void) {return 0;}
+static __inline int wifi_pm_gpio_ctrl(char* name, int level) {return -1;}
+#endif
+
+static const char bt_name[] = "bcm40183";
+static struct rfkill *sw_rfkill;
+static script_item_u val;
+
+static int rfkill_set_power(void *data, bool blocked)
+{
+    unsigned int mod_sel = wifi_pm_get_mod_type();
+
+    RF_MSG("rfkill set power %d\n", blocked);
+
+    switch (mod_sel)
+    {
+        case 2: /* bcm40183 */
+            if (!blocked) {
+                wifi_pm_gpio_ctrl("bcm40183_bt_regon", 1);
+                wifi_pm_gpio_ctrl("bcm40183_bt_rst", 1);
+            } else {
+                wifi_pm_gpio_ctrl("bcm40183_bt_rst", 0);
+                wifi_pm_gpio_ctrl("bcm40183_bt_regon", 0);
+            }
+            break;
+        case 3: /* realtek rtl8723as */
+            if (!blocked) {
+                wifi_pm_gpio_ctrl("rtk_rtl8723as_bt_dis", 1);
+            } else {
+                wifi_pm_gpio_ctrl("rtk_rtl8723as_bt_dis", 0);
+            }
+            break;
+
+        case 7: /* mtk6620 */
+            RF_MSG("[init] just record bt module select %d !!\n",mod_sel);
+            break;
+        default:
+            RF_MSG("no bt module matched !!\n");
+    }
+
+    msleep(10);
+    return 0;
+}
+
+static struct rfkill_ops sw_rfkill_ops = {
+    .set_block = rfkill_set_power,
+};
+
+static int sw_rfkill_probe(struct platform_device *pdev)
+{
+    int ret = 0;
+
+    sw_rfkill = rfkill_alloc(bt_name, &pdev->dev,
+                        RFKILL_TYPE_BLUETOOTH, &sw_rfkill_ops, NULL);
+    if (unlikely(!sw_rfkill))
+        return -ENOMEM;
+
+    ret = rfkill_register(sw_rfkill);
+    if (unlikely(ret)) {
+        rfkill_destroy(sw_rfkill);
+    }
+    return ret;
+}
+
+static int sw_rfkill_remove(struct platform_device *pdev)
+{
+    if (likely(sw_rfkill)) {
+        rfkill_unregister(sw_rfkill);
+        rfkill_destroy(sw_rfkill);
+    }
+    return 0;
+}
+
+static struct platform_driver sw_rfkill_driver = {
+    .probe = sw_rfkill_probe,
+    .remove = sw_rfkill_remove,
+    .driver = {
+        .name = "sunxi-rfkill",
+        .owner = THIS_MODULE,
+    },
+};
+
+static struct platform_device sw_rfkill_dev = {
+    .name = "sunxi-rfkill",
+};
+
+static int __init sw_rfkill_init(void)
+{
+	script_item_value_type_e type;
+
+	type = script_get_item("bt_para", "bt_used", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
+		RF_MSG("failed to fetch bt configuration!\n");
+		return -1;
+	}
+	if (!val.val) {
+		RF_MSG("init no bt used in configuration\n");
+		return 0;
+	}
+
+    platform_device_register(&sw_rfkill_dev);
+    return platform_driver_register(&sw_rfkill_driver);
+}
+
+static void __exit sw_rfkill_exit(void)
+{
+	if (!val.val) {
+		RF_MSG("exit no bt used in configuration");
+		return ;
+	}
+
+    platform_device_unregister(&sw_rfkill_dev);
+    platform_driver_unregister(&sw_rfkill_driver);
+}
+
+late_initcall(sw_rfkill_init);
+module_exit(sw_rfkill_exit);
+
+MODULE_DESCRIPTION("sunxi-rfkill driver");
+MODULE_AUTHOR("Aaron.magic<mgaic@reuuimllatech.com>");
+MODULE_LICENSE(GPL);
diff --git a/arch/arm/mach-sun6i/rf/wifi_pm.c b/arch/arm/mach-sun6i/rf/wifi_pm.c
new file mode 100644
index 0000000..b63d169
--- /dev/null
+++ b/arch/arm/mach-sun6i/rf/wifi_pm.c
@@ -0,0 +1,270 @@
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <mach/sys_config.h>
+#include <mach/gpio.h>
+#include <linux/proc_fs.h>
+#include "wifi_pm.h"
+
+#define wifi_pm_msg(...)    do {printk("[wifi_pm]: "__VA_ARGS__);} while(0)
+
+
+struct wifi_pm_ops wifi_select_pm_ops;
+static char* wifi_mod[] = {" ",
+	"bcm40181",   /* 1 - BCM40181(BCM4330)*/
+	"bcm40183",   /* 2 - BCM40183(BCM4330)*/
+	"rtl8723as",  /* 3 - RTL8723AS(RF-SM02B) */
+	"rtl8189es",  /* 4 - RTL8189ES(SM89E00) */
+	"rtl8192cu",  /* 5 - RTL8192CU*/
+	"rtl8188eu",  /* 6 - RTL8188EU*/
+	"mtk6620",	  /* 7 - MTK6620() */
+};
+
+int wifi_pm_get_mod_type(void)
+{
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+	if (ops->wifi_used.val)
+		return ops->module_sel.val;
+	else {
+		wifi_pm_msg("No select wifi, please check your config !!\n");
+		return 0;
+	}
+}
+EXPORT_SYMBOL(wifi_pm_get_mod_type);
+
+int wifi_pm_gpio_ctrl(char* name, int level)
+{
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+	if (ops->wifi_used.val && ops->gpio_ctrl)
+		return ops->gpio_ctrl(name, level);
+	else {
+		wifi_pm_msg("No select wifi, please check your config !!\n");
+		return -1;
+	}
+}
+EXPORT_SYMBOL(wifi_pm_gpio_ctrl);
+
+void wifi_pm_power(int on)
+{
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+	int power = on;
+	if (ops->wifi_used.val && ops->power)
+		return ops->power(1, &power);
+	else {
+		wifi_pm_msg("No select wifi, please check your config !!\n");
+		return;
+	}
+}
+EXPORT_SYMBOL(wifi_pm_power);
+
+#ifdef CONFIG_PROC_FS
+static int wifi_pm_power_stat(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	struct wifi_pm_ops *ops = (struct wifi_pm_ops *)data;
+	char *p = page;
+	int power = 0;
+
+	if (ops->power)
+		ops->power(0, &power);
+
+	p += sprintf(p, "%s : power state %s\n", ops->mod_name, power ? "on" : "off");
+	return p - page;
+}
+
+static int wifi_pm_power_ctrl(struct file *file, const char __user *buffer, unsigned long count, void *data)
+{
+    struct wifi_pm_ops *ops = (struct wifi_pm_ops *)data;
+    int power = simple_strtoul(buffer, NULL, 10);
+
+    power = power ? 1 : 0;
+    if (ops->power)
+        ops->power(1, &power);
+    else
+        wifi_pm_msg("No power control for %s\n", ops->mod_name);
+    return sizeof(power);
+}
+
+static inline void awwifi_procfs_attach(void)
+{
+	char proc_rootname[] = "driver/wifi-pm";
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+
+	ops->proc_root = proc_mkdir(proc_rootname, NULL);
+	if (IS_ERR(ops->proc_root))
+	{
+		wifi_pm_msg("failed to create procfs \"driver/wifi-pm\".\n");
+	}
+
+	ops->proc_power = create_proc_entry("power", 0644, ops->proc_root);
+	if (IS_ERR(ops->proc_power))
+	{
+		wifi_pm_msg("failed to create procfs \"power\".\n");
+	}
+	ops->proc_power->data = ops;
+	ops->proc_power->read_proc = wifi_pm_power_stat;
+	ops->proc_power->write_proc = wifi_pm_power_ctrl;
+}
+
+static inline void awwifi_procfs_remove(void)
+{
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+	char proc_rootname[] = "driver/wifi-pm";
+
+	remove_proc_entry("power", ops->proc_root);
+	remove_proc_entry(proc_rootname, NULL);
+}
+#else
+static inline void awwifi_procfs_attach(void) {}
+static inline void awwifi_procfs_remove(void) {}
+#endif
+
+static int wifi_pm_get_res(void)
+{
+	script_item_value_type_e type;
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+
+	type = script_get_item(wifi_para, "wifi_used", &ops->wifi_used);
+	if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
+		wifi_pm_msg("failed to fetch wifi configuration!\n");
+		return -1;
+	}
+	if (!ops->wifi_used.val) {
+		wifi_pm_msg("no wifi used in configuration\n");
+		return -1;
+	}
+
+	type = script_get_item(wifi_para, "wifi_sdc_id", &ops->sdio_id);
+	if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
+		wifi_pm_msg("failed to fetch sdio card's sdcid\n");
+		return -1;
+	}
+
+	type = script_get_item(wifi_para, "wifi_usbc_id", &ops->usb_id);
+	if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
+		wifi_pm_msg("failed to fetch usb's id\n");
+		return -1;
+	}
+
+	type = script_get_item(wifi_para, "wifi_mod_sel", &ops->module_sel);
+	if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
+		wifi_pm_msg("failed to fetch sdio module select\n");
+		return -1;
+	}
+	ops->mod_name = wifi_mod[ops->module_sel.val];
+	printk("[wifi]: select wifi: %s !!\n", wifi_mod[ops->module_sel.val]);
+
+	return 0;
+}
+
+static int __devinit wifi_pm_probe(struct platform_device *pdev)
+{
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+
+	switch (ops->module_sel.val) {
+		case 1: /* BCM40181 */
+			bcm40181_gpio_init();
+			break;
+		case 2: /* BCM40183 */
+			bcm40183_gpio_init();
+			break;
+		case 3: /* RTL8723AS */
+			rtl8723as_gpio_init();
+			break;
+		case 4: /* RTL8189ES */
+			rtl8189es_gpio_init();
+			break;
+		case 5: /* RTL8192CU */
+			rtl8192cu_gpio_init();
+			break;
+		case 6: /* RTL8188EU */
+			rtl8188eu_gpio_init();
+			break;
+		case 7: /* MTK6620 */
+			wifi_pm_msg("[init] just record sdio module select %d !!\n",ops->module_sel.val);
+			mtk6620_gpio_init();
+			break;
+		default:
+			wifi_pm_msg("wrong sdio module select %d !\n", ops->module_sel.val);
+	}
+
+	awwifi_procfs_attach();
+	wifi_pm_msg("wifi gpio init is OK !!\n");
+
+	//wifi_pm_power(1);
+
+	return 0;
+}
+
+static int __devexit wifi_pm_remove(struct platform_device *pdev)
+{
+	awwifi_procfs_remove();
+	wifi_pm_msg("wifi gpio is released !!\n");
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int wifi_pm_suspend(struct device *dev)
+{
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+
+	if (ops->standby)
+		ops->standby(1);
+	return 0;
+}
+
+static int wifi_pm_resume(struct device *dev)
+{
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+
+	if (ops->standby)
+		ops->standby(0);
+	return 0;
+}
+
+static struct dev_pm_ops wifi_dev_pm_ops = {
+	.suspend	= wifi_pm_suspend,
+	.resume		= wifi_pm_resume,
+};
+#endif
+
+static struct platform_device wifi_pm_dev = {
+	.name           = "wifi_pm",
+};
+
+static struct platform_driver wifi_pm_driver = {
+	.driver.name    = "wifi_pm",
+	.driver.owner   = THIS_MODULE,
+#ifdef CONFIG_PM
+	.driver.pm      = &wifi_dev_pm_ops,
+#endif
+	.probe          = wifi_pm_probe,
+	.remove         = __devexit_p(wifi_pm_remove),
+};
+
+static int __init wifi_pm_init(void)
+{
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+
+	memset(ops, 0, sizeof(struct wifi_pm_ops));
+	wifi_pm_get_res();
+	if (!ops->wifi_used.val)
+		return 0;
+
+	platform_device_register(&wifi_pm_dev);
+	return platform_driver_register(&wifi_pm_driver);
+}
+
+static void __exit wifi_pm_exit(void)
+{
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+	if (!ops->wifi_used.val)
+		return;
+
+	memset(ops, 0, sizeof(struct wifi_pm_ops));
+	platform_driver_unregister(&wifi_pm_driver);
+}
+
+module_init(wifi_pm_init);
+module_exit(wifi_pm_exit);
diff --git a/arch/arm/mach-sun6i/rf/wifi_pm.h b/arch/arm/mach-sun6i/rf/wifi_pm.h
new file mode 100644
index 0000000..b7e2790
--- /dev/null
+++ b/arch/arm/mach-sun6i/rf/wifi_pm.h
@@ -0,0 +1,36 @@
+#ifndef WIFI__PM__H
+#define WIFI__PM__H
+
+#include <linux/gpio.h>
+#define SDIO_WIFI_POWERUP   (1)
+#define SDIO_WIFI_INSUSPEND (2)
+static char* wifi_para = "wifi_para";
+
+struct wifi_pm_ops {
+	char*           mod_name;
+	script_item_u   wifi_used;
+	script_item_u   sdio_id;
+	script_item_u   usb_id;
+	script_item_u   module_sel;
+	int             (*gpio_ctrl)(char* name, int level);
+	void            (*standby)(int in);
+	void            (*power)(int mode, int *updown);
+
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry		*proc_root;
+	struct proc_dir_entry		*proc_power;
+#endif
+};
+
+void bcm40181_gpio_init(void);
+void bcm40183_gpio_init(void);
+void rtl8723as_gpio_init(void);
+void rtl8189es_gpio_init(void);
+void rtl8192cu_gpio_init(void);
+void rtl8188eu_gpio_init(void);
+void mtk6620_gpio_init(void);
+
+extern struct wifi_pm_ops wifi_select_pm_ops;
+extern void sw_mci_rescan_card(unsigned id, unsigned insert);
+
+#endif
diff --git a/arch/arm/mach-sun6i/rf/wifi_pm_bcm40181.c b/arch/arm/mach-sun6i/rf/wifi_pm_bcm40181.c
new file mode 100644
index 0000000..c6b1bda
--- /dev/null
+++ b/arch/arm/mach-sun6i/rf/wifi_pm_bcm40181.c
@@ -0,0 +1,125 @@
+/*
+ * bcm40181 sdio wifi power management API
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <mach/sys_config.h>
+#include <mach/gpio.h>
+
+#include "wifi_pm.h"
+
+#define bcm40181_msg(...)    do {printk("[bcm40181]: "__VA_ARGS__);} while(0)
+
+static int bcm40181_powerup = 0;
+static int bcm40181_vdd_en = 0;
+static int bcm40181_vcc_en = 0;
+static int bcm40181_shdn   = 0;
+
+static int bcm40181_gpio_ctrl(char* name, int level)
+{
+	int i = 0, ret = 0, gpio = 0;
+	unsigned long flags = 0;
+	char* gpio_name[3] = {"bcm40181_vdd_en", "bcm40181_vcc_en", "bcm40181_shdn"};
+
+	for (i=0; i<3; i++) {
+		if (strcmp(name, gpio_name[i])==0) {
+			    switch (i)
+			    {
+			        case 0: /* bcm40181_vdd_en */
+						gpio = bcm40181_vdd_en;
+			            break;
+			        case 1: /* bcm40181_vcc_en */
+						gpio = bcm40181_vcc_en;
+			            break;
+					case 2: /* bcm40181_shdn */
+						gpio = bcm40181_shdn;
+						break;
+					default:
+				bcm40181_msg("no matched gpio!\n");
+			    }
+			break;
+		}
+	}
+
+	if (i==3) {
+		bcm40181_msg("No gpio %s for bcm40181-wifi module\n", name);
+		return -1;
+	}
+
+	if (1==level)
+		flags = GPIOF_OUT_INIT_HIGH;
+	else
+		flags = GPIOF_OUT_INIT_LOW;
+
+	ret = gpio_request_one(gpio, flags, NULL);
+	if (ret) {
+		bcm40181_msg("failed to set gpio %d to %d !\n", gpio, level);
+		return -1;
+	} else {
+		gpio_free(gpio);
+		bcm40181_msg("succeed to set gpio %d to %d !\n", gpio, level);
+	}
+
+    if (strcmp(name, "bcm40181_vdd_en") == 0) {
+        bcm40181_powerup = level;
+    }
+
+	return 0;
+}
+
+void bcm40181_power(int mode, int *updown)
+{
+    if (mode) {
+        if (*updown) {
+			bcm40181_gpio_ctrl("bcm40181_vcc_en", 1);
+			udelay(50);
+			bcm40181_gpio_ctrl("bcm40181_vdd_en", 1);
+			udelay(500);
+			bcm40181_gpio_ctrl("bcm40181_shdn", 1);
+        } else {
+			bcm40181_gpio_ctrl("bcm40181_shdn", 0);
+			bcm40181_gpio_ctrl("bcm40181_vdd_en", 0);
+			bcm40181_gpio_ctrl("bcm40181_vcc_en", 0);
+        }
+        bcm40181_msg("sdio wifi power state: %s\n", *updown ? "on" : "off");
+    } else {
+        if (bcm40181_powerup)
+            *updown = 1;
+        else
+            *updown = 0;
+		bcm40181_msg("sdio wifi power state: %s\n", bcm40181_powerup ? "on" : "off");
+    }
+    return;
+}
+
+void bcm40181_gpio_init(void)
+{
+	script_item_u val ;
+	script_item_value_type_e type;
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+
+	bcm40181_msg("exec bcm40181_wifi_gpio_init\n");
+
+	type = script_get_item(wifi_para, "bcm40181_vdd_en", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_PIO!=type)
+		bcm40181_msg("get bcm40181 bcm40181_vdd_en gpio failed\n");
+	else
+		bcm40181_vdd_en = val.gpio.gpio;
+
+	type = script_get_item(wifi_para, "bcm40181_vcc_en", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_PIO!=type)
+		bcm40181_msg("get bcm40181 bcm40181_vcc_en gpio failed\n");
+	else
+		bcm40181_vcc_en = val.gpio.gpio;
+
+	type = script_get_item(wifi_para, "bcm40181_shdn", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_PIO!=type)
+		bcm40181_msg("get bcm40181 bcm40181_shdn gpio failed\n");
+	else
+		bcm40181_shdn = val.gpio.gpio;
+
+	bcm40181_powerup = 0;
+	ops->gpio_ctrl	= bcm40181_gpio_ctrl;
+	ops->power = bcm40181_power;
+}
diff --git a/arch/arm/mach-sun6i/rf/wifi_pm_bcm40183.c b/arch/arm/mach-sun6i/rf/wifi_pm_bcm40183.c
new file mode 100644
index 0000000..fc269e2
--- /dev/null
+++ b/arch/arm/mach-sun6i/rf/wifi_pm_bcm40183.c
@@ -0,0 +1,205 @@
+/*
+ * bcm40183 sdio wifi power management API
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <mach/sys_config.h>
+#include <mach/gpio.h>
+#include <linux/delay.h>
+
+#include "wifi_pm.h"
+
+#define bcm40183_msg(...)    do {printk("[bcm40183]: "__VA_ARGS__);} while(0)
+static int bcm40183_wl_on = 0;
+static int bcm40183_bt_on = 0;
+static int bcm40183_vdd_en = 0;
+static int bcm40183_vcc_en = 0;
+static int bcm40183_wl_regon = 0;
+static int bcm40183_bt_regon = 0;
+static int bcm40183_bt_rst = 0;
+
+static int bcm40183_gpio_ctrl(char* name, int level)
+{
+	int i = 0, ret = 0, gpio = 0;
+	unsigned long flags = 0;
+	char* gpio_name[3] = {"bcm40183_wl_regon", "bcm40183_bt_regon", "bcm40183_bt_rst"};
+
+	for (i=0; i<3; i++) {
+		if (strcmp(name, gpio_name[i])==0) {
+			    switch (i)
+			    {
+			        case 0: /* bcm40183_wl_regon */
+						gpio = bcm40183_wl_regon;
+			            break;
+			        case 1: /* bcm40183_bt_regon */
+						gpio = bcm40183_bt_regon;
+			            break;
+					case 2: /* bcm40183_bt_rst */
+						gpio = bcm40183_bt_rst;
+						break;
+					default:
+				bcm40183_msg("no matched gpio!\n");
+			    }
+			break;
+		}
+	}
+
+	if (i==3) {
+		bcm40183_msg("No gpio %s for BCM40183 module\n", name);
+		return -1;
+	}
+
+	if (1==level)
+		flags = GPIOF_OUT_INIT_HIGH;
+	else
+		flags = GPIOF_OUT_INIT_LOW;
+
+	bcm40183_msg("set GPIO %s to %d !\n", name, level);
+	if (strcmp(name, "bcm40183_wl_regon") == 0) {
+		if (level) {
+			if (bcm40183_bt_on) {
+				bcm40183_msg("BCM40183 is already powered up by bluetooth\n");
+				goto change_state;
+			} else {
+				bcm40183_msg("BCM40183 is powered up by wifi\n");
+				goto power_change;
+			}
+		} else {
+			if (bcm40183_bt_on) {
+				bcm40183_msg("BCM40183 should stay on because of bluetooth\n");
+				goto change_state;
+			} else {
+				bcm40183_msg("BCM40183 is powered off by wifi\n");
+				goto power_change;
+			}
+		}
+	}
+
+	if (strcmp(name, "bcm40183_bt_regon") == 0) {
+		if (level) {
+			if (bcm40183_wl_on) {
+				bcm40183_msg("BCM40183 is already powered up by wifi\n");
+				goto change_state;
+			} else {
+				bcm40183_msg("BCM40183 is powered up by bt\n");
+				goto power_change;
+			}
+		} else {
+			if (bcm40183_wl_on) {
+				bcm40183_msg("BCM40183 should stay on because of wifi\n");
+				goto change_state;
+			} else {
+				bcm40183_msg("BCM40183 is powered off by bt\n");
+				goto power_change;
+			}
+		}
+	}
+
+gpio_state_change:
+
+	ret = gpio_request_one(gpio, flags, NULL);
+	if (ret) {
+		bcm40183_msg("failed to set gpio %d to %d !\n", gpio, level);
+		return -1;
+	} else {
+		gpio_free(gpio);
+		bcm40183_msg("succeed to set gpio %d to %d !\n", gpio, level);
+	}
+
+	return 0;
+
+power_change:
+
+	ret = gpio_request_one(bcm40183_vcc_en, flags, NULL);
+	if (ret) {
+		bcm40183_msg("failed to set gpio bcm40183_vcc_en to %d !\n", level);
+		return -1;
+	} else {
+		gpio_free(bcm40183_vcc_en);
+		bcm40183_msg("succeed to set gpio bcm40183_vcc_en to %d !\n", level);
+	}
+
+	ret = gpio_request_one(bcm40183_vdd_en, flags, NULL);
+	if (ret) {
+		bcm40183_msg("failed to set gpio bcm40183_vdd_en to %d !\n", level);
+		return -1;
+	} else {
+		gpio_free(bcm40183_vdd_en);
+		bcm40183_msg("succeed to set gpio bcm40183_vdd_en to %d !\n", level);
+	}
+
+	udelay(500);
+
+change_state:
+	if (strcmp(name, "bcm40183_wl_regon")==0)
+		bcm40183_wl_on = level;
+	if (strcmp(name, "bcm40183_bt_regon")==0)
+		bcm40183_bt_on = level;
+	bcm40183_msg("BCM40183 power state change: wifi %d, bt %d !!\n", bcm40183_wl_on, bcm40183_bt_on);
+
+	goto gpio_state_change;
+}
+
+static void bcm40183_power(int mode, int *updown)
+{
+	if (mode) {
+		if (*updown) {
+            bcm40183_gpio_ctrl("bcm40183_wl_regon", 1);
+		} else {
+            bcm40183_gpio_ctrl("bcm40183_wl_regon", 0);
+		}
+		bcm40183_msg("sdio wifi power state: %s\n", *updown ? "on" : "off");
+	} else {
+        if (bcm40183_wl_on)
+            *updown = 1;
+        else
+            *updown = 0;
+		bcm40183_msg("sdio wifi power state: %s\n", bcm40183_wl_on ? "on" : "off");
+	}
+	return;
+}
+
+void bcm40183_gpio_init(void)
+{
+	script_item_u val ;
+	script_item_value_type_e type;
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+
+	bcm40183_msg("exec bcm40183_wifi_gpio_init\n");
+
+	type = script_get_item(wifi_para, "bcm40183_vdd_en", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_PIO!=type)
+		bcm40183_msg("get bcm40183 bcm40183_vdd_en gpio failed\n");
+	else
+		bcm40183_vdd_en = val.gpio.gpio;
+
+	type = script_get_item(wifi_para, "bcm40183_vcc_en", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_PIO!=type)
+		bcm40183_msg("get bcm40183 bcm40183_vcc_en gpio failed\n");
+	else
+		bcm40183_vcc_en = val.gpio.gpio;
+
+	type = script_get_item(wifi_para, "bcm40183_wl_regon", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_PIO!=type)
+		bcm40183_msg("get bcm40183 bcm40183_wl_regon gpio failed\n");
+	else
+		bcm40183_wl_regon = val.gpio.gpio;
+
+	type = script_get_item(wifi_para, "bcm40183_bt_regon", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_PIO!=type)
+		bcm40183_msg("get bcm40183 bcm40183_bt_regon gpio failed\n");
+	else
+		bcm40183_bt_regon = val.gpio.gpio;
+
+	type = script_get_item(wifi_para, "bcm40183_bt_rst", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_PIO!=type)
+		bcm40183_msg("get bcm40183 bcm40183_bt_rst gpio failed\n");
+	else
+		bcm40183_bt_rst = val.gpio.gpio;
+
+	bcm40183_wl_on = 0;
+	bcm40183_bt_on = 0;
+	ops->gpio_ctrl	= bcm40183_gpio_ctrl;
+	ops->power = bcm40183_power;
+}
diff --git a/arch/arm/mach-sun6i/rf/wifi_pm_mtk6620.c b/arch/arm/mach-sun6i/rf/wifi_pm_mtk6620.c
new file mode 100644
index 0000000..c766387
--- /dev/null
+++ b/arch/arm/mach-sun6i/rf/wifi_pm_mtk6620.c
@@ -0,0 +1,119 @@
+/*
+ * mtk6620 usb wifi power management API
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <mach/sys_config.h>
+#include <mach/gpio.h>
+#include <linux/regulator/consumer.h>
+#include "wifi_pm.h"
+
+#define mtk6620_msg(...)    do {printk("[mtk6620]: "__VA_ARGS__);} while(0)
+
+static int mtk6620_powerup = 0;
+static int mtk6620_suspend = 0;
+static char * axp_name = NULL;
+
+// power control by axp
+static int mtk6620_module_power(int onoff)
+{
+	struct regulator* wifi_ldo = NULL;
+	static int first = 1;
+	int ret = 0;
+
+	mtk6620_msg("mtk6620 module power set by axp.\n");
+	wifi_ldo = regulator_get(NULL, axp_name);
+	if (!wifi_ldo) {
+		mtk6620_msg("get power regulator failed.\n");
+		return -ret;
+	}
+
+	if (onoff) {
+		mtk6620_msg("regulator on.\n");
+		ret = regulator_set_voltage(wifi_ldo, 3000000, 3000000);
+		if (ret < 0) {
+			mtk6620_msg("regulator_set_voltage fail, return %d.\n", ret);
+			goto out;
+		}
+
+		ret = regulator_enable(wifi_ldo);
+		if (ret < 0) {
+			mtk6620_msg("regulator_enable fail, return %d.\n", ret);
+			goto out;
+		}
+	} else {
+		mtk6620_msg("regulator off.\n");
+		ret = regulator_disable(wifi_ldo);
+		if (ret < 0) {
+			mtk6620_msg("regulator_disable fail, return %d.\n", ret);
+			goto out;
+		}
+	}
+out:
+	regulator_put(wifi_ldo);
+	wifi_ldo = NULL;
+	return ret;
+}
+
+void mtk6620_power(int mode, int *updown)
+{
+    if (mode) {
+        if (*updown) {
+			mtk6620_module_power(1);
+			udelay(50);
+			mtk6620_powerup = 1;
+        } else {
+			mtk6620_module_power(0);
+			mtk6620_powerup = 0;
+        }
+        mtk6620_msg("mtk6620 wifi power state: %s\n", *updown ? "on" : "off");
+    } else {
+        if (mtk6620_powerup)
+            *updown = 1;
+        else
+            *updown = 0;
+		mtk6620_msg("usb wifi power state: %s\n", mtk6620_powerup ? "on" : "off");
+    }
+    return;
+}
+
+static void mtk6620_standby(int instadby)
+{
+	if (instadby) {
+		if (mtk6620_powerup) {
+			/*can't poweroff axp_dldo2 because mtk6620 VRTC pin links it. fix by huzhen2013-1-23*/
+			//mtk6620_module_power(0);
+			mtk6620_suspend = 1;
+		}
+	} else {
+		if (mtk6620_suspend) {
+			//mtk6620_module_power(1);
+			mtk6620_suspend = 0;
+		}
+	}
+	mtk6620_msg("usb wifi : %s\n", instadby ? "suspend" : "resume");
+}
+
+void mtk6620_gpio_init(void)
+{
+	script_item_u val;
+	script_item_value_type_e type;
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+
+	mtk6620_msg("exec mtk6620_wifi_gpio_init\n");
+
+	type = script_get_item(wifi_para, "wifi_power", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_STR != type) {
+		mtk6620_msg("failed to fetch wifi_power\n");
+		return ;
+	}
+
+	axp_name = val.str;
+	mtk6620_msg("module power name %s\n", axp_name);
+
+	mtk6620_powerup = 0;
+	mtk6620_suspend = 0;
+	ops->power     = mtk6620_power;
+	ops->standby   = mtk6620_standby;
+}
diff --git a/arch/arm/mach-sun6i/rf/wifi_pm_rtl8188eu.c b/arch/arm/mach-sun6i/rf/wifi_pm_rtl8188eu.c
new file mode 100644
index 0000000..5a5f233
--- /dev/null
+++ b/arch/arm/mach-sun6i/rf/wifi_pm_rtl8188eu.c
@@ -0,0 +1,136 @@
+/*
+ * rtl8188eu usb wifi power management API
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <mach/sys_config.h>
+#include <mach/gpio.h>
+#include <linux/regulator/consumer.h>
+#include "wifi_pm.h"
+
+#define rtl8188eu_msg(...)    do {printk("[rtl8188eu]: "__VA_ARGS__);} while(0)
+
+static int rtl8188eu_powerup = 0;
+static int rtk8188eu_suspend = 0;
+static char * axp_name = NULL;
+
+// power control by axp
+static int rtl8188eu_module_power(int onoff)
+{
+	struct regulator* wifi_ldo = NULL;
+	static int first = 1;
+	int ret = 0;
+
+	rtl8188eu_msg("rtl8188eu module power set by axp.\n");
+	wifi_ldo = regulator_get(NULL, axp_name);
+	if (!wifi_ldo) {
+		rtl8188eu_msg("get power regulator failed.\n");
+		return -ret;
+	}
+
+	if (first) {
+		rtl8188eu_msg("first time\n");
+		ret = regulator_force_disable(wifi_ldo);
+		if (ret < 0) {
+			rtl8188eu_msg("regulator_force_disable fail, return %d.\n", ret);
+			regulator_put(wifi_ldo);
+			return ret;
+		}
+		regulator_put(wifi_ldo);
+		first = 0;
+		return ret;
+	}
+
+	if (onoff) {
+		rtl8188eu_msg("regulator on.\n");
+		ret = regulator_set_voltage(wifi_ldo, 3300000, 3300000);
+		if (ret < 0) {
+			rtl8188eu_msg("regulator_set_voltage fail, return %d.\n", ret);
+			regulator_put(wifi_ldo);
+			return ret;
+		}
+
+		ret = regulator_enable(wifi_ldo);
+		if (ret < 0) {
+			rtl8188eu_msg("regulator_enable fail, return %d.\n", ret);
+			regulator_put(wifi_ldo);
+			return ret;
+		}
+	} else {
+		rtl8188eu_msg("regulator off.\n");
+		ret = regulator_disable(wifi_ldo);
+		if (ret < 0) {
+			rtl8188eu_msg("regulator_disable fail, return %d.\n", ret);
+			regulator_put(wifi_ldo);
+			return ret;
+		}
+	}
+	regulator_put(wifi_ldo);
+	return ret;
+}
+
+void rtl8188eu_power(int mode, int *updown)
+{
+    if (mode) {
+        if (*updown) {
+			rtl8188eu_module_power(1);
+			udelay(50);
+			rtl8188eu_powerup = 1;
+        } else {
+			rtl8188eu_module_power(0);
+			rtl8188eu_powerup = 0;
+        }
+        rtl8188eu_msg("usb wifi power state: %s\n", *updown ? "on" : "off");
+    } else {
+        if (rtl8188eu_powerup)
+            *updown = 1;
+        else
+            *updown = 0;
+		rtl8188eu_msg("usb wifi power state: %s\n", rtl8188eu_powerup ? "on" : "off");
+    }
+    return;
+}
+
+static void rtl8188eu_standby(int instadby)
+{
+	if (instadby) {
+		if (rtl8188eu_powerup) {
+			rtl8188eu_module_power(0);
+			rtk8188eu_suspend = 1;
+		}
+	} else {
+		if (rtk8188eu_suspend) {
+			rtl8188eu_module_power(1);
+			rtk8188eu_suspend = 0;
+		}
+	}
+	rtl8188eu_msg("usb wifi : %s\n", instadby ? "suspend" : "resume");
+}
+
+void rtl8188eu_gpio_init(void)
+{
+	script_item_u val;
+	script_item_value_type_e type;
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+
+	rtl8188eu_msg("exec rtl8188eu_wifi_gpio_init\n");
+
+	type = script_get_item(wifi_para, "wifi_power", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_STR != type) {
+		rtl8188eu_msg("failed to fetch wifi_power\n");
+		return ;
+	}
+
+	axp_name = val.str;
+	rtl8188eu_msg("module power name %s\n", axp_name);
+
+	rtl8188eu_powerup = 0;
+	rtk8188eu_suspend = 0;
+	ops->power     = rtl8188eu_power;
+	ops->standby   = rtl8188eu_standby;
+
+	// force to disable wifi power in system booting,
+	// make sure wifi power is down when system start up
+	rtl8188eu_module_power(0);
+}
diff --git a/arch/arm/mach-sun6i/rf/wifi_pm_rtl8189es.c b/arch/arm/mach-sun6i/rf/wifi_pm_rtl8189es.c
new file mode 100644
index 0000000..e72e6bd
--- /dev/null
+++ b/arch/arm/mach-sun6i/rf/wifi_pm_rtl8189es.c
@@ -0,0 +1,170 @@
+/*
+ * rtl8189es sdio wifi power management API
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <mach/sys_config.h>
+#include <mach/gpio.h>
+#include <linux/regulator/consumer.h>
+#include "wifi_pm.h"
+
+#define rtl8189es_msg(...)    do {printk("[rtl8189es]: "__VA_ARGS__);} while(0)
+
+static int rtl8189es_powerup = 0;
+static int rtl8189es_suspend = 0;
+static int rtl8189es_shdn = 0;
+static char * axp_name = NULL;
+
+// power control by axp
+static int rtl8189es_module_power(int onoff)
+{
+	struct regulator* wifi_ldo = NULL;
+	static int first = 1;
+	int ret = 0;
+
+	rtl8189es_msg("rtl8189es module power set by axp.\n");
+	wifi_ldo = regulator_get(NULL, axp_name);
+	if (!wifi_ldo) {
+		rtl8189es_msg("get power regulator failed.\n");
+		return -ret;
+	}
+
+	if (first) {
+		rtl8189es_msg("first time\n");
+		ret = regulator_force_disable(wifi_ldo);
+		if (ret < 0) {
+			rtl8189es_msg("regulator_force_disable fail, return %d.\n", ret);
+			regulator_put(wifi_ldo);
+			return ret;
+		}
+		regulator_put(wifi_ldo);
+		first = 0;
+		return ret;
+	}
+
+	if (onoff) {
+		rtl8189es_msg("regulator on.\n");
+		ret = regulator_set_voltage(wifi_ldo, 3300000, 3300000);
+		if (ret < 0) {
+			rtl8189es_msg("regulator_set_voltage fail, return %d.\n", ret);
+			regulator_put(wifi_ldo);
+			return ret;
+		}
+
+		ret = regulator_enable(wifi_ldo);
+		if (ret < 0) {
+			rtl8189es_msg("regulator_enable fail, return %d.\n", ret);
+			regulator_put(wifi_ldo);
+			return ret;
+		}
+	} else {
+		rtl8189es_msg("regulator off.\n");
+		ret = regulator_disable(wifi_ldo);
+		if (ret < 0) {
+			rtl8189es_msg("regulator_disable fail, return %d.\n", ret);
+			regulator_put(wifi_ldo);
+			return ret;
+		}
+	}
+	regulator_put(wifi_ldo);
+	return ret;
+}
+
+static int rtl8189es_gpio_ctrl(char* name, int level)
+{
+	int ret = 0;
+	unsigned long flags = 0;
+
+	if (1==level)
+		flags = GPIOF_OUT_INIT_HIGH;
+	else
+		flags = GPIOF_OUT_INIT_LOW;
+
+	ret = gpio_request_one(rtl8189es_shdn, flags, NULL);
+	if (ret) {
+		rtl8189es_msg("failed to set gpio %s to %d !\n", name, level);
+		return -1;
+	} else {
+		gpio_free(rtl8189es_shdn);
+		rtl8189es_msg("succeed to set gpio %s to %d !\n", name, level);
+	}
+
+	rtl8189es_powerup = level;
+
+	return 0;
+}
+
+static void rtl8189es_standby(int instadby)
+{
+	if (instadby) {
+		if (rtl8189es_powerup) {
+			rtl8189es_gpio_ctrl("rtl8189es_shdn", 0);
+			rtl8189es_module_power(0);
+			rtl8189es_suspend = 1;
+		}
+	} else {
+		if (rtl8189es_suspend) {
+			rtl8189es_module_power(1);
+			udelay(500);
+			rtl8189es_gpio_ctrl("rtl8189es_shdn", 1);
+			rtl8189es_suspend = 0;
+		}
+	}
+	rtl8189es_msg("sdio wifi : %s\n", instadby ? "suspend" : "resume");
+}
+
+static void rtl8189es_power(int mode, int *updown)
+{
+    if (mode) {
+        if (*updown) {
+			rtl8189es_module_power(1);
+			udelay(500);
+			rtl8189es_gpio_ctrl("rtl8189es_shdn", 1);
+        } else {
+			rtl8189es_gpio_ctrl("rtl8189es_shdn", 0);
+			rtl8189es_module_power(0);
+        }
+        rtl8189es_msg("sdio wifi power state: %s\n", *updown ? "on" : "off");
+    } else {
+        if (rtl8189es_powerup)
+            *updown = 1;
+        else
+            *updown = 0;
+		rtl8189es_msg("sdio wifi power state: %s\n", rtl8189es_powerup ? "on" : "off");
+    }
+    return;
+}
+
+void rtl8189es_gpio_init(void)
+{
+	script_item_u val ;
+	script_item_value_type_e type;
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+
+	rtl8189es_msg("exec rtl8189es_wifi_gpio_init\n");
+
+	type = script_get_item(wifi_para, "wifi_power", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_STR != type) {
+		rtl8189es_msg("failed to fetch wifi_power\n");
+		return ;
+	}
+
+	axp_name = val.str;
+
+	type = script_get_item(wifi_para, "rtl8189es_shdn", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_PIO!=type)
+		rtl8189es_msg("get rtl8189es rtl8189es_shdn gpio failed\n");
+	else
+		rtl8189es_shdn = val.gpio.gpio;
+
+	rtl8189es_powerup = 0;
+	rtl8189es_suspend = 0;
+	ops->standby 	  = rtl8189es_standby;
+	ops->power 		  = rtl8189es_power;
+
+	// force to disable wifi power in system booting,
+	// make sure wifi power is down when system start up
+	rtl8189es_module_power(0);
+}
diff --git a/arch/arm/mach-sun6i/rf/wifi_pm_rtl8192cu.c b/arch/arm/mach-sun6i/rf/wifi_pm_rtl8192cu.c
new file mode 100644
index 0000000..2572b3f
--- /dev/null
+++ b/arch/arm/mach-sun6i/rf/wifi_pm_rtl8192cu.c
@@ -0,0 +1,134 @@
+/*
+ * rtl8192cu usb wifi power management API
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <mach/sys_config.h>
+#include <mach/gpio.h>
+#include <linux/regulator/consumer.h>
+#include "wifi_pm.h"
+
+#define rtl8192cu_msg(...)    do {printk("[rtl8192cu]: "__VA_ARGS__);} while(0)
+
+static int rtl8192cu_powerup = 0;
+static int rtk8192cu_suspend = 0;
+static char * axp_name = NULL;
+
+// power control by axp
+static int rtl8192cu_module_power(int onoff)
+{
+	struct regulator* wifi_ldo = NULL;
+	static int first = 1;
+	int ret = 0;
+
+	rtl8192cu_msg("rtl8192cu module power set by axp.\n");
+	wifi_ldo = regulator_get(NULL, axp_name);
+	if (!wifi_ldo) {
+		rtl8192cu_msg("get power regulator failed.\n");
+		return -ret;
+	}
+
+	if (first) {
+		rtl8192cu_msg("first time\n");
+		ret = regulator_force_disable(wifi_ldo);
+		if (ret < 0) {
+			rtl8192cu_msg("regulator_force_disable fail, return %d.\n", ret);
+			regulator_put(wifi_ldo);
+			return ret;
+		}
+		regulator_put(wifi_ldo);
+		first = 0;
+		return ret;
+	}
+
+	if (onoff) {
+		rtl8192cu_msg("regulator on.\n");
+		ret = regulator_set_voltage(wifi_ldo, 3300000, 3300000);
+		if (ret < 0) {
+			rtl8192cu_msg("regulator_set_voltage fail, return %d.\n", ret);
+			regulator_put(wifi_ldo);
+			return ret;
+		}
+
+		ret = regulator_enable(wifi_ldo);
+		if (ret < 0) {
+			rtl8192cu_msg("regulator_enable fail, return %d.\n", ret);
+			regulator_put(wifi_ldo);
+			return ret;
+		}
+	} else {
+		rtl8192cu_msg("regulator off.\n");
+		ret = regulator_disable(wifi_ldo);
+		if (ret < 0) {
+			rtl8192cu_msg("regulator_disable fail, return %d.\n", ret);
+			regulator_put(wifi_ldo);
+			return ret;
+		}
+	}
+	regulator_put(wifi_ldo);
+	return ret;
+}
+
+void rtl8192cu_power(int mode, int *updown)
+{
+    if (mode) {
+        if (*updown) {
+			rtl8192cu_module_power(1);
+			udelay(50);
+			rtl8192cu_powerup = 1;
+        } else {
+			rtl8192cu_module_power(0);
+			rtl8192cu_powerup = 0;
+        }
+        rtl8192cu_msg("usb wifi power state: %s\n", *updown ? "on" : "off");
+    } else {
+        if (rtl8192cu_powerup)
+            *updown = 1;
+        else
+            *updown = 0;
+		rtl8192cu_msg("usb wifi power state: %s\n", rtl8192cu_powerup ? "on" : "off");
+    }
+    return;
+}
+
+static void rtl8192cu_standby(int instadby)
+{
+	if (instadby) {
+		if (rtl8192cu_powerup) {
+			rtl8192cu_module_power(0);
+			rtk8192cu_suspend = 1;
+		}
+	} else {
+		if (rtk8192cu_suspend) {
+			rtl8192cu_module_power(1);
+			rtk8192cu_suspend = 0;
+		}
+	}
+	rtl8192cu_msg("usb wifi : %s\n", instadby ? "suspend" : "resume");
+}
+
+void rtl8192cu_gpio_init(void)
+{
+	script_item_u val;
+	script_item_value_type_e type;
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+
+	rtl8192cu_msg("exec rtl8192cu_wifi_gpio_init\n");
+
+	type = script_get_item(wifi_para, "wifi_power", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_STR != type) {
+		rtl8192cu_msg("failed to fetch wifi_power\n");
+		return ;
+	}
+
+	axp_name = val.str;
+	rtl8192cu_powerup = 0;
+	rtk8192cu_suspend = 0;
+	ops->power     = rtl8192cu_power;
+	ops->standby   = rtl8192cu_standby;
+
+	// force to disable wifi power in system booting,
+	// make sure wifi power is down when system start up
+	rtl8192cu_module_power(0);
+}
diff --git a/arch/arm/mach-sun6i/rf/wifi_pm_rtl8723as.c b/arch/arm/mach-sun6i/rf/wifi_pm_rtl8723as.c
new file mode 100644
index 0000000..f9db734
--- /dev/null
+++ b/arch/arm/mach-sun6i/rf/wifi_pm_rtl8723as.c
@@ -0,0 +1,247 @@
+/*
+ * rtl8723as sdio wifi power management API
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <mach/sys_config.h>
+#include <mach/gpio.h>
+#include <linux/regulator/consumer.h>
+
+#include "wifi_pm.h"
+
+#define SDIO_MODULE_NAME "RTL8723AS"
+#define rtl8723as_msg(...)    do {printk("[RTL8723AS]: "__VA_ARGS__);} while(0)
+static int rtl8723as_wl_on = 0;
+static int rtl8723as_bt_on = 0;
+static int rtk_suspend = 0;
+static int rtk_rtl8723as_wl_dis = 0;
+static int rtk_rtl8723as_bt_dis = 0;
+static char * axp_name = NULL;
+static bool axp_power_on = false;
+
+static int rtl8723as_module_power(int onoff)
+{
+	struct regulator* wifi_ldo = NULL;
+	static int first = 1;
+	int ret = 0;
+
+	rtl8723as_msg("rtl8723as module power set by axp.\n");
+	wifi_ldo = regulator_get(NULL, axp_name);
+	if (!wifi_ldo) {
+		rtl8723as_msg("get power regulator failed.\n");
+		return -ret;
+	}
+
+	if (first) {
+		rtl8723as_msg("first time\n");
+		ret = regulator_force_disable(wifi_ldo);
+		if (ret < 0) {
+			rtl8723as_msg("regulator_force_disable fail, return %d.\n", ret);
+			regulator_put(wifi_ldo);
+			return ret;
+		}
+		regulator_put(wifi_ldo);
+		first = 0;
+		return ret;
+	}
+
+	if (onoff) {
+		if (axp_power_on == false) {
+			rtl8723as_msg("regulator on.\n");
+			ret = regulator_set_voltage(wifi_ldo, 3300000, 3300000);
+			if (ret < 0) {
+				rtl8723as_msg("regulator_set_voltage fail, return %d.\n", ret);
+			regulator_put(wifi_ldo);
+				return ret;
+			}
+
+			ret = regulator_enable(wifi_ldo);
+			if (ret < 0) {
+				rtl8723as_msg("regulator_enable fail, return %d.\n", ret);
+			regulator_put(wifi_ldo);
+				return ret;
+			}
+			axp_power_on = true;
+		}
+	} else {
+		if (axp_power_on == true) {
+			rtl8723as_msg("regulator off.\n");
+			ret = regulator_disable(wifi_ldo);
+			if (ret < 0) {
+				rtl8723as_msg("regulator_disable fail, return %d.\n", ret);
+			regulator_put(wifi_ldo);
+				return ret;
+			}
+			axp_power_on = false;
+		}
+	}
+	regulator_put(wifi_ldo);
+	return ret;
+}
+
+static int rtl8723as_gpio_ctrl(char* name, int level)
+{
+	int i = 0, ret = 0, gpio = 0;
+	unsigned long flags = 0;
+	char* gpio_name[2] = {"rtk_rtl8723as_wl_dis", "rtk_rtl8723as_bt_dis"};
+
+	for (i=0; i<2; i++) {
+		if (strcmp(name, gpio_name[i])==0) {
+			    switch (i)
+			    {
+			        case 0: /* rtk_rtl8723as_wl_dis */
+						gpio = rtk_rtl8723as_wl_dis;
+			            break;
+					case 1: /* rtk_rtl8723as_bt_dis */
+						gpio = rtk_rtl8723as_bt_dis;
+						break;
+					default:
+				rtl8723as_msg("no matched gpio!\n");
+			    }
+			break;
+		}
+	}
+
+	if (i==2) {
+		rtl8723as_msg("No gpio %s for %s module\n", name, SDIO_MODULE_NAME);
+		return -1;
+	}
+
+	if (1==level)
+		flags = GPIOF_OUT_INIT_HIGH;
+	else
+		flags = GPIOF_OUT_INIT_LOW;
+
+	rtl8723as_msg("Set GPIO %s to %d !\n", name, level);
+	if (strcmp(name, "rtk_rtl8723as_wl_dis") == 0) {
+		if ((level && !rtl8723as_bt_on)	|| (!level && !rtl8723as_bt_on)) {
+			rtl8723as_msg("%s is powered %s by wifi\n", SDIO_MODULE_NAME, level ? "up" : "down");
+			goto power_change;
+		} else {
+			if (level) {
+				rtl8723as_msg("%s is already on by bt\n", SDIO_MODULE_NAME);
+			} else {
+				rtl8723as_msg("%s should stay on because of bt\n", SDIO_MODULE_NAME);
+			}
+			goto state_change;
+		}
+	}
+	if (strcmp(name, "rtk_rtl8723as_bt_dis") == 0) {
+		if ((level && !rtl8723as_wl_on && !rtl8723as_bt_on)	|| (!level && !rtl8723as_wl_on)) {
+			rtl8723as_msg("%s is powered %s by bt\n", SDIO_MODULE_NAME, level ? "up" : "down");
+			goto power_change;
+		} else {
+			if (level) {
+				rtl8723as_msg("%s is already on by %s\n", SDIO_MODULE_NAME, rtl8723as_bt_on ? "bt" : "wifi");
+			} else {
+				rtl8723as_msg("%s should stay on because of wifi\n", SDIO_MODULE_NAME);
+			}
+			goto state_change;
+		}
+	}
+
+gpio_state_change:
+
+	ret = gpio_request_one(gpio, flags, NULL);
+	if (ret) {
+		rtl8723as_msg("failed to set gpio %s to %d !\n", name, level);
+		return -1;
+	} else {
+		gpio_free(gpio);
+		rtl8723as_msg("succeed to set gpio %s to %d !\n", name, level);
+	}
+
+	return 0;
+
+power_change:
+
+	rtl8723as_module_power(level);
+	udelay(500);
+
+state_change:
+	if (strcmp(name, "rtk_rtl8723as_wl_dis")==0)
+		rtl8723as_wl_on = level;
+	if (strcmp(name, "rtk_rtl8723as_bt_dis")==0)
+		rtl8723as_bt_on = level;
+	rtl8723as_msg("%s power state change: wifi %d, bt %d !!\n", SDIO_MODULE_NAME, rtl8723as_wl_on, rtl8723as_bt_on);
+
+	goto gpio_state_change;
+}
+
+void rtl8723as_power(int mode, int *updown)
+{
+    if (mode) {
+        if (*updown) {
+		rtl8723as_gpio_ctrl("rtk_rtl8723as_wl_dis", 1);
+        } else {
+		rtl8723as_gpio_ctrl("rtk_rtl8723as_wl_dis", 0);
+        }
+        rtl8723as_msg("sdio wifi power state: %s\n", *updown ? "on" : "off");
+    } else {
+        if (rtl8723as_wl_on)
+            *updown = 1;
+        else
+            *updown = 0;
+		rtl8723as_msg("sdio wifi power state: %s\n", rtl8723as_wl_on ? "on" : "off");
+    }
+    return;
+}
+
+static void rtl8723as_standby(int instadby)
+{
+	if (instadby) {
+		if (rtl8723as_wl_on) {
+			rtl8723as_gpio_ctrl("rtk_rtl8723as_wl_dis", 0);
+			rtk_suspend = 1;
+		}
+	} else {
+		if (rtk_suspend) {
+			rtl8723as_gpio_ctrl("rtk_rtl8723as_wl_dis", 1);
+			rtk_suspend = 0;
+		}
+	}
+	rtl8723as_msg("sdio wifi : %s\n", instadby ? "suspend" : "resume");
+}
+
+void rtl8723as_gpio_init(void)
+{
+	script_item_u val ;
+	script_item_value_type_e type;
+	struct wifi_pm_ops *ops = &wifi_select_pm_ops;
+
+	rtl8723as_msg("exec rt8723as_wifi_gpio_init\n");
+
+	type = script_get_item(wifi_para, "wifi_power", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_STR != type) {
+		rtl8723as_msg("failed to fetch wifi_power\n");
+		return ;
+	}
+	axp_name = val.str;
+
+	type = script_get_item(wifi_para, "rtk_rtl8723as_wl_dis", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_PIO!=type)
+		rtl8723as_msg("get rtl8723as rtk_rtl8723as_wl_dis gpio failed\n");
+	else
+		rtk_rtl8723as_wl_dis = val.gpio.gpio;
+
+	type = script_get_item(wifi_para, "rtk_rtl8723as_bt_dis", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_PIO!=type)
+		rtl8723as_msg("get rtl8723as rtk_rtl8723as_bt_dis gpio failed\n");
+	else
+		rtk_rtl8723as_bt_dis = val.gpio.gpio;
+
+	rtl8723as_wl_on = 0;
+	rtl8723as_bt_on = 0;
+	rtk_suspend 	= 0;
+	ops->gpio_ctrl	= rtl8723as_gpio_ctrl;
+	ops->power 	= rtl8723as_power;
+	ops->standby	= rtl8723as_standby;
+
+	// force to disable wifi power in system booting,
+	// make sure wifi power is down when system start up
+	rtl8723as_module_power(0);
+}
+
+#undef SDIO_MODULE_NAME
diff --git a/arch/arm/mach-sun6i/sunxi_dump_reg.c b/arch/arm/mach-sun6i/sunxi_dump_reg.c
new file mode 100644
index 0000000..5710aaa
--- /dev/null
+++ b/arch/arm/mach-sun6i/sunxi_dump_reg.c
@@ -0,0 +1,831 @@
+/*
+ * arch/arm/mach-sun6i/sunxi_dump_reg.c
+ * (C) Copyright 2010-2015
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * liugang <liugang@reuuimllatech.com>
+ *
+ * sunxi dump sysfs driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/kdev_t.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/miscdevice.h>
+
+#include <mach/platform.h>
+#include <mach/hardware.h>
+#include <mach/sunxi_dump_reg.h>
+
+#define ADD_MISC_DRIVER		/* add misc driver, for open("/sys/class/...") call */
+
+typedef struct __dump_struct {
+	u32 	st_addr;	/* start reg addr */
+	u32 	ed_addr;	/* end reg addr */
+}dump_struct;
+
+/* for sunxi_dump class */
+static dump_struct dump_para;
+struct compare_group *cmp_group = NULL;
+struct write_group *wt_group = NULL;
+/* for sunxi-reg misc driver */
+static dump_struct misc_dump_para;
+struct compare_group *misc_cmp_group = NULL;
+struct write_group *misc_wt_group = NULL;
+
+#define VADDR(x)	((x) - PLAT_PHYS_OFFSET + PAGE_OFFSET)
+
+u32 addr_table[][2] = {
+	{AW_IO_PHYS_BASE,		AW_IO_PHYS_BASE + AW_IO_SIZE		},
+	{AW_SRAM_A1_BASE,		AW_SRAM_A1_BASE + AW_SRAM_A1_SIZE	},
+	{AW_SRAM_A2_BASE, 		AW_SRAM_A2_BASE + AW_SRAM_A2_SIZE	},
+	{AW_BROM_BASE,			AW_BROM_BASE 	+ AW_BROM_SIZE		},
+	{PLAT_PHYS_OFFSET,		PLAT_PHYS_OFFSET + SZ_1G		},
+
+	{IO_ADDRESS(AW_IO_PHYS_BASE),	IO_ADDRESS(AW_IO_PHYS_BASE) + AW_IO_SIZE	},
+	{IO_ADDRESS(AW_SRAM_A1_BASE),	IO_ADDRESS(AW_SRAM_A1_BASE) + AW_SRAM_A1_SIZE	},
+	{IO_ADDRESS(AW_SRAM_A2_BASE), 	IO_ADDRESS(AW_SRAM_A2_BASE) + AW_SRAM_A2_SIZE	},
+	{IO_ADDRESS(AW_BROM_BASE),	IO_ADDRESS(AW_BROM_BASE) + AW_BROM_SIZE		},
+	{VADDR(PLAT_PHYS_OFFSET), 	VADDR(PLAT_PHYS_OFFSET) + SZ_1G	-1	}, /* -1 to avoid overflow */
+};
+
+/**
+ * __addr_valid - check if the addr is valid
+ * @addr: addr to judge
+ *
+ * return true if the addr is register addr, false if not.
+ */
+bool __addr_valid(u32 addr)
+{
+	int i;
+	for(i = 0; i < ARRAY_SIZE(addr_table); i++)
+		if(addr >= addr_table[i][0] && addr < addr_table[i][1])
+			return true;
+	return false;
+}
+
+u32 __get_vaddr(u32 addr)
+{
+	int i, offset;
+	for(i = 0; i < ARRAY_SIZE(addr_table) / 2; i++) {
+		if(addr >= addr_table[i][0] && addr < addr_table[i][1]) {
+			offset = addr - addr_table[i][0];
+			i += (ARRAY_SIZE(addr_table) / 2);
+			return addr_table[i][0] + offset;
+		}
+	}
+	return addr;
+}
+#define VA(x) 			__get_vaddr(x)
+#define R(x) 			readl(VA(x))
+#define W(v,a) 			writel((v),VA(a))
+
+/**
+ * first_str_to_int - convert substring of pstr to int, the substring is
+ * 		from hed_addrd of pstr to the first occurance of ch in pstr
+ * @pstr: the string to convert
+ * @ch: a char in pstr
+ * @pout: store the convert result
+ *
+ * return the first occurance of ch in pstr on success, NULL if failed.
+ */
+char * __first_str_to_u32(char *pstr, char ch, u32 *pout)
+{
+	char 	*pret = NULL;
+	char 	str_tmp[260] = {0};
+
+	pret = strchr(pstr, ch);
+	if(NULL != pret) {
+		memcpy(str_tmp, pstr, pret - pstr);
+		if(strict_strtoul(str_tmp, 16, (long unsigned int *)pout)) {
+			printk(KERN_ERR "%s err, line %d\n", __func__, __LINE__);
+			return NULL;
+		}
+	} else
+		*pout = 0;
+
+	return pret;
+}
+
+/**
+ * __parse_dump_str - parse the input string for dump attri.
+ * @buf:     the input string, eg: "0x01c20000,0x01c20300".
+ * @size:    buf size.
+ * @start:   store the start reg's addr parsed from buf, eg 0x01c20000.
+ * @end:     store the end reg's addr parsed from buf, eg 0x01c20300.
+ *
+ * return 0 if success, otherwise failed.
+ */
+int __parse_dump_str(const char *buf, size_t size, u32 *start, u32 *end)
+{
+	char 	*ptr = (char *)buf;
+
+	if(NULL == strchr(ptr, ',')) { /* only one reg to dump */
+		if(strict_strtoul(ptr, 16, (long unsigned int *)start))
+			return -EINVAL;
+		*end = *start;
+		return 0;
+	}
+
+	ptr = __first_str_to_u32(ptr, ',', start);
+	if(NULL == ptr)
+		return -EINVAL;
+
+	ptr += 1;
+	if(strict_strtoul(ptr, 16, (long unsigned int *)end))
+		return -EINVAL;
+
+	return 0;
+}
+
+/**
+ * __sunxi_dump_regs_ex - dump a range of registers' value, copy to buf.
+ * @start_reg:   address of start reg.
+ * @end_reg:     address of end reg.
+ * @buf:         store the dump info.
+ *
+ * return bytes written to buf, <=0 indicate err
+ */
+ssize_t __sunxi_dump_regs_ex(u32 start_reg, u32 end_reg, char *buf)
+{
+	int 	i;
+	ssize_t cnt = 0;
+	u32 	first_addr = 0, end_addr = 0;
+
+	if(!__addr_valid(start_reg) || !__addr_valid(end_reg) || NULL == buf) {
+		printk(KERN_ERR "%s err, invalid para, start 0x%08x, end 0x%08x, buf 0x%08x\n", __func__, start_reg, end_reg, (u32)buf);
+		return -EIO;
+	}
+	/* only one to dump */
+	if(start_reg == end_reg)
+		//return sprintf(buf, "0x%08x: 0x%08x\n", start_reg, R(start_reg));
+		return sprintf(buf, "0x%08x\n", R(start_reg)); /* for open("/sys/class/...") app call */
+
+	first_addr = start_reg & (~0xf);
+	end_addr   = (end_reg   & (~0xf)) + 0xf;
+	cnt += sprintf(buf, "0x%08x: ", first_addr);
+	for(i = first_addr; i < end_addr; i += 4) {
+		if(i < start_reg || i > end_reg)
+			cnt += sprintf(buf + cnt, "           "); /* "0x12345678 ", 11 space*/
+		else
+			cnt += sprintf(buf + cnt, "0x%08x ", R(i));
+
+		if((i & 0xc) == 0xc) {
+			cnt += sprintf(buf + cnt, "\n");
+			if(i + 4 < end_addr) /* avoid the last blank line */
+				cnt += sprintf(buf + cnt, "0x%08x: ", i + 4);
+		}
+	}
+	printk(KERN_INFO "%s, start 0x%08x, end 0x%08x, return %d\n", __func__, start_reg, end_reg, cnt);
+	return cnt;
+}
+
+/**
+ * dump_show - show func of dump attribute.
+ * @dev:     class ptr.
+ * @attr:    attribute ptr.
+ * @buf:     the input buf which contain the start and end reg. eg: "0x01c20000,0x01c20100\n"
+ *
+ * return size written to the buf, otherwise failed
+ */
+ssize_t dump_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return __sunxi_dump_regs_ex(dump_para.st_addr, dump_para.ed_addr, buf);
+}
+
+/**
+ * dump_store - store func of dump attribute.
+ * @class:   class ptr.
+ * @attr:    attribute ptr.
+ * @buf:     the input buf which contain the start and end reg. eg: "0x01c20000,0x01c20100\n"
+ * @size:    buf size.
+ *
+ * return size if success, otherwise failed
+ */
+ssize_t dump_store(struct class *class, struct class_attribute *attr,
+			const char *buf, size_t size)
+{
+	u32 	start_reg = 0, end_reg = 0;
+
+	if(0 != __parse_dump_str((char *)buf, size, &start_reg, &end_reg)) {
+		printk(KERN_ERR "%s err, invalid para, __parse_dump_str failed\n", __func__);
+		goto err;
+	}
+	//printk(KERN_INFO "%s: get start_reg 0x%08x, end_reg 0x%08x\n", __func__, start_reg, end_reg);
+	if(!__addr_valid(start_reg) || !__addr_valid(end_reg)) {
+		printk(KERN_ERR "%s err, invalid para, the addr is not reg\n", __func__);
+		goto err;
+	}
+
+	dump_para.st_addr = start_reg;
+	dump_para.ed_addr = end_reg;
+	return size;
+err:
+	dump_para.st_addr = dump_para.ed_addr = 0;
+	return -EINVAL;
+}
+
+/**
+ * __parse_compare_str - parse the input string for compare attri.
+ * @str:     string to be parsed, eg: "0x01c20000 0x80000011 0x00000011".
+ * @reg_addr:   store the reg address. eg: 0x01c20000.
+ * @val_expect: store the expect value. eg: 0x80000011.
+ * @val_mask:   store the mask value. eg: 0x00000011.
+ *
+ * return 0 if success, otherwise failed.
+ */
+int __parse_compare_str(char *str, u32 *reg_addr,
+		u32 *val_expect, u32 *val_mask)
+{
+	char *ptr = str;
+
+	ptr = __first_str_to_u32(ptr, ' ', reg_addr);
+	if(NULL == ptr)
+		return -EINVAL;
+
+	ptr += 1;
+	ptr = __first_str_to_u32(ptr, ' ', val_expect);
+	if(NULL == ptr)
+		return -EINVAL;
+
+	ptr += 1;
+	if(strict_strtoul(ptr, 16, (long unsigned int *)val_mask))
+		return -EINVAL;
+
+	return 0;
+}
+
+/**
+ * __compare_item_init - init for compare attri. parse input string, and construct compare struct.
+ * @buf:     the input string, eg: "0x01c20000 0x80000011 0x00000011,0x01c20004 0x0000c0a4 0x0000c0a0...".
+ * @size:    buf size.
+ * @ppgroup: store the struct allocated, the struct contains items parsed from input buf.
+ *
+ * return 0 if success, otherwise failed.
+ */
+int __compare_item_init(const char *buf, size_t size, struct compare_group **ppgroup)
+{
+	int 	i = 0;
+	char 	str_temp[256] = {0};
+	char 	*ptr = NULL, *ptr2 = NULL;
+	u32 	reg_addr = 0, val_expect = 0, val_mask = 0;
+	struct compare_group *pgroup = NULL;
+
+	/* alloc item buffer */
+	pgroup = kmalloc(sizeof(struct compare_group), GFP_KERNEL);
+	if(NULL == pgroup)
+		return -EINVAL;
+	pgroup->pitem = kmalloc(sizeof(struct compare_item) * MAX_COMPARE_ITEM, GFP_KERNEL);
+	if(NULL == pgroup->pitem) {
+		kfree(pgroup);
+		return -EINVAL;
+	}
+
+	pgroup->num = 0;
+
+	/* get item from buf */
+	ptr = (char *)buf;
+	while((ptr2 = strchr(ptr, ',')) != NULL) {
+		i = ptr2 - ptr;
+		memcpy(str_temp, ptr, i);
+		str_temp[i] = 0;
+		if(0 != __parse_compare_str(str_temp, &reg_addr, &val_expect, &val_mask))
+			printk(KERN_ERR "%s err, line %d, str_temp %s\n", __func__, __LINE__, str_temp);
+		else {
+			//printk(KERN_DEBUG "%s: reg_addr 0x%08x, val_expect 0x%08x, val_mask 0x%08x\n",
+			//	__func__, reg_addr, val_expect, val_mask);
+			if(pgroup->num < MAX_COMPARE_ITEM) {
+				if(!__addr_valid(reg_addr)) {
+					printk(KERN_ERR "%s(%d) err, addr 0x%08x invalid!\n", __func__, __LINE__, reg_addr);
+					pgroup->num = 0;
+					goto end;
+				}
+				pgroup->pitem[pgroup->num].reg_addr = reg_addr;
+				pgroup->pitem[pgroup->num].val_expect = val_expect;
+				pgroup->pitem[pgroup->num].val_mask = val_mask;
+				pgroup->num++;
+			} else {
+				printk(KERN_ERR "%s err, line %d, pgroup->num %d exceed %d\n",
+					__func__, __LINE__, pgroup->num, MAX_COMPARE_ITEM);
+				break;
+			}
+		}
+
+		ptr = ptr2 + 1;
+	}
+
+	/* the last item */
+	if(0 != __parse_compare_str(ptr, &reg_addr, &val_expect, &val_mask))
+		printk(KERN_ERR "%s err, line %d, ptr %s\n", __func__, __LINE__, ptr);
+	else {
+		//printk(KERN_DEBUG "%s: line %d, reg_addr 0x%08x, val_expect 0x%08x, val_mask 0x%08x\n",
+		//	__func__, __LINE__, reg_addr, val_expect, val_mask);
+		if(pgroup->num < MAX_COMPARE_ITEM) {
+			if(!__addr_valid(reg_addr)) {
+				printk(KERN_ERR "%s(%d) err, addr 0x%08x invalid!\n", __func__, __LINE__, reg_addr);
+				pgroup->num = 0;
+				goto end;
+			}
+			pgroup->pitem[pgroup->num].reg_addr = reg_addr;
+			pgroup->pitem[pgroup->num].val_expect = val_expect;
+			pgroup->pitem[pgroup->num].val_mask = val_mask;
+			pgroup->num++;
+		}
+	}
+
+end:
+	/* free buffer if no valid item */
+	if(0 == pgroup->num) {
+		kfree(pgroup->pitem);
+		kfree(pgroup);
+		return -EINVAL;
+	}
+
+	*ppgroup = pgroup;
+	return 0;
+}
+
+/**
+ * __compare_item_deinit - reled_addrse memory that cred_addrted by __compare_item_init.
+ * @pgroup: the compare struct allocated in __compare_item_init.
+ */
+void __compare_item_deinit(struct compare_group *pgroup)
+{
+	if(NULL != pgroup) {
+		if(NULL != pgroup->pitem)
+			kfree(pgroup->pitem);
+		kfree(pgroup);
+	}
+}
+
+ssize_t __sunxi_compare_regs_ex(struct compare_group *pgroup, char *buf)
+{
+	int 	i = 0;
+	ssize_t cnt = 0;
+	u32 	reg = 0, expect = 0, actual = 0, mask = 0;
+
+	if(NULL == pgroup) {
+		printk(KERN_ERR "%s err, line %d, pgroup is NULL\n", __func__, __LINE__);
+		goto end;
+	}
+	cnt += sprintf(buf, "reg         expect      actual      mask        result\n");
+	for(i = 0; i < pgroup->num; i++) {
+		reg    = pgroup->pitem[i].reg_addr;
+		expect = pgroup->pitem[i].val_expect;
+		actual = R(reg);
+		mask   = pgroup->pitem[i].val_mask;
+		if((actual & mask) == (expect & mask))
+			cnt += sprintf(buf + cnt, "0x%08x  0x%08x  0x%08x  0x%08x  OK\n", reg, expect, actual, mask);
+		else
+			cnt += sprintf(buf + cnt, "0x%08x  0x%08x  0x%08x  0x%08x  ERR\n", reg, expect, actual, mask);
+	}
+end:
+	return cnt;
+}
+
+ssize_t compare_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	/* dump the items */
+	return __sunxi_compare_regs_ex(cmp_group, buf);
+}
+
+/**
+ * compare_store - store func of compare attribute.
+ * @class:   class ptr.
+ * @attr:    attribute ptr.
+ * @buf:     the input buf which contain the items to compared.
+ * 		eg: "0x01c20000 0x01c20100\n"
+ * @size:    buf size.
+ */
+ssize_t compare_store(struct class *class, struct class_attribute *attr,
+			const char *buf, size_t size)
+{
+	/* free if struct not null */
+	if(NULL != cmp_group) {
+		__compare_item_deinit(cmp_group);
+		cmp_group = NULL;
+	}
+	/* parse input buf for items that will be dumped */
+	if(__compare_item_init(buf, size, &cmp_group) < 0)
+		return -EINVAL;
+	return size;
+}
+
+/**
+ * __parse_write_str - parse the input string for write attri.
+ * @str:     string to be parsed, eg: "0x01c20818 0x55555555".
+ * @reg_addr:   store the reg address. eg: 0x01c20818.
+ * @val: store the expect value. eg: 0x55555555.
+ *
+ * return 0 if success, otherwise failed.
+ */
+int __parse_write_str(char *str, u32 *reg_addr, u32 *val)
+{
+	char *ptr = str;
+
+	ptr = __first_str_to_u32(ptr, ' ', reg_addr);
+	if(NULL == ptr)
+		return -EINVAL;
+
+	ptr += 1;
+	if(strict_strtoul(ptr, 16, (long unsigned int *)val))
+		return -EINVAL;
+
+	return 0;
+}
+
+/**
+ * __write_item_init - init for write attri. parse input string, and construct write struct.
+ * @buf:     the input string, eg: "0x01c20800 0x00000031,0x01c20818 0x55555555,...".
+ * @size:    buf size.
+ * @ppgroup: store the struct allocated, the struct contains items parsed from input buf.
+ *
+ * return 0 if success, otherwise failed.
+ */
+int __write_item_init(const char *buf, size_t size, struct write_group **ppgroup)
+{
+	int 	i = 0;
+	char 	str_temp[256] = {0};
+	char 	*ptr = NULL, *ptr2 = NULL;
+	u32 	reg_addr = 0, val;
+	struct write_group *pgroup = NULL;
+
+	/* alloc item buffer */
+	pgroup = kmalloc(sizeof(struct write_group), GFP_KERNEL);
+	if(NULL == pgroup)
+		return -EINVAL;
+	pgroup->pitem = kmalloc(sizeof(struct write_item) * MAX_WRITE_ITEM, GFP_KERNEL);
+	if(NULL == pgroup->pitem) {
+		kfree(pgroup);
+		return -EINVAL;
+	}
+
+	pgroup->num = 0;
+
+	/* get item from buf */
+	ptr = (char *)buf;
+	while((ptr2 = strchr(ptr, ',')) != NULL) {
+		i = ptr2 - ptr;
+		memcpy(str_temp, ptr, i);
+		str_temp[i] = 0;
+		if(0 != __parse_write_str(str_temp, &reg_addr, &val))
+			printk(KERN_ERR "%s err, line %d, str_temp %s\n", __func__, __LINE__, str_temp);
+		else {
+			//printk(KERN_DEBUG "%s: reg_addr 0x%08x, val 0x%08x\n", __func__, reg_addr, val);
+			if(pgroup->num < MAX_WRITE_ITEM) {
+				if(!__addr_valid(reg_addr)) {
+					printk(KERN_ERR "%s(%d) err, addr 0x%08x invalid!\n", __func__, __LINE__, reg_addr);
+					pgroup->num = 0;
+					goto end;
+				}
+				pgroup->pitem[pgroup->num].reg_addr = reg_addr;
+				pgroup->pitem[pgroup->num].val = val;
+				pgroup->num++;
+			} else {
+				printk(KERN_ERR "%s err, line %d, pgroup->num %d exceed %d\n",
+					__func__, __LINE__, pgroup->num, MAX_WRITE_ITEM);
+				break;
+			}
+		}
+
+		ptr = ptr2 + 1;
+	}
+
+	/* the last item */
+	if(0 != __parse_write_str(ptr, &reg_addr, &val))
+		printk(KERN_ERR "%s err, line %d, ptr %s\n", __func__, __LINE__, ptr);
+	else {
+		//printk(KERN_DEBUG "%s: line %d, reg_addr 0x%08x, val 0x%08x\n", __func__, __LINE__, reg_addr, val);
+		if(pgroup->num < MAX_WRITE_ITEM) {
+			if(!__addr_valid(reg_addr)) {
+				printk(KERN_ERR "%s(%d) err, addr 0x%08x invalid!\n", __func__, __LINE__, reg_addr);
+				pgroup->num = 0;
+				goto end;
+			}
+			pgroup->pitem[pgroup->num].reg_addr = reg_addr;
+			pgroup->pitem[pgroup->num].val = val;
+			pgroup->num++;
+		}
+	}
+
+end:
+	/* free buffer if no valid item */
+	if(0 == pgroup->num) {
+		kfree(pgroup->pitem);
+		kfree(pgroup);
+		return -EINVAL;
+	}
+
+	*ppgroup = pgroup;
+	return 0;
+}
+
+/**
+ * __write_item_deinit - reled_addrse memory that cred_addrted by __write_item_init.
+ * @pgroup: the write struct allocated in __write_item_init.
+ */
+void __write_item_deinit(struct write_group *pgroup)
+{
+	if(NULL != pgroup) {
+		if(NULL != pgroup->pitem)
+			kfree(pgroup->pitem);
+		kfree(pgroup);
+	}
+}
+
+ssize_t __sunxi_write_show(struct write_group *pgroup, char *buf)
+{
+	int 	i = 0;
+	ssize_t cnt = 0;
+	u32 	reg = 0, val = 0, red_addrdback = 0;
+
+	if(NULL == pgroup) {
+		printk(KERN_ERR "%s err, line %d, pgroup is NULL\n", __func__, __LINE__);
+		goto end;
+	}
+	cnt += sprintf(buf, "reg         to_write    after_write \n");
+	for(i = 0; i < pgroup->num; i++) {
+		reg    	= pgroup->pitem[i].reg_addr;
+		val 	= pgroup->pitem[i].val;
+		red_addrdback = R(reg);
+		cnt += sprintf(buf + cnt, "0x%08x  0x%08x  0x%08x\n", reg, val, red_addrdback);
+	}
+end:
+	return cnt;
+}
+
+ssize_t write_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	/* display write result */
+	return __sunxi_write_show(wt_group, buf);
+}
+
+/**
+ * write_store - store func of dump attribute.
+ * @class:   class ptr.
+ * @attr:    attribute ptr.
+ * @buf:     the input buf which contain reg&val to write.
+ * 		eg: "0x01c20800 0x00000031,0x01c20818 0x55555555,...\n"
+ * @size:    buf size.
+ */
+ssize_t write_store(struct class *class, struct class_attribute *attr,
+			const char *buf, size_t size)
+{
+	int i = 0;
+	u32 reg = 0, val= 0;
+
+	/* free if not NULL */
+	if(NULL != wt_group) {
+		__write_item_deinit(wt_group);
+		wt_group = NULL;
+	}
+	/* parse input buf for items that will be dumped */
+	if(__write_item_init(buf, size, &wt_group) < 0)
+		return -EINVAL;
+	/* write reg */
+	for(i = 0; i < wt_group->num; i++) {
+		reg    	= wt_group->pitem[i].reg_addr;
+		val 	= wt_group->pitem[i].val;
+		W(val, reg);
+	}
+
+	return size;
+}
+
+static struct class_attribute dump_class_attrs[] = {
+	__ATTR(dump, 	0664, dump_show, dump_store),
+	__ATTR(compare,	0664, compare_show, compare_store),
+	__ATTR(write,	0664, write_show, write_store),
+	__ATTR_NULL,
+};
+
+static struct class dump_class = {
+	.name		= "sunxi_dump",
+	.owner		= THIS_MODULE,
+	.class_attrs	= dump_class_attrs,
+};
+
+static int __init sunxi_dump_init(void)
+{
+	int	status;
+
+	status = class_register(&dump_class);
+	if(status < 0)
+		printk(KERN_ERR "%s err, status %d\n", __func__, status);
+	else
+		printk(KERN_DEBUG "%s success\n", __func__);
+
+	return status;
+}
+postcore_initcall(sunxi_dump_init);
+
+/**
+ * sunxi_write_regs - write a group of regs' value.
+ * @pgroup: the write struct which contain items that will be write.
+ */
+void sunxi_write_regs(struct write_group *pgroup)
+{
+	int 	i = 0;
+	u32 	reg = 0, val = 0, red_addrdback = 0;
+
+	printk("reg         to_write    after_write \n");
+	for(i = 0; i < pgroup->num; i++) {
+		reg    	= pgroup->pitem[i].reg_addr;
+		val 	= pgroup->pitem[i].val;
+		W(val, reg);
+		red_addrdback = R(reg);
+		printk("0x%08x  0x%08x  0x%08x\n", reg, val, red_addrdback);
+	}
+}
+EXPORT_SYMBOL(sunxi_write_regs);
+
+/**
+ * sunxi_compare_regs - dump values for compare items.
+ * @pgroup: the compare struct which contain items that will be dumped.
+ */
+void sunxi_compare_regs(struct compare_group *pgroup)
+{
+	int 	i = 0;
+	u32 	reg = 0, expect = 0, actual = 0, mask = 0;
+
+	printk("reg         expect      actual      mask        result\n");
+	for(i = 0; i < pgroup->num; i++) {
+		reg    = pgroup->pitem[i].reg_addr;
+		expect = pgroup->pitem[i].val_expect;
+		actual = R(reg);
+		mask   = pgroup->pitem[i].val_mask;
+		if((actual & mask) == (expect & mask))
+			printk("0x%08x  0x%08x  0x%08x  0x%08x  OK\n", reg, expect, actual, mask);
+		else
+			printk("0x%08x  0x%08x  0x%08x  0x%08x  ERR\n", reg, expect, actual, mask);
+	}
+}
+EXPORT_SYMBOL(sunxi_compare_regs);
+
+/**
+ * sunxi_dump_regs - dump a range of registers' value.
+ * @start_reg:   address of start reg.
+ * @end_reg:     address of end reg.
+ */
+void sunxi_dump_regs(u32 start_reg, u32 end_reg)
+{
+	int 	i;
+	u32 	first_addr = 0, end_addr = 0;
+
+	if(start_reg == end_reg) { /* only one to dump */
+		printk("0x%08x: 0x%08x\n", start_reg, R(start_reg));
+		return;
+	}
+
+	first_addr = start_reg & (~0xf);
+	end_addr   = end_reg   & (~0xf);
+
+	printk("0x%08x: ", first_addr);
+
+	for(i = first_addr; i < end_addr + 0xf; i += 4) {
+		if(i < start_reg || i > end_reg)
+			printk("           "); /* "0x12345678 ", 11 space*/
+		else
+			printk("0x%08x ", R(i));
+
+		if((i & 0xc) == 0xc) {
+			printk("\n");
+			if(i + 4 < end_addr + 0xf) /* avoid the last blank line */
+				printk("0x%08x: ", i + 4);
+		}
+	}
+}
+EXPORT_SYMBOL(sunxi_dump_regs);
+
+#ifdef ADD_MISC_DRIVER
+static ssize_t misc_dump_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return __sunxi_dump_regs_ex(misc_dump_para.st_addr, misc_dump_para.ed_addr, buf);
+}
+static ssize_t misc_dump_store(struct device *dev,struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	u32 	start_reg = 0, end_reg = 0;
+
+	if(0 != __parse_dump_str((char *)buf, size, &start_reg, &end_reg)) {
+		printk(KERN_ERR "%s err, invalid para, __parse_dump_str failed\n", __func__);
+		goto err;
+	}
+	if(!__addr_valid(start_reg) || !__addr_valid(end_reg)) {
+		printk(KERN_ERR "%s err, invalid para, the addr is not reg\n", __func__);
+		goto err;
+	}
+
+	misc_dump_para.st_addr = start_reg;
+	misc_dump_para.ed_addr = end_reg;
+	printk(KERN_INFO "%s: get start_reg 0x%08x, end_reg 0x%08x\n", __func__, start_reg, end_reg);
+	return size;
+err:
+	misc_dump_para.st_addr = misc_dump_para.ed_addr = 0;
+	return -EINVAL;
+}
+
+static ssize_t misc_compare_store(struct device *dev,struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	/* free if struct not null */
+	if(NULL != misc_cmp_group) {
+		__compare_item_deinit(misc_cmp_group);
+		misc_cmp_group = NULL;
+	}
+	/* parse input buf for items that will be dumped */
+	if(__compare_item_init(buf, size, &misc_cmp_group) < 0)
+		return -EINVAL;
+	return size;
+}
+
+static ssize_t misc_compare_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	/* dump the items */
+	return __sunxi_compare_regs_ex(misc_cmp_group, buf);
+}
+static ssize_t misc_write_store(struct device *dev,struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	int i = 0;
+	u32 reg = 0, val= 0;
+
+	/* free if not NULL */
+	if(NULL != misc_wt_group) {
+		__write_item_deinit(misc_wt_group);
+		misc_wt_group = NULL;
+	}
+	/* parse input buf for items that will be dumped */
+	if(__write_item_init(buf, size, &misc_wt_group) < 0)
+		return -EINVAL;
+	/* write reg */
+	for(i = 0; i < misc_wt_group->num; i++) {
+		reg    	= misc_wt_group->pitem[i].reg_addr;
+		val 	= misc_wt_group->pitem[i].val;
+		W(val, reg);
+	}
+
+	return size;
+}
+static ssize_t misc_write_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	/* display write result */
+	return __sunxi_write_show(misc_wt_group, buf);
+}
+
+static DEVICE_ATTR(dump, 0664, misc_dump_show, misc_dump_store);
+static DEVICE_ATTR(compare, 0664, misc_compare_show, misc_compare_store);
+static DEVICE_ATTR(write, 0664, misc_write_show, misc_write_store);
+static struct attribute *misc_attributes[] = {
+	&dev_attr_dump.attr,
+	&dev_attr_compare.attr,
+	&dev_attr_write.attr,
+	NULL
+};
+static struct attribute_group misc_attribute_group = {
+	.name  = "rw",
+	.attrs = misc_attributes
+};
+static struct miscdevice sunxi_reg_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name  = "sunxi-reg",
+};
+
+static int __init sunxi_reg_init(void) {
+	int 	err;
+
+	printk(KERN_INFO "sunxi_reg_init enter\n");
+	err = misc_register(&sunxi_reg_dev);
+	if(err) {
+		printk(KERN_ERR "%s register sunxi debug register driver as misc device error\n", __func__);
+		goto exit;
+	}
+
+	err = sysfs_create_group(&sunxi_reg_dev.this_device->kobj, &misc_attribute_group);
+	if(err)
+		printk("%s err: sysfs_create_group failed\n", __func__);
+exit:
+	return err;
+}
+
+static void __exit sunxi_reg_exit(void) {
+	printk("sunxi_reg_exit enter\n");
+	WARN_ON(0 != misc_deregister(&sunxi_reg_dev));
+	sysfs_remove_group(&sunxi_reg_dev.this_device->kobj, &misc_attribute_group);
+}
+
+module_init(sunxi_reg_init);
+module_exit(sunxi_reg_exit);
+#endif /* ADD_MISC_DRIVER */
diff --git a/arch/arm/mach-sun6i/sys_config.c b/arch/arm/mach-sun6i/sys_config.c
new file mode 100644
index 0000000..68e3d7c
--- /dev/null
+++ b/arch/arm/mach-sun6i/sys_config.c
@@ -0,0 +1,571 @@
+/*
+ * arch/arch/mach-sun6i/sys_config.c
+ * (C) Copyright 2010-2015
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * sys_config utils (porting from 2.6.36)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/string.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <mach/sys_config.h>
+#include <mach/gpio.h>
+#include <linux/slab.h>
+
+#define SCRIPT_MALLOC(x)	kzalloc((x), GFP_KERNEL)
+#define SCRIPT_FREE(x)		kfree(x)
+
+/*
+ * define origin main key data structure in cript buffer
+ * @name: main key name, defined left of "="
+ * @items: count of sub key
+ * @offset: position of the value of main key, in dword
+ */
+#pragma pack(1)
+typedef struct
+{
+    char name[32];
+    int  sub_cnt;
+    int  offset;
+} script_origin_main_key_t;
+#pragma pack()
+
+/*
+ * define origin sub key data structure in cript buffer
+ * @name: sub key name, defined left of "="
+ * @offset: sub key value position, in dword
+ * @type: type of sub key, int / string / gpio
+ * @cnt:  length of the value area, in dword
+ */
+#pragma pack(1)
+typedef struct
+{
+    char name[32];
+    int  offset;
+    struct {
+        u32 cnt : 16;
+        u32 type: 16;
+    }pattern;
+} script_origin_sub_key_t;
+#pragma pack()
+
+/*
+ * define origin header of the script in cript buffer
+ * @main_cnt: count of main keys
+ * @version: script version
+ * @main_key: fist main key
+ */
+#pragma pack(1)
+typedef struct
+{
+    int  main_cnt;
+    int  version[3];
+    script_origin_main_key_t    main_key;
+} script_origin_head_t;
+#pragma pack()
+
+/*
+ * define origin gpio data structure in cript buffer
+ * @gpio_name: gpio name, defined left of '='
+ * @port: gpio port number, 1-PA, 2-PB, 3-PC, ...
+ * @port_num: pin number in port, 0-Px0, 1-Px1, ...
+ * @mul_sel: multi-function select
+ * @pull: pin status,
+ * @drv_level: drive level
+ * @data: gpio data value
+ */
+#pragma pack(1)
+typedef struct {
+    char    gpio_name[32];
+    int     port;
+    int     port_num;
+    int     mul_sel;
+    int     pull;
+    int     drv_level;
+    int     data;
+} script_origin_gpio_t;
+#pragma pack()
+
+/*
+ *===========================================================================================================
+ * origin script defined as follows:
+ *
+ * |-----------------------|
+ * |@main-cnt |@version[3] |
+ * |-----------------------|
+ * | origin main key 0:    |
+ * | @name[32]             |
+ * | @sub_cnt              |
+ * | @offset   ------------|-----
+ * |-----------------------|    |
+ * | origin main key 1:    |    |
+ * | @name[32]             |    |
+ * | @sub_cnt              |    |
+ * | @offset               |    |
+ * |-----------------------|    |
+ * | origin main key 2:    |    |
+ * |      ......           |    |
+ *                              |
+ *                              |
+ *                              |
+ * |-----------------------|    |
+ * | origin sub key 0:     |<---|
+ * | @name                 |
+ * | @offset   ------------|----|
+ * | @type                 |    |
+ * |-----------------------|    |
+ * | origin sub key 0:     |    |
+ * | @name                 |    |
+ * | @offset               |    |
+ * | @type                 |    |
+ * |-----------------------|    |
+ * | origin sub key 0:     |    |
+ * |    ......             |    |
+ *                              |
+ *                              |
+ *                              |
+ * |-----------------------|    |
+ * | origin sub key value: |<---|
+ * |    ......             |
+ *
+ *
+ *
+ *===========================================================================================================
+ * script parse result organized as follows:
+ *
+ * |-----------------------|
+ * | script_main_key_t     |
+ * | @name[]               |
+ * | @subkey      ---------|-------------------------------------------->|-----------------------|
+ * | @subkey_val  ---------|------->|-----------------------|            | script_sub_key_t      |
+ * | @gpio    -------------|------->| script_item_u         |<-----|     | @name[]               |
+ * | @gpio_cnt             |        | @val                  |      ------|-@value                |
+ * | @hash                 |        | @str                  |            | @type                 |
+ * | @next      -----------|----    | @gpio                 |            | @hash                 |
+ * |-----------------------|   |    |-----------------------|            | @next    -------------|---|
+ * | script_main_key_t     |<--|    | script_item_u         |<----|      |-----------------------|   |
+ * | @name[]               |        | @val                  |     |      | script_sub_key_t      |<--|
+ * | @subkey               |        | @str                  |--|  |      | @name[]               |
+ * | @subkey_val           |        | @gpio                 |  |  -------|-@value                |
+ * | @gpio                 |        |-----------------------|  |         | @type                 |
+ * | @gpio_cnt             |        | script_item_u         |  |         | @hash                 |
+ * | @hash                 |        | @val                  |  |         | @next                 |
+ * | @next                 |        | @str                  |  |         |-----------------------|
+ * |-----------------------|        | @gpio                 |  |         | script_sub_key_t      |
+ * | main key 2:           |        |-----------------------|  |         |  ......               |
+ * |    ......             |        | script_item_u         |  |
+ *                                  | ......                |  |
+ *                                                             |--------->|-----------------------|
+ *                                                                        | string                |
+ *                                                                        |-----------------------|
+ *===========================================================================================================
+ */
+
+#define SCRIPT_NAME_SIZE_MAX    (32)
+
+/*
+ * define script item management data
+ * @name: item name, which is defined left of '='
+ * @value: value of the item
+ * @type: type of the item, interge / string / gpio?
+ * @hash: hash value of sub key name, for searching quickly
+ * @next: pointer for list
+ */
+typedef struct {
+    char                        name[SCRIPT_NAME_SIZE_MAX];
+    script_item_u               *value;
+    script_item_value_type_e    type;
+    int                         hash;
+    void                        *next;
+} script_sub_key_t;
+
+/*
+ * define script main key management data
+ * @name: main key name, which is defined by '[]'
+ * @subkey: sub key list
+ * @subkey_val: buffer for save sub keys
+ * @gpio: gpio list pointer
+ * @gpio_cnt: gpio conter
+ * @hash: hash value of sub key name, for searching quickly
+ * @next: pointer for list
+ */
+typedef struct {
+    char                name[SCRIPT_NAME_SIZE_MAX];
+    script_sub_key_t    *subkey;
+    script_item_u       *subkey_val;
+    script_item_u       *gpio;
+    int                 gpio_cnt;
+    int                 hash;
+    void                *next;
+} script_main_key_t;
+
+/*
+ * define script sub key type, raw from sys_config.bin
+ * @SCIRPT_PARSER_VALUE_TYPE_INVALID: invalid type
+ * @SCIRPT_PARSER_VALUE_TYPE_SINGLE_WORD: int item type
+ * @SCIRPT_PARSER_VALUE_TYPE_STRING: string item type
+ * @SCIRPT_PARSER_VALUE_TYPE_MULTI_WORD: multi int type, not used currently
+ * @SCIRPT_PARSER_VALUE_TYPE_GPIO_WORD: gpio item type
+ */
+typedef enum {
+	SCIRPT_PARSER_VALUE_TYPE_INVALID = 0,
+	SCIRPT_PARSER_VALUE_TYPE_SINGLE_WORD,
+	SCIRPT_PARSER_VALUE_TYPE_STRING,
+	SCIRPT_PARSER_VALUE_TYPE_MULTI_WORD,
+	SCIRPT_PARSER_VALUE_TYPE_GPIO_WORD
+} script_parser_value_type_t;
+
+static script_main_key_t   *g_script;
+
+static int hash(char *string)
+{
+    int     hash = 0;
+
+    if(!string) {
+        return 0;
+    }
+
+    while(*string){
+        hash += *string;
+	string++;
+    }
+
+    return hash;
+}
+
+/**
+ * port_to_index - gpio port to global index, port is from script
+ * @port: gpio port group index, eg: 1 for PA, 2 for PB..., -1(0xFFFF) for axp pin
+ * @port_num: port index in gpio group, eg: 0 for PA0, 1 for PA1...
+ *
+ * return the gpio index for the port, GPIO_INDEX_INVALID indicate err
+ */
+u32 port_to_index(u32 port, u32 port_num)
+{
+	struct pio_group {
+		u32 	base;
+		u32 	nr;
+	};
+	/* define gpio number translate table */
+	const struct pio_group gpio_trans_tbl[] = {
+		{PA_NR_BASE,         PA_NR},
+		{PB_NR_BASE,         PB_NR},
+		{PC_NR_BASE,         PC_NR},
+		{PD_NR_BASE,         PD_NR},
+		{PE_NR_BASE,         PE_NR},
+		{PF_NR_BASE,         PF_NR},
+		{PG_NR_BASE,         PG_NR},
+		{PH_NR_BASE,         PH_NR},
+		{GPIO_INDEX_INVALID, 0    },
+		{GPIO_INDEX_INVALID, 0    },
+		{GPIO_INDEX_INVALID, 0    },
+		{PL_NR_BASE,         PL_NR},
+		{PM_NR_BASE,         PM_NR}
+	};
+
+#ifdef CONFIG_AW_AXP22
+	/* check power pin */
+	if(AXP_PORT_VAL == port) {
+		WARN(port_num >= AXP_NR, "%s err, line %d, please check sys_config.fex", __func__, __LINE__);
+		return (AXP_NR_BASE + port_num);
+	} else
+#endif /* CONFIG_AW_AXP22 */
+	{
+		if(port - 1 < ARRAY_SIZE(gpio_trans_tbl)
+			&& GPIO_INDEX_INVALID != gpio_trans_tbl[port - 1].base
+			&& port_num < gpio_trans_tbl[port - 1].nr)
+			return (gpio_trans_tbl[port - 1].base + port_num);
+	}
+	printk(KERN_ERR "%s err: port %d, port_num %d, please check sys_config.fex\n", __func__, port, port_num);
+	return GPIO_INDEX_INVALID;
+}
+
+void dump_mainkey(script_main_key_t *pmainkey)
+{
+	#define TYPE_TO_STR(type)	((SCIRPT_ITEM_VALUE_TYPE_INT == (type)) ?  "int"    :	\
+					((SCIRPT_ITEM_VALUE_TYPE_STR == (type))  ?  "string" :	\
+					((SCIRPT_ITEM_VALUE_TYPE_PIO == (type))  ?   "gpio" : "invalid")))
+	script_sub_key_t *psubkey = NULL;
+
+	if(NULL == pmainkey || NULL == pmainkey->subkey || NULL == pmainkey->subkey_val)
+		return;
+
+	printk("++++++++++++++++++++++++++%s++++++++++++++++++++++++++\n", __func__);
+	printk("    name:      %s\n", pmainkey->name);
+	printk("    sub_key:   name           type      value\n");
+	psubkey = pmainkey->subkey;
+	while(psubkey) {
+		switch(psubkey->type) {
+		case SCIRPT_ITEM_VALUE_TYPE_INT:
+			printk("               %-15s%-10s%d\n", psubkey->name,
+				TYPE_TO_STR(psubkey->type), psubkey->value->val);
+			break;
+		case SCIRPT_ITEM_VALUE_TYPE_STR:
+			printk("               %-15s%-10s\"%s\"\n", psubkey->name,
+				TYPE_TO_STR(psubkey->type), psubkey->value->str);
+			break;
+		case SCIRPT_ITEM_VALUE_TYPE_PIO:
+			printk("               %-15s%-10s(gpio: %3d, mul: %d, pull %d, drv %d, data %d)\n",
+				psubkey->name, TYPE_TO_STR(psubkey->type), psubkey->value->gpio.gpio, psubkey->value->gpio.mul_sel,
+				psubkey->value->gpio.pull, psubkey->value->gpio.drv_level, psubkey->value->gpio.data);
+			break;
+		default:
+			printk("               %-15sinvalid type!\n", psubkey->name);
+			break;
+		}
+		psubkey = psubkey->next;
+	}
+	printk("--------------------------%s--------------------------\n", __func__);
+}
+
+int script_dump_mainkey(char *main_key)
+{
+	int     main_hash = 0;
+	script_main_key_t *pmainkey = g_script;
+
+	if(NULL != main_key) {
+		printk("%s: dump main_key %s\n", __func__, main_key);
+		main_hash = hash(main_key);
+		while(pmainkey) {
+			if((pmainkey->hash == main_hash) && !strcmp(pmainkey->name, main_key)) {
+				dump_mainkey(pmainkey);
+				return 0;
+			}
+			pmainkey = pmainkey->next;
+		}
+		printk(KERN_ERR "%s err: main key %s not found!\n", __func__, main_key);
+	} else {
+		printk("%s: dump all the mainkey, \n", __func__);
+		while(pmainkey) {
+			printk("%s: dump main key %s\n", __func__, pmainkey->name);
+			dump_mainkey(pmainkey);
+			pmainkey = pmainkey->next;
+		}
+	}
+	printk("%s exit\n", __func__);
+	return 0;
+}
+EXPORT_SYMBOL(script_dump_mainkey);
+
+script_item_value_type_e
+script_get_item(char *main_key, char *sub_key, script_item_u *item)
+{
+    int     main_hash, sub_hash;
+    script_main_key_t   *mainkey = g_script;
+
+    if(!main_key || !sub_key || !item || !g_script) {
+        return SCIRPT_ITEM_VALUE_TYPE_INVALID;
+    }
+
+    main_hash = hash(main_key);
+    sub_hash = hash(sub_key);
+
+    /* try to look for the main key from main key list */
+    while(mainkey) {
+        if((mainkey->hash == main_hash) && !strcmp(mainkey->name, main_key)) {
+            /* find the main key */
+            script_sub_key_t    *subkey = mainkey->subkey;
+            while(subkey) {
+                if((subkey->hash == sub_hash) && !strcmp(subkey->name, sub_key)) {
+                    /* find the sub key */
+                    *item = *subkey->value;
+                    return subkey->type;
+                }
+                subkey = subkey->next;
+            }
+
+            /* no sub key defined under the main key */
+            return SCIRPT_ITEM_VALUE_TYPE_INVALID;
+        }
+        mainkey = mainkey->next;
+    }
+
+    return SCIRPT_ITEM_VALUE_TYPE_INVALID;
+}
+EXPORT_SYMBOL(script_get_item);
+
+int script_get_pio_list(char *main_key, script_item_u **list)
+{
+    int     main_hash;
+    script_main_key_t   *mainkey = g_script;
+
+    if(!main_key || !list || !g_script) {
+        return 0;
+    }
+
+    main_hash = hash(main_key);
+
+    /* try to look for the main key from main key list */
+    while(mainkey) {
+        if((mainkey->hash == main_hash) && !strcmp(mainkey->name, main_key)) {
+            /* find the main key */
+            *list = mainkey->gpio;
+            return mainkey->gpio_cnt;
+        }
+        mainkey = mainkey->next;
+    }
+
+    /* look for main key failed */
+    return 0;
+}
+EXPORT_SYMBOL(script_get_pio_list);
+
+/*
+ * init script
+ */
+static int __init script_init(void)
+{
+    int     i, j, count;
+
+    script_origin_head_t        *script_hdr = __va(SYS_CONFIG_MEMBASE);
+
+    script_origin_main_key_t    *origin_main;
+    script_origin_sub_key_t     *origin_sub;
+
+    script_main_key_t           *main_key;
+    script_sub_key_t            *sub_key, *tmp_sub, swap_sub;
+
+    script_item_u               *sub_val, *tmp_val, swap_val, *pval_temp;
+
+    printk("%s enter!\n", __func__);
+    if(!script_hdr) {
+        printk(KERN_ERR "script buffer is NULL!\n");
+        return -1;
+    }
+
+    /* alloc memory for main keys */
+    g_script = SCRIPT_MALLOC(script_hdr->main_cnt*sizeof(script_main_key_t));
+    if(!g_script) {
+        printk(KERN_ERR "try to alloc memory for main keys!\n");
+        return -1;
+    }
+
+    origin_main = &script_hdr->main_key;
+    for(i=0; i<script_hdr->main_cnt; i++) {
+        main_key = &g_script[i];
+
+        /* copy main key name */
+        strncpy(main_key->name, origin_main[i].name, SCRIPT_NAME_SIZE_MAX);
+        /* calculate hash value */
+        main_key->hash = hash(main_key->name);
+
+        /* allock memory for sub-keys */
+        main_key->subkey = SCRIPT_MALLOC(origin_main[i].sub_cnt*sizeof(script_sub_key_t));
+        main_key->subkey_val = SCRIPT_MALLOC(origin_main[i].sub_cnt*sizeof(script_item_u));
+        if(!main_key->subkey || !main_key->subkey_val) {
+            printk(KERN_ERR "try alloc memory for sub keys failed!\n");
+            goto err_out;
+        }
+
+        sub_key = main_key->subkey;
+        sub_val = main_key->subkey_val;
+        origin_sub = (script_origin_sub_key_t *)((unsigned int)script_hdr + (origin_main[i].offset<<2));
+
+        /* process sub keys */
+        for(j=0; j<origin_main[i].sub_cnt; j++) {
+            strncpy(sub_key[j].name, origin_sub[j].name, SCRIPT_NAME_SIZE_MAX);
+            sub_key[j].hash = hash(sub_key[j].name);
+            sub_key[j].type = (script_item_value_type_e)origin_sub[j].pattern.type;
+            sub_key[j].value = &sub_val[j];
+            if(origin_sub[j].pattern.type == SCIRPT_PARSER_VALUE_TYPE_SINGLE_WORD) {
+                sub_val[j].val = *(int *)((unsigned int)script_hdr + (origin_sub[j].offset<<2));
+                sub_key[j].type = SCIRPT_ITEM_VALUE_TYPE_INT;
+            } else if(origin_sub[j].pattern.type == SCIRPT_PARSER_VALUE_TYPE_STRING) {
+                sub_val[j].str = SCRIPT_MALLOC((origin_sub[j].pattern.cnt<<2) + 1);
+                memcpy(sub_val[j].str, (char *)((unsigned int)script_hdr + (origin_sub[j].offset<<2)), origin_sub[j].pattern.cnt<<2);
+                sub_key[j].type = SCIRPT_ITEM_VALUE_TYPE_STR;
+            } else if(origin_sub[j].pattern.type == SCIRPT_PARSER_VALUE_TYPE_GPIO_WORD) {
+                script_origin_gpio_t    *origin_gpio = (script_origin_gpio_t *)((unsigned int)script_hdr + (origin_sub[j].offset<<2) - 32);
+		u32 gpio_tmp = port_to_index(origin_gpio->port, origin_gpio->port_num);
+
+		if(GPIO_INDEX_INVALID == gpio_tmp)
+			printk(KERN_ERR "%s:%s->%s gpio cfg invalid, please check sys_config.fex!\n",__func__,main_key->name,sub_key[j].name);
+                sub_val[j].gpio.gpio = gpio_tmp;
+                sub_val[j].gpio.mul_sel = (u32)origin_gpio->mul_sel;
+                sub_val[j].gpio.pull = (u32)origin_gpio->pull;
+                sub_val[j].gpio.drv_level = (u32)origin_gpio->drv_level;
+		sub_val[j].gpio.data = (u32)origin_gpio->data;
+                sub_key[j].type = SCIRPT_ITEM_VALUE_TYPE_PIO;
+            } else {
+                sub_key[j].type = SCIRPT_ITEM_VALUE_TYPE_INVALID;
+            }
+        }
+
+        /* process gpios */
+        tmp_sub = main_key->subkey;
+        tmp_val = main_key->subkey_val;
+        count = 0;
+        for(j=0; j<origin_main[i].sub_cnt; j++) {
+            if(sub_key[j].type == SCIRPT_ITEM_VALUE_TYPE_PIO) {
+                /* swap sub key */
+                swap_sub = *tmp_sub;
+                *tmp_sub = sub_key[j];
+                sub_key[j] = swap_sub;
+		/* swap sub key value ptr */
+		pval_temp = tmp_sub->value;
+		tmp_sub->value = sub_key[j].value;
+		sub_key[j].value = pval_temp;
+                /* swap key value */
+                swap_val = *tmp_val;
+                *tmp_val = main_key->subkey_val[j];
+                main_key->subkey_val[j] = swap_val;
+                tmp_sub++;
+                tmp_val++;
+                count++;
+            }
+        }
+
+        /* process sub key link */
+        for(j=0; j<origin_main[i].sub_cnt-1; j++) {
+            main_key->subkey[j].next = &main_key->subkey[j+1];
+        }
+
+        /* set gpio infermation */
+        main_key->gpio = main_key->subkey_val;
+        main_key->gpio_cnt = count;
+	main_key->next = &g_script[i+1];
+    }
+    g_script[script_hdr->main_cnt-1].next = 0;
+
+    /* dump all the item */
+    //script_dump_mainkey(NULL);
+    printk("%s exit!\n", __func__);
+    return 0;
+
+err_out:
+
+    /* script init failed, release resource */
+    printk(KERN_ERR "init sys_config script failed!\n");
+    if(g_script) {
+        for(i=0; i<script_hdr->main_cnt; i++) {
+            main_key = &g_script[i];
+
+            if(main_key->subkey_val) {
+                for(j=0; j<origin_main[i].sub_cnt; j++) {
+                    if(main_key->subkey[j].type == SCIRPT_ITEM_VALUE_TYPE_STR) {
+                        SCRIPT_FREE(main_key->subkey_val[j].str);
+                    }
+                }
+
+                SCRIPT_FREE(main_key->subkey_val);
+            }
+            if(main_key->subkey) {
+                SCRIPT_FREE(main_key->subkey);
+            }
+        }
+
+        SCRIPT_FREE(g_script);
+        g_script = 0;
+    }
+
+    return -1;
+}
+core_initcall(script_init);
+
diff --git a/arch/arm/mach-sun6i/sysfs/Makefile b/arch/arm/mach-sun6i/sysfs/Makefile
new file mode 100644
index 0000000..7c1bf85
--- /dev/null
+++ b/arch/arm/mach-sun6i/sysfs/Makefile
@@ -0,0 +1,3 @@
+
+obj-$(CONFIG_SUNXI_SYSFS)   += sunxi_sysfs.o
+obj-$(CONFIG_SUNXI_POWER_SCENE)	+= power_scene.o
diff --git a/arch/arm/mach-sun6i/sysfs/power_scene.c b/arch/arm/mach-sun6i/sysfs/power_scene.c
new file mode 100644
index 0000000..bc2f27e
--- /dev/null
+++ b/arch/arm/mach-sun6i/sysfs/power_scene.c
@@ -0,0 +1,137 @@
+/*
+ * arch/arm/mach-sun6i/scene.c
+ *
+ * Copyright (C) 2012 - 2016 Reuuimlla Limited
+ * Pan Nan <pannan@Reuuimllatech.com>
+ *
+ * Scene Sysfs Driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <mach/scene.h>
+
+extern struct class *sunxi_class;
+extern struct platform_device sunxi_power_device;
+
+static struct srcu_notifier_head scene_change_notifier;
+static bool init_scene_change_notifier_called;
+static struct mutex scene_mutex;
+struct device *scene_dev;
+static enum scene_type cur_type;
+static u8 scene_list[SCENE_TYPE_MAX] = {
+        SCENE_TYPE_DEF, SCENE_TYPE1, SCENE_TYPE2, SCENE_TYPE3,
+        SCENE_TYPE4, SCENE_TYPE5, SCENE_TYPE6, SCENE_TYPE7,
+        SCENE_TYPE8, SCENE_TYPE9
+};
+
+static int __init init_scene_change_notifier(void)
+{
+	srcu_init_notifier_head(&scene_change_notifier);
+	init_scene_change_notifier_called = true;
+	return 0;
+}
+pure_initcall(init_scene_change_notifier);
+
+int scene_register_notifier(struct notifier_block *nb)
+{
+	WARN_ON(!init_scene_change_notifier_called);
+	return srcu_notifier_chain_register(&scene_change_notifier, nb);
+}
+EXPORT_SYMBOL_GPL(scene_register_notifier);
+
+int scene_unregister_notifier(struct notifier_block *nb)
+{
+	return srcu_notifier_chain_unregister(&scene_change_notifier, nb);
+}
+EXPORT_SYMBOL_GPL(scene_unregister_notifier);
+
+
+static ssize_t available_scenes_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	ssize_t i = 0;
+    int j;
+    enum scene_type scene;
+
+    for (j = 0; j < ARRAY_SIZE(scene_list); j++) {
+        scene = scene_list[j];
+        i += sprintf(&buf[i], "%d ", scene);
+    }
+	i += sprintf(&buf[i], "\n");
+
+	return i;
+}
+
+static ssize_t set_scene_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	return sprintf(buf, "%d\n", cur_type);
+}
+
+static ssize_t set_scene_store(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+    enum scene_type st;
+    int value, ret;
+
+	ret = sscanf(buf, "%d", &value);
+	if (ret != 1)
+		goto out;
+
+    mutex_lock(&scene_mutex);
+    st = (enum scene_type)value;
+    srcu_notifier_call_chain(&scene_change_notifier, st, NULL);
+    cur_type = st;
+    ret = count;
+    mutex_unlock(&scene_mutex);
+
+out:
+	return ret;
+}
+
+static DEVICE_ATTR(available_scenes, S_IRUGO, available_scenes_show, NULL);
+static DEVICE_ATTR(set_scene, S_IRUGO | S_IWUSR, set_scene_show, set_scene_store);
+
+static struct attribute *scene_dev_entries[] = {
+	&dev_attr_available_scenes.attr,
+    &dev_attr_set_scene.attr,
+	NULL,
+};
+
+static struct attribute_group scene_dev_attr_group = {
+	.name	= "scene",
+	.attrs	= scene_dev_entries,
+};
+
+static int __init scene_init(void)
+{
+	int ret;
+
+	scene_dev = device_create(sunxi_class, &sunxi_power_device.dev, 0, NULL,
+            (char *)sunxi_power_device.dev.platform_data);
+
+    ret = sysfs_create_group(&scene_dev->kobj, &scene_dev_attr_group);
+    if (ret) {
+        printk(KERN_ERR "Failed to add %s group attrs\n", scene_dev_attr_group.name);
+        goto out;
+    }
+
+    cur_type = SCENE_TYPE_DEF;
+    mutex_init(&scene_mutex);
+
+	return 0;
+
+out:
+    return ret;
+}
+late_initcall(scene_init);
diff --git a/arch/arm/mach-sun6i/sysfs/sunxi_sysfs.c b/arch/arm/mach-sun6i/sysfs/sunxi_sysfs.c
new file mode 100644
index 0000000..f880476
--- /dev/null
+++ b/arch/arm/mach-sun6i/sysfs/sunxi_sysfs.c
@@ -0,0 +1,58 @@
+/*
+ * arch/arm/mach-sun6i/pm/scene.c
+ *
+ * Copyright (C) 2012 - 2016 Reuuimlla Limited
+ * Pan Nan <pannan@Reuuimllatech.com>
+ *
+ * Scene Sysfs Driver
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+
+struct class *sunxi_class;
+
+static int __init sunxi_class_init(void)
+{
+	sunxi_class = class_create(THIS_MODULE, "sunxi");
+	if (IS_ERR(sunxi_class)) {
+		printk(KERN_ERR "%s: couldn't create sunxi class\n", __FILE__);
+		return PTR_ERR(sunxi_class);
+	}
+
+	return 0;
+}
+subsys_initcall(sunxi_class_init);
+
+static void __exit sunxi_class_exit(void)
+{
+	class_destroy(sunxi_class);
+}
+module_exit(sunxi_class_exit);
+
+
+char power_dev_name[] = "power";
+struct platform_device sunxi_power_device = {
+	.name   = "sunxi_power",
+    .dev    = {
+        .platform_data = power_dev_name,
+    },
+};
+
+static struct platform_device *sunxi_sysfs_pdevs[] __initdata = {
+	&sunxi_power_device,
+};
+
+static int __init sunxi_sys_dev_init(void)
+{
+	return platform_add_devices(sunxi_sysfs_pdevs, ARRAY_SIZE(sunxi_sysfs_pdevs));
+}
+module_init(sunxi_sys_dev_init);
diff --git a/arch/arm/mach-sun6i/timer.c b/arch/arm/mach-sun6i/timer.c
new file mode 100644
index 0000000..defa734
--- /dev/null
+++ b/arch/arm/mach-sun6i/timer.c
@@ -0,0 +1,288 @@
+/*
+ * arch\arm\mach-sun6i\timer.c
+ * (C) Copyright 2010-2016
+ * Allwinner Technology Co., Ltd. <www.reuuimllatech.com>
+ * huangxin<huangxin@reuuimllatech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <mach/hardware.h>
+#include <mach/platform.h>
+#include <linux/init.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <asm/sched_clock.h>
+#include <mach/timer.h>
+
+static void __iomem *timer_cpu_base = 0;
+static spinlock_t timer0_spin_lock;
+static int timer_set_next_clkevt(unsigned long delta, struct clock_event_device *dev);
+
+static void timer_set_mode(enum clock_event_mode mode, struct clock_event_device *clk)
+{
+    volatile u32 ctrl = 0;
+    if (clk) {
+        switch (mode) {
+        case CLOCK_EVT_MODE_PERIODIC:
+            ctrl &= ~(1<<0);    /* Disable timer0 */
+            ctrl = readl(timer_cpu_base + AW_TMR0_CTRL_REG);
+            ctrl &= ~(1<<7);    /* Continuous mode */
+            ctrl |= 1;  /* Enable this timer */
+            break;
+        case CLOCK_EVT_MODE_ONESHOT:
+            ctrl &= ~(1<<0);    /* Disable timer0 */
+            ctrl = readl(timer_cpu_base + AW_TMR0_CTRL_REG);
+            ctrl &= (1<<7);    /* single mode */
+            ctrl |= 1;  /* Enable this timer */
+            break;
+        case CLOCK_EVT_MODE_UNUSED:
+        case CLOCK_EVT_MODE_SHUTDOWN:
+        default:
+            ctrl = readl(timer_cpu_base + AW_TMR0_CTRL_REG);
+            ctrl &= ~(1<<0);    /* Disable timer0 */
+            break;
+        }
+        writel(ctrl, timer_cpu_base + AW_TMR0_CTRL_REG);
+    } else {
+        pr_warning("error:%s,line:%d\n", __func__, __LINE__);
+        BUG();
+    }
+}
+
+
+static int timer_set_next_clkevt(unsigned long delta, struct clock_event_device *dev)
+{
+    unsigned long flags;
+    volatile u32 ctrl = 0;
+    if (dev) {
+        spin_lock_irqsave(&timer0_spin_lock, flags);
+        /* disable timer*/
+        ctrl= readl(timer_cpu_base + AW_TMR0_CTRL_REG);
+        ctrl |= (~(1<<0));
+        writel(ctrl, timer_cpu_base + AW_TMR0_CTRL_REG);
+        udelay(1);
+        /* set timer intervalue         */
+        writel(delta, timer_cpu_base + AW_TMR0_INTV_VALUE_REG);
+        /* reload the timer intervalue  */
+        ctrl= readl(timer_cpu_base + AW_TMR0_CTRL_REG);
+        ctrl |= (1<<1);
+        writel(ctrl, timer_cpu_base + AW_TMR0_CTRL_REG);
+        /* enable timer */
+        ctrl= readl(timer_cpu_base + AW_TMR0_CTRL_REG);
+        ctrl |= (1<<0);
+        writel(ctrl, timer_cpu_base + AW_TMR0_CTRL_REG);
+        spin_unlock_irqrestore(&timer0_spin_lock, flags);
+    } else {
+        pr_warning("error:%s,line:%d\n", __func__, __LINE__);
+        BUG();
+        return -EINVAL;
+    }
+    return 0;
+}
+
+static struct clock_event_device sun6i_timer0_clockevent = {
+    .name = "timer0",
+    .shift = 32,
+    .rating = 100,
+    .features = CLOCK_EVT_FEAT_PERIODIC|CLOCK_EVT_FEAT_ONESHOT,
+    .set_mode = timer_set_mode,
+    .set_next_event = timer_set_next_clkevt,
+};
+
+static irqreturn_t sun6i_timer_interrupt(int irq, void *dev_id)
+{
+    struct clock_event_device *evt;
+    if (dev_id) {
+        evt = (struct clock_event_device *)dev_id;
+
+        /* Clear interrupt */
+        writel(0x1, timer_cpu_base + AW_TMR_IRQ_STA_REG);
+
+        /*
+         * timer_set_next_event will be called only in ONESHOT mode
+         */
+        evt->event_handler(evt);
+    } else {
+        printk("error:%s,line:%d\n", __func__, __LINE__);
+        BUG();
+        return IRQ_NONE;
+    }
+    return IRQ_HANDLED;
+}
+
+static struct irqaction sun6i_timer_irq = {
+    .name = "timer0",
+    .flags = IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+    .handler = sun6i_timer_interrupt,
+    .dev_id = &sun6i_timer0_clockevent,
+    .irq = AW_IRQ_TIMER0,
+};
+
+void __init sun6i_clkevt_init(void)
+{
+    int ret = 0;
+    volatile u32 ctrl = 0;
+
+    timer_cpu_base = ioremap_nocache(AW_TIMER_BASE, 0x1000);
+    pr_debug("hx-tickless-hrtimer:[%s] base=%p\n", __FUNCTION__,timer_cpu_base);
+
+    /* Disable & clear all timers */
+    writel(0x0, timer_cpu_base + AW_TMR_IRQ_EN_REG);
+    writel(0x3f, timer_cpu_base + AW_TMR_IRQ_STA_REG);
+
+    /* Init timer0 */
+    writel(TIMER0_VALUE, timer_cpu_base + AW_TMR0_INTV_VALUE_REG);
+
+    ctrl = readl(timer_cpu_base + AW_TMR0_CTRL_REG);
+#ifdef CONFIG_AW_ASIC_EVB_PLATFORM
+    /*OSC24m*/
+    pr_debug("asic,%s,line:%d\n", __func__, __LINE__);
+    ctrl |= (1<<2);
+#else
+    /*internalOSC/N*/
+    pr_debug("fpga,%s,line:%d\n", __func__, __LINE__);
+    ctrl |= (0<<2);
+#endif
+    ctrl |= (1<<1);
+    writel(ctrl, timer_cpu_base + AW_TMR0_CTRL_REG);
+    ret = setup_irq(AW_IRQ_TIMER0, &sun6i_timer_irq);
+    if (ret) {
+        pr_warning("failed to setup irq %d\n", AW_IRQ_TIMER0);
+    }
+
+    /* Enable timer0 */
+    writel(0x1, timer_cpu_base + AW_TMR_IRQ_EN_REG);
+
+    sun6i_timer0_clockevent.mult = div_sc(AW_CLOCK_SRC/AW_CLOCK_DIV, NSEC_PER_SEC, sun6i_timer0_clockevent.shift);
+    sun6i_timer0_clockevent.max_delta_ns = clockevent_delta2ns(0x80000000, &sun6i_timer0_clockevent);
+    sun6i_timer0_clockevent.min_delta_ns = clockevent_delta2ns(0x1, &sun6i_timer0_clockevent)+100000;
+    sun6i_timer0_clockevent.cpumask = cpu_all_mask;
+    sun6i_timer0_clockevent.irq = sun6i_timer_irq.irq;
+    clockevents_register_device(&sun6i_timer0_clockevent);
+
+#ifdef CONFIG_AW_TIME_DELAY
+	use_time_delay();
+#endif
+
+}
+
+
+#define CNT64_REG_BASE      0xF1F01E80
+#define CNT64_CTL_REG       0x00
+#define CNT64_LOW_REG       0x04
+#define CNT64_HIGH_REG      0x08
+
+static DEFINE_SPINLOCK(clksrc_lock);
+
+/*
+*********************************************************************************************************
+*                           sun6i_clksrc_read
+*
+*Description: read cycle count of the clock source;
+*
+*Arguments  : cs    clock source handle.
+*
+*Return     : cycle count;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+static cycle_t sun6i_clksrc_read(struct clocksource *cs)
+{
+    __u32   reg, lower, upper;
+    unsigned long   flags;
+
+    spin_lock_irqsave(&clksrc_lock, flags);
+    /* latch 64bit counter and wait ready for read */
+    reg = readl(CNT64_REG_BASE + CNT64_CTL_REG);
+    reg |= (1<<1);
+    writel(reg, CNT64_REG_BASE + CNT64_CTL_REG);
+    while(readl(CNT64_REG_BASE + CNT64_CTL_REG) & (1<<1));
+
+    /* read the 64bits counter */
+    lower = readl(CNT64_REG_BASE + CNT64_LOW_REG);
+    upper = readl(CNT64_REG_BASE + CNT64_HIGH_REG);
+    spin_unlock_irqrestore(&clksrc_lock, flags);
+
+    return (((__u64)upper)<<32) | lower;
+}
+
+
+__u32 sched_clock_read(void)
+{
+    __u32   reg, lower;
+    unsigned long   flags;
+
+    spin_lock_irqsave(&clksrc_lock, flags);
+    /* latch 64bit counter and wait ready for read */
+    reg = readl(CNT64_REG_BASE + CNT64_CTL_REG);
+    reg |= (1<<1);
+    writel(reg, CNT64_REG_BASE + CNT64_CTL_REG);
+    while(readl(CNT64_REG_BASE + CNT64_CTL_REG) & (1<<1));
+
+    /* read the low 32bits counter */
+    lower = readl(CNT64_REG_BASE + CNT64_LOW_REG);
+    spin_unlock_irqrestore(&clksrc_lock, flags);
+
+    return lower;
+}
+
+
+static struct clocksource aw_clocksrc =
+{
+    .name = "sun6i high-res couter",
+    .list = {NULL, NULL},
+    .rating = 300,                  /* perfect clock source             */
+    .read = sun6i_clksrc_read,      /* read clock counter               */
+    .enable = 0,                    /* not define                       */
+    .disable = 0,                   /* not define                       */
+    .mask = CLOCKSOURCE_MASK(64),   /* 64bits mask                      */
+    .mult = 0,                      /* it will be calculated by shift   */
+    .shift = 10,                    /* 32bit shift for                  */
+    .max_idle_ns = 1000000000000ULL,
+    .flags = CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+
+/*
+*********************************************************************************************************
+*                           sun6i_clksrc_init
+*
+*Description: clock source initialise.
+*
+*Arguments  : none
+*
+*Return     : result,
+*               0,  initiate successed;
+*              !0,  initiate failed;
+*
+*Notes      :
+*
+*********************************************************************************************************
+*/
+int __init sun6i_clksrc_init(void)
+{
+    pr_debug("sun6i clock source init!\n");
+    /* calculate the mult by shift  */
+    aw_clocksrc.mult = clocksource_hz2mult(24000000, aw_clocksrc.shift);
+    /* register clock source */
+    clocksource_register(&aw_clocksrc);
+    /* set sched clock */
+    setup_sched_clock(sched_clock_read, 32, 24000000);
+
+    return 0;
+}
diff --git a/arch/arm/mach-tegra/Makefile b/arch/arm/mach-tegra/Makefile
index e120ff5..f7d0443 100644
--- a/arch/arm/mach-tegra/Makefile
+++ b/arch/arm/mach-tegra/Makefile
@@ -13,7 +13,7 @@ obj-$(CONFIG_ARCH_TEGRA_2x_SOC)		+= tegra2_emc.o
 obj-$(CONFIG_ARCH_TEGRA_2x_SOC)		+= pinmux-tegra20-tables.o
 obj-$(CONFIG_ARCH_TEGRA_3x_SOC)		+= pinmux-tegra30-tables.o
 obj-$(CONFIG_ARCH_TEGRA_3x_SOC)		+= board-dt-tegra30.o
-obj-$(CONFIG_SMP)                       += platsmp.o localtimer.o headsmp.o
+obj-$(CONFIG_SMP)                       += platsmp.o headsmp.o
 obj-$(CONFIG_HOTPLUG_CPU)               += hotplug.o
 obj-$(CONFIG_TEGRA_SYSTEM_DMA)		+= dma.o
 obj-$(CONFIG_CPU_FREQ)                  += cpu-tegra.o
diff --git a/arch/arm/mach-tegra/localtimer.c b/arch/arm/mach-tegra/localtimer.c
deleted file mode 100644
index e91d681..0000000
--- a/arch/arm/mach-tegra/localtimer.c
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- *  arch/arm/mach-tegra/localtimer.c
- *
- *  Copyright (C) 2002 ARM Ltd.
- *  All Rights Reserved
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#include <linux/init.h>
-#include <linux/smp.h>
-#include <linux/clockchips.h>
-#include <asm/irq.h>
-#include <asm/smp_twd.h>
-#include <asm/localtimer.h>
-
-/*
- * Setup the local clock events for a CPU.
- */
-int __cpuinit local_timer_setup(struct clock_event_device *evt)
-{
-	evt->irq = IRQ_LOCALTIMER;
-	twd_timer_setup(evt);
-	return 0;
-}
diff --git a/arch/arm/mach-tegra/timer.c b/arch/arm/mach-tegra/timer.c
index 1d1acda..1eed8d4 100644
--- a/arch/arm/mach-tegra/timer.c
+++ b/arch/arm/mach-tegra/timer.c
@@ -28,7 +28,7 @@
 #include <linux/io.h>
 
 #include <asm/mach/time.h>
-#include <asm/localtimer.h>
+#include <asm/smp_twd.h>
 #include <asm/sched_clock.h>
 
 #include <mach/iomap.h>
@@ -162,6 +162,21 @@ static struct irqaction tegra_timer_irq = {
 	.irq		= INT_TMR3,
 };
 
+#ifdef CONFIG_HAVE_ARM_TWD
+static DEFINE_TWD_LOCAL_TIMER(twd_local_timer,
+			      TEGRA_ARM_PERIF_BASE + 0x600,
+			      IRQ_LOCALTIMER);
+
+static void __init tegra_twd_init(void)
+{
+	int err = twd_local_timer_register(&twd_local_timer);
+	if (err)
+		pr_err("twd_local_timer_register failed %d\n", err);
+}
+#else
+#define tegra_twd_init()	do {} while(0)
+#endif
+
 static void __init tegra_init_timer(void)
 {
 	struct clk *clk;
@@ -188,10 +203,6 @@ static void __init tegra_init_timer(void)
 	else
 		clk_enable(clk);
 
-#ifdef CONFIG_HAVE_ARM_TWD
-	twd_base = IO_ADDRESS(TEGRA_ARM_PERIF_BASE + 0x600);
-#endif
-
 	switch (rate) {
 	case 12000000:
 		timer_writel(0x000b, TIMERUS_USEC_CFG);
@@ -231,6 +242,7 @@ static void __init tegra_init_timer(void)
 	tegra_clockevent.cpumask = cpu_all_mask;
 	tegra_clockevent.irq = tegra_timer_irq.irq;
 	clockevents_register_device(&tegra_clockevent);
+	tegra_twd_init();
 }
 
 struct sys_timer tegra_timer = {
diff --git a/arch/arm/mach-ux500/Makefile b/arch/arm/mach-ux500/Makefile
index 6bd2f45..35b3894 100644
--- a/arch/arm/mach-ux500/Makefile
+++ b/arch/arm/mach-ux500/Makefile
@@ -15,7 +15,6 @@ obj-$(CONFIG_MACH_U8500)	+= board-mop500.o board-mop500-sdi.o \
 obj-$(CONFIG_MACH_U5500)	+= board-u5500.o board-u5500-sdi.o
 obj-$(CONFIG_SMP)		+= platsmp.o headsmp.o
 obj-$(CONFIG_HOTPLUG_CPU)	+= hotplug.o
-obj-$(CONFIG_LOCAL_TIMERS)	+= localtimer.o
 obj-$(CONFIG_U5500_MODEM_IRQ)	+= modem-irq-db5500.o
 obj-$(CONFIG_U5500_MBOX)	+= mbox-db5500.o
 
diff --git a/arch/arm/mach-ux500/cpu.c b/arch/arm/mach-ux500/cpu.c
index f418574..851308b 100644
--- a/arch/arm/mach-ux500/cpu.c
+++ b/arch/arm/mach-ux500/cpu.c
@@ -14,7 +14,6 @@
 
 #include <asm/hardware/gic.h>
 #include <asm/mach/map.h>
-#include <asm/localtimer.h>
 
 #include <mach/hardware.h>
 #include <mach/setup.h>
diff --git a/arch/arm/mach-ux500/localtimer.c b/arch/arm/mach-ux500/localtimer.c
deleted file mode 100644
index 5ba1133..0000000
--- a/arch/arm/mach-ux500/localtimer.c
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2008-2009 ST-Ericsson
- * Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
- *
- * This file is heavily based on relaview platform, almost a copy.
- *
- * Copyright (C) 2002 ARM Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#include <linux/init.h>
-#include <linux/smp.h>
-#include <linux/clockchips.h>
-
-#include <asm/irq.h>
-#include <asm/smp_twd.h>
-#include <asm/localtimer.h>
-
-/*
- * Setup the local clock events for a CPU.
- */
-int __cpuinit local_timer_setup(struct clock_event_device *evt)
-{
-	evt->irq = IRQ_LOCALTIMER;
-	twd_timer_setup(evt);
-	return 0;
-}
diff --git a/arch/arm/mach-ux500/timer.c b/arch/arm/mach-ux500/timer.c
index aea467d..e2021c0 100644
--- a/arch/arm/mach-ux500/timer.c
+++ b/arch/arm/mach-ux500/timer.c
@@ -8,27 +8,44 @@
 #include <linux/errno.h>
 #include <linux/clksrc-dbx500-prcmu.h>
 
-#include <asm/localtimer.h>
+#include <asm/smp_twd.h>
 
 #include <plat/mtu.h>
 
 #include <mach/setup.h>
 #include <mach/hardware.h>
+#include <mach/irqs.h>
+
+#ifdef CONFIG_HAVE_ARM_TWD
+static DEFINE_TWD_LOCAL_TIMER(u5500_twd_local_timer,
+			      U5500_TWD_BASE, IRQ_LOCALTIMER);
+static DEFINE_TWD_LOCAL_TIMER(u8500_twd_local_timer,
+			      U8500_TWD_BASE, IRQ_LOCALTIMER);
+
+static void __init ux500_twd_init(void)
+{
+	struct twd_local_timer *twd_local_timer;
+	int err;
+
+	twd_local_timer = cpu_is_u5500() ? &u5500_twd_local_timer :
+					   &u8500_twd_local_timer;
+
+	err = twd_local_timer_register(twd_local_timer);
+	if (err)
+		pr_err("twd_local_timer_register failed %d\n", err);
+}
+#else
+#define ux500_twd_init()	do { } while(0)
+#endif
 
 static void __init ux500_timer_init(void)
 {
 	void __iomem *prcmu_timer_base;
 
 	if (cpu_is_u5500()) {
-#ifdef CONFIG_LOCAL_TIMERS
-		twd_base = __io_address(U5500_TWD_BASE);
-#endif
 		mtu_base = __io_address(U5500_MTU0_BASE);
 		prcmu_timer_base = __io_address(U5500_PRCMU_TIMER_3_BASE);
 	} else if (cpu_is_u8500()) {
-#ifdef CONFIG_LOCAL_TIMERS
-		twd_base = __io_address(U8500_TWD_BASE);
-#endif
 		mtu_base = __io_address(U8500_MTU0_BASE);
 		prcmu_timer_base = __io_address(U8500_PRCMU_TIMER_4_BASE);
 	} else {
@@ -54,6 +71,7 @@ static void __init ux500_timer_init(void)
 
 	nmdk_timer_init();
 	clksrc_dbx500_prcmu_init(prcmu_timer_base);
+	ux500_twd_init();
 }
 
 static void ux500_timer_reset(void)
diff --git a/arch/arm/mach-vexpress/Kconfig b/arch/arm/mach-vexpress/Kconfig
index 88c3ba1..cf8730d 100644
--- a/arch/arm/mach-vexpress/Kconfig
+++ b/arch/arm/mach-vexpress/Kconfig
@@ -1,14 +1,55 @@
 menu "Versatile Express platform type"
 	depends on ARCH_VEXPRESS
 
+config ARCH_VEXPRESS_CORTEX_A5_A9_ERRATA
+	bool
+	select ARM_ERRATA_720789
+	select ARM_ERRATA_751472
+	select PL310_ERRATA_753970 if CACHE_PL310
+	help
+	  Provides common dependencies for Versatile Express platforms
+	  based on Cortex-A5 and Cortex-A9 processors. In order to
+	  build a working kernel, you must also enable relevant core
+	  tile support or Flattened Device Tree based support options.
+
 config ARCH_VEXPRESS_CA9X4
 	bool "Versatile Express Cortex-A9x4 tile"
+	select ARCH_VEXPRESS_CORTEX_A5_A9_ERRATA
+	select ARM_GIC
 	select CPU_V7
+	select HAVE_SMP
+	select MIGHT_HAVE_CACHE_L2X0
+
+config ARCH_VEXPRESS_DT
+	bool "Device Tree support for Versatile Express platforms"
+	select ARCH_VEXPRESS_CORTEX_A5_A9_ERRATA
 	select ARM_GIC
-	select ARM_ERRATA_720789
-	select ARM_ERRATA_751472
-	select PL310_ERRATA_753970
+	select ARM_PATCH_PHYS_VIRT
+	select AUTO_ZRELADDR
+	select CPU_V7
 	select HAVE_SMP
 	select MIGHT_HAVE_CACHE_L2X0
+	select USE_OF
+	help
+	  New Versatile Express platforms require Flattened Device Tree to
+	  be passed to the kernel.
+
+	  This option enables support for systems using Cortex processor based
+	  ARM core and logic (FPGA) tiles on the Versatile Express motherboard,
+	  for example:
+
+	  - CoreTile Express A5x2 (V2P-CA5s)
+	  - CoreTile Express A9x4 (V2P-CA9)
+	  - CoreTile Express A15x2 (V2P-CA15)
+	  - LogicTile Express 13MG (V2F-2XV6) with A5, A7, A9 or A15 SMMs
+	    (Soft Macrocell Models)
+	  - Versatile Express RTSMs (Models)
+
+	  You must boot using a Flattened Device Tree in order to use these
+	  platforms. The traditional (ATAGs) boot method is not usable on
+	  these boards with this option.
+
+	  If your bootloader supports Flattened Device Tree based booting,
+	  say Y here.
 
 endmenu
diff --git a/arch/arm/mach-vexpress/Makefile.boot b/arch/arm/mach-vexpress/Makefile.boot
index 8630b3d..2f0ad9f 100644
--- a/arch/arm/mach-vexpress/Makefile.boot
+++ b/arch/arm/mach-vexpress/Makefile.boot
@@ -1,3 +1,8 @@
+# Those numbers are used only by the non-DT V2P-CA9 platform
+# The DT-enabled ones require CONFIG_AUTO_ZRELADDR=y
    zreladdr-y	+= 0x60008000
 params_phys-y	:= 0x60000100
 initrd_phys-y	:= 0x60800000
+
+dtb-$(CONFIG_ARCH_VEXPRESS_DT)	+= vexpress-v2p-ca5s.dtb \
+				   vexpress-v2p-ca9.dtb
diff --git a/arch/arm/mach-vexpress/core.h b/arch/arm/mach-vexpress/core.h
index f439715..d78322d 100644
--- a/arch/arm/mach-vexpress/core.h
+++ b/arch/arm/mach-vexpress/core.h
@@ -1,6 +1,3 @@
-#define __MMIO_P2V(x)	(((x) & 0xfffff) | (((x) & 0x0f000000) >> 4) | 0xf8000000)
-#define MMIO_P2V(x)	((void __iomem *)__MMIO_P2V(x))
-
 #define AMBA_DEVICE(name,busid,base,plat)	\
 struct amba_device name##_device = {		\
 	.dev		= {			\
@@ -17,3 +14,11 @@ struct amba_device name##_device = {		\
 	.irq		= IRQ_##base,		\
 	/* .dma		= DMA_##base,*/		\
 }
+
+/* 2MB large area for motherboard's peripherals static mapping */
+#define V2M_PERIPH 0xf8000000
+
+/* Tile's peripherals static mappings should start here */
+#define V2T_PERIPH 0xf8200000
+
+void vexpress_dt_smp_map_io(void);
diff --git a/arch/arm/mach-vexpress/ct-ca9x4.c b/arch/arm/mach-vexpress/ct-ca9x4.c
index b1e87c1..e5abe85 100644
--- a/arch/arm/mach-vexpress/ct-ca9x4.c
+++ b/arch/arm/mach-vexpress/ct-ca9x4.c
@@ -30,57 +30,40 @@
 
 #include <plat/clcd.h>
 
-#define V2M_PA_CS7	0x10000000
-
 static struct map_desc ct_ca9x4_io_desc[] __initdata = {
 	{
-		.virtual	= __MMIO_P2V(CT_CA9X4_MPIC),
-		.pfn		= __phys_to_pfn(CT_CA9X4_MPIC),
-		.length		= SZ_16K,
-		.type		= MT_DEVICE,
-	}, {
-		.virtual	= __MMIO_P2V(CT_CA9X4_SP804_TIMER),
-		.pfn		= __phys_to_pfn(CT_CA9X4_SP804_TIMER),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE,
-	}, {
-		.virtual	= __MMIO_P2V(CT_CA9X4_L2CC),
-		.pfn		= __phys_to_pfn(CT_CA9X4_L2CC),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE,
+		.virtual        = V2T_PERIPH,
+		.pfn            = __phys_to_pfn(CT_CA9X4_MPIC),
+		.length         = SZ_8K,
+		.type           = MT_DEVICE,
 	},
 };
 
 static void __init ct_ca9x4_map_io(void)
 {
-#ifdef CONFIG_LOCAL_TIMERS
-	twd_base = MMIO_P2V(A9_MPCORE_TWD);
-#endif
 	iotable_init(ct_ca9x4_io_desc, ARRAY_SIZE(ct_ca9x4_io_desc));
 }
 
-static void __init ct_ca9x4_init_irq(void)
+#ifdef CONFIG_HAVE_ARM_TWD
+static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, A9_MPCORE_TWD, IRQ_LOCALTIMER);
+
+static void __init ca9x4_twd_init(void)
 {
-	gic_init(0, 29, MMIO_P2V(A9_MPCORE_GIC_DIST),
-		 MMIO_P2V(A9_MPCORE_GIC_CPU));
+	int err = twd_local_timer_register(&twd_local_timer);
+	if (err)
+		pr_err("twd_local_timer_register failed %d\n", err);
 }
+#else
+#define ca9x4_twd_init()	do {} while(0)
+#endif
 
-#if 0
-static void __init ct_ca9x4_timer_init(void)
+static void __init ct_ca9x4_init_irq(void)
 {
-	writel(0, MMIO_P2V(CT_CA9X4_TIMER0) + TIMER_CTRL);
-	writel(0, MMIO_P2V(CT_CA9X4_TIMER1) + TIMER_CTRL);
-
-	sp804_clocksource_init(MMIO_P2V(CT_CA9X4_TIMER1), "ct-timer1");
-	sp804_clockevents_init(MMIO_P2V(CT_CA9X4_TIMER0), IRQ_CT_CA9X4_TIMER0,
-		"ct-timer0");
+	gic_init(0, 29, ioremap(A9_MPCORE_GIC_DIST, SZ_4K),
+		 ioremap(A9_MPCORE_GIC_CPU, SZ_256));
+	ca9x4_twd_init();
 }
 
-static struct sys_timer ct_ca9x4_timer = {
-	.init	= ct_ca9x4_timer_init,
-};
-#endif
-
 static void ct_ca9x4_clcd_enable(struct clcd_fb *fb)
 {
 	v2m_cfg_write(SYS_CFG_MUXFPGA | SYS_CFG_SITE_DB1, 0);
@@ -201,7 +184,7 @@ static void __init ct_ca9x4_init(void)
 	int i;
 
 #ifdef CONFIG_CACHE_L2X0
-	void __iomem *l2x0_base = MMIO_P2V(CT_CA9X4_L2CC);
+	void __iomem *l2x0_base = ioremap(CT_CA9X4_L2CC, SZ_4K);
 
 	/* set RAM latencies to 1 cycle for this core tile. */
 	writel(0, l2x0_base + L2X0_TAG_LATENCY_CTRL);
@@ -217,9 +200,17 @@ static void __init ct_ca9x4_init(void)
 }
 
 #ifdef CONFIG_SMP
+static void *ct_ca9x4_scu_base __initdata;
+
 static void __init ct_ca9x4_init_cpu_map(void)
 {
-	int i, ncores = scu_get_core_count(MMIO_P2V(A9_MPCORE_SCU));
+	int i, ncores;
+
+	ct_ca9x4_scu_base = ioremap(A9_MPCORE_SCU, SZ_128);
+	if (WARN_ON(!ct_ca9x4_scu_base))
+		return;
+
+	ncores = scu_get_core_count(ct_ca9x4_scu_base);
 
 	if (ncores > nr_cpu_ids) {
 		pr_warn("SMP: %u cores greater than maximum (%u), clipping\n",
@@ -235,7 +226,7 @@ static void __init ct_ca9x4_init_cpu_map(void)
 
 static void __init ct_ca9x4_smp_enable(unsigned int max_cpus)
 {
-	scu_enable(MMIO_P2V(A9_MPCORE_SCU));
+	scu_enable(ct_ca9x4_scu_base);
 }
 #endif
 
diff --git a/arch/arm/mach-vexpress/hotplug.c b/arch/arm/mach-vexpress/hotplug.c
index 3034a4d..331d59f 100644
--- a/arch/arm/mach-vexpress/hotplug.c
+++ b/arch/arm/mach-vexpress/hotplug.c
@@ -94,7 +94,7 @@ int platform_cpu_kill(unsigned int cpu)
  *
  * Called with IRQs disabled
  */
-void platform_cpu_die(unsigned int cpu)
+void __cpuinit platform_cpu_die(unsigned int cpu)
 {
 	int spurious = 0;
 
diff --git a/arch/arm/mach-vexpress/include/mach/ct-ca9x4.h b/arch/arm/mach-vexpress/include/mach/ct-ca9x4.h
index a34d3d4..2260fde 100644
--- a/arch/arm/mach-vexpress/include/mach/ct-ca9x4.h
+++ b/arch/arm/mach-vexpress/include/mach/ct-ca9x4.h
@@ -22,9 +22,6 @@
 #define CT_CA9X4_SYSWDT		(0x1e007000)
 #define CT_CA9X4_L2CC		(0x1e00a000)
 
-#define CT_CA9X4_TIMER0		(CT_CA9X4_SP804_TIMER + 0x000)
-#define CT_CA9X4_TIMER1		(CT_CA9X4_SP804_TIMER + 0x020)
-
 #define A9_MPCORE_SCU		(CT_CA9X4_MPIC + 0x0000)
 #define A9_MPCORE_GIC_CPU	(CT_CA9X4_MPIC + 0x0100)
 #define A9_MPCORE_GIT		(CT_CA9X4_MPIC + 0x0200)
diff --git a/arch/arm/mach-vexpress/include/mach/debug-macro.S b/arch/arm/mach-vexpress/include/mach/debug-macro.S
index fd9e6c7..f25a024 100644
--- a/arch/arm/mach-vexpress/include/mach/debug-macro.S
+++ b/arch/arm/mach-vexpress/include/mach/debug-macro.S
@@ -10,12 +10,26 @@
  * published by the Free Software Foundation.
  */
 
-#define DEBUG_LL_UART_OFFSET	0x00009000
+#ifdef CONFIG_DEBUG_VEXPRESS_CA9X4_UART
+#define DEBUG_LL_PHYS_BASE		0x10000000
+#define DEBUG_LL_UART_OFFSET		0x00009000
+#endif
+
+#ifdef CONFIG_DEBUG_VEXPRESS_RS1_UART
+#define DEBUG_LL_PHYS_BASE		0x1c000000
+#define DEBUG_LL_UART_OFFSET		0x00090000
+#endif
+
+#define DEBUG_LL_VIRT_BASE		0xf8000000
+
+#ifndef DEBUG_LL_UART_OFFSET
+#error "Unknown vexpress UART offset"
+#endif
 
 		.macro	addruart,rp,rv,tmp
 		mov	\rp, #DEBUG_LL_UART_OFFSET
-		orr	\rv, \rp, #0xf8000000	@ virtual base
-		orr	\rp, \rp, #0x10000000	@ physical base
+		orr	\rv, \rp, #DEBUG_LL_VIRT_BASE
+		orr	\rp, \rp, #DEBUG_LL_PHYS_BASE
 		.endm
 
 #include <asm/hardware/debug-pl01x.S>
diff --git a/arch/arm/mach-vexpress/include/mach/motherboard.h b/arch/arm/mach-vexpress/include/mach/motherboard.h
index 0a3a375..31a9289 100644
--- a/arch/arm/mach-vexpress/include/mach/motherboard.h
+++ b/arch/arm/mach-vexpress/include/mach/motherboard.h
@@ -39,33 +39,30 @@
 #define V2M_CF			(V2M_PA_CS7 + 0x0001a000)
 #define V2M_CLCD		(V2M_PA_CS7 + 0x0001f000)
 
-#define V2M_SYS_ID		(V2M_SYSREGS + 0x000)
-#define V2M_SYS_SW		(V2M_SYSREGS + 0x004)
-#define V2M_SYS_LED		(V2M_SYSREGS + 0x008)
-#define V2M_SYS_100HZ		(V2M_SYSREGS + 0x024)
-#define V2M_SYS_FLAGS		(V2M_SYSREGS + 0x030)
-#define V2M_SYS_FLAGSSET	(V2M_SYSREGS + 0x030)
-#define V2M_SYS_FLAGSCLR	(V2M_SYSREGS + 0x034)
-#define V2M_SYS_NVFLAGS		(V2M_SYSREGS + 0x038)
-#define V2M_SYS_NVFLAGSSET	(V2M_SYSREGS + 0x038)
-#define V2M_SYS_NVFLAGSCLR	(V2M_SYSREGS + 0x03c)
-#define V2M_SYS_MCI		(V2M_SYSREGS + 0x048)
-#define V2M_SYS_FLASH		(V2M_SYSREGS + 0x03c)
-#define V2M_SYS_CFGSW		(V2M_SYSREGS + 0x058)
-#define V2M_SYS_24MHZ		(V2M_SYSREGS + 0x05c)
-#define V2M_SYS_MISC		(V2M_SYSREGS + 0x060)
-#define V2M_SYS_DMA		(V2M_SYSREGS + 0x064)
-#define V2M_SYS_PROCID0		(V2M_SYSREGS + 0x084)
-#define V2M_SYS_PROCID1		(V2M_SYSREGS + 0x088)
-#define V2M_SYS_CFGDATA		(V2M_SYSREGS + 0x0a0)
-#define V2M_SYS_CFGCTRL		(V2M_SYSREGS + 0x0a4)
-#define V2M_SYS_CFGSTAT		(V2M_SYSREGS + 0x0a8)
-
-#define V2M_TIMER0		(V2M_TIMER01 + 0x000)
-#define V2M_TIMER1		(V2M_TIMER01 + 0x020)
-
-#define V2M_TIMER2		(V2M_TIMER23 + 0x000)
-#define V2M_TIMER3		(V2M_TIMER23 + 0x020)
+/*
+ * Offsets from SYSREGS base
+ */
+#define V2M_SYS_ID		0x000
+#define V2M_SYS_SW		0x004
+#define V2M_SYS_LED		0x008
+#define V2M_SYS_100HZ		0x024
+#define V2M_SYS_FLAGS		0x030
+#define V2M_SYS_FLAGSSET	0x030
+#define V2M_SYS_FLAGSCLR	0x034
+#define V2M_SYS_NVFLAGS		0x038
+#define V2M_SYS_NVFLAGSSET	0x038
+#define V2M_SYS_NVFLAGSCLR	0x03c
+#define V2M_SYS_MCI		0x048
+#define V2M_SYS_FLASH		0x03c
+#define V2M_SYS_CFGSW		0x058
+#define V2M_SYS_24MHZ		0x05c
+#define V2M_SYS_MISC		0x060
+#define V2M_SYS_DMA		0x064
+#define V2M_SYS_PROCID0		0x084
+#define V2M_SYS_PROCID1		0x088
+#define V2M_SYS_CFGDATA		0x0a0
+#define V2M_SYS_CFGCTRL		0x0a4
+#define V2M_SYS_CFGSTAT		0x0a8
 
 
 /*
@@ -117,6 +114,13 @@
 
 int v2m_cfg_write(u32 devfn, u32 data);
 int v2m_cfg_read(u32 devfn, u32 *data);
+void v2m_flags_set(u32 data);
+
+/*
+ * Miscellaneous
+ */
+#define SYS_MISC_MASTERSITE	(1 << 14)
+#define SYS_PROCIDx_HBI_MASK	0xfff
 
 /*
  * Core tile IDs
diff --git a/arch/arm/mach-vexpress/include/mach/uncompress.h b/arch/arm/mach-vexpress/include/mach/uncompress.h
index 7972c57..a386048 100644
--- a/arch/arm/mach-vexpress/include/mach/uncompress.h
+++ b/arch/arm/mach-vexpress/include/mach/uncompress.h
@@ -22,7 +22,14 @@
 #define AMBA_UART_CR(base)	(*(volatile unsigned char *)((base) + 0x30))
 #define AMBA_UART_FR(base)	(*(volatile unsigned char *)((base) + 0x18))
 
+
+#if defined(CONFIG_DEBUG_VEXPRESS_CA9X4_UART)
 #define get_uart_base()	(0x10000000 + 0x00009000)
+#elif defined(CONFIG_DEBUG_VEXPRESS_RS1_UART)
+#define get_uart_base()	(0x1c000000 + 0x00090000)
+#else
+#define get_uart_base() (0UL)
+#endif
 
 /*
  * This does not append a newline
@@ -31,6 +38,9 @@ static inline void putc(int c)
 {
 	unsigned long base = get_uart_base();
 
+	if (!base)
+		return;
+
 	while (AMBA_UART_FR(base) & (1 << 5))
 		barrier();
 
@@ -41,6 +51,9 @@ static inline void flush(void)
 {
 	unsigned long base = get_uart_base();
 
+	if (!base)
+		return;
+
 	while (AMBA_UART_FR(base) & (1 << 3))
 		barrier();
 }
diff --git a/arch/arm/mach-vexpress/platsmp.c b/arch/arm/mach-vexpress/platsmp.c
index 124ffb1..14ba112 100644
--- a/arch/arm/mach-vexpress/platsmp.c
+++ b/arch/arm/mach-vexpress/platsmp.c
@@ -12,21 +12,168 @@
 #include <linux/errno.h>
 #include <linux/smp.h>
 #include <linux/io.h>
+#include <linux/of_fdt.h>
+
+#include <asm/smp_scu.h>
+#include <asm/hardware/gic.h>
+#include <asm/mach/map.h>
 
 #include <mach/motherboard.h>
-#define V2M_PA_CS7 0x10000000
 
 #include "core.h"
 
 extern void versatile_secondary_startup(void);
 
+#if defined(CONFIG_OF)
+
+static enum {
+	GENERIC_SCU,
+	CORTEX_A9_SCU,
+} vexpress_dt_scu __initdata = GENERIC_SCU;
+
+static struct map_desc vexpress_dt_cortex_a9_scu_map __initdata = {
+	.virtual	= V2T_PERIPH,
+	/* .pfn	set in vexpress_dt_init_cortex_a9_scu() */
+	.length		= SZ_128,
+	.type		= MT_DEVICE,
+};
+
+static void *vexpress_dt_cortex_a9_scu_base __initdata;
+
+const static char *vexpress_dt_cortex_a9_match[] __initconst = {
+	"arm,cortex-a5-scu",
+	"arm,cortex-a9-scu",
+	NULL
+};
+
+static int __init vexpress_dt_find_scu(unsigned long node,
+		const char *uname, int depth, void *data)
+{
+	if (of_flat_dt_match(node, vexpress_dt_cortex_a9_match)) {
+		phys_addr_t phys_addr;
+		__be32 *reg = of_get_flat_dt_prop(node, "reg", NULL);
+
+		if (WARN_ON(!reg))
+			return -EINVAL;
+
+		phys_addr = be32_to_cpup(reg);
+		vexpress_dt_scu = CORTEX_A9_SCU;
+
+		vexpress_dt_cortex_a9_scu_map.pfn = __phys_to_pfn(phys_addr);
+		iotable_init(&vexpress_dt_cortex_a9_scu_map, 1);
+		vexpress_dt_cortex_a9_scu_base = ioremap(phys_addr, SZ_256);
+		if (WARN_ON(!vexpress_dt_cortex_a9_scu_base))
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+void __init vexpress_dt_smp_map_io(void)
+{
+	if (initial_boot_params)
+		WARN_ON(of_scan_flat_dt(vexpress_dt_find_scu, NULL));
+}
+
+static int __init vexpress_dt_cpus_num(unsigned long node, const char *uname,
+		int depth, void *data)
+{
+	static int prev_depth = -1;
+	static int nr_cpus = -1;
+
+	if (prev_depth > depth && nr_cpus > 0)
+		return nr_cpus;
+
+	if (nr_cpus < 0 && strcmp(uname, "cpus") == 0)
+		nr_cpus = 0;
+
+	if (nr_cpus >= 0) {
+		const char *device_type = of_get_flat_dt_prop(node,
+				"device_type", NULL);
+
+		if (device_type && strcmp(device_type, "cpu") == 0)
+			nr_cpus++;
+	}
+
+	prev_depth = depth;
+
+	return 0;
+}
+
+static void __init vexpress_dt_smp_init_cpus(void)
+{
+	int ncores = 0, i;
+
+	switch (vexpress_dt_scu) {
+	case GENERIC_SCU:
+		ncores = of_scan_flat_dt(vexpress_dt_cpus_num, NULL);
+		break;
+	case CORTEX_A9_SCU:
+		ncores = scu_get_core_count(vexpress_dt_cortex_a9_scu_base);
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+
+	if (ncores < 2)
+		return;
+
+	if (ncores > nr_cpu_ids) {
+		pr_warn("SMP: %u cores greater than maximum (%u), clipping\n",
+				ncores, nr_cpu_ids);
+		ncores = nr_cpu_ids;
+	}
+
+	for (i = 0; i < ncores; ++i)
+		set_cpu_possible(i, true);
+
+	set_smp_cross_call(gic_raise_softirq);
+}
+
+static void __init vexpress_dt_smp_prepare_cpus(unsigned int max_cpus)
+{
+	int i;
+
+	switch (vexpress_dt_scu) {
+	case GENERIC_SCU:
+		for (i = 0; i < max_cpus; i++)
+			set_cpu_present(i, true);
+		break;
+	case CORTEX_A9_SCU:
+		scu_enable(vexpress_dt_cortex_a9_scu_base);
+		break;
+	default:
+		WARN_ON(1);
+		break;
+	}
+}
+
+#else
+
+static void __init vexpress_dt_smp_init_cpus(void)
+{
+	WARN_ON(1);
+}
+
+void __init vexpress_dt_smp_prepare_cpus(unsigned int max_cpus)
+{
+	WARN_ON(1);
+}
+
+#endif
+
 /*
  * Initialise the CPU possible map early - this describes the CPUs
  * which may be present or become present in the system.
  */
 void __init smp_init_cpus(void)
 {
-	ct_desc->init_cpu_map();
+	if (ct_desc)
+		ct_desc->init_cpu_map();
+	else
+		vexpress_dt_smp_init_cpus();
+
 }
 
 void __init platform_smp_prepare_cpus(unsigned int max_cpus)
@@ -35,7 +182,10 @@ void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 	 * Initialise the present map, which describes the set of CPUs
 	 * actually populated at the present time.
 	 */
-	ct_desc->smp_enable(max_cpus);
+	if (ct_desc)
+		ct_desc->smp_enable(max_cpus);
+	else
+		vexpress_dt_smp_prepare_cpus(max_cpus);
 
 	/*
 	 * Write the address of secondary startup into the
@@ -43,7 +193,5 @@ void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 	 * until it receives a soft interrupt, and then the
 	 * secondary CPU branches to this address.
 	 */
-	writel(~0, MMIO_P2V(V2M_SYS_FLAGSCLR));
-	writel(virt_to_phys(versatile_secondary_startup),
-		MMIO_P2V(V2M_SYS_FLAGSSET));
+	v2m_flags_set(virt_to_phys(versatile_secondary_startup));
 }
diff --git a/arch/arm/mach-vexpress/v2m.c b/arch/arm/mach-vexpress/v2m.c
index b4a28ca..318489b 100644
--- a/arch/arm/mach-vexpress/v2m.c
+++ b/arch/arm/mach-vexpress/v2m.c
@@ -6,6 +6,10 @@
 #include <linux/amba/mmci.h>
 #include <linux/io.h>
 #include <linux/init.h>
+#include <linux/of_address.h>
+#include <linux/of_fdt.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
 #include <linux/platform_device.h>
 #include <linux/ata_platform.h>
 #include <linux/smsc911x.h>
@@ -15,12 +19,16 @@
 #include <linux/clkdev.h>
 #include <linux/mtd/physmap.h>
 
+#include <asm/arch_timer.h>
 #include <asm/mach-types.h>
 #include <asm/sizes.h>
+#include <asm/smp_twd.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 #include <asm/mach/time.h>
 #include <asm/hardware/arm_timer.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/hardware/gic.h>
 #include <asm/hardware/timer-sp.h>
 #include <asm/hardware/sp810.h>
 #include <asm/hardware/gic.h>
@@ -40,29 +48,45 @@
 
 static struct map_desc v2m_io_desc[] __initdata = {
 	{
-		.virtual	= __MMIO_P2V(V2M_PA_CS7),
+		.virtual	= V2M_PERIPH,
 		.pfn		= __phys_to_pfn(V2M_PA_CS7),
 		.length		= SZ_128K,
 		.type		= MT_DEVICE,
 	},
 };
 
-static void __init v2m_timer_init(void)
+static void __iomem *v2m_sysreg_base;
+
+static void __init v2m_sysctl_init(void __iomem *base)
 {
 	u32 scctrl;
 
+	if (WARN_ON(!base))
+		return;
+
 	/* Select 1MHz TIMCLK as the reference clock for SP804 timers */
-	scctrl = readl(MMIO_P2V(V2M_SYSCTL + SCCTRL));
+	scctrl = readl(base + SCCTRL);
 	scctrl |= SCCTRL_TIMEREN0SEL_TIMCLK;
 	scctrl |= SCCTRL_TIMEREN1SEL_TIMCLK;
-	writel(scctrl, MMIO_P2V(V2M_SYSCTL + SCCTRL));
+	writel(scctrl, base + SCCTRL);
+}
+
+static void __init v2m_sp804_init(void __iomem *base, unsigned int irq)
+{
+	if (WARN_ON(!base || irq == NO_IRQ))
+		return;
 
-	writel(0, MMIO_P2V(V2M_TIMER0) + TIMER_CTRL);
-	writel(0, MMIO_P2V(V2M_TIMER1) + TIMER_CTRL);
+	writel(0, base + TIMER_1_BASE + TIMER_CTRL);
+	writel(0, base + TIMER_2_BASE + TIMER_CTRL);
 
-	sp804_clocksource_init(MMIO_P2V(V2M_TIMER1), "v2m-timer1");
-	sp804_clockevents_init(MMIO_P2V(V2M_TIMER0), IRQ_V2M_TIMER0,
-		"v2m-timer0");
+	sp804_clocksource_init(base + TIMER_2_BASE, "v2m-timer1");
+	sp804_clockevents_init(base + TIMER_1_BASE, irq, "v2m-timer0");
+}
+
+static void __init v2m_timer_init(void)
+{
+	v2m_sysctl_init(ioremap(V2M_SYSCTL, SZ_4K));
+	v2m_sp804_init(ioremap(V2M_TIMER01, SZ_4K), IRQ_V2M_TIMER0);
 }
 
 static struct sys_timer v2m_timer = {
@@ -82,14 +106,14 @@ int v2m_cfg_write(u32 devfn, u32 data)
 	devfn |= SYS_CFG_START | SYS_CFG_WRITE;
 
 	spin_lock(&v2m_cfg_lock);
-	val = readl(MMIO_P2V(V2M_SYS_CFGSTAT));
-	writel(val & ~SYS_CFG_COMPLETE, MMIO_P2V(V2M_SYS_CFGSTAT));
+	val = readl(v2m_sysreg_base + V2M_SYS_CFGSTAT);
+	writel(val & ~SYS_CFG_COMPLETE, v2m_sysreg_base + V2M_SYS_CFGSTAT);
 
-	writel(data, MMIO_P2V(V2M_SYS_CFGDATA));
-	writel(devfn, MMIO_P2V(V2M_SYS_CFGCTRL));
+	writel(data, v2m_sysreg_base +  V2M_SYS_CFGDATA);
+	writel(devfn, v2m_sysreg_base + V2M_SYS_CFGCTRL);
 
 	do {
-		val = readl(MMIO_P2V(V2M_SYS_CFGSTAT));
+		val = readl(v2m_sysreg_base + V2M_SYS_CFGSTAT);
 	} while (val == 0);
 	spin_unlock(&v2m_cfg_lock);
 
@@ -103,22 +127,28 @@ int v2m_cfg_read(u32 devfn, u32 *data)
 	devfn |= SYS_CFG_START;
 
 	spin_lock(&v2m_cfg_lock);
-	writel(0, MMIO_P2V(V2M_SYS_CFGSTAT));
-	writel(devfn, MMIO_P2V(V2M_SYS_CFGCTRL));
+	writel(0, v2m_sysreg_base + V2M_SYS_CFGSTAT);
+	writel(devfn, v2m_sysreg_base + V2M_SYS_CFGCTRL);
 
 	mb();
 
 	do {
 		cpu_relax();
-		val = readl(MMIO_P2V(V2M_SYS_CFGSTAT));
+		val = readl(v2m_sysreg_base + V2M_SYS_CFGSTAT);
 	} while (val == 0);
 
-	*data = readl(MMIO_P2V(V2M_SYS_CFGDATA));
+	*data = readl(v2m_sysreg_base + V2M_SYS_CFGDATA);
 	spin_unlock(&v2m_cfg_lock);
 
 	return !!(val & SYS_CFG_ERR);
 }
 
+void __init v2m_flags_set(u32 data)
+{
+	writel(~0, v2m_sysreg_base + V2M_SYS_FLAGSCLR);
+	writel(data, v2m_sysreg_base + V2M_SYS_FLAGSSET);
+}
+
 
 static struct resource v2m_pcie_i2c_resource = {
 	.start	= V2M_SERIAL_BUS_PCI,
@@ -204,7 +234,7 @@ static struct platform_device v2m_usb_device = {
 
 static void v2m_flash_set_vpp(struct platform_device *pdev, int on)
 {
-	writel(on != 0, MMIO_P2V(V2M_SYS_FLASH));
+	writel(on != 0, v2m_sysreg_base + V2M_SYS_FLASH);
 }
 
 static struct physmap_flash_data v2m_flash_data = {
@@ -258,7 +288,7 @@ static struct platform_device v2m_cf_device = {
 
 static unsigned int v2m_mmci_status(struct device *dev)
 {
-	return readl(MMIO_P2V(V2M_SYS_MCI)) & (1 << 0);
+	return readl(v2m_sysreg_base + V2M_SYS_MCI) & (1 << 0);
 }
 
 static struct mmci_platform_data v2m_mmci_data = {
@@ -371,7 +401,7 @@ static void __init v2m_init_early(void)
 {
 	ct_desc->init_early();
 	clkdev_add_table(v2m_lookups, ARRAY_SIZE(v2m_lookups));
-	versatile_sched_clock_init(MMIO_P2V(V2M_SYS_24MHZ), 24000000);
+	versatile_sched_clock_init(v2m_sysreg_base + V2M_SYS_24MHZ, 24000000);
 }
 
 static void v2m_power_off(void)
@@ -400,20 +430,23 @@ static void __init v2m_populate_ct_desc(void)
 	u32 current_tile_id;
 
 	ct_desc = NULL;
-	current_tile_id = readl(MMIO_P2V(V2M_SYS_PROCID0)) & V2M_CT_ID_MASK;
+	current_tile_id = readl(v2m_sysreg_base + V2M_SYS_PROCID0)
+				& V2M_CT_ID_MASK;
 
 	for (i = 0; i < ARRAY_SIZE(ct_descs) && !ct_desc; ++i)
 		if (ct_descs[i]->id == current_tile_id)
 			ct_desc = ct_descs[i];
 
 	if (!ct_desc)
-		panic("vexpress: failed to populate core tile description "
-		      "for tile ID 0x%8x\n", current_tile_id);
+		panic("vexpress: this kernel does not support core tile ID 0x%08x when booting via ATAGs.\n"
+		      "You may need a device tree blob or a different kernel to boot on this board.\n",
+		      current_tile_id);
 }
 
 static void __init v2m_map_io(void)
 {
 	iotable_init(v2m_io_desc, ARRAY_SIZE(v2m_io_desc));
+	v2m_sysreg_base = ioremap(V2M_SYSREGS, SZ_4K);
 	v2m_populate_ct_desc();
 	ct_desc->map_io();
 }
@@ -452,3 +485,298 @@ MACHINE_START(VEXPRESS, "ARM-Versatile Express")
 	.init_machine	= v2m_init,
 	.restart	= v2m_restart,
 MACHINE_END
+
+#if defined(CONFIG_ARCH_VEXPRESS_DT)
+
+/*
+ * Platform data for the motherboard CLCD. There is an HDLCD on the core
+ * tile but there is no driver for it in mainline. Furthermore, there
+ * aren't any existing bindings for LCD controllers so the whole thing
+ * is a temporary kludge.
+ */
+#include <linux/amba/clcd.h>
+
+static struct clcd_panel xvga_panel = {
+	.mode		= {
+		.name		= "XVGA",
+		.refresh	= 60,
+		.xres		= 1024,
+		.yres		= 768,
+		.pixclock	= 15384,
+		.left_margin	= 168,
+		.right_margin	= 8,
+		.upper_margin	= 29,
+		.lower_margin	= 3,
+		.hsync_len	= 144,
+		.vsync_len	= 6,
+		.sync		= 0,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+	.width		= -1,
+	.height		= -1,
+	.tim2		= TIM2_BCD | TIM2_IPC,
+	.cntl		= CNTL_LCDTFT | CNTL_BGR | CNTL_LCDVCOMP(1),
+	.bpp		= 16,
+};
+
+static void v2m_clcd_enable(struct clcd_fb *fb)
+{
+	v2m_cfg_write(SYS_CFG_MUXFPGA | SYS_CFG_SITE_MB, 0);
+}
+
+static int v2m_clcd_setup(struct clcd_fb *fb)
+{
+	unsigned long framesize = 1024 * 768 * 2;
+	struct device_node *node;
+	void *screen_base;
+
+	node = of_find_compatible_node(NULL, NULL, "arm,vexpress-vram");
+	screen_base = of_iomap(node, 0);
+
+	if (!screen_base)
+		return -ENOMEM;
+
+	fb->fb.screen_base = screen_base;
+	fb->panel = &xvga_panel;
+	fb->fb.fix.smem_start = of_translate_address(node, of_get_address(node, 0, NULL, NULL));
+	fb->fb.fix.smem_len = framesize;
+
+	return 0;
+}
+
+static int v2m_clcd_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)
+{
+	unsigned long off, user_size, kern_size;
+
+	off = vma->vm_pgoff << PAGE_SHIFT;
+	user_size = vma->vm_end - vma->vm_start;
+	kern_size = fb->fb.fix.smem_len;
+
+	if (off >= kern_size || user_size > (kern_size - off))
+		return -ENXIO;
+
+	return remap_pfn_range(vma, vma->vm_start,
+			__phys_to_pfn(fb->fb.fix.smem_start) + vma->vm_pgoff,
+			user_size,
+			pgprot_writecombine(vma->vm_page_prot));
+}
+
+static void v2m_clcd_remove(struct clcd_fb *fb)
+{
+	iounmap(fb->fb.screen_base);
+}
+
+static struct clcd_board v2m_clcd_data = {
+	.name		= "V2M",
+	.check		= clcdfb_check,
+	.decode		= clcdfb_decode,
+	.enable		= v2m_clcd_enable,
+	.setup		= v2m_clcd_setup,
+	.mmap		= v2m_clcd_mmap,
+	.remove		= v2m_clcd_remove,
+};
+
+static struct map_desc v2m_rs1_io_desc __initdata = {
+	.virtual	= V2M_PERIPH,
+	.pfn		= __phys_to_pfn(0x1c000000),
+	.length		= SZ_2M,
+	.type		= MT_DEVICE,
+};
+
+static int __init v2m_dt_scan_memory_map(unsigned long node, const char *uname,
+		int depth, void *data)
+{
+	const char **map = data;
+
+	if (strcmp(uname, "motherboard") != 0)
+		return 0;
+
+	*map = of_get_flat_dt_prop(node, "arm,v2m-memory-map", NULL);
+
+	return 1;
+}
+
+void __init v2m_dt_map_io(void)
+{
+	const char *map = NULL;
+
+	of_scan_flat_dt(v2m_dt_scan_memory_map, &map);
+
+	if (map && strcmp(map, "rs1") == 0)
+		iotable_init(&v2m_rs1_io_desc, 1);
+	else
+		iotable_init(v2m_io_desc, ARRAY_SIZE(v2m_io_desc));
+
+#if defined(CONFIG_SMP)
+	vexpress_dt_smp_map_io();
+#endif
+}
+
+static struct clk_lookup v2m_dt_lookups[] = {
+	{	/* AMBA bus clock */
+		.con_id		= "apb_pclk",
+		.clk		= &dummy_apb_pclk,
+	}, {	/* SP804 timers */
+		.dev_id		= "sp804",
+		.con_id		= "v2m-timer0",
+		.clk		= &v2m_sp804_clk,
+	}, {	/* SP804 timers */
+		.dev_id		= "sp804",
+		.con_id		= "v2m-timer1",
+		.clk		= &v2m_sp804_clk,
+	}, {	/* PL180 MMCI */
+		.dev_id		= "mb:mmci", /* 10005000.mmci */
+		.clk		= &osc2_clk,
+	}, {	/* PL050 KMI0 */
+		.dev_id		= "10006000.kmi",
+		.clk		= &osc2_clk,
+	}, {	/* PL050 KMI1 */
+		.dev_id		= "10007000.kmi",
+		.clk		= &osc2_clk,
+	}, {	/* PL011 UART0 */
+		.dev_id		= "10009000.uart",
+		.clk		= &osc2_clk,
+	}, {	/* PL011 UART1 */
+		.dev_id		= "1000a000.uart",
+		.clk		= &osc2_clk,
+	}, {	/* PL011 UART2 */
+		.dev_id		= "1000b000.uart",
+		.clk		= &osc2_clk,
+	}, {	/* PL011 UART3 */
+		.dev_id		= "1000c000.uart",
+		.clk		= &osc2_clk,
+	}, {	/* SP805 WDT */
+		.dev_id		= "1000f000.wdt",
+		.clk		= &v2m_ref_clk,
+	}, {	/* PL111 CLCD */
+		.dev_id		= "1001f000.clcd",
+		.clk		= &osc1_clk,
+	},
+	/* RS1 memory map */
+	{	/* PL180 MMCI */
+		.dev_id		= "mb:mmci", /* 1c050000.mmci */
+		.clk		= &osc2_clk,
+	}, {	/* PL050 KMI0 */
+		.dev_id		= "1c060000.kmi",
+		.clk		= &osc2_clk,
+	}, {	/* PL050 KMI1 */
+		.dev_id		= "1c070000.kmi",
+		.clk		= &osc2_clk,
+	}, {	/* PL011 UART0 */
+		.dev_id		= "1c090000.uart",
+		.clk		= &osc2_clk,
+	}, {	/* PL011 UART1 */
+		.dev_id		= "1c0a0000.uart",
+		.clk		= &osc2_clk,
+	}, {	/* PL011 UART2 */
+		.dev_id		= "1c0b0000.uart",
+		.clk		= &osc2_clk,
+	}, {	/* PL011 UART3 */
+		.dev_id		= "1c0c0000.uart",
+		.clk		= &osc2_clk,
+	}, {	/* SP805 WDT */
+		.dev_id		= "1c0f0000.wdt",
+		.clk		= &v2m_ref_clk,
+	}, {	/* PL111 CLCD */
+		.dev_id		= "mb:clcd", /* 1c1f0000.clcd */
+		.clk		= &osc1_clk,
+	},
+};
+
+void __init v2m_dt_init_early(void)
+{
+	struct device_node *node;
+	u32 dt_hbi;
+
+	node = of_find_compatible_node(NULL, NULL, "arm,vexpress-sysreg");
+	v2m_sysreg_base = of_iomap(node, 0);
+	if (WARN_ON(!v2m_sysreg_base))
+		return;
+
+	/* Confirm board type against DT property, if available */
+	if (of_property_read_u32(allnodes, "arm,hbi", &dt_hbi) == 0) {
+		u32 misc = readl(v2m_sysreg_base + V2M_SYS_MISC);
+		u32 id = readl(v2m_sysreg_base + (misc & SYS_MISC_MASTERSITE ?
+				V2M_SYS_PROCID1 : V2M_SYS_PROCID0));
+		u32 hbi = id & SYS_PROCIDx_HBI_MASK;
+
+		if (WARN_ON(dt_hbi != hbi))
+			pr_warning("vexpress: DT HBI (%x) is not matching "
+					"hardware (%x)!\n", dt_hbi, hbi);
+	}
+
+	clkdev_add_table(v2m_dt_lookups, ARRAY_SIZE(v2m_dt_lookups));
+}
+
+static  struct of_device_id vexpress_irq_match[] __initdata = {
+	{ .compatible = "arm,cortex-a9-gic", .data = gic_of_init, },
+	{}
+};
+
+static void __init v2m_dt_init_irq(void)
+{
+	of_irq_init(vexpress_irq_match);
+}
+
+static void __init v2m_dt_timer_init(void)
+{
+	struct device_node *node;
+	const char *path;
+	int err;
+
+	node = of_find_compatible_node(NULL, NULL, "arm,sp810");
+	v2m_sysctl_init(of_iomap(node, 0));
+
+	err = of_property_read_string(of_aliases, "arm,v2m_timer", &path);
+	if (WARN_ON(err))
+		return;
+	node = of_find_node_by_path(path);
+	v2m_sp804_init(of_iomap(node, 0), irq_of_parse_and_map(node, 0));
+	if (arch_timer_of_register())
+		twd_local_timer_of_register();
+
+	if (arch_timer_sched_clock_init())
+		versatile_sched_clock_init(v2m_sysreg_base + V2M_SYS_24MHZ, 24000000);
+}
+
+static struct sys_timer v2m_dt_timer = {
+	.init = v2m_dt_timer_init,
+};
+
+static struct of_dev_auxdata v2m_dt_auxdata_lookup[] __initdata = {
+	OF_DEV_AUXDATA("arm,vexpress-flash", V2M_NOR0, "physmap-flash",
+			&v2m_flash_data),
+	OF_DEV_AUXDATA("arm,primecell", V2M_MMCI, "mb:mmci", &v2m_mmci_data),
+	/* RS1 memory map */
+	OF_DEV_AUXDATA("arm,vexpress-flash", 0x08000000, "physmap-flash",
+			&v2m_flash_data),
+	OF_DEV_AUXDATA("arm,primecell", 0x1c050000, "mb:mmci", &v2m_mmci_data),
+	OF_DEV_AUXDATA("arm,primecell", 0x1c1f0000, "mb:clcd", &v2m_clcd_data),
+	{}
+};
+
+static void __init v2m_dt_init(void)
+{
+	l2x0_of_init(0x00400000, 0xfe0fffff);
+	of_platform_populate(NULL, of_default_bus_match_table,
+			v2m_dt_auxdata_lookup, NULL);
+	pm_power_off = v2m_power_off;
+}
+
+const static char *v2m_dt_match[] __initconst = {
+	"arm,vexpress",
+	NULL,
+};
+
+DT_MACHINE_START(VEXPRESS_DT, "ARM-Versatile Express")
+	.dt_compat	= v2m_dt_match,
+	.map_io		= v2m_dt_map_io,
+	.init_early	= v2m_dt_init_early,
+	.init_irq	= v2m_dt_init_irq,
+	.timer		= &v2m_dt_timer,
+	.init_machine	= v2m_dt_init,
+	.handle_irq	= gic_handle_irq,
+	.restart	= v2m_restart,
+MACHINE_END
+
+#endif
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index 7edef91..7c8a7d8 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -723,7 +723,7 @@ config CPU_HIGH_VECTOR
 	bool "Select the High exception vector"
 	help
 	  Say Y here to select high exception vector(0xFFFF0000~).
-	  The exception vector can be vary depending on the platform
+	  The exception vector can vary depending on the platform
 	  design in nommu mode. If your platform needs to select
 	  high exception vector, say Y.
 	  Otherwise or if you are unsure, say N, and the low exception
diff --git a/arch/arm/mm/abort-ev6.S b/arch/arm/mm/abort-ev6.S
index ff1f7cc..8074199 100644
--- a/arch/arm/mm/abort-ev6.S
+++ b/arch/arm/mm/abort-ev6.S
@@ -26,18 +26,23 @@ ENTRY(v6_early_abort)
 	mrc	p15, 0, r1, c5, c0, 0		@ get FSR
 	mrc	p15, 0, r0, c6, c0, 0		@ get FAR
 /*
- * Faulty SWP instruction on 1136 doesn't set bit 11 in DFSR (erratum 326103).
- * The test below covers all the write situations, including Java bytecodes
+ * Faulty SWP instruction on 1136 doesn't set bit 11 in DFSR.
  */
-	bic	r1, r1, #1 << 11		@ clear bit 11 of FSR
+#ifdef CONFIG_ARM_ERRATA_326103
+	ldr	ip, =0x4107b36
+	mrc	p15, 0, r3, c0, c0, 0		@ get processor id
+	teq	ip, r3, lsr #4			@ r0 ARM1136?
+	bne	do_DataAbort
 	tst	r5, #PSR_J_BIT			@ Java?
+	tsteq	r5, #PSR_T_BIT			@ Thumb?
 	bne	do_DataAbort
-	do_thumb_abort fsr=r1, pc=r4, psr=r5, tmp=r3
-	ldreq	r3, [r4]			@ read aborted ARM instruction
+	bic	r1, r1, #1 << 11		@ clear bit 11 of FSR
+	ldr	r3, [r4]			@ read aborted ARM instruction
 #ifdef CONFIG_CPU_ENDIAN_BE8
-	reveq	r3, r3
+	rev	r3, r3
 #endif
 	do_ldrd_abort tmp=ip, insn=r3
 	tst	r3, #1 << 20			@ L = 0 -> write
 	orreq	r1, r1, #1 << 11		@ yes.
+#endif
 	b	do_DataAbort
diff --git a/arch/arm/mm/alignment.c b/arch/arm/mm/alignment.c
index caf14dc..2876d08 100644
--- a/arch/arm/mm/alignment.c
+++ b/arch/arm/mm/alignment.c
@@ -745,7 +745,7 @@ do_alignment_t32_to_handler(unsigned long *pinstr, struct pt_regs *regs,
 static int
 do_alignment(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
 {
-	union offset_union offset;
+	union offset_union offset ={.un = 0};
 	unsigned long instr = 0, instrptr;
 	int (*handler)(unsigned long addr, unsigned long instr, struct pt_regs *regs);
 	unsigned int type;
diff --git a/arch/arm/mm/cache-l2x0.c b/arch/arm/mm/cache-l2x0.c
index a6a84ff..dc22326 100644
--- a/arch/arm/mm/cache-l2x0.c
+++ b/arch/arm/mm/cache-l2x0.c
@@ -71,12 +71,7 @@ static inline void cache_sync(void)
 {
 	void __iomem *base = l2x0_base;
 
-#ifdef CONFIG_PL310_ERRATA_753970
-	/* write to an unmmapped register */
-	writel_relaxed(0, base + L2X0_DUMMY_REG);
-#else
-	writel_relaxed(0, base + L2X0_CACHE_SYNC);
-#endif
+	writel_relaxed(0, base + sync_reg_offset);
 	cache_wait(base + L2X0_CACHE_SYNC, 1);
 }
 
@@ -95,10 +90,13 @@ static inline void l2x0_inv_line(unsigned long addr)
 }
 
 #if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
+static inline void debug_writel(unsigned long val)
+{
+	if (outer_cache.set_debug)
+		outer_cache.set_debug(val);
+}
 
-#define debug_writel(val)	outer_cache.set_debug(val)
-
-static void l2x0_set_debug(unsigned long val)
+static void pl310_set_debug(unsigned long val)
 {
 	writel_relaxed(val, l2x0_base + L2X0_DEBUG_CTRL);
 }
@@ -108,7 +106,7 @@ static inline void debug_writel(unsigned long val)
 {
 }
 
-#define l2x0_set_debug	NULL
+#define pl310_set_debug	NULL
 #endif
 
 #ifdef CONFIG_PL310_ERRATA_588369
@@ -372,6 +370,11 @@ void __init l2x0_init(void __iomem *base, __u32 aux_val, __u32 aux_mask)
 		else
 			l2x0_ways = 8;
 		type = "L310";
+#ifdef CONFIG_PL310_ERRATA_753970
+		/* Unmapped register. */
+		sync_reg_offset = L2X0_DUMMY_REG;
+#endif
+		outer_cache.set_debug = pl310_set_debug;
 		break;
 	case L2X0_CACHE_ID_PART_L210:
 		l2x0_ways = (aux >> 13) & 0xf;
@@ -421,7 +424,6 @@ void __init l2x0_init(void __iomem *base, __u32 aux_val, __u32 aux_mask)
 	outer_cache.flush_all = l2x0_flush_all;
 	outer_cache.inv_all = l2x0_inv_all;
 	outer_cache.disable = l2x0_disable;
-	outer_cache.set_debug = l2x0_set_debug;
 
 	printk(KERN_INFO "%s cache controller enabled\n", type);
 	printk(KERN_INFO "l2x0: %d ways, CACHE_ID 0x%08x, AUX_CTRL 0x%08x, Cache size: %d B\n",
diff --git a/arch/arm/mm/context.c b/arch/arm/mm/context.c
index ee9bb36..806cc4f 100644
--- a/arch/arm/mm/context.c
+++ b/arch/arm/mm/context.c
@@ -18,30 +18,39 @@
 
 static DEFINE_RAW_SPINLOCK(cpu_asid_lock);
 unsigned int cpu_last_asid = ASID_FIRST_VERSION;
-#ifdef CONFIG_SMP
-DEFINE_PER_CPU(struct mm_struct *, current_mm);
-#endif
 
 #ifdef CONFIG_ARM_LPAE
-#define cpu_set_asid(asid) {						\
-	unsigned long ttbl, ttbh;					\
-	asm volatile(							\
-	"	mrrc	p15, 0, %0, %1, c2		@ read TTBR0\n"	\
-	"	mov	%1, %2, lsl #(48 - 32)		@ set ASID\n"	\
-	"	mcrr	p15, 0, %0, %1, c2		@ set TTBR0\n"	\
-	: "=&r" (ttbl), "=&r" (ttbh)					\
-	: "r" (asid & ~ASID_MASK));					\
+void cpu_set_reserved_ttbr0(void)
+{
+	unsigned long ttbl = __pa(swapper_pg_dir);
+	unsigned long ttbh = 0;
+
+	/*
+	 * Set TTBR0 to swapper_pg_dir which contains only global entries. The
+	 * ASID is set to 0.
+	 */
+	asm volatile(
+	"	mcrr	p15, 0, %0, %1, c2		@ set TTBR0\n"
+	:
+	: "r" (ttbl), "r" (ttbh));
+	isb();
 }
 #else
-#define cpu_set_asid(asid) \
-	asm("	mcr	p15, 0, %0, c13, c0, 1\n" : : "r" (asid))
+void cpu_set_reserved_ttbr0(void)
+{
+	u32 ttb;
+	/* Copy TTBR1 into TTBR0 */
+	asm volatile(
+	"	mrc	p15, 0, %0, c2, c0, 1		@ read TTBR1\n"
+	"	mcr	p15, 0, %0, c2, c0, 0		@ set TTBR0\n"
+	: "=r" (ttb));
+	isb();
+}
 #endif
 
 /*
  * We fork()ed a process, and we need a new context for the child
- * to run in.  We reserve version 0 for initial tasks so we will
- * always allocate an ASID. The ASID 0 is reserved for the TTBR
- * register changing sequence.
+ * to run in.
  */
 void __init_new_context(struct task_struct *tsk, struct mm_struct *mm)
 {
@@ -51,9 +60,7 @@ void __init_new_context(struct task_struct *tsk, struct mm_struct *mm)
 
 static void flush_context(void)
 {
-	/* set the reserved ASID before flushing the TLB */
-	cpu_set_asid(0);
-	isb();
+	cpu_set_reserved_ttbr0();
 	local_flush_tlb_all();
 	if (icache_is_vivt_asid_tagged()) {
 		__flush_icache_all();
@@ -98,14 +105,7 @@ static void reset_context(void *info)
 {
 	unsigned int asid;
 	unsigned int cpu = smp_processor_id();
-	struct mm_struct *mm = per_cpu(current_mm, cpu);
-
-	/*
-	 * Check if a current_mm was set on this CPU as it might still
-	 * be in the early booting stages and using the reserved ASID.
-	 */
-	if (!mm)
-		return;
+	struct mm_struct *mm = current->active_mm;
 
 	smp_rmb();
 	asid = cpu_last_asid + cpu + 1;
@@ -114,8 +114,7 @@ static void reset_context(void *info)
 	set_mm_context(mm, asid);
 
 	/* set the new ASID */
-	cpu_set_asid(mm->context.id);
-	isb();
+	cpu_switch_mm(mm->pgd, mm);
 }
 
 #else
diff --git a/arch/arm/mm/fault.c b/arch/arm/mm/fault.c
index bb7eac3..d9aacf0 100644
--- a/arch/arm/mm/fault.c
+++ b/arch/arm/mm/fault.c
@@ -444,8 +444,16 @@ do_translation_fault(unsigned long addr, unsigned int fsr,
 
 	if (pud_none(*pud_k))
 		goto bad_area;
-	if (!pud_present(*pud))
+	if (!pud_present(*pud)) {
 		set_pud(pud, *pud_k);
+		/*
+		 * There is a small window during free_pgtables() where the
+		 * user *pud entry is 0 but the TLB has not been invalidated
+		 * and we get a level 2 (pmd) translation fault caused by the
+		 * intermediate TLB caching of the old level 1 (pud) entry.
+		 */
+		flush_tlb_kernel_page(addr);
+	}
 
 	pmd = pmd_offset(pud, addr);
 	pmd_k = pmd_offset(pud_k, addr);
@@ -468,8 +476,9 @@ do_translation_fault(unsigned long addr, unsigned int fsr,
 #endif
 	if (pmd_none(pmd_k[index]))
 		goto bad_area;
+	if (!pmd_present(pmd[index]))
+		copy_pmd(pmd, pmd_k);
 
-	copy_pmd(pmd, pmd_k);
 	return 0;
 
 bad_area:
diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index d2b36b6..b3e9bba 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -415,12 +415,6 @@ static void __init build_mem_type_table(void)
 	vecs_pgprot = kern_pgprot = user_pgprot = cp->pte;
 
 	/*
-	 * Only use write-through for non-SMP systems
-	 */
-	if (!is_smp() && cpu_arch >= CPU_ARCH_ARMv5 && cachepolicy > CPOLICY_WRITETHROUGH)
-		vecs_pgprot = cache_policies[CPOLICY_WRITETHROUGH].pte;
-
-	/*
 	 * Enable CPU-specific coherency if supported.
 	 * (Only available on XSC3 at the moment.)
 	 */
diff --git a/arch/arm/mm/proc-v6.S b/arch/arm/mm/proc-v6.S
index 5900cd5..2f702fd 100644
--- a/arch/arm/mm/proc-v6.S
+++ b/arch/arm/mm/proc-v6.S
@@ -136,8 +136,10 @@ ENTRY(cpu_v6_set_pte_ext)
 ENTRY(cpu_v6_do_suspend)
 	stmfd	sp!, {r4 - r9, lr}
 	mrc	p15, 0, r4, c13, c0, 0	@ FCSE/PID
+#ifdef CONFIG_MMU
 	mrc	p15, 0, r5, c3, c0, 0	@ Domain ID
 	mrc	p15, 0, r6, c2, c0, 1	@ Translation table base 1
+#endif
 	mrc	p15, 0, r7, c1, c0, 1	@ auxiliary control register
 	mrc	p15, 0, r8, c1, c0, 2	@ co-processor access control
 	mrc	p15, 0, r9, c1, c0, 0	@ control register
@@ -154,14 +156,16 @@ ENTRY(cpu_v6_do_resume)
 	mcr	p15, 0, ip, c13, c0, 1	@ set reserved context ID
 	ldmia	r0, {r4 - r9}
 	mcr	p15, 0, r4, c13, c0, 0	@ FCSE/PID
+#ifdef CONFIG_MMU
 	mcr	p15, 0, r5, c3, c0, 0	@ Domain ID
 	ALT_SMP(orr	r1, r1, #TTB_FLAGS_SMP)
 	ALT_UP(orr	r1, r1, #TTB_FLAGS_UP)
 	mcr	p15, 0, r1, c2, c0, 0	@ Translation table base 0
 	mcr	p15, 0, r6, c2, c0, 1	@ Translation table base 1
+	mcr	p15, 0, ip, c2, c0, 2	@ TTB control register
+#endif
 	mcr	p15, 0, r7, c1, c0, 1	@ auxiliary control register
 	mcr	p15, 0, r8, c1, c0, 2	@ co-processor access control
-	mcr	p15, 0, ip, c2, c0, 2	@ TTB control register
 	mcr	p15, 0, ip, c7, c5, 4	@ ISB
 	mov	r0, r9			@ control register
 	b	cpu_resume_mmu
diff --git a/arch/arm/mm/proc-v7-2level.S b/arch/arm/mm/proc-v7-2level.S
index 3a4b3e7..e3f2ba9 100644
--- a/arch/arm/mm/proc-v7-2level.S
+++ b/arch/arm/mm/proc-v7-2level.S
@@ -49,15 +49,10 @@ ENTRY(cpu_v7_switch_mm)
 #ifdef CONFIG_ARM_ERRATA_754322
 	dsb
 #endif
-	mcr	p15, 0, r2, c13, c0, 1		@ set reserved context ID
-	isb
-1:	mcr	p15, 0, r0, c2, c0, 0		@ set TTB 0
-	isb
-#ifdef CONFIG_ARM_ERRATA_754322
-	dsb
-#endif
 	mcr	p15, 0, r1, c13, c0, 1		@ set context ID
 	isb
+	mcr	p15, 0, r0, c2, c0, 0		@ set TTB 0
+	isb
 #endif
 	mov	pc, lr
 ENDPROC(cpu_v7_switch_mm)
@@ -106,7 +101,9 @@ ENTRY(cpu_v7_set_pte_ext)
  ARM(	str	r3, [r0, #2048]! )
  THUMB(	add	r0, r0, #2048 )
  THUMB(	str	r3, [r0] )
-	mcr	p15, 0, r0, c7, c10, 1		@ flush_pte
+	mrc	p15, 0, r3, c0, c1, 7		@ read ID_MMFR3
+	tst	r3, #0xf << 20			@ check the coherent walk bits
+	mcreq	p15, 0, r0, c7, c10, 1		@ clean D-cache to PoU
 #endif
 	mov	pc, lr
 ENDPROC(cpu_v7_set_pte_ext)
diff --git a/arch/arm/mm/proc-v7-3level.S b/arch/arm/mm/proc-v7-3level.S
index 8de0f1d..6b30605 100644
--- a/arch/arm/mm/proc-v7-3level.S
+++ b/arch/arm/mm/proc-v7-3level.S
@@ -70,7 +70,9 @@ ENTRY(cpu_v7_set_pte_ext)
 	tst	r3, #1 << (55 - 32)		@ L_PTE_DIRTY
 	orreq	r2, #L_PTE_RDONLY
 1:	strd	r2, r3, [r0]
-	mcr	p15, 0, r0, c7, c10, 1		@ flush_pte
+	mrc	p15, 0, r3, c0, c1, 7		@ read ID_MMFR3
+	tst	r3, #0xf << 20			@ check the coherent walk bits
+	mcreq	p15, 0, r0, c7, c10, 1		@ clean D-cache to PoU
 #endif
 	mov	pc, lr
 ENDPROC(cpu_v7_set_pte_ext)
diff --git a/arch/arm/mm/proc-v7.S b/arch/arm/mm/proc-v7.S
index f1c8486..c32e5cf 100644
--- a/arch/arm/mm/proc-v7.S
+++ b/arch/arm/mm/proc-v7.S
@@ -98,9 +98,11 @@ ENTRY(cpu_v7_do_suspend)
 	mrc	p15, 0, r4, c13, c0, 0	@ FCSE/PID
 	mrc	p15, 0, r5, c13, c0, 3	@ User r/o thread ID
 	stmia	r0!, {r4 - r5}
+#ifdef CONFIG_MMU
 	mrc	p15, 0, r6, c3, c0, 0	@ Domain ID
 	mrc	p15, 0, r7, c2, c0, 1	@ TTB 1
 	mrc	p15, 0, r11, c2, c0, 2	@ TTB control register
+#endif
 	mrc	p15, 0, r8, c1, c0, 0	@ Control register
 	mrc	p15, 0, r9, c1, c0, 1	@ Auxiliary control register
 	mrc	p15, 0, r10, c1, c0, 2	@ Co-processor access control
@@ -110,13 +112,14 @@ ENDPROC(cpu_v7_do_suspend)
 
 ENTRY(cpu_v7_do_resume)
 	mov	ip, #0
-	mcr	p15, 0, ip, c8, c7, 0	@ invalidate TLBs
 	mcr	p15, 0, ip, c7, c5, 0	@ invalidate I cache
 	mcr	p15, 0, ip, c13, c0, 1	@ set reserved context ID
 	ldmia	r0!, {r4 - r5}
 	mcr	p15, 0, r4, c13, c0, 0	@ FCSE/PID
 	mcr	p15, 0, r5, c13, c0, 3	@ User r/o thread ID
 	ldmia	r0, {r6 - r11}
+#ifdef CONFIG_MMU
+	mcr	p15, 0, ip, c8, c7, 0	@ invalidate TLBs
 	mcr	p15, 0, r6, c3, c0, 0	@ Domain ID
 #ifndef CONFIG_ARM_LPAE
 	ALT_SMP(orr	r1, r1, #TTB_FLAGS_SMP)
@@ -125,14 +128,15 @@ ENTRY(cpu_v7_do_resume)
 	mcr	p15, 0, r1, c2, c0, 0	@ TTB 0
 	mcr	p15, 0, r7, c2, c0, 1	@ TTB 1
 	mcr	p15, 0, r11, c2, c0, 2	@ TTB control register
-	mrc	p15, 0, r4, c1, c0, 1	@ Read Auxiliary control register
-	teq	r4, r9			@ Is it already set?
-	mcrne	p15, 0, r9, c1, c0, 1	@ No, so write it
-	mcr	p15, 0, r10, c1, c0, 2	@ Co-processor access control
 	ldr	r4, =PRRR		@ PRRR
 	ldr	r5, =NMRR		@ NMRR
 	mcr	p15, 0, r4, c10, c2, 0	@ write PRRR
 	mcr	p15, 0, r5, c10, c2, 1	@ write NMRR
+#endif	/* CONFIG_MMU */
+	mrc	p15, 0, r4, c1, c0, 1	@ Read Auxiliary control register
+	teq	r4, r9			@ Is it already set?
+	mcrne	p15, 0, r9, c1, c0, 1	@ No, so write it
+	mcr	p15, 0, r10, c1, c0, 2	@ Co-processor access control
 	isb
 	dsb
 	mov	r0, r8			@ control register
@@ -255,6 +259,18 @@ __v7_setup:
 	mcr	p15, 0, r5, c10, c2, 0		@ write PRRR
 	mcr	p15, 0, r6, c10, c2, 1		@ write NMRR
 #endif
+#ifndef CONFIG_ARM_THUMBEE
+	mrc	p15, 0, r0, c0, c1, 0		@ read ID_PFR0 for ThumbEE
+	and	r0, r0, #(0xf << 12)		@ ThumbEE enabled field
+	teq	r0, #(1 << 12)			@ check if ThumbEE is present
+	bne	1f
+	mov	r5, #0
+	mcr	p14, 6, r5, c1, c0, 0		@ Initialize TEEHBR to 0
+	mrc	p14, 6, r0, c0, c0, 0		@ load TEECR
+	orr	r0, r0, #1			@ set the 1st bit in order to
+	mcr	p14, 6, r0, c0, c0, 0		@ stop userspace TEEHBR access
+1:
+#endif
 	adr	r5, v7_crval
 	ldmia	r5, {r5, r6}
 #ifdef CONFIG_CPU_ENDIAN_BE8
diff --git a/arch/arm/mm/rodata.c b/arch/arm/mm/rodata.c
index 9a8eb84..f19f845 100644
--- a/arch/arm/mm/rodata.c
+++ b/arch/arm/mm/rodata.c
@@ -89,7 +89,7 @@ static int set_page_attributes(unsigned long virt, int numpages,
 
 		if ((pmd_val(*pmd) & PMD_TYPE_MASK) != PMD_TYPE_TABLE) {
 			pr_err("%s: pmd %p=%08lx for %08lx not page table\n",
-				__func__, pmd, pmd_val(*pmd), virt);
+				__func__, pmd, (long unsigned int)pmd_val(*pmd), virt);
 			virt = pmd_end;
 			continue;
 		}
diff --git a/arch/arm/plat-versatile/Makefile b/arch/arm/plat-versatile/Makefile
index 69714db..a5cb194 100644
--- a/arch/arm/plat-versatile/Makefile
+++ b/arch/arm/plat-versatile/Makefile
@@ -1,5 +1,4 @@
 obj-y	:= clock.o
-obj-$(CONFIG_LOCAL_TIMERS) += localtimer.o
 obj-$(CONFIG_PLAT_VERSATILE_CLCD) += clcd.o
 obj-$(CONFIG_PLAT_VERSATILE_FPGA_IRQ) += fpga-irq.o
 obj-$(CONFIG_PLAT_VERSATILE_LEDS) += leds.o
diff --git a/arch/arm/plat-versatile/localtimer.c b/arch/arm/plat-versatile/localtimer.c
deleted file mode 100644
index 0fb3961..0000000
--- a/arch/arm/plat-versatile/localtimer.c
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- *  linux/arch/arm/plat-versatile/localtimer.c
- *
- *  Copyright (C) 2002 ARM Ltd.
- *  All Rights Reserved
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#include <linux/init.h>
-#include <linux/smp.h>
-#include <linux/clockchips.h>
-
-#include <asm/smp_twd.h>
-#include <asm/localtimer.h>
-#include <mach/irqs.h>
-
-/*
- * Setup the local clock events for a CPU.
- */
-int __cpuinit local_timer_setup(struct clock_event_device *evt)
-{
-	evt->irq = IRQ_LOCALTIMER;
-	twd_timer_setup(evt);
-	return 0;
-}
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index f9c9f33..e7560b7 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1169,3 +1169,4 @@ elite_ulk		MACH_ELITE_ULK		ELITE_ULK		3888
 pov2			MACH_POV2		POV2			3889
 ipod_touch_2g		MACH_IPOD_TOUCH_2G	IPOD_TOUCH_2G		3890
 da850_pqab		MACH_DA850_PQAB		DA850_PQAB		3891
+sun6i			MACH_SUN6I		SUN6I			3892
diff --git a/arch/arm/vfp/vfpmodule.c b/arch/arm/vfp/vfpmodule.c
index 4942007..f76e890 100644
--- a/arch/arm/vfp/vfpmodule.c
+++ b/arch/arm/vfp/vfpmodule.c
@@ -17,6 +17,8 @@
 #include <linux/sched.h>
 #include <linux/smp.h>
 #include <linux/init.h>
+#include <linux/uaccess.h>
+#include <linux/user.h>
 
 #include <asm/cputype.h>
 #include <asm/thread_notify.h>
@@ -531,6 +533,103 @@ void vfp_flush_hwstate(struct thread_info *thread)
 }
 
 /*
+ * Save the current VFP state into the provided structures and prepare
+ * for entry into a new function (signal handler).
+ */
+int vfp_preserve_user_clear_hwstate(struct user_vfp __user *ufp,
+				    struct user_vfp_exc __user *ufp_exc)
+{
+	struct thread_info *thread = current_thread_info();
+	struct vfp_hard_struct *hwstate = &thread->vfpstate.hard;
+	int err = 0;
+
+	/* Ensure that the saved hwstate is up-to-date. */
+	vfp_sync_hwstate(thread);
+
+	/*
+	 * Copy the floating point registers. There can be unused
+	 * registers see asm/hwcap.h for details.
+	 */
+	err |= __copy_to_user(&ufp->fpregs, &hwstate->fpregs,
+			      sizeof(hwstate->fpregs));
+	/*
+	 * Copy the status and control register.
+	 */
+	__put_user_error(hwstate->fpscr, &ufp->fpscr, err);
+
+	/*
+	 * Copy the exception registers.
+	 */
+	__put_user_error(hwstate->fpexc, &ufp_exc->fpexc, err);
+	__put_user_error(hwstate->fpinst, &ufp_exc->fpinst, err);
+	__put_user_error(hwstate->fpinst2, &ufp_exc->fpinst2, err);
+
+	if (err)
+		return -EFAULT;
+
+	/* Ensure that VFP is disabled. */
+	vfp_flush_hwstate(thread);
+
+	/*
+	 * As per the PCS, clear the length and stride bits for function
+	 * entry.
+	 */
+	hwstate->fpscr &= ~(FPSCR_LENGTH_MASK | FPSCR_STRIDE_MASK);
+
+	/*
+	 * Disable VFP in the hwstate so that we can detect if it gets
+	 * used.
+	 */
+	hwstate->fpexc &= ~FPEXC_EN;
+	return 0;
+}
+
+/* Sanitise and restore the current VFP state from the provided structures. */
+int vfp_restore_user_hwstate(struct user_vfp __user *ufp,
+			     struct user_vfp_exc __user *ufp_exc)
+{
+	struct thread_info *thread = current_thread_info();
+	struct vfp_hard_struct *hwstate = &thread->vfpstate.hard;
+	unsigned long fpexc;
+	int err = 0;
+
+	/*
+	 * If VFP has been used, then disable it to avoid corrupting
+	 * the new thread state.
+	 */
+	if (hwstate->fpexc & FPEXC_EN)
+		vfp_flush_hwstate(thread);
+
+	/*
+	 * Copy the floating point registers. There can be unused
+	 * registers see asm/hwcap.h for details.
+	 */
+	err |= __copy_from_user(&hwstate->fpregs, &ufp->fpregs,
+				sizeof(hwstate->fpregs));
+	/*
+	 * Copy the status and control register.
+	 */
+	__get_user_error(hwstate->fpscr, &ufp->fpscr, err);
+
+	/*
+	 * Sanitise and restore the exception registers.
+	 */
+	__get_user_error(fpexc, &ufp_exc->fpexc, err);
+
+	/* Ensure the VFP is enabled. */
+	fpexc |= FPEXC_EN;
+
+	/* Ensure FPINST2 is invalid and the exception flag is cleared. */
+	fpexc &= ~(FPEXC_EX | FPEXC_FP2V);
+	hwstate->fpexc = fpexc;
+
+	__get_user_error(hwstate->fpinst, &ufp_exc->fpinst, err);
+	__get_user_error(hwstate->fpinst2, &ufp_exc->fpinst2, err);
+
+	return err ? -EFAULT : 0;
+}
+
+/*
  * VFP hardware can lose all context when a CPU goes offline.
  * As we will be running in SMP mode with CPU hotplug, we will save the
  * hardware state at every thread switch.  We clear our held state when
